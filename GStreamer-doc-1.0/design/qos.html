<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Quality-of-Service</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/utils.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/navigation.js"></script>


<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>


<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body data-spy="scroll" data-target=".scrollspy" data-offset="70">


<nav class="navbar navbar-fixed-top navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a href="https://gstreamer.freedesktop.org/" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
							</ul>
		</div>
	</div>
</nav>

<main class="page-row page-row-expanded">
<div data-extension="core" data-hotdoc-project="GStreamer-doc-1.0" data-hotdoc-ref="design/qos.html" class="page_container" id="page-wrapper">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-xl-2" id="sidenav-column">
	<div class="panel panel-collapse" id="sidenav" data-hotdoc-role="navigation">
		<div id="sidenav-search" role="search">
			<input type="text" class="form-control" placeholder="Fetching index" id="sidenav-lookup-field" disabled>
		</div>
		<div id="sitenav-wrapper" class="mCustomScrollbar" data-mcs-theme="minimal">
			<div class="sidenav-main-panel-body">
				<div id="site-navigation">
				</div>
			</div>
			<!-- FIXME -->
			<div style="height: 76px;"></div>
		</div>
	</div>
</div>

<div class="col-sm-12 col-md-9 col-xl-8">
	<div id="main">
				
<div id="page-description" data-hotdoc-source="qos.md">
<h1 id="qualityofservice">Quality-of-Service</h1>
<p>Quality of service is about measuring and adjusting the real-time
performance of a pipeline.</p>
<p>The real-time performance is always measured relative to the pipeline
clock and typically happens in the sinks when they synchronize buffers
against the clock.</p>
<p>The measurements result in QOS events that aim to adjust the datarate in
one or more upstream elements. Two types of adjustments can be made:</p>
<ul>
<li>
<p>short time "emergency" corrections based on latest observation in
the sinks.</p>
</li>
<li>
<p>long term rate corrections based on trends observed in the sinks.</p>
</li>
</ul>
<p>It is also possible for the application to artificially introduce delay
between synchronized buffers, this is called throttling. It can be used
to reduce the framerate, for example.</p>
<h2 id="sources-of-quality-problems">Sources of quality problems</h2>
<ul>
<li>
<p>High CPU load</p>
</li>
<li>
<p>Network problems</p>
</li>
<li>
<p>Other resource problems such as disk load, memory bottlenecks etc.</p>
</li>
<li>
<p>application level throttling</p>
</li>
</ul>
<h2 id="qos-event">QoS event</h2>
<p>The QoS event is generated by an element that synchronizes against the
clock. It travels upstream and contains the following fields:</p>
<ul>
<li>
<p><strong><code>type</code></strong>: <code>GST_TYPE_QOS_TYPE:</code> The type of the QoS event, we have the
following types and the default type is <code>GST_QOS_TYPE_UNDERFLOW</code>:</p>
<ul>
<li>
<p><code>GST_QOS_TYPE_OVERFLOW</code>:  an element is receiving buffers too fast and can't
keep up processing them. Upstream should reduce the rate.</p>
</li>
<li>
<p><code>GST_QOS_TYPE_UNDERFLOW</code>: an element is receiving buffers too slowly
and has to drop them because they are too late. Upstream should
increase the processing rate.</p>
</li>
<li>
<p><code>GST_QOS_TYPE_THROTTLE</code>:  the application is asking to add extra delay
between buffers, upstream is allowed to drop buffers</p>
</li>
</ul>
</li>
<li>
<p><strong><code>timestamp</code></strong>: <code>G_TYPE_UINT64</code>: The timestamp on the buffer that
generated the QoS event. These timestamps are expressed in total
<code>running_time</code> in the sink so that the value is ever increasing.</p>
</li>
<li>
<p><strong><code>jitter</code></strong>: <code>G_TYPE_INT64</code>: The difference of that timestamp against the
current clock time. Negative values mean the timestamp was on time.
Positive values indicate the timestamp was late by that amount. When
buffers are received in time and throttling is not enabled, the QoS
type field is set to OVERFLOW. When throttling, the jitter contains
the throttling delay added by the application and the type is set to
THROTTLE.</p>
</li>
<li>
<p><strong><code>proportion</code></strong>: <code>G_TYPE_DOUBLE</code>: Long term prediction of the ideal rate
relative to normal rate to get optimal quality.</p>
</li>
</ul>
<p>The rest of this document deals with how these values can be calculated
in a sink and how the values can be used by other elements to adjust
their operations.</p>
<h2 id="qos-message">QoS message</h2>
<p>A QOS message is posted on the bus whenever an element decides to:</p>
<ul>
<li>
<p>drop a buffer because of QoS reasons</p>
</li>
<li>
<p>change its processing strategy because of QoS reasons (quality)</p>
</li>
</ul>
<p>It should be expected that creating and posting the QoS message is
reasonably fast and does not significantly contribute to the QoS
problems. Options to disable this feature could also be presented on
elements.</p>
<p>This message can be posted by a sink/src that performs synchronisation
against the clock (live) or it could be posted by an upstream element
that performs QoS because of QOS events received from a downstream
element (!live).</p>
<p>The <code>GST_MESSAGE_QOS</code> contains at least the following info:</p>
<ul>
<li>
<p><strong><code>live</code></strong>: <code>G_TYPE_BOOLEAN</code>: If the QoS message was dropped by a live
element such as a sink or a live source. If the live property is
FALSE, the QoS message was generated as a response to a QoS event in
a non-live element.</p>
</li>
<li>
<p><strong><code>running-time</code></strong>: <code>G_TYPE_UINT64</code>: The <code>running_time</code> of the buffer that
generated the QoS message.</p>
</li>
<li>
<p><strong><code>stream-time</code></strong>: <code>G_TYPE_UINT64</code>: The <code>stream_time</code> of the buffer that
generated the QoS message.</p>
</li>
<li>
<p><strong><code>timestamp</code></strong>: <code>G_TYPE_UINT64</code>: The timestamp of the buffer that
generated the QoS message.</p>
</li>
<li>
<p><strong><code>duration</code></strong>: <code>G_TYPE_UINT64</code>: The duration of the buffer that generated
the QoS message.</p>
</li>
<li>
<p><strong><code>jitter</code></strong>: <code>G_TYPE_INT64</code>: The difference of the running-time against
the deadline. Negative values mean the timestamp was on time.
Positive values indicate the timestamp was late (and dropped) by
that amount. The deadline can be a realtime <code>running_time</code> or an
estimated <code>running_time</code>.</p>
</li>
<li>
<p><strong><code>proportion</code></strong>: <code>G_TYPE_DOUBLE</code>: Long term prediction of the ideal rate
relative to normal rate to get optimal quality.</p>
</li>
<li>
<p><strong><code>quality</code></strong>: <code>G_TYPE_INT</code>: An element dependent integer value that
specifies the current quality level of the element. The default
maximum quality is 1000000.</p>
</li>
<li>
<p><strong><code>format</code></strong>: <code>GST_TYPE_FORMAT</code> Units of the <em>processed</em> and <em>dropped</em>
fields. Video sinks and video filters will use <code>GST_FORMAT_BUFFERS</code>
(frames). Audio sinks and audio filters will likely use
<code>GST_FORMAT_DEFAULT</code> (samples).</p>
</li>
<li>
<p><strong><code>processed</code></strong>: <code>G_TYPE_UINT64</code>: Total number of units correctly
processed since the last state change to READY or a flushing
operation.</p>
</li>
<li>
<p><strong><code>dropped</code></strong>: <code>G_TYPE_UINT64</code>: Total number of units dropped since the
last state change to READY or a flushing operation.</p>
</li>
</ul>
<p>The <em>running-time</em> and <em>processed</em> fields can be used to estimate the
average processing rate (framerate for video).</p>
<p>Elements might add additional fields in the message which are documented
in the relevant elements or baseclasses.</p>
<h2 id="collecting-statistics">Collecting statistics</h2>
<p>A buffer with timestamp B1 arrives in the sink at time T1. The buffer
timestamp is then synchronized against the clock which yields a jitter
J1 return value from the clock. The jitter J1 is simply calculated as</p>
<pre><code>J1 = CT - B1
</code></pre>
<p>Where CT is the clock time when the entry arrives in the sink. This
value is calculated inside the clock when we perform
<code>gst_clock_id_wait()</code>.</p>
<p>If the jitter is negative, the entry arrived in time and can be rendered
after waiting for the clock to reach time B1 (which is also CT - J1).</p>
<p>If the jitter is positive however, the entry arrived too late in the
sink and should therefore be dropped. J1 is the amount of time the entry
was late.</p>
<p>Any buffer that arrives in the sink should generate a QoS event
upstream.</p>
<p>Using the jitter we can calculate the time when the buffer arrived in
the sink:</p>
<pre><code>    T1 = B1 + J1.                                (1)
</code></pre>
<p>The time the buffer leaves the sink after synchronisation is measured
as:</p>
<pre><code>    T2 = B1 + (J1 &lt; 0 ? 0 : J1)                  (2)
</code></pre>
<p>For buffers that arrive in time (J1 &lt; 0) the buffer leaves after
synchronisation which is exactly B1. Late buffers (J1 &gt;= 0) leave the
sink when they arrive, whithout any synchronisation, which is <code>T2 = T1 = B1 + J1</code>.</p>
<p>Using a previous T0 and a new T1, we can calculate the time it took for
upstream to generate a buffer with timestamp B1.</p>
<pre><code>    PT1 = T1 - T0                                (3)
</code></pre>
<p>We call PT1 the processing time needed to generate buffer with timestamp
B1.</p>
<p>Moreover, given the duration of the buffer D1, the current data rate
(DR1) of the upstream element is given as:</p>
<pre><code>      PT1   T1 - T0
DR1 = --- = -------                           (4)
      D1      D1
</code></pre>
<p>For values 0.0 &lt; DR1 ‚áê 1.0 the upstream element is producing faster
than real-time. If DR1 is exactly 1.0, the element is running at a
perfect speed.</p>
<p>Values DR1 &gt; 1.0 mean that the upstream element cannot produce buffers
of duration D1 in real-time. It is exactly DR1 that tells the amount of
speedup we require from upstream to regain real-time performance.</p>
<p>An element that is not receiving enough data is said to be underflowed.</p>
<h2 id="element-measurements">Element measurements</h2>
<p>In addition to the measurements of the datarate of the upstream element,
a typical element must also measure its own performance. Global pipeline
performance problems can indeed also be caused by the element itself
when it receives too much data it cannot process in time. The element is
then said to be overflowed.</p>
<h2 id="short-term-correction">Short term correction</h2>
<p>The timestamp and jitter serve as short term correction information for
upstream elements. Indeed, given arrival time T1 as given in (1) we can
be certain that buffers with a timestamp B2 &lt; T1 will be too late in
the sink.</p>
<p>In case of a positive jitter we can therefore send a QoS event with a
timestamp B1, jitter J1 and proportion given by (4).</p>
<p>This allows an upstream element to not generate any data with timestamps
B2 &lt; T1, where the element can derive T1 as B1 + J1.</p>
<p>This will effectively result in frame drops.</p>
<p>The element can even do a better estimation of the next valid timestamp
it should output.</p>
<p>Indeed, given the element generated a buffer with timestamp B0 that
arrived in time in the sink but then received a QoS event stating B1
arrived J1 too late. This means generating B1 took (B1 + J1) - B0 = T1 -
T0 = PT1, as given in (3). Given the buffer B1 had a duration D1 and
assuming that generating a new buffer B2 will take the same amount of
processing time, a better estimation for B2 would then be:</p>
<pre><code>    B2 = T1 + D2 * DR1
</code></pre>
<p>expanding gives:</p>
<pre><code>    B2 = (B1 + J1) + D2 * (B1 + J1 - B0)
                          --------------
                               D1
</code></pre>
<p>assuming the durations of the frames are equal and thus D1 = D2:</p>
<pre><code>    B2 = (B1 + J1) + (B1 + J1 - B0)

    B2 =  2 * (B1 + J1) - B0
</code></pre>
<p>also:</p>
<pre><code>    B0 = B1 - D1
</code></pre>
<p>so:</p>
<pre><code>    B2 =  2 * (B1 + J1) - (B1 - D1)
</code></pre>
<p>Which yields a more accurate prediction for the next buffer given as:</p>
<pre><code>    B2 =  B1 + 2 * J1 + D1                          (5)
</code></pre>
<h2 id="long-term-correction">Long term correction</h2>
<p>The datarate used to calculate (5) for the short term prediction is
based on a single observation. A more accurate datarate can be obtained
by creating a running average over multiple datarate observations.</p>
<p>This average is less susceptible to sudden changes that would only
influence the datarate for a very short period.</p>
<p>A running average is calculated over the observations given in (4) and
is used as the proportion member in the QoS event that is sent upstream.</p>
<p>Receivers of the QoS event should permanently reduce their datarate as
given by the proportion member. Failure to do so will certainly lead to
more dropped frames and a generally worse QoS.</p>
<h2 id="throttling">Throttling</h2>
<p>In throttle mode, the time distance between buffers is kept to a
configurable throttle interval. This means that effectively the buffer
rate is limited to 1 buffer per throttle interval. This can be used to
limit the framerate, for example.</p>
<p>When an element is configured in throttling mode (this is usually only
implemented on sinks) it should produce QoS events upstream with the
jitter field set to the throttle interval. This should instruct upstream
elements to skip or drop the remaining buffers in the configured
throttle interval.</p>
<p>The proportion field is set to the desired slowdown needed to get the
desired throttle interval. Implementations can use the QoS Throttle
type, the proportion and the jitter member to tune their
implementations.</p>
<h2 id="qos-strategies">QoS strategies</h2>
<p>Several strategies exist to reduce processing delay that might affect
real time performance.</p>
<ul>
<li>
<p>lowering quality</p>
</li>
<li>
<p>dropping frames (reduce CPU/bandwidth usage)</p>
</li>
<li>
<p>switch to a lower decoding/encoding quality (reduce algorithmic
complexity)</p>
</li>
<li>
<p>switch to a lower quality source (reduce network usage)</p>
</li>
<li>
<p>increasing thread priorities</p>
</li>
<li>
<p>switch to real-time scheduling</p>
</li>
<li>
<p>assign more CPU cycles to critial pipeline parts</p>
</li>
<li>
<p>assign more CPU(s) to critical pipeline parts</p>
</li>
</ul>
<h2 id="qos-implementations">QoS implementations</h2>
<p>Here follows a small overview of how QoS can be implemented in a range
of different types of elements.</p>
<h3 id="gstbasesink">GstBaseSink</h3>
<p>The primary implementor of QoS is GstBaseSink. It will calculate the
following values:</p>
<ul>
<li>
<p>upstream running average of processing time (5) in stream time.</p>
</li>
<li>
<p>running average of buffer durations.</p>
</li>
<li>
<p>running average of render time (in system time)</p>
</li>
<li>
<p>rendered/dropped buffers</p>
</li>
</ul>
<p>The processing time and the average buffer durations will be used to
calculate a proportion.</p>
<p>The processing time in system time is compared to render time to decide
if the majority of the time is spend upstream or in the sink itself.
This value is used to decide overflow or underflow.</p>
<p>The number of rendered and dropped buffers is used to query stats on the
sink.</p>
<p>A QoS event with the most current values is sent upstream for each
buffer that was received by the sink.</p>
<p>Normally QoS is only enabled for video pipelines. The reason being that
drops in audio are more disturbing than dropping video frames. Also
video requires in general more processing than audio.</p>
<p>Normally there is a threshold for when buffers get dropped in a video
sink. Frames that arrive 20 milliseconds late are still rendered as it
is not noticeable for the human eye.</p>
<p>A QoS message is posted whenever a (part of a) buffer is dropped.</p>
<p>In throttle mode, the sink sends QoS event upstream with the timestamp
set to the <code>running_time</code> of the latest buffer and the jitter set to the
throttle interval. If the throttled buffer is late, the lateness is
subtracted from the throttle interval in order to keep the desired
throttle interval.</p>
<h3 id="gstbasetransform">GstBaseTransform</h3>
<p>Transform elements can entirely skip the transform based on the
timestamp and jitter values of recent QoS event since these buffers will
certainly arrive too late.</p>
<p>With any intermediate element, the element should measure its
performance to decide if it is responsible for the quality problems or
any upstream/downstream element.</p>
<p>some transforms can reduce the complexity of their algorithms. Depending
on the algorithm, the changes in quality may have disturbing visual or
audible effect that should be avoided.</p>
<p>A QoS message should be posted when a frame is dropped or when the
quality of the filter is reduced. The quality member in the QOS message
should reflect the quality setting of the filter.</p>
<h3 id="video-decoders">Video Decoders</h3>
<p>A video decoder can, based on the codec in use, decide to not decode
intermediate frames. A typical codec can for example skip the decoding
of B-frames to reduce the CPU usage and framerate.</p>
<p>If each frame is independantly decodable, any arbitrary frame can be
skipped based on the timestamp and jitter values of the latest QoS
event. In addition can the proportion member be used to permanently skip
frames.</p>
<p>It is suggested to adjust the quality field of the QoS message with the
expected amount of dropped frames (skipping B and/or P frames). This
depends on the particular spacing of B and P frames in the stream. If
the quality control would result in half of the frames to be dropped
(typical B frame skipping), the quality field would be set to <code>1000000 * 1/2 = 500000</code>. If a typical I frame spacing of 18 frames is used,
skipping B and P frames would result in 17 dropped frames or 1 decoded
frame every 18 frames. The quality member should be set to <code>1000000 * 1/18 = 55555</code>.</p>
<ul>
<li>
<p>skipping B frames: quality = 500000</p>
</li>
<li>
<p>skipping P/B frames: quality = 55555 (for I-frame spacing of 18
frames)</p>
</li>
</ul>
<h3 id="demuxers">Demuxers</h3>
<p>Demuxers usually cannot do a lot regarding QoS except for skipping
frames to the next keyframe when a lateness QoS event arrives on a
source pad.</p>
<p>A demuxer can however measure if the performance problems are upstream
or downstream and forward an updated QoS event upstream.</p>
<p>Most demuxers that have multiple output pads might need to combine the
QoS events on all the pads and derive an aggregated QoS event for the
upstream element.</p>
<h3 id="sources">Sources</h3>
<p>The QoS events only apply to push based sources since pull based sources
are entirely controlled by another downstream element.</p>
<p>Sources can receive a overflow or underflow event that can be used to
switch to less demanding source material. In case of a network stream, a
switch could be done to a lower or higher quality stream or additional
enhancement layers could be used or ignored.</p>
<p>Live sources will automatically drop data when it takes too long to
process the data that the element pushes out.</p>
<p>Live sources should post a QoS message when data is dropped.</p>

</div>


	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
</div>
<div class="hidden-xs col-xl-2">
</div>
	</div>
</div>
</main>

<footer class="page-row">
	<div class="container-fluid">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-xl-2"></div>
		<div class="col-sm-12 col-md-9 col-xl-8">
						
		</div>
		<div class="hidden-xs col-xl-2"></div>
	</div>
</div>
</footer>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>