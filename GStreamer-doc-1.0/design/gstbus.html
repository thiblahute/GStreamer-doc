<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>GstBus</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">


<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/utils.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/navigation.js"></script>


<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/trie.js"></script>


</head>

<body data-spy="scroll" data-target=".scrollspy" data-offset="70">

<nav class="navbar navbar-fixed-top navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a id="home-link" class="hotdoc-navbar-brand">
				
<img src="assets/images/home.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
							</ul>
		</div>
	</div>
</nav>

<main class="page-row page-row-expanded">
<div data-extension="core" data-hotdoc-project="GStreamer-doc-1.0" data-hotdoc-ref="design/gstbus.html" class="page_container" id="page-wrapper">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-xl-2" id="sidenav-column">
	<div class="panel panel-collapse" id="sidenav" data-hotdoc-role="navigation">
		<div id="sidenav-search" role="search">
			<input type="text" class="form-control" placeholder="Fetching index" id="sidenav-lookup-field" disabled>
		</div>
		<div id="sitenav-wrapper" class="mCustomScrollbar" data-mcs-theme="minimal">
			<div class="sidenav-main-panel-body">
				<div id="site-navigation">
				</div>
			</div>
			<!-- FIXME -->
			<div style="height: 76px;"></div>
		</div>
	</div>
</div>

<div class="col-sm-12 col-md-9 col-xl-8">
	<div id="main">
				
<div id="page-description" data-hotdoc-source="gstbus.md">
<h1 id="gstbus">GstBus</h1>
<p>The <code>GstBus</code> is an object responsible for delivering <code>GstMessages</code> in a
first-in first-out way from the streaming threads to the application.</p>
<p>Since the application typically only wants to deal with delivery of
these messages from one thread, the <code>GstBus</code> will marshall the messages
between different threads. This is important since the actual streaming
of media is done in other threads (streaming threads) than the
application. It is also important to not block the streaming threads
while the application deals with the message.</p>
<p>The <code>GstBus</code> provides support for <code>GSource</code> based notifications. This makes
it possible to handle the delivery in the glib mainloop. Different
<code>GSources</code> can be added to the same bin provided they listen to different
message types.</p>
<p>A message is posted on the bus with the <code>gst_bus_post()</code> method. With
the <code>gst_bus_peek()</code> and <code>_pop()</code> methods one can look at or retrieve a
previously posted message.</p>
<p>The bus can be polled with the <code>gst_bus_poll()</code> method. This method
blocks up to the specified timeout value until one of the specified
message types are posted on the bus. The application can then <code>_pop()</code>
these messages from the bus to handle them.</p>
<p>It is also possible to get messages from the bus without any thread
marshalling with the <code>gst_bus_set_sync_handler()</code> method. This makes
it possible to react to a message in the same thread that posted it
on the bus. This should only be used if the application is able
to deal with messages from different threads.</p>
<p>If no messages are popped from the bus with either a <code>GSource</code> or
<code>gst_bus_pop()</code>, they remain on the bus.</p>
<p>When a pipeline or bin goes from READY into NULL state, it will set its
bus to flushing, ie. the bus will drop all existing and new messages on
the bus. This is necessary because bus messages hold references to the
bin/pipeline or its elements, so there are circular references that need
to be broken if one ever wants to be able to destroy a bin or pipeline
properly.</p>

</div>


	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
</div>
<div class="hidden-xs col-xl-2">
</div>
	</div>
</div>
</main>

<footer class="page-row">
	<div class="container-fluid">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-xl-2"></div>
		<div class="col-sm-12 col-md-9 col-xl-8">
						
		</div>
		<div class="hidden-xs col-xl-2"></div>
	</div>
</div>
</footer>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>