<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>multifdsink</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/devhelp.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/utils.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/navigation.js"></script>


<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/trie.js"></script>


<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body data-spy="scroll" data-target=".scrollspy" data-offset="70">


<nav class="navbar navbar-fixed-top navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a href="https://gstreamer.freedesktop.org/" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
							</ul>
		</div>
	</div>
</nav>

<main class="page-row page-row-expanded">
<div data-extension="gst-extension" data-hotdoc-project="gst-plugins-base-plugins-doc-1.0" data-hotdoc-ref="multifdsink.html" class="page_container" id="page-wrapper" data-hotdoc-meta-gi-languages="c,python,javascript" data-hotdoc-meta-gi-language="javascript">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-xl-2" id="sidenav-column">
	<div class="panel panel-collapse" id="sidenav" data-hotdoc-role="navigation">
		<div id="sidenav-search" role="search">
			<input type="text" class="form-control" placeholder="Fetching index" id="sidenav-lookup-field" disabled>
		</div>
		<div id="sitenav-wrapper" class="mCustomScrollbar" data-mcs-theme="minimal">
			<div class="sidenav-main-panel-body">
				<div id="site-navigation">
				</div>
			</div>
			<!-- FIXME -->
			<div style="height: 76px;"></div>
		</div>
	</div>
</div>

<div class="col-sm-12 col-md-9 col-xl-8">
	<div id="main">
				
<div id="page-description" data-hotdoc-source="multifdsink">
<h1 id="multifdsink">multifdsink</h1><p>This plugin writes incoming data to a set of file descriptors. The
file descriptors can be added to multifdsink by emitting the <a href="multifdsink.html#GstMultiFdSink::add">add</a> signal.
For each descriptor added, the <a href="multifdsink.html#GstMultiFdSink::client-added">client-added</a> signal will be called.</p>
<p>The multifdsink element needs to be set into READY, PAUSED or PLAYING state
before operations such as adding clients are possible.</p>
<p>A client can also be added with the <a href="multifdsink.html#GstMultiFdSink::add-full">add-full</a> signal
that allows for more control over what and how much data a client
initially receives.</p>
<p>Clients can be removed from multifdsink by emitting the <a href="multifdsink.html#GstMultiFdSink::remove">remove</a> signal. For
each descriptor removed, the <a href="multifdsink.html#GstMultiFdSink::client-removed">client-removed</a> signal will be called. The
<a href="multifdsink.html#GstMultiFdSink::client-removed">client-removed</a> signal can also be fired when multifdsink decides that a
client is not active anymore or, depending on the value of the
GstMultiFdSink:recover-policy property, if the client is reading too slowly.
In all cases, multifdsink will never close a file descriptor itself.
The user of multifdsink is responsible for closing all file descriptors.
This can for example be done in response to the <a href="multifdsink.html#GstMultiFdSink::client-fd-removed">client-fd-removed</a> signal.
Note that multifdsink still has a reference to the file descriptor when the
<a href="multifdsink.html#GstMultiFdSink::client-removed">client-removed</a> signal is emitted, so that "get-stats" can be performed on
the descriptor; it is therefore not safe to close the file descriptor in
the <a href="multifdsink.html#GstMultiFdSink::client-removed">client-removed</a> signal handler, and you should use the
<a href="multifdsink.html#GstMultiFdSink::client-fd-removed">client-fd-removed</a> signal to safely close the fd.</p>
<p>Multifdsink internally keeps a queue of the incoming buffers and uses a
separate thread to send the buffers to the clients. This ensures that no
client write can block the pipeline and that clients can read with different
speeds.</p>
<p>When adding a client to multifdsink, the GstMultiFdSink:sync-method property will define
which buffer in the queued buffers will be sent first to the client. Clients
can be sent the most recent buffer (which might not be decodable by the
client if it is not a keyframe), the next keyframe received in
multifdsink (which can take some time depending on the keyframe rate), or the
last received keyframe (which will cause a simple burst-on-connect).
Multifdsink will always keep at least one keyframe in its internal buffers
when the sync-mode is set to latest-keyframe.</p>
<p>There are additional values for the GstMultiFdSink:sync-method
property to allow finer control over burst-on-connect behaviour. By selecting
the 'burst' method a minimum burst size can be chosen, 'burst-keyframe'
additionally requires that the burst begin with a keyframe, and
'burst-with-keyframe' attempts to burst beginning with a keyframe, but will
prefer a minimum burst size even if it requires not starting with a keyframe.</p>
<p>Multifdsink can be instructed to keep at least a minimum amount of data
expressed in time or byte units in its internal queues with the
GstMultiFdSink:time-min and GstMultiFdSink:bytes-min properties respectively.
These properties are useful if the application adds clients with the
<a href="multifdsink.html#GstMultiFdSink::add-full">add-full</a> signal to make sure that a burst connect can
actually be honored.</p>
<p>When streaming data, clients are allowed to read at a different rate than
the rate at which multifdsink receives data. If the client is reading too
fast, no data will be send to the client until multifdsink receives more
data. If the client, however, reads too slowly, data for that client will be
queued up in multifdsink. Two properties control the amount of data
(buffers) that is queued in multifdsink: GstMultiFdSink:buffers-max and
GstMultiFdSink:buffers-soft-max. A client that falls behind by
GstMultiFdSink:buffers-max is removed from multifdsink forcibly.</p>
<p>A client with a lag of at least GstMultiFdSink:buffers-soft-max enters the recovery
procedure which is controlled with the GstMultiFdSink:recover-policy property.
A recover policy of NONE will do nothing, RESYNC_LATEST will send the most recently
received buffer as the next buffer for the client, RESYNC_SOFT_LIMIT
positions the client to the soft limit in the buffer queue and
RESYNC_KEYFRAME positions the client at the most recent keyframe in the
buffer queue.</p>
<p>multifdsink will by default synchronize on the clock before serving the
buffers to the clients. This behaviour can be disabled by setting the sync
property to FALSE. Multifdsink will by default not do QoS and will never
drop late buffers.</p>

</div>


<h2 class="symbol_section" id="Classes">Classes</h2>


<div class="base_symbol_container" data-hotdoc-tags="" id="GstMultiFdSink">
		<h3 id="multifdsink1">
	multifdsink
</h3>

		<div class="hierarchy_container">
	<div class="hierarchy_details">
<pre>
<a title="GObject" href="https://developer.gnome.org/gobject/unstable/gobject-The-Base-Object-Type.html#GObject-struct">GObject</a>
    <span class="lineart">╰──</span><a title="GInitiallyUnowned" href="https://developer.gnome.org/gobject/unstable/gobject-The-Base-Object-Type.html#GInitiallyUnowned">GInitiallyUnowned</a>
        <span class="lineart">╰──</span><a title="GstObject" href="../libgstreamer-doc-1.0/c/gstobject.html#GstObject">GstObject</a>
            <span class="lineart">╰──</span><a title="GstElement" href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer/html/GstElement.html#GstElement-struct">GstElement</a>
                <span class="lineart">╰──</span><a title="GstBaseSink" href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer-libs/html/GstBaseSink.html#GstBaseSink-struct">GstBaseSink</a>
                    <span class="lineart">╰──</span>GstMultiHandleSink
                        <span class="lineart">╰──</span>multifdsink
</pre>

</div>

</div>

<div class="class_details">
	<p>The multifdsink object structure.</p>

</div>

</div>


<h2 class="symbol_section" id="Pad_Templates">Pad Templates</h2>


<div class="base_symbol_container" data-hotdoc-tags="" id="GstMultiFdSink-&gt;sink">
		<h3 id="sink">
    sink:
</h3>
<table>
    <tbody>
        <tr><td><b>Presence:</b></td><td>always</td></tr>
        <tr><td><b>Direction:</b></td><td>sink</td></tr>
        <tr><td><b>Capabilities:</b></td><td>ANY</td></tr>
    </tbody>
</table>

			
</div>


<h2 class="symbol_section" id="Signals">Signals</h2>


<div class="base_symbol_container" data-hotdoc-tags="" id="GstMultiFdSink::add">
		<h3 id="add">
	<span><code>add</code></span>
</h3>

		

<pre class="prototype">
void
add_callback (GstMultiFdSink * gstmultifdsink,
              gint fd,
              gpointer udata)</pre>

<p>Hand the given open file descriptor to multifdsink to write to.</p>

	<div class="parameter_container">
		<h4 id="parameters">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>gstmultifdsink:</code></em></i>
		</p>
	</td>
		<td><p>the multifdsink element to emit this signal on</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>fd:</code></em></i>
		</p>
	</td>
		<td><p>the file descriptor to add to multifdsink</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>udata:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
			<h4 id="returns">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		
	</td>
	<td>
		void
	</td>
	</tr>

					</tbody>
	</table>
</div>




</div>



<div class="base_symbol_container" data-hotdoc-tags="" id="GstMultiFdSink::add-full">
		<h3 id="addfull">
	<span><code>add-full</code></span>
</h3>

		

<pre class="prototype">
void
add_full_callback (GstMultiFdSink * gstmultifdsink,
                   gint fd,
                   GstMultiHandleSinkSyncMethod sync,
                   GstFormat format_min,
                   guint64 value_min,
                   GstFormat format_max,
                   guint64 value_max,
                   gpointer udata)</pre>

<p>Hand the given open file descriptor to multifdsink to write to and
specify the burst parameters for the new connection.</p>

	<div class="parameter_container">
		<h4 id="parameters1">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>gstmultifdsink:</code></em></i>
		</p>
	</td>
		<td><p>the multifdsink element to emit this signal on</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>fd:</code></em></i>
		</p>
	</td>
		<td><p>the file descriptor to add to multifdsink</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>sync:</code></em></i>
		</p>
	</td>
		<td><p>the sync method to use</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>format_min:</code></em></i>
		</p>
	</td>
		<td><p>the format of <em>value_min</em></p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>value_min:</code></em></i>
		</p>
	</td>
		<td><p>the minimum amount of data to burst expressed in
<em>format_min</em> units.</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>format_max:</code></em></i>
		</p>
	</td>
		<td><p>the format of <em>value_max</em></p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>value_max:</code></em></i>
		</p>
	</td>
		<td><p>the maximum amount of data to burst expressed in
<em>format_max</em> units.</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>udata:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
			<h4 id="returns1">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		
	</td>
	<td>
		void
	</td>
	</tr>

					</tbody>
	</table>
</div>




</div>



<div class="base_symbol_container" data-hotdoc-tags="" id="GstMultiFdSink::remove">
		<h3 id="remove">
	<span><code>remove</code></span>
</h3>

		

<pre class="prototype">
void
remove_callback (GstMultiFdSink * gstmultifdsink,
                 gint fd,
                 gpointer udata)</pre>

<p>Remove the given open file descriptor from multifdsink.</p>

	<div class="parameter_container">
		<h4 id="parameters2">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>gstmultifdsink:</code></em></i>
		</p>
	</td>
		<td><p>the multifdsink element to emit this signal on</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>fd:</code></em></i>
		</p>
	</td>
		<td><p>the file descriptor to remove from multifdsink</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>udata:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
			<h4 id="returns2">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		
	</td>
	<td>
		void
	</td>
	</tr>

					</tbody>
	</table>
</div>




</div>



<div class="base_symbol_container" data-hotdoc-tags="" id="GstMultiFdSink::remove-flush">
		<h3 id="removeflush">
	<span><code>remove-flush</code></span>
</h3>

		

<pre class="prototype">
void
remove_flush_callback (GstMultiFdSink * gstmultifdsink,
                       gint fd,
                       gpointer udata)</pre>

<p>Remove the given open file descriptor from multifdsink after flushing all
the pending data to the fd.</p>

	<div class="parameter_container">
		<h4 id="parameters3">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>gstmultifdsink:</code></em></i>
		</p>
	</td>
		<td><p>the multifdsink element to emit this signal on</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>fd:</code></em></i>
		</p>
	</td>
		<td><p>the file descriptor to remove from multifdsink</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>udata:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
			<h4 id="returns3">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		
	</td>
	<td>
		void
	</td>
	</tr>

					</tbody>
	</table>
</div>




</div>



<div class="base_symbol_container" data-hotdoc-tags="" id="GstMultiFdSink::get-stats">
		<h3 id="getstats">
	<span><code>get-stats</code></span>
</h3>

		

<pre class="prototype">
GstStructure
get_stats_callback (GstMultiFdSink * gstmultifdsink,
                    gint fd,
                    gpointer udata)</pre>

<p>Get statistics about <em>fd</em>. This function returns a GValueArray to ease
automatic wrapping for bindings.</p>

	<div class="parameter_container">
		<h4 id="parameters4">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>gstmultifdsink:</code></em></i>
		</p>
	</td>
		<td><p>the multifdsink element to emit this signal on</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>fd:</code></em></i>
		</p>
	</td>
		<td><p>the file descriptor to get stats of from multifdsink</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>udata:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
			<h4 id="returns4">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a GValueArray with the statistics. The array contains guint64
values that represent respectively: total number of bytes sent, time
when the client was added, time when the client was
disconnected/removed, time the client is/was active, last activity
time (in epoch seconds), number of buffers dropped.
All times are expressed in nanoseconds (GstClockTime).
The array can be 0-length if the client was not found.</p>

	</td>
	<td>
		GstStructure
	</td>
	</tr>

					</tbody>
	</table>
</div>




</div>



<div class="base_symbol_container" data-hotdoc-tags="" id="GstMultiFdSink::client-added">
		<h3 id="clientadded">
	<span><code>client-added</code></span>
</h3>

		

<pre class="prototype">
void
client_added_callback (GstMultiFdSink * gstmultifdsink,
                       gint fd,
                       gpointer udata)</pre>

<p>The given file descriptor was added to multifdsink. This signal will
be emitted from the streaming thread so application should be prepared
for that.</p>

	<div class="parameter_container">
		<h4 id="parameters5">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>gstmultifdsink:</code></em></i>
		</p>
	</td>
		<td><p>the multifdsink element that emitted this signal</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>fd:</code></em></i>
		</p>
	</td>
		<td><p>the file descriptor that was added to multifdsink</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>udata:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
			<h4 id="returns5">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		
	</td>
	<td>
		void
	</td>
	</tr>

					</tbody>
	</table>
</div>




</div>



<div class="base_symbol_container" data-hotdoc-tags="" id="GstMultiFdSink::client-removed">
		<h3 id="clientremoved">
	<span><code>client-removed</code></span>
</h3>

		

<pre class="prototype">
void
client_removed_callback (GstMultiFdSink * gstmultifdsink,
                         gint fd,
                         GstMultiHandleSinkClientStatus status,
                         gpointer udata)</pre>

<p>The given file descriptor is about to be removed from multifdsink. This
signal will be emitted from the streaming thread so applications should
be prepared for that.</p>
<p><em>gstmultifdsink</em> still holds a handle to <em>fd</em> so it is possible to call
the get-stats signal from this callback. For the same reason it is
not safe to close and reuse <em>fd</em> in this callback.</p>

	<div class="parameter_container">
		<h4 id="parameters6">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>gstmultifdsink:</code></em></i>
		</p>
	</td>
		<td><p>the multifdsink element that emitted this signal</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>fd:</code></em></i>
		</p>
	</td>
		<td><p>the file descriptor that is to be removed from multifdsink</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>status:</code></em></i>
		</p>
	</td>
		<td><p>the reason why the client was removed</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>udata:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
			<h4 id="returns6">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		
	</td>
	<td>
		void
	</td>
	</tr>

					</tbody>
	</table>
</div>




</div>



<div class="base_symbol_container" data-hotdoc-tags="" id="GstMultiFdSink::client-fd-removed">
		<h3 id="clientfdremoved">
	<span><code>client-fd-removed</code></span>
</h3>

		

<pre class="prototype">
void
client_fd_removed_callback (GstMultiFdSink * gstmultifdsink,
                            gint fd,
                            gpointer udata)</pre>

<p>The given file descriptor was removed from multifdsink. This signal will
be emitted from the streaming thread so applications should be prepared
for that.</p>
<p>In this callback, <em>gstmultifdsink</em> has removed all the information
associated with <em>fd</em> and it is therefore not possible to call get-stats
with <em>fd</em>. It is however safe to close and reuse <em>fd</em> in the callback.</p>

	<div class="parameter_container">
		<h4 id="parameters7">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>gstmultifdsink:</code></em></i>
		</p>
	</td>
		<td><p>the multifdsink element that emitted this signal</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>fd:</code></em></i>
		</p>
	</td>
		<td><p>the file descriptor that was removed from multifdsink</p>
</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>udata:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
			<h4 id="returns7">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		
	</td>
	<td>
		void
	</td>
	</tr>

					</tbody>
	</table>
</div>




</div>



<div class="base_symbol_container" data-hotdoc-tags="" id="GstMultiFdSink::clear">
		<h3 id="clear">
	<span><code>clear</code></span>
</h3>

		

<pre class="prototype">
void
clear_callback (GstMultiFdSink * param_0,
                gpointer udata)</pre>


	<div class="parameter_container">
		<h4 id="parameters8">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>param_0:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>udata:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
			<h4 id="returns8">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		
	</td>
	<td>
		void
	</td>
	</tr>

					</tbody>
	</table>
</div>




</div>


<h2 class="symbol_section" id="Properties">Properties</h2>


<div class="base_symbol_container" data-hotdoc-tags="" id="GstMultiFdSink:handle-read">
		<h3 class="method" id="handleread">
	<span><code>handle-read</code></span>
</h3>

		<pre class="property_signature">
“handle-read” <span class="type">gboolean</span>
</pre>



<p>
	Flags :	
	
		
				Read
			
				/		
				Write
			
</p>

</div>


	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
</div>
<div class="hidden-xs col-xl-2">
</div>
	</div>
</div>
</main>

<footer class="page-row">
	<div class="container-fluid">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-xl-2"></div>
		<div class="col-sm-12 col-md-9 col-xl-8">
						
		</div>
		<div class="hidden-xs col-xl-2"></div>
	</div>
</div>
</footer>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>