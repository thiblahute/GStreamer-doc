<!DOCTYPE html>
<html lang="en">
<head>

<base href="..">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>Tracing</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/bootstrap-toc.min.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/jquery.touchSwipe.min.js"></script>
<script src="assets/js/anchor.min.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>

<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/trie.js"></script>
<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>

<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body class="no-script
" data-spy="scroll" data-target="#toc" data-offset="70">

<script>
$('body').removeClass('no-script');
</script>

<nav class="navbar navbar-fixed-top navbar-default" id="topnav">
	<div class="container-fluid">
		<div class="navbar-right">
			<a id="toc-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<form action="" class="navbar-form pull-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                        </form>
		</div>
		<div class="navbar-header">
			<a id="sidenav-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<a id="home-link" href="index.html" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        API References<span class="caret"></span>
    </a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="libgstreamer-1.0/c/index.html">GStreamer core</a>
			</li>
					<li>
				<a href="libs.html">GStreamer Libraries</a>
			</li>
					<li>
				<a href="plugins_doc.html">GStreamer Plugins</a>
			</li>
		</ul>
</li>

<li>
    <a href="application-development/index.html">Application manual</a>
</li>


<li>
    <a href="tutorials/index.html">Tutorials</a>
</li>

			</ul>
			<div class="hidden-xs hidden-sm navbar-text navbar-center">
							</div>
		</div>
	</div>
</nav>

<main>
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-1.0" data-hotdoc-ref="design/tracing.html" class="page_container" id="page-wrapper">
<script src="assets/js/utils.js"></script>

<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
	<script src="assets/js/navigation.js"></script>
			<script src="assets/js/sitemap.js"></script>
	</div>

<div id="body">
	<div id="main">
				    <div id="page-description" data-hotdoc-source="tracing.md" data-hotdoc-role="main">
        <h1 id="tracing">Tracing</h1>
<p>This subsystem will provide a mechanism to get structured tracing info
from GStreamer applications. This can be used for post-run analysis as
well as for live introspection.</p>
<h2 id="use-cases">Use cases</h2>
<ul>
<li>
<p>I’d like to get statistics from a running application.</p>
</li>
<li>
<p>I’d like to to understand which parts of my pipeline use how many
resources.</p>
</li>
<li>
<p>I’d like to know which parts of the pipeline use how much memory.</p>
</li>
<li>
<p>I’d like to know about ref-counts of parts in the pipeline to find
ref-count issues.</p>
</li>
</ul>
<h2 id="non-usecases">Non use-cases</h2>
<ul>
<li>Some element in the pipeline does not play along the rules, find out
which one. This could be done with generic tests.</li>
</ul>
<h2 id="design">Design</h2>
<p>The system brings the following new items: core hooks: probes in the
core api, that will expose internal state when tracing is in use
tracers: plugin features that can process data from the hooks and emit a
log tracing front-ends: applications that consume logs from tracers</p>
<p>Like the logging, the tracer hooks can be compiled out and if not use a
local condition to check if active.</p>
<p>Certain GStreamer core function (such as <code>gst_pad_push()</code> or
<code>gst_element_add_pad()</code>) will call into the tracer subsystem to dispatch
into active tracing modules. Developers will be able to select a list of
plugins by setting an environment variable, such as
<code>GST_TRACERS="meminfo;dbus"</code>. One can also pass parameters to plugins:
<code>GST_TRACERS="log(events,buffers);stats(all)"</code>. When then plugins are
loaded, we’ll add them to certain hooks according to which they are
interested in.</p>
<p>Right now tracing info is logged as <code>GstStructures</code> to the TRACE level.
Idea: Another env var <code>GST_TRACE_CHANNEL</code> could be used to send the
tracing to a file or a socket. See
<a href="https://bugzilla.gnome.org/show_bug.cgi?id=733188">https://bugzilla.gnome.org/show_bug.cgi?id=733188</a> for discussion on
these environment variables.</p>
<h2 id="hook-api">Hook api</h2>
<p>We’ll wrap interesting api calls with two macros, e.g. <code>gst_pad_push()</code>:</p>
<pre><code class="language-c">GstFlowReturn gst_pad_push (GstPad * pad, GstBuffer * buffer) {
  GstFlowReturn res;

  g_return_val_if_fail (GST_IS_PAD (pad), GST_FLOW_ERROR);
  g_return_val_if_fail (GST_PAD_IS_SRC (pad), GST_FLOW_ERROR);
  g_return_val_if_fail (GST_IS_BUFFER (buffer), GST_FLOW_ERROR);

  GST_TRACER_PAD_PUSH_PRE (pad, buffer);
  res = gst_pad_push_data (pad,
      GST_PAD_PROBE_TYPE_BUFFER | GST_PAD_PROBE_TYPE_PUSH, buffer);
  GST_TRACER_PAD_PUSH_POST (pad, res);
  return res;
}
</code></pre>
<p>TODO(ensonic): gcc has some magic for wrapping functions -
<a href="http://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html">http://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html</a> -
<a href="http://www.clifford.at/cfun/gccfeat/#gccfeat05.c">http://www.clifford.at/cfun/gccfeat/#gccfeat05.c</a></p>
<p>TODO(ensonic): we should eval if we can use something like jump_label
in the kernel - <a href="http://lwn.net/Articles/412072/">http://lwn.net/Articles/412072/</a> +
<a href="http://lwn.net/Articles/435215/">http://lwn.net/Articles/435215/</a> -
<a href="http://lxr.free-electrons.com/source/kernel/jump_label.c">http://lxr.free-electrons.com/source/kernel/jump_label.c</a> -
<a href="http://lxr.free-electrons.com/source/include/linux/jump_label.h">http://lxr.free-electrons.com/source/include/linux/jump_label.h</a> -
<a href="http://lxr.free-electrons.com/source/arch/x86/kernel/jump_label.c">http://lxr.free-electrons.com/source/arch/x86/kernel/jump_label.c</a>
TODO(ensonic): liblttng-ust provides such a mechanism for user-space -
but this is mostly about logging traces - it is linux specific :/</p>
<p>In addition to api hooks we should also provide timer hooks. Interval
timers are useful to get e.g. resource usage snapshots. Also absolute
timers might make sense. All this could be implemented with a clock
thread. We can use another env-var <code>GST_TRACE_TIMERS="100ms,75ms"</code> to
configure timers and then pass them to the tracers like,
<code>GST_TRACERS="rusage(timer=100ms);meminfo(timer=75ms)"</code>. Maybe we can
create them ad-hoc and avoid the <code>GST_TRACE_TIMERS</code> var.</p>
<p>Hooks (* already implemented)</p>
<pre><code>* gst_bin_add
* gst_bin_remove
* gst_element_add_pad
* gst_element_post_message
* gst_element_query
* gst_element_remove_pad
* gst_element_factory_make
* gst_pad_link
* gst_pad_pull_range
* gst_pad_push
* gst_pad_push_list
* gst_pad_push_event
* gst_pad_unlink
</code></pre>
<h2 id="tracer-api">Tracer api</h2>
<p>Tracers are plugin features. They have a simple api:</p>
<p>class init Here the tracers describe the data the will emit.</p>
<p>instance init Tracers attach handlers to one or more hooks using
<code>gst_tracing_register_hook()</code>. In case the are configurable, they can
read the options from the <em>params</em> property. This is the extra detail
from the environment var.</p>
<p>hook functions Hooks marshal the parameters given to a trace hook into
varargs and also add some extra into such as a timestamp. Hooks will be
called from misc threads. The trace plugins should only consume (=read)
the provided data. Expensive computation should be avoided to not affect
the execution too much. Most trace plugins will log data to a trace
channel.</p>
<p>instance destruction Tracers can output results and release data. This
would ideally be done at the end of the applications, but <code>gst_deinit()</code>
is not mandatory. <code>gst_tracelib</code> was using a <code>gcc_destructor</code>. Ideally
tracer modules log data as they have them and leave aggregation to a
tool that processes the log.</p>
<h2 id="tracer-event-classes">tracer event classes</h2>
<p>Most tracers will log some kind of <em>events</em> : a data transfer, an event,
a message, a query or a measurement. Every tracer should describe the
data format. This way tools that process tracer logs can show the data
in a meaningful way without having to know about the tracer plugin.</p>
<p>One way would be to introspect the data from the plugin. This has the
disadvantage that the postprocessing app needs to load the plugins or
talk to the gstreamer registry. An alternative is to also log the format
description into the log. Right now we’re logging several nested
<code>GstStructure</code> from the <code>tracer_class_init()</code> function (except in the
log tracer).</p>
<pre><code>gst_tracer_record_new ("thread-rusage.class",
    // value in the log record (order does not matter)
    // *thread-id* is a *key* to related the record to something as indicated
    // by *scope* substructure "thread-id",
    GST_TYPE_STRUCTURE, gst_structure_new ("scope", "type",
        G_TYPE_GTYPE, G_TYPE_GUINT64, "related-to",
        GST_TYPE_TRACER_VALUE_SCOPE, GST_TRACER_VALUE_SCOPE_THREAD,
        NULL),
        // next value in the record // *average-cpuload* is a measurement as indicated by the *value*
        // substructure "average-cpuload",
    GST_TYPE_STRUCTURE, gst_structure_new ("value", // value type
        "type", G_TYPE_GTYPE, G_TYPE_UINT,
        // human readable description, that can be used as a graph label
        "description", G_TYPE_STRING, "average cpu usage per thread",
        // flags that help to use the right graph type
        // flags { aggregated, windowed, cumulative, … }
        "flags", GST_TYPE_TRACER_VALUE_FLAGS, GST_TRACER_VALUE_FLAGS_AGGREGATED,
        // value range
        "min", G_TYPE_UINT, 0, "max", G_TYPE_UINT, 100, NULL),
    … NULL);
</code></pre>
<p>A few ideas that are not yet in the above spec:</p>
<ul>
<li>it would be nice to describe the unit of values
<ul>
<li>putting it into the description is not flexible though, e.g. time
would be a guint64 but a ui would reformat it to e.g. h:m:s.ms</li>
<li>other units are e.g.: percent, per-mille, or kbit/s</li>
</ul>
</li>
<li>we’d like to have some metadata on scopes
<ul>
<li>e.g. we’d like to log the thread-names, so that a UI can show
that instead of thread-ids</li>
<li>the stats tracer logs <em>new-element</em> and <em>new-pad</em> messages</li>
<li>they add a unique <em>ix</em> to each instance as the memory ptr can be
reused for new instances, the data is attached to the objects as qdata</li>
<li>the latency tracer would like to also reference this metadata</li>
</ul>
</li>
</ul>
<p>Right now we log the classes as structures, this is important so that the log
is self contained. It would be nice to add them to the registry, so that
gst-inspect can show them. We could also consider to add each value as a
READONLY gobject property. The property has name/description. We could use
qdata for scope and flags (or have some new property flags). We would also
need a new "notify" signal, so that value-change notifications would include a
time-stamp. This way the tracers would not needs to be aware of the
logging. The core tracer would register the notify handlers and emit the
log. Or we just add a <code>gst_tracer_class_install_event()</code> and that
mimics the <code>g_object_class_install_property()</code>.</p>
<p>Frontends can:</p>
<ul>
<li>do an events over time histogram</li>
<li>plot curves of values over time or deltas</li>
<li>show gauges</li>
<li>collect statistics (min, max, avg, …)</li>
</ul>
<h2 id="latency">latency</h2>
<ul>
<li>register to buffer and event flow</li>
<li>send custom event on buffer flow at source elements</li>
<li>catch events on event transfer at sink elements</li>
</ul>
<h2 id="meminfo-not-yet-implemented">meminfo (not yet implemented)</h2>
<ul>
<li>register to an interval-timer hook.</li>
<li>call <code>mallinfo()</code> and log memory usage rusage</li>
<li>register to an interval-timer hook.</li>
<li>call <code>getrusage()</code> and log resource usage</li>
</ul>
<h2 id="dbus-not-yet-implemented">dbus (not yet implemented)</h2>
<ul>
<li>provide a dbus iface to announce applications that are traced</li>
<li>tracing UIs can use the dbus iface to find the channels where logging and
tracing is getting logged to</li>
<li>one would start the tracing UI first and when the application is started with
tracing activated, the dbus plugin will announce the new application,
upon which the tracing UI can start reading from the log channels, this avoid
missing some data</li>
</ul>
<h2 id="topology-not-yet-implemented">topology (not yet implemented)</h2>
<ul>
<li>register to pipeline topology hooks</li>
<li>tracing UIs can show a live pipeline graph</li>
</ul>
<h2 id="stats">stats</h2>
<ul>
<li>register to buffer, event, message and query flow</li>
<li>tracing apps can do e.g. statistics</li>
</ul>
<h2 id="refcounts-not-yet-implemented">refcounts (not yet implemented)</h2>
<ul>
<li>log ref-counts of objects</li>
<li>just logging them outside of glib/gobject would still make it hard to detect
issues though</li>
</ul>
<h2 id="opengl-not-yet-implemented">opengl (not yet implemented)</h2>
<ul>
<li>upload/download times</li>
<li>there is not hardware agnostic way to get e.g. memory usage info (gl
extensions)</li>
</ul>
<h2 id="memory-not-yet-implemented">memory (not yet implemented)</h2>
<ul>
<li>trace live instance (and pointer to the memory)</li>
<li>use an atexit handler to dump leaked instance
https://bugzilla.gnome.org/show_bug.cgi?id=756760#c6</li>
</ul>
<h2 id="leaks">leaks</h2>
<ul>
<li>
<p>track creation/destruction of <code>GstObject</code> and <code>GstMiniObject</code></p>
</li>
<li>
<p>log those which are still alive when app is exiting and raise an
error if any</p>
</li>
<li>
<p>The tracer takes several parameters in a <code>GstStructure</code> like syntax (without the structure name):</p>
<ul>
<li>check-refs (boolean): Whether to also track object ref and unref operations
example: <code>GST_TRACERS=leaks(check-refs=true)</code> COMMAND</li>
<li>stack-traces-flags: Flags to use when generating stack trace (does not generate stack trace
if not set), valid values are “full” to retrieve as much information as possible in the
backtrace, or “none” for a simple backtrace (usually does not contain line number or source files).
This may significantly increase memory consumption. (You can also set the <code>GST_LEAKS_TRACER_STACK_TRACE</code>
environment variable for that).</li>
<li>filters: (string): A comma separated list of object types to trace (make sure to enclose in
quotation marks)</li>
</ul>
</li>
</ul>
<p><strong>Run the leaks tracer on all <code>GstProxyPad</code> objects logging the references with a full backtraces</strong></p>
<pre><code>GST_TRACERS=leaks(stack-traces-flags=full,filters=”GstProxyPad”,check-refs=true) COMMAND
</code></pre>
<p><strong>Run the leaks tracer on all (mini)objects logging the references with less complete backtraces</strong></p>
<pre><code>GST_TRACERS=leaks(stack-traces-flags=fast,check-refs=true) COMMAND
</code></pre>
<ul>
<li>
<p>If the <code>GST_LEAKS_TRACER_SIG</code> env variable is defined the tracer
will handle the following UNIX signals:</p>
</li>
<li>
<p>SIGUSR1: log alive objects</p>
</li>
<li>
<p>SIGUSR2: create a checkpoint and print a list of objects created and
destroyed since the previous checkpoint.</p>
</li>
</ul>
<h2 id="gstdebugviewer">gst-debug-viewer</h2>
<p>gst-debug-viewer could be given the trace log in addition to the debug
log (or a combined log). Alternatively it would show a dialog that shows
all local apps (if the dbus plugin is loaded) and read the log streams
from the sockets/files that are configured for the app.</p>
<h2 id="gsttracer">gst-tracer</h2>
<p>Counterpart of gst-tracelib-ui.</p>
<h2 id="gststats">gst-stats</h2>
<p>A terminal app that shows summary/running stats like the summary
gst-tracelib shows at the end of a run. Currently only shows an
aggregated status.</p>
<h2 id="livegraphers">live-graphers</h2>
<p>Maybe we can even feed the log into existing live graphers, with a
little driver * <a href="https://github.com/dkogan/feedgnuplot">https://github.com/dkogan/feedgnuplot</a></p>
<ul>
<li>
<p>should tracers log into the debug.log or into a separate log?</p>
</li>
<li>
<p>separate log</p>
</li>
<li>
<p>use a binary format?</p>
</li>
<li>
<p>worse performance (we’re writing two logs at the same time)</p>
</li>
<li>
<p>need to be careful when people to <code>GST_DEBUG_CHANNEL=stderr</code> and
GST_TRACE_CHANNEL=stderr (use a shared channel, but what about the
formats?)</p>
</li>
<li>
<p>debug log</p>
</li>
<li>
<p>the tracer subsystem would need to log the <code>GST_TRACE</code> at a level
that is active</p>
</li>
<li>
<p>should the tracer call <code>gst_debug_category_set_threshold()</code> to
ensure things work, even though the levels don’t make a lot of sense
here</p>
</li>
<li>
<p>make logging a tracer (a hook in <code>gst_debug_log_valist()</code>, move
<code>gst_debug_log_default()</code> to the tracer module)</p>
</li>
<li>
<p>log all debug log to the tracer log, some of the current logging
statements can be replaced by generic logging as shown in the
log-tracer</p>
</li>
<li>
<p>add tools/gst-debug to extract a human readable debug log from the
trace log</p>
</li>
<li>
<p>we could maintain a list of log functions, where
gst_tracer_log_trace() is the default one. This way e.g.
gst-validate could consume the traces directly.</p>
</li>
<li>
<p>when hooking into a timer, should we just have some predefined
intervals?</p>
</li>
<li>
<p>can we add a tracer module that registers the timer hook? then we
could do <code>GST_TRACER="timer(10ms);rusage"</code> right now the tracer hooks
are defined as an enum though.</p>
</li>
<li>
<p>when connecting to a running app, we can’t easily get the <em>current</em>
state if logging is using a socket, as past events are not
explicitly stored, we could determine the current topology and emit
events with <code>GST_CLOCK_TIME_NONE</code> as ts to indicate that the events
are synthetic.</p>
</li>
<li>
<p>we need stable ids for scopes (threads, elements, pads)</p>
</li>
<li>
<p>the address can be reused</p>
</li>
<li>
<p>we can use <code>gst_util_seqnum_next()</code></p>
</li>
<li>
<p>something like <code>gst_object_get_path_string()</code> won’t work as
objects are initially without parent</p>
</li>
<li>
<p>right now the tracing-hooks are enabled/disabled from configure with
<code>--{enable,disable}-gst-tracer-hooks</code> The tracer code and the plugins
are still built though. We should add a
<code>--{enable,disable}-gst-tracer</code> to disabled the whole system,
allthough this is a bit confusing with the <code>--{enable,disable}-trace</code>
option we have already.</p>
</li>
</ul>
<h2 id="try-it">Try it</h2>
<h3 id="traces-for-buffer-flow-events-and-messages-in-trace-level">Traces for buffer flow, events and messages in TRACE level:</h3>
<pre><code>GST_DEBUG="GST_TRACER:7,GST_BUFFER*:7,GST_EVENT:7,GST_MESSAGE:7"
GST_TRACERS=log gst-launch-1.0 fakesrc num-buffers=10 ! fakesink -
</code></pre>
<h3 id="print-some-pipeline-stats-on-exit">Print some pipeline stats on exit:</h3>
<pre><code>GST_DEBUG="GST_TRACER:7" GST_TRACERS="stats;rusage"
GST_DEBUG_FILE=trace.log gst-launch-1.0 fakesrc num-buffers=10
sizetype=fixed ! queue ! fakesink &amp;&amp; gst-stats-1.0 trace.log
</code></pre>
<h3 id="get-ts-averagecpuload-currentcpuload-time-and-plot">get ts, average-cpuload, current-cpuload, time and plot</h3>
<pre><code>GST_DEBUG="GST_TRACER:7" GST_TRACERS="stats;rusage"
GST_DEBUG_FILE=trace.log /usr/bin/gst-play-1.0 $HOME/Videos/movie.mp4 &amp;&amp;
./scripts/gst-plot-traces.sh --format=png | gnuplot eog trace.log.*.png
</code></pre>
<h3 id="print-processing-latencies">print processing latencies</h3>
<pre><code>GST_DEBUG="GST_TRACER:7" GST_TRACERS=latency gst-launch-1.0 \
audiotestsrc num-buffers=10 ! audioconvert ! volume volume=0.7 ! \
autoaudiosink
</code></pre>
<h3 id="raise-a-warning-if-a-leak-is-detected">Raise a warning if a leak is detected</h3>
<pre><code>GST_TRACERS="leaks" gst-launch-1.0 videotestsrc num-buffers=10 !
fakesink
</code></pre>
<h3 id="check-if-any-gstevent-or-gstmessage-is-leaked-and-raise-a-warning">check if any GstEvent or GstMessage is leaked and raise a warning</h3>
<pre><code>GST_DEBUG="GST_TRACER:7" GST_TRACERS="leaks(GstEvent,GstMessage)"
gst-launch-1.0 videotestsrc num-buffers=10 ! fakesink
</code></pre>
<h2 id="performance">Performance</h2>
<pre><code>run ./tests/benchmarks/tracing.sh &lt;tracer(s)&gt; &lt;media&gt;

egrep -c "(proc|thread)-rusage" trace.log 658618 grep -c
"gst_tracer_log_trace" trace.log 823351
</code></pre>
<ul>
<li>we can optimize most of it by using quarks in structures or
eventually avoid structures totally</li>
</ul>

    </div>
        




		
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
	<hr>
	<div id="footer">
		    

	</div>
</div>

<div id="toc-column">
	
		<div class="edit-button">
		

	</div>
		<div id="toc-wrapper">
		<nav id="toc"></nav>
	</div>
</div>
</div>
</main>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>
