<html lang="en">
<head>

<base href="..">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>Synchronisation</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/jquery.touchSwipe.min.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>

<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/trie.js"></script>
<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>

<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body class="no-script
" data-spy="scroll" data-target="#toc" data-offset="70">

<script>
$('body').removeClass('no-script');
</script>

<nav class="navbar navbar-fixed-top navbar-default" id="topnav">
	<div class="container-fluid">
		<div class="navbar-right">
			<a id="toc-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<form action="" class="navbar-form pull-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                        </form>
		</div>
		<div class="navbar-header">
			<a id="sidenav-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<a id="home-link" href="index.html" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        API References<span class="caret"></span>
    </a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="libgstreamer-1.0/c/index.html">GStreamer core</a>
			</li>
					<li>
				<a href="libs.html">GStreamer Libraries</a>
			</li>
					<li>
				<a href="plugins_doc.html">GStreamer Plugins</a>
			</li>
		</ul>
</li>

<li>
    <a href="application-development/index.html">Application manual</a>
</li>


<li>
    <a href="tutorials/index.html">Tutorials</a>
</li>

			</ul>
			<div class="hidden-xs hidden-sm navbar-text navbar-center">
							</div>
		</div>
	</div>
</nav>

<main>
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-1.0" data-hotdoc-ref="design/synchronisation.html" class="page_container" id="page-wrapper">
<script src="assets/js/utils.js"></script>

<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
	<script src="assets/js/navigation.js"></script>
	<script src="assets/js/sitemap.js"></script>
</div>

<div id="body">
	<div id="main">
				    <div id="page-description" data-hotdoc-source="synchronisation.md" data-hotdoc-role="main">
        <h1 id="synchronisation">Synchronisation</h1>
<p>This document outlines the techniques used for doing synchronised
playback of multiple streams.</p>
<p>Synchronisation in a <code>GstPipeline</code> is achieved using the following 3
components:</p>
<ul>
<li>
<p>a <code>GstClock</code>, which is global for all elements in a <code>GstPipeline</code>.</p>
</li>
<li>
<p>Timestamps on a <code>GstBuffer</code>.</p>
</li>
<li>
<p>the SEGMENT event preceding the buffers.</p>
</li>
</ul>
<h2 id="a-gstclock">A GstClock</h2>
<p>This object provides a counter that represents the current time in
nanoseconds. This value is called the <code>absolute_time</code>. A <code>GstClock</code>
always counts time upwards and does not necessarily start at 0.</p>
<p>Different sources exist for this counter:</p>
<ul>
<li>
<p>the system time (with <code>g_get_current_time()</code> and with microsecond
accuracy)</p>
</li>
<li>
<p>monotonic time (with <code>g_get_monotonic_time()</code> with microsecond
accuracy)</p>
</li>
<li>
<p>an audio device (based on number of samples played)</p>
</li>
<li>
<p>a network source based on packets received + timestamps in those
packets (a typical example is an RTP source)</p>
</li>
<li>
<p>…</p>
</li>
</ul>
<p>In GStreamer any element can provide a <code>GstClock</code> object that can be used
in the pipeline. The <code>GstPipeline</code> object will select a clock from all the
providers and will distribute it to all other elements (see
<a href="design/gstpipeline.html">gstpipeline</a>).</p>
<p>While it is possible, it is not recommended to create a clock derived
from the contents of a stream (for example, create a clock from the PCR
in an mpeg-ts stream).</p>
<h2 id="running-time">Running time</h2>
<p>After a pipeline selected a clock it will maintain the <code>running_time</code>
based on the selected clock. This <code>running_time</code> represents the total
time spent in the PLAYING state and is calculated as follows:</p>
<ul>
<li>
<p>If the pipeline is NULL/READY, the <code>running_time</code> is undefined.</p>
</li>
<li>
<p>In PAUSED, the <code>running_time</code> remains at the time when it was last
PAUSED. When the stream is <code>PAUSED</code> for the first time, the
<code>running_time</code> is 0.</p>
</li>
<li>
<p>In PLAYING, the <code>running_time</code> is the delta between the
<code>absolute_time</code> and the base time. The base time is defined as the
<code>absolute_time</code> minus the <code>running_time</code> at the time when the pipeline
is set to <code>PLAYING</code>.</p>
</li>
<li>
<p>after a flushing seek, the <code>running_time</code> is set to 0 (see
<a href="design/seeking.html">seeking</a>). This is accomplished by redistributing a new
base_time to the elements that got flushed.</p>
</li>
</ul>
<p>This algorithm captures the <code>running_time</code> when the pipeline is set from
<code>PLAYING</code> to <code>PAUSED</code> and restores this time based on the current
<code>absolute_time</code> when going back to <code>PLAYING</code>. This allows for both clocks
that progress when in the <code>PAUSED</code> state (systemclock) and clocks that
don’t (audioclock).</p>
<p>The clock and pipeline now provide a <code>running_time</code> to all elements that
want to perform synchronisation. Indeed, the running time can be
observed in each element (during the PLAYING state) as:</p>
<pre><code>    C.running_time = absolute_time - base_time
</code></pre>
<p>We note <code>C.running_time</code> as the <code>running_time</code> obtained by looking at the
clock. This value is monotonically increasing at the rate of the clock.</p>
<h2 id="timestamps">Timestamps</h2>
<p>The <code>GstBuffer</code> timestamps and the preceding SEGMENT event (See
<a href="design/streams.html">streams</a>) define a transformation of the buffer timestamps
to <code>running_time</code> as follows:</p>
<p>The following notation is used:</p>
<p><strong>B</strong>: <code>GstBuffer</code>
- B.timestamp = buffer timestamp (<code>GST_BUFFER_PTS</code> or <code>GST_BUFFER_DTS</code>)</p>
<p><strong>S</strong>:  SEGMENT event preceding the buffers.
- S.start: start field in the SEGMENT event. This is the lowest allowed
timestamp.
- S.stop: stop field in the SEGMENT event. This is the highers allowed
timestamp.
- S.rate: rate field of SEGMENT event. This is the playback rate.
- S.base: a base time for the time. This is the total elapsed <code>running_time</code>
of any previous segments.
- S.offset: an offset to apply to S.start or S.stop. This is the amount that
has already been elapsed in the segment.</p>
<p>Valid buffers for synchronisation are those with B.timestamp between
<code>S.start</code> and <code>S.stop</code> (after applying the <code>S.offset</code>). All other buffers
outside this range should be dropped or clipped to these boundaries (see
also <a href="design/segments.html">segments</a>).</p>
<p>The following transformation to <code>running_time</code> exist:</p>
<pre><code>    if (S.rate &gt; 0.0)
      B.running_time = (B.timestamp - (S.start + S.offset)) / ABS (S.rate) + S.base
      =&gt;
      B.timestamp = (B.running_time - S.base) * ABS (S.rate) + S.start + S.offset
    else
      B.running_time = ((S.stop - S.offset) - B.timestamp) / ABS (S.rate) + S.base
      =&gt;
      B.timestamp = S.stop - S.offset - ((B.running_time - S.base) * ABS (S.rate))
</code></pre>
<p>We write <code>B.running_time</code> as the <code>running_time</code> obtained from the <code>SEGMENT</code>
event and the buffers of that segment.</p>
<p>The first displayable buffer will yield a value of 0 (since <code>B.timestamp == S.start and S.offset and S.base == 0</code>).</p>
<p>For <code>S.rate &gt; 1.0</code>, the timestamps will be scaled down to increase the
playback rate. Likewise, a rate between 0.0 and 1.0 will slow down
playback.</p>
<p>For negative rates, timestamps are received stop S.stop to <code>S.start</code> so
that the first buffer received will be transformed into <code>B.running_time</code>
of 0 (<code>B.timestamp == S.stop and S.base == 0</code>).</p>
<p>This makes it so that <code>B.running_time</code> is always monotonically increasing
starting from 0 with both positive and negative rates.</p>
<h2 id="synchronisation1">Synchronisation</h2>
<p>As we have seen, we can get a <code>running_time</code>:</p>
<ul>
<li>using the clock and the element’s <code>base_time</code> with:</li>
</ul>
<pre><code>        C.running_time = absolute_time - base_time
</code></pre>
<ul>
<li>using the buffer timestamp and the preceding <code>SEGMENT</code> event as (assuming
positive playback rate):</li>
</ul>
<pre><code>        B.running_time = (B.timestamp - (S.start + S.offset)) / ABS (S.rate) + S.base
</code></pre>
<p>We prefix C. and B. before the two running times to note how they were
calculated.</p>
<p>The task of synchronized playback is to make sure that we play a buffer
with <code>B.running_time</code> at the moment when the clock reaches the same
<code>C.running_time</code>.</p>
<p>Thus the following must hold:</p>
<pre><code>    B.running_time = C.running_time
</code></pre>
<p>expaning:</p>
<pre><code>    B.running_time = absolute_time - base_time
</code></pre>
<p>or:</p>
<pre><code>    absolute_time = B.running_time + base_time
</code></pre>
<p>The <code>absolute_time</code> when a buffer with <code>B.running_time</code> should be played
is noted with <code>B.sync_time</code>. Thus:</p>
<pre><code>    B.sync_time = B.running_time + base_time
</code></pre>
<p>One then waits for the clock to reach <code>B.sync_time</code> before rendering the
buffer in the sink (See also <a href="design/clocks.html">clocks</a>).</p>
<p>For multiple streams this means that buffers with the same <code>running_time</code>
are to be displayed at the same time.</p>
<p>A demuxer must make sure that the <code>SEGMENT</code> it emits on its output pads
yield the same <code>running_time</code> for buffers that should be played
synchronized. This usually means sending the same <code>SEGMENT</code> on all pads
and making sure that the synchronized buffers have the same timestamps.</p>
<h2 id="stream-time">Stream time</h2>
<p>The stream time is also known as the position in the stream and is a
value between 0 and the total duration of the media file.</p>
<p>It is the stream time that is used for:</p>
<ul>
<li>
<p>report the <code>POSITION</code> query in the pipeline</p>
</li>
<li>
<p>the position used in seek events/queries</p>
</li>
<li>
<p>the position used to synchronize controller values</p>
</li>
</ul>
<p>Additional fields in the <code>SEGMENT</code> are used:</p>
<ul>
<li>
<p><code>S.time</code>: time field in the <code>SEGMENT</code> event. This the stream-time of
<code>S.start</code></p>
</li>
<li>
<p><code>S.applied_rate</code>: The rate already applied to the segment.</p>
</li>
</ul>
<p>Stream time is calculated using the buffer times and the preceding
<code>SEGMENT</code> event as follows:</p>
<pre><code>    stream_time = (B.timestamp - S.start) * ABS (S.applied_rate) + S.time
    =&gt; B.timestamp = (stream_time - S.time) / ABS(S.applied_rate) + S.start
</code></pre>
<p>For negative rates, <code>B.timestamp</code> will go backwards from <code>S.stop</code> to
<code>S.start</code>, making the stream time go backwards:</p>
<pre><code>    stream_time = (S.stop - B.timestamp) * ABS(S.applied_rate) + S.time
    =&gt; B.timestamp = S.stop - (stream_time - S.time) / ABS(S.applied_rate)
</code></pre>
<p>In the <code>PLAYING</code> state, it is also possible to use the pipeline clock to
derive the current <code>stream_time</code>.</p>
<p>Give the two formulas above to match the clock times with buffer
timestamps allows us to rewrite the above formula for <code>stream_time</code> (and
for positive rates).</p>
<pre><code>    C.running_time = absolute_time - base_time
    B.running_time = (B.timestamp - (S.start + S.offset)) / ABS (S.rate) + S.base

    =&gt;
      (B.timestamp - (S.start + S.offset)) / ABS (S.rate) + S.base = absolute_time - base_time;

    =&gt;
      (B.timestamp - (S.start + S.offset)) / ABS (S.rate) = absolute_time - base_time - S.base;

    =&gt;
      (B.timestamp - (S.start + S.offset)) = (absolute_time - base_time - S.base) * ABS (S.rate)

    =&gt;
      (B.timestamp - S.start) = S.offset + (absolute_time - base_time - S.base) * ABS (S.rate)

    filling (B.timestamp - S.start) in the above formule for stream time

    =&gt;
      stream_time = (S.offset + (absolute_time - base_time - S.base) * ABS (S.rate)) * ABS (S.applied_rate) + S.time
</code></pre>
<p>This last formula is typically used in sinks to report the current
position in an accurate and efficient way.</p>
<p>Note that the stream time is never used for synchronisation against the
clock.</p>

    </div>
        




		
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
	<div id="footer">
		    

	</div>
</div>

<div id="toc-column">
	
		<div class="edit-button">
		

	</div>
		<div id="toc-wrapper">
		<nav id="toc"></nav>
	</div>
</div>
</div>
</main>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>
