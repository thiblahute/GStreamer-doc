<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>States</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/utils.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/navigation.js"></script>


<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>


<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body data-spy="scroll" data-target="#toc" data-offset="70">

<nav class="navbar navbar-fixed-top navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a id="home-link" class="hotdoc-navbar-brand">
				
<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        API References<span class="caret"></span>
    </a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="../gstreamer-1.0/index.html">GStreamer core</a>
			</li>
					<li>
				<a href="../gst-plugins-base-1.0/index.html">GStreamer Plugins Base</a>
			</li>
					<li>
				<a href="../gst-plugins-good-1.0/index.html">GStreamer Plugins Good</a>
			</li>
					<li>
				<a href="../gst-plugins-bad-1.0/index.html">GStreamer Plugins Bad</a>
			</li>
					<li>
				<a href="../gst-plugins-ugly-1.0/index.html">GStreamer Plugins Ugly</a>
			</li>
					<li>
				<a href="../gst-libav-1.0/index.html">GStreamer ffmpeg</a>
			</li>
					<li>
				<a href="../gstreamer-vaapi-1.0/index.html">GStreamer VAAPI</a>
			</li>
					<li>
				<a href="../gst-devtools-1.0/index.html">GStreamer Validate</a>
			</li>
					<li>
				<a href="../gst-rtsp-server/index.html">GStreamer RTSP server</a>
			</li>
					<li>
				<a href="../gst-editing-services-1.0/c/index.html">GStreamer Editing Services</a>
			</li>
		</ul></li>

<li>
    <a href="../application-development/index.html">Application manual</a>
</li>


<li>
    <a href="../tutorials/index.html">Tutorials</a>
</li>

			</ul>
						<form action="" class="navbar-form navbar-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                       </form>
		</div>
	</div>
</nav>

<main class="page-row page-row-expanded">
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-1.0" data-hotdoc-ref="design/states.html" class="page_container" id="page-wrapper">
	<div class="row">
		
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 col-xl-2" id="sidenav-column">
	<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
		<div id="sitenav-wrapper">
			<div class="sidenav-main-panel-body">
				<div id="site-navigation">
				</div>
			</div>
		</div>
	</div>
	<button id="offcanvasleft" class="btn btn-xs" type="button" data-toggle="offcanvasleft">
		<i class="glyphicon glyphicon-chevron-right" id="offcanvasleft-chevron"></i>
	</button>
</div>

<div class="col-xs-12 col-sm-12 col-md-9 col-lg-7 col-xl-8" id="content-column">

	<div id="main">
				    <div id="page-description" data-hotdoc-source="states.md">
        <h1 id="states">States</h1>
<p>Both elements and pads can be in different states. The states of the
pads are linked to the state of the element so the design of the states
is mainly focused around the element states.</p>
<p>An element can be in 4 states. <code>NULL</code>, <code>READY</code>, <code>PAUSED</code> and <code>PLAYING</code>. When an
element is initially instantiated, it is in the NULL state.</p>
<h2 id="state-definitions">State definitions</h2>
<ul>
<li>
<p><code>NULL</code>: This is the initial state of an element.</p>
</li>
<li>
<p><code>READY</code>: The element should be prepared to go to <code>PAUSED</code>.</p>
</li>
<li>
<p><code>PAUSED</code>: The element should be ready to accept and process data. Sink
elements, however, only accept one buffer and then block.</p>
</li>
<li>
<p><code>PLAYING</code>: The same as <code>PAUSED</code> except for live sources and sinks. Sinks
accept and render data. Live sources produce data.</p>
</li>
</ul>
<p>We call the sequence <code>NULL→PLAYING</code> an upwards state change and
<code>PLAYING→NULL</code> a downwards state change.</p>
<h2 id="state-transitions">State transitions</h2>
<p>the following state changes are possible:</p>
<ul>
<li>
<p><code>NULL -&gt; READY</code>:</p>
<ul>
<li>The element must check if the resources it needs are available.
Device sinks and sources typically try to probe the device to constrain
their caps.</li>
<li>The element opens the device, this is needed if the previous step requires
the device to be opened.</li>
</ul>
</li>
<li>
<p><code>READY -&gt; PAUSED</code>:</p>
<ul>
<li>The element pads are activated in order to receive data in <code>PAUSED</code>.
Streaming threads are started.</li>
<li>Some elements might need to return <code>ASYNC</code> and complete the state change
when they have enough information. It is a requirement for sinks to
return <code>ASYNC</code> and complete the state change when they receive the first
buffer or EOS event (preroll). Sinks also block the dataflow when in <code>PAUSED</code>.</li>
<li>A pipeline resets the <code>running_time</code> to 0.</li>
<li>Live sources return <code>NO_PREROLL</code> and don't generate data.</li>
</ul>
</li>
<li>
<p><code>PAUSED -&gt; PLAYING</code>:</p>
<ul>
<li>Most elements ignore this state change.</li>
<li>The pipeline selects a clock and distributes this to all the children
before setting them to <code>PLAYING</code>. This means that it is only allowed to
synchronize on the clock in the <code>PLAYING</code> state.</li>
<li>The pipeline uses the clock and the <code>running_time</code> to calculate the
<code>base_time</code>. This <code>base_time</code> is distributed to all children when
performing the state change.</li>
<li>Sink elements stop blocking on the preroll buffer or event and start
rendering the data.</li>
<li>Sinks can post the EOS message in the <code>PLAYING</code> state. It is not allowed to
post EOS when not in the <code>PLAYING</code> state.</li>
<li>While streaming in <code>PAUSED</code> or <code>PLAYING</code> elements can create and remove
sometimes pads.</li>
<li>Live sources start generating data and return <code>SUCCESS</code>.</li>
</ul>
</li>
<li>
<p><code>PLAYING -&gt; PAUSED</code>:</p>
<ul>
<li>Most elements ignore this state change.</li>
<li>The pipeline calculates the <code>running_time</code> based on the last selected clock
and the <code>base_time</code>. It stores this information to continue playback when
going back to the <code>PLAYING</code> state.</li>
<li>Sinks unblock any clock wait calls.</li>
<li>When a sink does not have a pending buffer to play, it returns <code>ASYNC</code> from
this state change and completes the state change when it receives a new
buffer or an EOS event.</li>
<li>Any queued EOS messages are removed since they will be reposted when going
back to the <code>PLAYING</code> state. The EOS messages are queued in <code>GstBins</code>.</li>
<li>Live sources stop generating data and return <code>NO_PREROLL</code>.</li>
</ul>
</li>
<li>
<p><code>PAUSED -&gt; READY</code>:</p>
<ul>
<li>Sinks unblock any waits in the preroll.</li>
<li>Elements unblock any waits on devices</li>
<li>Chain or <code>get_range()</code> functions return <code>FLUSHING</code>.</li>
<li>The element pads are deactivated so that streaming becomes impossible and
all streaming threads are stopped.</li>
<li>The sink forgets all negotiated formats</li>
<li>Elements remove all sometimes pads</li>
</ul>
</li>
<li>
<p><code>READY -&gt; NULL</code>:</p>
<ul>
<li>Elements close devices</li>
<li>Elements reset any internal state.</li>
</ul>
</li>
</ul>
<h2 id="state-variables">State variables</h2>
<p>An element has 4 state variables that are protected with the object LOCK:</p>
<ul>
<li><code>STATE</code></li>
<li><code>STATE_NEXT</code></li>
<li><code>STATE_PENDING</code></li>
<li><code>STATE_RETURN</code></li>
</ul>
<p>The <code>STATE</code> always reflects the current state of the element. The
<code>STATE_NEXT</code> reflects the next state the element will go to. The
<code>STATE_PENDING</code> always reflects the required state of the element. The
<code>STATE_RETURN</code> reflects the last return value of a state change.</p>
<p>The <code>STATE_NEXT</code> and <code>STATE_PENDING</code> can be <code>VOID_PENDING</code> if the element
is in the right state.</p>
<p>An element has a special lock to protect against concurrent invocations
of <code>set_state()</code>, called the <code>STATE_LOCK</code>.</p>
<h2 id="setting-state-on-elements">Setting state on elements</h2>
<p>The state of an element can be changed with <code>_element_set_state()</code>.
When changing the state of an element all intermediate states will also
be set on the element until the final desired state is set.</p>
<p>The <code>set_state()</code> function can return 3 possible values:</p>
<ul>
<li>
<p><code>GST_STATE_FAILURE</code>: The state change failed for some reason. The plugin should have posted an error message on the bus with information.</p>
</li>
<li>
<p><code>GST_STATE_SUCCESS</code>: The state change is completed successfully.</p>
</li>
<li>
<p><code>GST_STATE_ASYNC</code>: The state change will complete later on. This can happen
when the element needs a long time to perform the state change or for sinks
that need to receive the first buffer before they can complete the state change
(preroll).</p>
</li>
<li>
<p><code>GST_STATE_NO_PREROLL</code>: The state change is completed successfully but the
element will not be able to produce data in the <code>PAUSED</code> state.</p>
</li>
</ul>
<p>In the case of an <code>ASYNC</code> state change, it is possible to proceed to the
next state before the current state change completes, however, the
element will only get to this next state before completing the previous
<code>ASYNC</code> state change. After receiving an <code>ASYNC</code> return value, you can use
<code>element_get_state()</code> to poll the status of the element. If the
polling returns <code>SUCCESS</code>, the element completed the state change to the
last requested state with <code>set_state()</code>.</p>
<p>When setting the state of an element, the <code>STATE_PENDING</code> is set to the
required state. Then the state change function of the element is called
and the result of that function is used to update the <code>STATE</code> and
<code>STATE_RETURN</code> fields, <code>STATE_NEXT</code>, <code>STATE_PENDING</code> and <code>STATE_RETURN</code>
fields. If the function returned <code>ASYNC</code>, this result is immediately
returned to the caller.</p>
<h2 id="getting-the-state-of-elements">Getting the state of elements</h2>
<p>The <code>get_state()</code> function takes 3 arguments, two pointers that will
hold the current and pending state and one <code>GstClockTime</code> that holds a
timeout value. The function returns a <code>GstElementStateReturn</code>.</p>
<ul>
<li>
<p>If the element returned <code>SUCCESS</code> to the previous <code>_set_state()</code>
function, this function will return the last state set on the
element and <code>VOID_PENDING</code> in the pending state value. The function
returns <code>GST_STATE_SUCCESS</code>.</p>
</li>
<li>
<p>If the element returned <code>NO_PREROLL</code> to the previous <code>_set_state()</code>
function, this function will return the last state set on the
element and <code>VOID_PENDING</code> in the pending state value. The function
returns <code>GST_STATE_NO_PREROLL</code>.</p>
</li>
<li>
<p>If the element returned <code>FAILURE</code> to the previous <code>_set_state()</code> call,
this function will return <code>FAILURE</code> with the state set to the current
state of the element and the pending state set to the value used in
the last call of <code>_set_state()</code>.</p>
</li>
<li>
<p>If the element returned <code>ASYNC</code> to the previous <code>_set_state()</code> call,
this function will wait for the element to complete its state change
up to the amount of time specified in the <code>GstClockTime</code>.</p>
<ul>
<li>
<p>If the element does not complete the state change in the
specified amount of time, this function will return <code>ASYNC</code> with
the state set to the current state and the pending state set to
the pending state.</p>
</li>
<li>
<p>If the element completes the state change within the specified
timeout, this function returns the updated state and
<code>VOID_PENDING</code> as the pending state.</p>
</li>
<li>
<p>If the element aborts the <code>ASYNC</code> state change due to an error
within the specified timeout, this function returns <code>FAILURE</code> with
the state set to last successful state and pending set to the
last attempt. The element should also post an error message on
the bus with more information about the problem.</p>
</li>
</ul>
</li>
</ul>
<h2 id="states-in-gstbin">States in GstBin</h2>
<p>A <code>GstBin</code> manages the state of its children. It does this by propagating
the state changes performed on it to all of its children. The
<code>_set_state()</code> function on a bin will call the <code>_set_state()</code> function
on all of its children, that are not already in the target state or in a
change state to the target state.</p>
<p>The children are iterated from the sink elements to the source elements.
This makes sure that when changing the state of an element, the
downstream elements are in the correct state to process the eventual
buffers. In the case of a downwards state change, the sink elements will
shut down first which makes the upstream elements shut down as well
since the <code>_push()</code> function returns a <code>GST_FLOW_FLUSHING</code> error.</p>
<p>If all the children return <code>SUCCESS</code>, the function returns <code>SUCCESS</code> as
well.</p>
<p>If one of the children returns <code>FAILURE</code>, the function returns <code>FAILURE</code> as
well. In this state it is possible that some elements successfully
changed state. The application can check which elements have a changed
state, which were in error and which were not affected by iterating the
elements and calling <code>_get_state()</code> on the elements.</p>
<p>If after calling the state function on all children, one of the children
returned <code>ASYNC</code>, the function returns <code>ASYNC</code> as well.</p>
<p>If after calling the state function on all children, one of the children
returned <code>NO_PREROLL</code>, the function returns <code>NO_PREROLL</code> as well.</p>
<p>If both <code>NO_PREROLL</code> and <code>ASYNC</code> children are present, <code>NO_PREROLL</code> is
returned.</p>
<p>The current state of the bin can be retrieved with <code>_get_state()</code>.</p>
<p>If the bin is performing an <code>ASYNC</code> state change, it will automatically
update its current state fields when it receives state messages from the
children.</p>
<h2 id="implementing-states-in-elements">Implementing states in elements</h2>
<h3 id="upward-state-change">Upward state change</h3>
<p>Upward state changes always return <code>ASYNC</code> either if the <code>STATE_PENDING</code> is
reached or not.</p>
<p>Element:</p>
<ul>
<li>
<p>A -&gt; B =&gt; <code>SUCCESS</code></p>
<ul>
<li>commit state</li>
</ul>
</li>
<li>
<p>A -&gt; B =&gt; <code>ASYNC</code></p>
<ul>
<li>no commit state</li>
<li>element commits state <code>ASYNC</code></li>
</ul>
</li>
<li>
<p>A -&gt; B while <code>ASYNC</code></p>
<ul>
<li>update <code>STATE_PENDING</code> state</li>
<li>no commit state</li>
<li>no <code>change_state()</code> called on element</li>
</ul>
</li>
</ul>
<p>Bin:</p>
<ul>
<li>
<p>A-&gt;B: all elements <code>SUCCESS</code></p>
<ul>
<li>commit state</li>
</ul>
</li>
<li>
<p>A-&gt;B: some elements <code>ASYNC</code></p>
<ul>
<li>no commit state</li>
<li>listen for commit messages on bus</li>
<li>for each commit message, poll elements, this happens in another
thread.</li>
<li>if no <code>ASYNC</code> elements, commit state, continue state change
to <code>STATE_PENDING</code></li>
</ul>
</li>
</ul>
<h3 id="downward-state-change">Downward state change</h3>
<p>Downward state changes only return <code>ASYNC</code> if the final state is <code>ASYNC</code>.
This is to make sure that it’s not needed to wait for an element to
complete the preroll or other <code>ASYNC</code> state changes when one only wants to
shut down an element.</p>
<p>Element:</p>
<p>A -&gt; B =&gt; <code>SUCCESS</code></p>
<ul>
<li>commit state</li>
</ul>
<p>A -&gt; B =&gt; <code>ASYNC</code> not final state</p>
<ul>
<li>commit state on behalf of element</li>
</ul>
<p>A -&gt; B =&gt; <code>ASYNC</code> final state</p>
<ul>
<li>element will commit <code>ASYNC</code></li>
</ul>
<p>Bin:</p>
<p>A -&gt; B -&gt; <code>SUCCESS</code></p>
<ul>
<li>commit state</li>
</ul>
<p>A -&gt; B -&gt; <code>ASYNC</code> not final state</p>
<ul>
<li>commit state on behalf of element, continue state change</li>
</ul>
<p>A -&gt; B =&gt; <code>ASYNC</code> final state</p>
<ul>
<li>no commit state</li>
<li>listen for commit messages on bus</li>
<li>for each commit message, poll elements</li>
<li>if no <code>ASYNC</code> elements, commit state</li>
</ul>
<h2 id="locking-overview-element">Locking overview (element)</h2>
<ul>
<li>
<p>Element committing <code>SUCCESS</code></p>
<ul>
<li>
<p><code>STATE_LOCK</code> is taken in <code>set_state()</code></p>
</li>
<li>
<p>change state is called if <code>SUCCESS</code>, commit state is called</p>
</li>
<li>
<p>commit state calls <code>change_state()</code> to next state change.</p>
</li>
<li>
<p>if final state is reached, stack unwinds and result is returned
to <code>set_state()</code> and caller.</p>
</li>
</ul>
</li>
</ul>
<pre><code>set_state(element)       change_state (element)   commit_state

    |                         |                       |
    |                         |                       |
STATE_LOCK                    |                       |
    |                         |                       |
    |------------------------&gt;|                       |
    |                         |                       |
    |                         |                       |
    |                         | (do state change)     |
    |                         |                       |
    |                         |                       |
    |                         | if `SUCCESS`            |
    |                         |----------------------&gt;|
    |                         |                       | post message
    |                         |                       |
    |                         |&lt;----------------------| if (!final) change_state (next)
    |                         |                       | else SIGNAL
    |                         |                       |
    |                         |                       |
    |                         |                       |
    |&lt;------------------------|                       |
    |     `SUCCESS`
    |
STATE_UNLOCK
    |
  `SUCCESS`
</code></pre>
<ul>
<li>
<p>Element committing <code>ASYNC</code></p>
<ul>
<li>
<p><code>STATE_LOCK</code> is taken in <code>set_state()</code></p>
</li>
<li>
<p>change state is called and returns <code>ASYNC</code></p>
</li>
<li>
<p><code>ASYNC</code> returned to the caller.</p>
</li>
<li>
<p>element takes LOCK in streaming thread.</p>
</li>
<li>
<p>element calls <code>commit_state</code> in streaming thread.</p>
</li>
<li>
<p>commit state calls <code>change_state()</code> to next state
change.</p>
</li>
</ul>
</li>
</ul>
<pre><code>set_state(element)       change_state (element)     stream_thread      commit_state (element)

    |                         |                          |                  |
    |                         |                          |                  |
STATE_LOCK                    |                          |                  |
    |                         |                          |                  |
    |------------------------&gt;|                          |                  |
    |                         |                          |                  |
    |                         |                          |                  |
    |                         | (start_task)             |                  |
    |                         |                          |                  |
    |                         |                     STREAM_LOCK             |
    |                         |                          |...               |
    |&lt;------------------------|                          |                  |
    |     ASYNC                                     STREAM_UNLOCK           |
STATE_UNLOCK                                             |                  |
    |                .....sync........               STATE_LOCK             |
  ASYNC                                                  |-----------------&gt;|
                                                         |                  |
                                                         |                  |---&gt; post_message()
                                                         |                  |---&gt; if (!final) change_state (next)
                                                         |                  |     else SIGNAL
                                                         |&lt;-----------------|
                                                     STATE_UNLOCK
                                                         |
                                                    STREAM_LOCK
                                                         | ...
                                                    STREAM_UNLOCK
</code></pre>
<h2 id="remarks">Remarks</h2>
<p><code>set_state()</code> cannot be called from multiple threads at the same time. The
<code>STATE_LOCK</code> prevents this.</p>
<p>State variables are protected with the LOCK.</p>
<p>Calling <code>set_state()</code> while <code>get_state()</code> is called should unlock the
<code>get_state()</code> with an error. The cookie will do that.</p>
<pre><code class="language-c">set_state(element)

STATE_LOCK

LOCK
update current, next, pending state
cookie++
UNLOCK

change_state

STATE_UNLOCK
</code></pre>

    </div>
        




		<div id="subpages"></div>
		</div>
		<div id="search_results">
			<p>The results of the search are</p>
		</div>
	</div>

</div>

<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2">
	<div id="toc-column">
		
					<div class="edit-button">
				

			</div>
				<div id="toc-wrapper">
			<nav id="toc"></nav>
		</div>
	</div>
</div>
	</div>

</main>


<footer class="page-row">
	<div class="container-fluid">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-lg-3 col-xl-2" id="footer-left-column"></div>
		<div class="col-xs-12 col-sm-12 col-md-9 col-lg-7 col-xl-8" id="footer-content-column">
						    

		</div>
		<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2" id="footer-right-column"></div>
	</div>
</div>
</footer>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>