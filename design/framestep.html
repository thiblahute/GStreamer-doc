<html lang="en">
<head>

<base href="..">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>Frame step</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/bootstrap-toc.min.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/jquery.touchSwipe.min.js"></script>
<script src="assets/js/anchor.min.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>

<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>

<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body class="no-script
" data-spy="scroll" data-target="#toc" data-offset="70">

<script>
$('body').removeClass('no-script');
</script>

<nav class="navbar navbar-fixed-top navbar-default" id="topnav">
	<div class="container-fluid">
		<div class="navbar-right">
			<a id="toc-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<form action="" class="navbar-form pull-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                        </form>
		</div>
		<div class="navbar-header">
			<a id="sidenav-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<a id="home-link" href="index.html" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        API References<span class="caret"></span>
    </a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="libgstreamer-1.0/c/index.html">GStreamer core</a>
			</li>
					<li>
				<a href="libs.html">GStreamer Libraries</a>
			</li>
					<li>
				<a href="plugins_doc.html">GStreamer Plugins</a>
			</li>
		</ul>
</li>

<li>
    <a href="application-development/index.html">Application manual</a>
</li>


<li>
    <a href="tutorials/index.html">Tutorials</a>
</li>

			</ul>
			<div class="hidden-xs hidden-sm navbar-text navbar-center">
							</div>
		</div>
	</div>
</nav>

<main>
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-1.0" data-hotdoc-ref="design/framestep.html" class="page_container" id="page-wrapper">
<script src="assets/js/utils.js"></script>

<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
	<script src="assets/js/navigation.js"></script>
			<script src="assets/js/sitemap.js"></script>
	</div>

<div id="body">
	<div id="main">
				    <div id="page-description" data-hotdoc-source="framestep.md" data-hotdoc-role="main">
        <h1 id="frame-step">Frame step</h1>
<p>This document outlines the details of the frame stepping functionality
in GStreamer.</p>
<p>The stepping functionality operates on the current playback segment,
position and rate as it was configured with a regular seek event. In
contrast to the seek event, it operates very closely to the sink and
thus has a very low latency and is not slowed down by queues and does
not actually perform any seeking logic. For this reason we want to
include a new API instead of reusing the seek API.</p>
<p>The following requirements are needed:</p>
<ul>
<li>
<p>The ability to walk forwards and backwards in the stream.</p>
</li>
<li>
<p>Arbitrary increments in any supported format (time, frames, bytes …)</p>
</li>
<li>
<p>High speed, minimal overhead. This mechanism is not more expensive
than simple playback.</p>
</li>
<li>
<p>switching between forwards and backwards stepping should be fast.</p>
</li>
<li>
<p>Maintain synchronisation between streams.</p>
</li>
<li>
<p>Get feedback of the amount of skipped data.</p>
</li>
<li>
<p>Ability to play a certain amount of data at an arbitrary speed.</p>
</li>
</ul>
<p>We want a system where we can step frames in <code>PAUSED</code> as well as play
short segments of data in <code>PLAYING</code>.</p>
<h2 id="use-cases">Use Cases</h2>
<h3 id="video-only-pipeline-in-paused">video only pipeline in PAUSED</h3>
<pre><code>.-----.    .-------.              .------.    .-------.
| src |    | demux |    .-----.   | vdec |    | vsink |
|    src-&gt;sink    src1-&gt;|queue|-&gt;sink   src-&gt;sink     |
'-----'    '-------'    '-----'   '------'    '-------'
</code></pre>
<ul>
<li>
<p>app sets the pipeline to <code>PAUSED</code> to block on the preroll picture</p>
</li>
<li>
<p>app seeks to required position in the stream. This can be done
with a positive or negative rate depending on the required frame
stepping direction.</p>
</li>
<li>
<p>app steps frames (in <code>GST_FORMAT_DEFAULT</code> or <code>GST_FORMAT_BUFFER)</code>. The
pipeline loses its <code>PAUSED</code> state until the required number of frames have been
skipped, it then prerolls again. This skipping is purely done in the sink.</p>
</li>
<li>
<p>sink posts <code>STEP_DONE</code> with amount of frames stepped and
corresponding time interval.</p>
</li>
</ul>
<h3 id="audiovideo-pipeline-in-paused">audio/video pipeline in PAUSED</h3>
<pre><code>.-----.    .-------.              .------.    .-------.
| src |    | demux |    .-----.   | vdec |    | vsink |
|    src-&gt;sink    src1-&gt;|queue|-&gt;sink   src-&gt;sink     |
'-----'    |       |    '-----'   '------'    '-------'
           |       |              .------.    .-------.
           |       |    .-----.   | adec |    | asink |
           |      src2-&gt;|queue|-&gt;sink   src-&gt;sink     |
           '-------'    '-----'   '------'    '-------'
</code></pre>
<ul>
<li>
<p>app sets the pipeline to <code>PAUSED</code> to block on the preroll picture</p>
</li>
<li>
<p>app seeks to required position in the stream. This can be done
with a positive or negative rate depending on the required frame
stepping direction.</p>
</li>
<li>
<p>app steps frames (in <code>GST_FORMAT_DEFAULT</code> or <code>GST_FORMAT_BUFFER</code>) or an
amount of time on the video sink. The pipeline loses its <code>PAUSED</code> state until
the required number of frames have been skipped, it then prerolls again. This
skipping is purely done in the sink.</p>
</li>
<li>
<p>sink posts <code>STEP_DONE</code> with amount of frames stepped and
corresponding time interval.</p>
</li>
<li>
<p>the app skips the same amount of time on the audiosink to align
the streams again. When huge amount of video frames are skipped,
there needs to be enough queueing in the pipeline to compensate
for the accumulated audio.</p>
</li>
</ul>
<h3 id="audiovideo-pipeline-in-playing">audio/video pipeline in PLAYING</h3>
<ul>
<li>
<p>app sets the pipeline to <code>PAUSED</code> to block on the preroll picture</p>
</li>
<li>
<p>app seeks to required position in the stream. This can be done
with a positive or negative rate depending on the required frame
stepping direction.</p>
</li>
<li>
<p>app configures frames steps (in <code>GST_FORMAT_DEFAULT</code> or
<code>GST_FORMAT_BUFFER</code> or an amount of time on the sink. The step event has
a flag indicating live stepping so that the stepping will only happens in
PLAYING.</p>
</li>
<li>
<p>app sets pipeline to PLAYING. The pipeline continues PLAYING
until it consumed the amount of time.</p>
</li>
<li>
<p>sink posts <code>STEP_DONE</code> with amount of frames stepped and
corresponding time interval. The sink will then wait for another
step event. Since the <code>STEP_DONE</code> message was emitted by the sink
when it handed off the buffer to the device, there is usually
sufficient time to queue a new STEP event so that one can
seamlessly continue stepping.</p>
</li>
</ul>
<h2 id="events">events</h2>
<p>A new <code>GST_EVENT_STEP</code> event is introduced to start the step operation.
The step event is created with the following fields in the structure:</p>
<ul>
<li>
<p><strong><code>format</code></strong> <code>GST_TYPE_FORMAT</code>: The format of the step units</p>
</li>
<li>
<p><strong><code>amount</code></strong> <code>G_TYPE_UINT64</code>: The amount of units to step. A 0 amount
immediately completes and can be used to cancel the current step and resume
normal non-stepping behaviour to the end of the segment. A -1 amount steps
until the end of the segment.</p>
</li>
<li>
<p><strong><code>rate</code></strong> <code>G_TYPE_DOUBLE</code>: The rate at which the frames should be stepped in
PLAYING mode. 1.0 is the normal playback speed and direction of the segment,
2.0 is double speed. A speed of 0.0 is not allowed. When performing a flushing
step, the speed is not relevant. Note that we don't allow negative rates here,
use a seek with a negative rate first to reverse the playback direction.</p>
</li>
<li>
<p><strong><code>flush</code></strong> <code>G_TYPE_BOOLEAN</code>: when flushing is TRUE, the step is performed
immediately:</p>
<ul>
<li>
<p>In the <code>PAUSED</code> state the pipeline loses the <code>PAUSED</code> state, the
requested amount of data is skipped and the pipeline prerolls again
when a non-intermediate step completes. When the pipeline was
stepping while the event is sent, the current step operation is
updated with the new amount and format. The sink will do a best
effort to comply with the new amount.</p>
</li>
<li>
<p>In the PLAYING state, the pipeline loses the <code>PLAYING</code> state, the
requested amount of data is skipped (not rendered) from the previous
STEP request or from the position of the last <code>PAUSED</code> if no previous
STEP operation was performed. The pipeline goes back to the <code>PLAYING</code>
state when a non-intermediate step completes.</p>
</li>
<li>
<p>When flushing is FALSE, the step will be performed later.</p>
</li>
<li>
<p>In the <code>PAUSED</code> state the step will be done when going to <code>PLAYING</code>. Any
previous step operation will be overridden with the new <code>STEP</code> event.</p>
</li>
<li>
<p>In the <code>PLAYING</code> state the step operation will be performed after the
current step operation completes. If there was no previous step
operation, the step operation will be performed from the position of
the last <code>PAUSED</code> state.</p>
</li>
</ul>
</li>
<li>
<p><strong><code>intermediate</code></strong> <code>G_TYPE_BOOLEAN</code>: Signal that this step operation is an
intermediate step, part of a series of step operations. It is mostly
interesting for stepping in the <code>PAUSED</code> state because the sink will only perform
a preroll after a non-intermediate step operation completes. Intermediate steps
are useful to flush out data from other sinks in order to not cause excessive
queueing. In the PLAYING state the intermediate flag has no visual effect. In
all states, the intermediate flag is passed to the corresponding
<code>GST_MESSAGE_STEP_DONE</code>.</p>
</li>
</ul>
<p>The application will create a STEP event to start or stop the stepping
operation. Both stepping in <code>PAUSED</code> and <code>PLAYING</code> can be performed by means
of the flush flag.</p>
<p>The event is usually sent to the pipeline, which will typically
distribute the event to all of its sinks. For some use cases, like frame
stepping on video frames only, the event should only be sent to the
video sink and upon reception of the <code>STEP_DONE</code> message, one can step
the other sinks to align the streams again.</p>
<p>For large stepping amounts, there needs to be enough queueing in front
of all the sinks. If large steps need to be performed, they can be split
up into smaller step operations using the "intermediate" flag on the
step.</p>
<p>Since the step event does not update the <code>base_time</code> of any of the
elements, the sinks should keep track of the amount of stepped data in
order to remain synchronized against the clock.</p>
<h2 id="messages">messages</h2>
<p>A <code>GST_MESSAGE_STEP_START</code> is created. It contains the following
fields.</p>
<ul>
<li>
<p><strong><code>active</code></strong>: If the step was queued or activated.</p>
</li>
<li>
<p><strong><code>format</code></strong> <code>GST_TYPE_FORMAT</code>: The format of the step units that queued/activated.</p>
</li>
<li>
<p><strong><code>amount</code></strong> <code>G_TYPE_UINT64</code>: The amount of units that were queued/activated.</p>
</li>
<li>
<p><strong><code>rate</code></strong> <code>G_TYPE_DOUBLE</code>: The rate and direction at which the frames were queued/activated.</p>
</li>
<li>
<p><strong><code>flush</code></strong> <code>G_TYPE_BOOLEAN</code>: If the queued/activated frames will be flushed.</p>
</li>
<li>
<p><strong><code>intermediate</code></strong> <code>G_TYPE_BOOLEAN</code>: If this is an intermediate step operation
that queued/activated.</p>
</li>
</ul>
<p>The <code>STEP_START</code> message is emitted 2 times:</p>
<ul>
<li>
<p>first when an element received the STEP event and queued it. The
"active" field will be FALSE in this case.</p>
</li>
<li>
<p>second when the step operation started in the streaming thread. The
"active" field is TRUE in this case. After this message is emitted,
the application can queue a new step operation.</p>
</li>
</ul>
<p>The purpose of this message is to find out how many elements participate
in the step operation and to queue new step operations at the earliest
possible moment.</p>
<p>A new <code>GST_MESSAGE_STEP_DONE</code> message is created. It contains the
following fields:</p>
<ul>
<li>
<strong><code>format</code></strong> <code>GST_TYPE_FORMAT</code>: The format of the step units that completed.</li>
<li>
<strong><code>amount</code></strong> <code>G_TYPE_UINT64</code>: The amount of units that were stepped.</li>
<li>
<strong><code>rate</code></strong> <code>G_TYPE_DOUBLE</code>: The rate and direction at which the frames were stepped.</li>
<li>
<strong><code>flush</code></strong> <code>G_TYPE_BOOLEAN</code>: If the stepped frames were flushed.</li>
<li>
<strong><code>intermediate</code></strong> <code>G_TYPE_BOOLEAN</code>: If this is an intermediate step operation that completed.</li>
<li>
<strong><code>duration</code></strong> <code>G_TYPE_UINT64</code>: The total duration of the stepped units in <code>GST_FORMAT_TIME</code>.</li>
<li>
<strong><code>eos</code></strong> <code>G_TYPE_BOOLEAN</code>: The step ended because of EOS.</li>
</ul>
<p>The message is emitted by the element that performs the step operation.
The purpose is to return the duration in <code>GST_FORMAT_TIME</code> of the
stepped media. This especially interesting to align other stream in case
of stepping frames on the video sink element.</p>
<h2 id="direction-switch">Direction switch</h2>
<p>When quickly switching between a forwards and a backwards step of, for
example, one video frame, we need either:</p>
<ol>
<li>issue a new seek to change the direction from the current position.</li>
<li>cache a certain number of stepped frames and walk the cache.</li>
</ol>
<p>option 1) might be very slow. For option 2) we would ideally like to
offload this caching functionality to a separate element, which means
that we need to forward the STEP event upstream. It’s unclear how this
could work in a generic way. What is a demuxer supposed to do when it
received a step event? a flushing seek to what stream position?</p>

    </div>
        




		
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
	<hr>
	<div id="footer">
		    

	</div>
</div>

<div id="toc-column">
	
		<div class="edit-button">
		

	</div>
		<div id="toc-wrapper">
		<nav id="toc"></nav>
	</div>
</div>
</div>
</main>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>
