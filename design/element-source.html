<!DOCTYPE html>
<html lang="en">
<head>

<base href="..">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>Source elements</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/bootstrap-toc.min.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/scrollspy.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/jquery.touchSwipe.min.js"></script>
<script src="assets/js/anchor.min.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>

<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/trie.js"></script>
<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>

<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body class="no-script
" data-spy="scroll" data-target="#toc" data-offset="70">

<script>
$('body').removeClass('no-script');
</script>

<nav class="navbar navbar-fixed-top navbar-default" id="topnav">
	<div class="container-fluid">
		<div class="navbar-right">
			<a id="toc-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<form action="" class="navbar-form pull-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                        </form>
		</div>
		<div class="navbar-header">
			<a id="sidenav-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<a id="home-link" href="index.html" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        API References<span class="caret"></span>
    </a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="libgstreamer-1.0/index.html">GStreamer core</a>
			</li>
					<li>
				<a href="libs.html">GStreamer Libraries</a>
			</li>
					<li>
				<a href="plugins_doc.html">GStreamer Plugins</a>
			</li>
		</ul>
</li>

<li>
    <a href="application-development/index.html">Application manual</a>
</li>


<li>
    <a href="tutorials/index.html">Tutorials</a>
</li>

			</ul>
			<div class="hidden-xs hidden-sm navbar-text navbar-center">
							</div>
		</div>
	</div>
</nav>

<main>
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-1.0" data-hotdoc-ref="design/element-source.html" class="page_container" id="page-wrapper" data-hotdoc-meta-gi-languages="['javascript', 'c', 'python']">
<script src="assets/js/utils.js"></script>

<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
	<script src="assets/js/navigation.js"></script>
	<script src="assets/js/sitemap.js"></script>
</div>

<div id="body">
	<div id="main">
				    <div id="page-description" data-hotdoc-source="element-source.md" data-hotdoc-role="main">
        <h1 id="source-elements">Source elements</h1>
<p>A source element is an element that provides data to the pipeline. It
does typically not have any sink (input) pads.</p>
<p>Typical source elements include:</p>
<ul>
<li>
<p>file readers</p>
</li>
<li>
<p>network elements (live or not)</p>
</li>
<li>
<p>capture elements (video/audio/…)</p>
</li>
<li>
<p>generators (signals/video/audio/…)</p>
</li>
</ul>
<h2 id="live-sources">Live sources</h2>
<p>A source is said to be a live source when it has the following property:</p>
<ul>
<li>temporarily stopping reading from the source causes data to be lost.</li>
</ul>
<p>In general when this property holds, the source also produces data at a
fixed rate. Most sources have a limit on the rate at which they can
deliver data, which might be faster or slower than the consumption rate.
This property however does not make them a live source.</p>
<p>Let’s look at some example sources.</p>
<ul>
<li>
<p>file readers: you can PAUSE without losing data. There is however a
limit to how fast you can read from this source. This limit is
usually much higher than the consumption rate. In some cases it
might be slower (an NFS share, for example) in which case you might
need to use some buffering (see <a href="design/buffering.html">buffering</a>).</p>
</li>
<li>
<p>HTTP network element: you can PAUSE without data loss. Depending on
the available network bandwidth, consumption rate might be higher
than production rate in which case buffering should be used (see
<a href="design/buffering.html">buffering</a>).</p>
</li>
<li>
<p>audio source: pausing the audio capture will lead to lost data. this
source is therefore definitely live. In addition, an audio source
will produce data at a fixed rate (the samplerate). Also depending
on the buffersize, this source will introduce a latency (see
<a href="design/latency.html">latency</a>).</p>
</li>
<li>
<p>udp network source: Pausing the receiving part will lead to lost
data. This source is therefore a live source. Also in a typical case
the udp packets will be received at a certain rate, which might be
difficult to guess because of network jitter. This source does not
necessarily introduce latency on its own.</p>
</li>
<li>
<p>dvb source: PAUSING this element will lead to data loss, it’s a live
source similar to a UDP source.</p>
</li>
</ul>
<h2 id="source-types">Source types</h2>
<p>A source element can operate in three ways:</p>
<ul>
<li>
<p>it is fully seekable, this means that random access can be performed
on it in an efficient way. (a file reader,…). This also typically
means that the source is not live.</p>
</li>
<li>
<p>data can be obtained from it with a variable size. This means that
the source can give N bytes of data. An example is an audio source.
A video source always provides the same amount of data (one video
frame). Note that this is not a fully seekable source.</p>
</li>
<li>
<p>it is a live source, see above.</p>
</li>
</ul>
<p>When writing a source, one has to look at how the source can operate to
decide on the scheduling methods to implement on the source.</p>
<ul>
<li>
<p>fully seekable sources implement a getrange function on the source
pad.</p>
</li>
<li>
<p>sources that can give N bytes but cannot do seeking also implement a
getrange function but state that they cannot do random access.</p>
</li>
<li>
<p>sources that are purely live sources implement a task to push out
data.</p>
</li>
</ul>
<p>Any source that has a getrange function must also implement a push based
scheduling mode. In this mode the source starts a task that gets N bytes
and pushes them out. Whenever possible, the peer element will select the
getrange based scheduling method of the source, though.</p>
<p>A source with a getrange function must activate itself in the pad
activate function. This is needed because the downstream peer element
will decide and activate the source element in its state change function
before the source’s state change function is called.</p>
<h2 id="source-base-classes">Source base classes</h2>
<p><code>GstBaseSrc</code>:</p>
<p>This base class provides an implementation of a random access source and
is very well suited for file reader like sources.</p>
<p><code>GstPushSrc</code>:</p>
<p>Base class for block-based sources. This class is mostly useful for
elements that cannot do random access, or at least very slowly. The
source usually prefers to push out a fixed size buffer.</p>
<p>Classes extending this base class will usually be scheduled in a push
based mode. If the peer accepts to operate without offsets and within
the limits of the allowed block size, this class can operate in getrange
based mode automatically.</p>
<p>The subclass should extend the methods from the baseclass in addition to
the create method. If the source is seekable, it needs to override
<code>GstBaseSrc::event()</code> in addition to <code>GstBaseSrc::is_seekable()</code> in order
to retrieve the seek offset, which is the offset of the next buffer to
be requested.</p>
<p>Flushing, scheduling and sync is all handled by this base class.</p>
<h2 id="timestamps">Timestamps</h2>
<p>A non-live source should timestamp the buffers it produces starting from</p>
<ol start="0">
<li>If it is not possible to timestamp every buffer (filesrc), the source
is allowed to only timestamp the first buffer (as 0).</li>
</ol>
<p>Live sources only produce data in the <code>PLAYING</code> state, when the clock is
running. They should timestamp each buffer they produce with the current
<code>running_time</code> of the pipeline, which is expressed as:</p>
<pre><code>absolute_time - base_time
</code></pre>
<p>With <code>absolute_time</code> being the time obtained from the global pipeline with
<code>gst_clock_get_time()</code> and <code>base_time</code> being the time of that clock when
the pipeline was last set to <code>PLAYING</code>.</p>

    </div>
        




		
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
	<hr>
	<div id="footer">
		    

	</div>
</div>

<div id="toc-column">
	
		<div class="edit-button">
		

	</div>
		<div id="toc-wrapper">
		<nav id="toc"></nav>
	</div>
</div>
</div>
</main>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>
