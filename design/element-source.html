<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Source elements</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/utils.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/navigation.js"></script>


<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>


<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body data-spy="scroll" data-target=".scrollspy" data-offset="70">


<nav class="navbar navbar-fixed-top navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a href="https://gstreamer.freedesktop.org/" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
							</ul>
			<form action="" class="navbar-form navbar-right">
				<div class="form-group has-feedback">
					<input type="text" class="form-control" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
					<span class="glyphicon glyphicon-search form-control-feedback"></span>
				</div>
			</form>
		</div>
	</div>
</nav>

<main class="page-row page-row-expanded">
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-1.0" data-hotdoc-ref="design/element-source.html" class="page_container" id="page-wrapper">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-xl-2" id="sidenav-column">
	<div class="panel panel-collapse" id="sidenav" data-hotdoc-role="navigation">
		<div id="sitenav-wrapper" class="mCustomScrollbar" data-mcs-theme="minimal">
			<div class="sidenav-main-panel-body">
				<div id="site-navigation">
				</div>
			</div>
		</div>
	</div>
</div>

<div class="col-sm-12 col-md-9 col-xl-8">
	<div id="main">
				
<div id="page-description" data-hotdoc-source="element-source.md">
<h1 id="source-elements">Source elements</h1>
<p>A source element is an element that provides data to the pipeline. It
does typically not have any sink (input) pads.</p>
<p>Typical source elements include:</p>
<ul>
<li>
<p>file readers</p>
</li>
<li>
<p>network elements (live or not)</p>
</li>
<li>
<p>capture elements (video/audio/…)</p>
</li>
<li>
<p>generators (signals/video/audio/…)</p>
</li>
</ul>
<h2 id="live-sources">Live sources</h2>
<p>A source is said to be a live source when it has the following property:</p>
<ul>
<li>temporarily stopping reading from the source causes data to be lost.</li>
</ul>
<p>In general when this property holds, the source also produces data at a
fixed rate. Most sources have a limit on the rate at which they can
deliver data, which might be faster or slower than the consumption rate.
This property however does not make them a live source.</p>
<p>Let’s look at some example sources.</p>
<ul>
<li>
<p>file readers: you can PAUSE without losing data. There is however a
limit to how fast you can read from this source. This limit is
usually much higher than the consumption rate. In some cases it
might be slower (an NFS share, for example) in which case you might
need to use some buffering (see <a href="buffering.html">buffering</a>).</p>
</li>
<li>
<p>HTTP network element: you can PAUSE without data loss. Depending on
the available network bandwidth, consumption rate might be higher
than production rate in which case buffering should be used (see
<a href="buffering.html">buffering</a>).</p>
</li>
<li>
<p>audio source: pausing the audio capture will lead to lost data. this
source is therefore definitely live. In addition, an audio source
will produce data at a fixed rate (the samplerate). Also depending
on the buffersize, this source will introduce a latency (see
<a href="latency.html">latency</a>).</p>
</li>
<li>
<p>udp network source: Pausing the receiving part will lead to lost
data. This source is therefore a live source. Also in a typical case
the udp packets will be received at a certain rate, which might be
difficult to guess because of network jitter. This source does not
necessarily introduce latency on its own.</p>
</li>
<li>
<p>dvb source: PAUSING this element will lead to data loss, it’s a live
source similar to a UDP source.</p>
</li>
</ul>
<h2 id="source-types">Source types</h2>
<p>A source element can operate in three ways:</p>
<ul>
<li>
<p>it is fully seekable, this means that random access can be performed
on it in an efficient way. (a file reader,…). This also typically
means that the source is not live.</p>
</li>
<li>
<p>data can be obtained from it with a variable size. This means that
the source can give N bytes of data. An example is an audio source.
A video source always provides the same amount of data (one video
frame). Note that this is not a fully seekable source.</p>
</li>
<li>
<p>it is a live source, see above.</p>
</li>
</ul>
<p>When writing a source, one has to look at how the source can operate to
decide on the scheduling methods to implement on the source.</p>
<ul>
<li>
<p>fully seekable sources implement a getrange function on the source
pad.</p>
</li>
<li>
<p>sources that can give N bytes but cannot do seeking also implement a
getrange function but state that they cannot do random access.</p>
</li>
<li>
<p>sources that are purely live sources implement a task to push out
data.</p>
</li>
</ul>
<p>Any source that has a getrange function must also implement a push based
scheduling mode. In this mode the source starts a task that gets N bytes
and pushes them out. Whenever possible, the peer element will select the
getrange based scheduling method of the source, though.</p>
<p>A source with a getrange function must activate itself in the pad
activate function. This is needed because the downstream peer element
will decide and activate the source element in its state change function
before the source’s state change function is called.</p>
<h2 id="source-base-classes">Source base classes</h2>
<p><code>GstBaseSrc</code>:</p>
<p>This base class provides an implementation of a random access source and
is very well suited for file reader like sources.</p>
<p><code>GstPushSrc</code>:</p>
<p>Base class for block-based sources. This class is mostly useful for
elements that cannot do random access, or at least very slowly. The
source usually prefers to push out a fixed size buffer.</p>
<p>Classes extending this base class will usually be scheduled in a push
based mode. If the peer accepts to operate without offsets and within
the limits of the allowed block size, this class can operate in getrange
based mode automatically.</p>
<p>The subclass should extend the methods from the baseclass in addition to
the create method. If the source is seekable, it needs to override
<code>GstBaseSrc::event()</code> in addition to <code>GstBaseSrc::is_seekable()</code> in order
to retrieve the seek offset, which is the offset of the next buffer to
be requested.</p>
<p>Flushing, scheduling and sync is all handled by this base class.</p>
<h2 id="timestamps">Timestamps</h2>
<p>A non-live source should timestamp the buffers it produces starting from</p>
<ol start="0">
<li>If it is not possible to timestamp every buffer (filesrc), the source
is allowed to only timestamp the first buffer (as 0).</li>
</ol>
<p>Live sources only produce data in the PLAYING state, when the clock is
running. They should timestamp each buffer they produce with the current
<code>running_time</code> of the pipeline, which is expressed as:</p>
<pre><code>absolute_time - base_time
</code></pre>
<p>With <code>absolute_time</code> being the time obtained from the global pipeline with
<code>gst_clock_get_time()</code> and <code>base_time</code> being the time of that clock when
the pipeline was last set to PLAYING.</p>

</div>


        <div id="subpages"></div>
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
</div>
<div class="hidden-xs col-xl-2">
</div>
	</div>
</div>
</main>


<footer class="page-row">
	<div class="container-fluid">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-xl-2"></div>
		<div class="col-sm-12 col-md-9 col-xl-8">
						
		</div>
		<div class="hidden-xs col-xl-2"></div>
	</div>
</div>
</footer>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>