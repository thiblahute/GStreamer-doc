<html lang="en">
<head>

<base href="..">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>Object relation types</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/jquery.touchSwipe.min.js"></script>
<script src="assets/js/anchor.min.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>

<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>

<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body class="no-script
" data-spy="scroll" data-target="#toc" data-offset="70">

<script>
$('body').removeClass('no-script');
</script>

<nav class="navbar navbar-fixed-top navbar-default" id="topnav">
	<div class="container-fluid">
		<div class="navbar-right">
			<a id="toc-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<form action="" class="navbar-form pull-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                        </form>
		</div>
		<div class="navbar-header">
			<a id="sidenav-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<a id="home-link" href="index.html" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        API References<span class="caret"></span>
    </a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="libgstreamer-1.0/c/index.html">GStreamer core</a>
			</li>
					<li>
				<a href="libs.html">GStreamer Libraries</a>
			</li>
					<li>
				<a href="plugins_doc.html">GStreamer Plugins</a>
			</li>
		</ul>
</li>

<li>
    <a href="application-development/index.html">Application manual</a>
</li>


<li>
    <a href="tutorials/index.html">Tutorials</a>
</li>

			</ul>
			<div class="hidden-xs hidden-sm navbar-text navbar-center">
							</div>
		</div>
	</div>
</nav>

<main>
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-1.0" data-hotdoc-ref="design/relations.html" class="page_container" id="page-wrapper">
<script src="assets/js/utils.js"></script>

<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
	<script src="assets/js/navigation.js"></script>
	<script src="assets/js/sitemap.js"></script>
</div>

<div id="body">
	<div id="main">
				    <div id="page-description" data-hotdoc-source="relations.md" data-hotdoc-role="main">
        <h1 id="object-relation-types">Object relation types</h1>
<p>This document describes the relations between objects that exist in
GStreamer. It will also describe the way of handling the relation wrt
locking and refcounting.</p>
<h2 id="parentchild-relation">parent-child relation</h2>
<pre><code>     +---------+    +-------+
     | parent  |    | child |
*---&gt;|       *-----&gt;|       |
     |       F1|&lt;-----*    1|
     +---------+    +-------+
</code></pre>
<h3 id="properties">properties</h3>
<pre><code>- parent has references to multiple children
- child has reference to parent
- reference fields protected with LOCK
- the reference held by each child to the parent is NOT reflected in
the refcount of the parent.
- the parent removes the floating flag of the child when taking
ownership.
- the application has valid reference to parent
- creation/destruction requires two unnested locks and 1 refcount.
</code></pre>
<h3 id="usage-in-gstreamer">usage in GStreamer</h3>
<pre><code>* `GstBin` -&gt; `GstElement`
* `GstElement` -&gt; `GstRealPad`
</code></pre>
<h3 id="lifecycle">lifecycle</h3>
<h4 id="object-creation">object creation</h4>
<p>The application creates two objects and holds a pointer
to them. The objects are initially FLOATING with a refcount of 1.</p>
<pre><code>     +---------+              +-------+
*---&gt;| parent  |         *---&gt;| child |
     |       * |              |       |
     |       F1|              | *   F1|
     +---------+              +-------+
</code></pre>
<h4 id="establishing-the-parentchild-relationship">establishing the parent-child relationship</h4>
<p>The application then calls a method on the parent object to take ownership of
the child object. The parent performs the following actions:</p>
<pre><code>result = _set_parent (child, parent);
if (result) {
  lock (parent);
  ref_pointer = child;

  1.  update other data structures .. unlock (parent);
} else {

  2.  child had parent ..
}
</code></pre>
<p>the <code>_set_parent()</code> method performs the following actions:</p>
<pre><code>lock (child);
if (child-&gt;parent != null) {
  unlock (child);
  return false;
}
if (is_floating (child)) {
  unset (child, floating);
}
else {
  _ref (child);
}
child-&gt;parent = parent;
unlock (child);
_signal (parent_set, child, parent);
return true;
</code></pre>
<p>The function atomically checks if the child has no parent yet
and will set the parent if not. It will also sink the child, meaning
all floating references to the child are invalid now as it takes
over the refcount of the object.</p>
<p>Visually:</p>
<p>after <code>_set_parent()</code> returns TRUE:</p>
<pre><code>      +---------+            +-------+
*----&gt;| parent  |      *-//-&gt;| child |
      |       * |            |       |
      |       F1|&lt;-------------*    1|
      +---------+            +-------+
</code></pre>
<p>after parent updates <code>ref_pointer</code> to child.</p>
<pre><code>      +---------+        +-------+
*----&gt;| parent  |  *-//-&gt;| child |
      |       *---------&gt;|       |
      |       F1|&lt;---------*    1|
      +---------+        +-------+
</code></pre>
<ul>
<li>
<p>only one parent is able to <code>_sink</code> the same object because the
<code>_set_parent()</code> method is atomic.</p>
</li>
<li>
<p>since only one parent is able to <code>_set_parent()</code> the object, only
one will add a reference to the object.</p>
</li>
<li>
<p>since the parent can hold multiple references to children, we don’t
need to lock the parent when locking the child. Many threads can
call <code>_set_parent()</code> on the children with the same parent, the
parent can then add all those to its lists.</p>
</li>
</ul>
<blockquote>
<p>Note: that the signal is emitted before the parent has added the
element to its internal data structures. This is not a problem
since the parent usually has his own signal to inform the app that
the child was reffed. One possible solution would be to update the
internal structure first and then perform a rollback if the <code>_set_parent()</code>
failed. This is not a good solution as iterators might grab the
'half-added' child too soon.</p>
</blockquote>
<h4 id="using-the-parentchild-relationship">using the parent-child relationship</h4>
<ul>
<li>
<p>since the initial floating reference to the child object became
invalid after giving it to the parent, any reference to a child has
at least a refcount &gt; 1.</p>
</li>
<li>
<p>this means that unreffing a child object cannot decrease the
refcount to 0. In fact, only the parent can destroy and dispose the
child object.</p>
</li>
<li>
<p>given a reference to the child object, the parent pointer is only
valid when holding the child LOCK. Indeed, after unlocking the child
LOCK, the parent can unparent the child or the parent could even
become disposed. To avoid the parent dispose problem, when obtaining
the parent pointer, if should be reffed before releasing the child
LOCK.</p>
</li>
</ul>
<ul>
<li>getting a reference to the parent.
<ul>
<li>a referece is held to the child, so it cannot be disposed.</li>
</ul>
</li>
</ul>
<pre><code class="language-c">    LOCK (child);
    parent = _ref (child-&gt;parent);
    UNLOCK (child);

   .. use parent ..

   _unref (parent);
</code></pre>
<ul>
<li>
<p>getting a reference to a child</p>
<ul>
<li>
<p>a reference to a child can be obtained by reffing it before adding
it to the parent or by querying the parent.</p>
</li>
<li>
<p>when requesting a child from the parent, a reference is held to the
parent so it cannot be disposed. The parent will use its internal
data structures to locate the child element and will return a
reference to it with an incremented refcount. The requester should
<code>_unref()</code> the child after usage.</p>
</li>
</ul>
</li>
<li>
<p>destroying the parent-child relationship</p>
<ul>
<li>
<p>only the parent can actively destroy the parent-child relationship
this typically happens when a method is called on the parent to
release ownership of the child.</p>
</li>
<li>
<p>a child shall never remove itself from the parent.</p>
</li>
<li>
<p>since calling a method on the parent with the child as an argument
requires the caller to obtain a valid reference to the child, the
child refcount is at least &gt; 1.</p>
</li>
<li>
<p>the parent will perform the folowing actions:</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-c">    LOCK (parent);
    if (ref_pointer == child) {
      ref_pointer = NULL;

      ..update other data structures ..
      UNLOCK (parent);

      _unparent (child);
    } else {
      UNLOCK (parent);
      .. not our child ..
    }
</code></pre>
<p>The <code>_unparent()</code> method performs the following actions:</p>
<pre><code class="language-c">LOCK (child);
if (child-&gt;parent != NULL) {
  child-&gt;parent = NULL;
  UNLOCK (child);
  _signal (PARENT_UNSET, child, parent);

  _unref (child);
} else {
  UNLOCK (child);
}
</code></pre>
<p>Since the <code>_unparent()</code> method unrefs the child object, it is possible that
the child pointer is invalid after this function. If the parent wants to
perform other actions on the child (such as signal emission) it should
<code>_ref()</code> the child first.</p>
<h2 id="singlereffed-relation">single-reffed relation</h2>
<pre><code>     +---------+        +---------+
*---&gt;| object1 |   *---&gt;| object2 |
     |       *---------&gt;|         |
     |        1|        |        2|
     +---------+        +---------+
</code></pre>
<h3 id="properties1">properties</h3>
<pre><code>  - one object has a reference to another
  - reference field protected with LOCK
  - the reference held by the object is reflected in the refcount of the
    other object.
  - typically the other object can be shared among multiple other
    objects where each ref is counted for in the refcount.
  - no object has ownership of the other.
  - either shared state or copy-on-write.
  - creation/destruction requires one lock and one refcount.
</code></pre>
<h3 id="usage">usage</h3>
<pre><code>        GstRealPad -&gt; GstCaps
        GstBuffer -&gt; GstCaps
        GstEvent -&gt; GstCaps
        GstEvent -&gt; GstObject
        GstMessage -&gt; GstCaps
        GstMessage -&gt; GstObject
</code></pre>
<h3 id="lifecycle1">lifecycle</h3>
<h4 id="two-objects-exist-unlinked">Two objects exist unlinked.</h4>
<pre><code>     +---------+        +---------+
*---&gt;| object1 |   *---&gt;| object2 |
     |      *  |        |         |
     |        1|        |        1|
     +---------+        +---------+
</code></pre>
<h4 id="establishing-the-singlereffed-relationship">establishing the single-reffed relationship</h4>
<p>The second object is attached to the first one using a method
on the first object. The second object is reffed and a pointer
is updated in the first object using the following algorithm:</p>
<pre><code class="language-c">LOCK (object1);
if (object1-&gt;pointer)
  _unref (object1-&gt;pointer);
object1-&gt;pointer = _ref (object2);
UNLOCK (object1);
</code></pre>
<p>After releasing the lock on the first object is is not sure that
object2 is still reffed from object1.</p>
<pre><code>     +---------+        +---------+
*---&gt;| object1 |   *---&gt;| object2 |
     |       *---------&gt;|         |
     |        1|        |        2|
     +---------+        +---------+
</code></pre>
<h4 id="using-the-singlereffed-relationship">using the single-reffed relationship</h4>
<p>The only way to access object2 is by holding a ref to it or by
getting the reference from object1.
Reading the object pointed to by object1 can be done like this:</p>
<pre><code class="language-c">LOCK (object1);
object2 = object1-&gt;pointer;
_ref (object2);
UNLOCK (object1);

… use object2 …
_unref (object2);
</code></pre>
<p>Depending on the type of the object, modifications can be done either with
copy-on-write or directly into the object.</p>
<p>Copy on write can practically only be done like this:</p>
<pre><code class="language-c">LOCK (object1);
object2 = object1-&gt;pointer;
object2 = _copy_on_write (object2);
... make modifications to object2 ...
UNLOCK (object1);

Releasing the lock has only a very small window where the copy_on_write
actually does not perform a copy:

LOCK (object1);
object2 = object1-&gt;pointer;
_ref (object2);
UNLOCK (object1);

/* object2 now has at least 2 refcounts making the next
copy-on-write make a real copy, unless some other thread writes
another object2 to object1 here … */

object2 = _copy_on_write (object2);

/* make modifications to object2 … */

LOCK (object1);
if (object1-&gt;pointer != object2) {
  if (object1-&gt;pointer)
    _unref (object1-&gt;pointer);
  object1-&gt;pointer = gst_object_ref (object2);
}
UNLOCK (object1);
</code></pre>
<h4 id="destroying-the-singlereffed-relationship">destroying the single-reffed relationship</h4>
<p>The folowing algorithm removes the single-reffed link between
object1 and object2.</p>
<pre><code class="language-c">LOCK (object1);
_unref (object1-&gt;pointer);
object1-&gt;pointer = NULL;
UNLOCK (object1);
</code></pre>
<p>Which yields the following initial state again:</p>
<pre><code>     +---------+        +---------+
*---&gt;| object1 |   *---&gt;| object2 |
     |      *  |        |         |
     |        1|        |        1|
     +---------+        +---------+
</code></pre>
<h2 id="unreffed-relation">unreffed relation</h2>
<pre><code>     +---------+        +---------+
*---&gt;| object1 |   *---&gt;| object2 |
     |       *---------&gt;|         |
     |        1|&lt;---------*      1|
     +---------+        +---------+
</code></pre>
<h3 id="properties2">properties</h3>
<ul>
<li>two objects have references to each other</li>
<li>both objects can only have 1 reference to another object.</li>
<li>reference fields protected with LOCK</li>
<li>the references held by each object are NOT reflected in the refcount
of the other object.</li>
<li>no object has ownership of the other.</li>
<li>typically each object is owned by a different parent.</li>
<li>creation/destruction requires two nested locks and no refcounts.</li>
</ul>
<h3 id="usage1">usage</h3>
<ul>
<li>
<p>This type of link is used when the link is less important than the
existance of the objects, If one of the objects is disposed, so is
the link.</p>
<p><code>GstRealPad</code> &lt;-&gt; <code>GstRealPad</code> (srcpad lock taken first)</p>
</li>
</ul>
<h3 id="lifecycle2">lifecycle</h3>
<h4 id="two-objects-exist-unlinked1">Two objects exist unlinked.</h4>
<pre><code>     +---------+        +---------+
*---&gt;| object1 |   *---&gt;| object2 |
     |       * |        |         |
     |        1|        | *      1|
     +---------+        +---------+
</code></pre>
<h4 id="establishing-the-unreffed-relationship">establishing the unreffed relationship</h4>
<p>Since we need to take two locks, the order in which these locks are
taken is very important or we might cause deadlocks. This lock order
must be defined for all unreffed relations. In these examples we always
lock object1 first and then object2.</p>
<pre><code class="language-c">LOCK (object1);
LOCK (object2);
object2-&gt;refpointer = object1;
object1-&gt;refpointer = object2;
UNLOCK (object2);
UNLOCK (object1);
</code></pre>
<h4 id="using-the-unreffed-relationship">using the unreffed relationship</h4>
<p>Reading requires taking one of the locks and reading the corresponing
object. Again we need to ref the object before releasing the lock.</p>
<pre><code class="language-c">LOCK (object1);
object2 = _ref (object1-&gt;refpointer);
UNLOCK (object1);

.. use object2 ..
_unref (object2);
</code></pre>
<h4 id="destroying-the-unreffed-relationship">destroying the unreffed relationship</h4>
<p>Because of the lock order we need to be careful when destroying this
relation.</p>
<p>When only a reference to object1 is held:</p>
<pre><code class="language-c">LOCK (object1);
LOCK (object2);
object1-&gt;refpointer-&gt;refpointer = NULL;
object1-&gt;refpointer = NULL;
UNLOCK (object2);
UNLOCK (object1);
</code></pre>
<p>When only a reference to object2 is held, we need to get a handle to the
other object fist so that we can lock it first. There is a window where
we need to release all locks and the relation could be invalid. To solve
this we check the relation after grabbing both locks and retry if the
relation changed.</p>
<pre><code class="language-c">retry:
  LOCK (object2);
  object1 = _ref (object2-&gt;refpointer);
  UNLOCK (object2);
  .. things can change here ..
  LOCK (object1);
  LOCK (object2);
  if (object1 == object2-&gt;refpointer) {
    /* relation unchanged */
    object1-&gt;refpointer-&gt;refpointer = NULL;
    object1-&gt;refpointer = NULL;
  }
  else {
    /* relation changed.. retry */
    UNLOCK (object2);
    UNLOCK (object1);
    _unref (object1);
    goto retry;
  }
  UNLOCK (object2);
  UNLOCK (object1);
  _unref (object1);

/* When references are held to both objects. Note that it is not possible to
get references to both objects with the locks released since when the
references are taken and the locks are released, a concurrent update might
have changed the link, making the references not point to linked objects. */

LOCK (object1);
LOCK (object2);
if (object1-&gt;refpointer == object2) {
  object2-&gt;refpointer = NULL;
  object1-&gt;refpointer = NULL;
}
else {
  .. objects are not linked ..
}
UNLOCK (object2);
UNLOCK (object1);
</code></pre>
<h2 id="doublereffed-relation">double-reffed relation</h2>
<pre><code>     +---------+        +---------+
*---&gt;| object1 |   *---&gt;| object2 |
     |       *---------&gt;|         |
     |        2|&lt;---------*      2|
     +---------+        +---------+
</code></pre>
<h3 id="properties3">properties</h3>
<ul>
<li>two objects have references to each other</li>
<li>reference fields protected with LOCK</li>
<li>the references held by each object are reflected in the refcount of
the other object.</li>
<li>no object has ownership of the other.</li>
<li>typically each object is owned by a different parent.</li>
<li>creation/destruction requires two locks and two refcounts.</li>
</ul>
<h4 id="usage2">usage</h4>
<p>Not used in GStreamer.</p>
<h3 id="lifecycle3">lifecycle</h3>

    </div>
        




		
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
	<div id="footer">
		    

	</div>
</div>

<div id="toc-column">
	
		<div class="edit-button">
		

	</div>
		<div id="toc-wrapper">
		<nav id="toc"></nav>
	</div>
</div>
</div>
</main>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>
