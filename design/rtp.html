<html lang="en">
<head>

<base href="..">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>RTP</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/bootstrap-toc.min.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/jquery.touchSwipe.min.js"></script>
<script src="assets/js/anchor.min.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>

<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>

<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body class="no-script
" data-spy="scroll" data-target="#toc" data-offset="70">

<script>
$('body').removeClass('no-script');
</script>

<nav class="navbar navbar-fixed-top navbar-default" id="topnav">
	<div class="container-fluid">
		<div class="navbar-right">
			<a id="toc-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<form action="" class="navbar-form pull-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                        </form>
		</div>
		<div class="navbar-header">
			<a id="sidenav-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<a id="home-link" href="index.html" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        API References<span class="caret"></span>
    </a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="libgstreamer-1.0/c/index.html">GStreamer core</a>
			</li>
					<li>
				<a href="libs.html">GStreamer Libraries</a>
			</li>
					<li>
				<a href="plugins_doc.html">GStreamer Plugins</a>
			</li>
		</ul>
</li>

<li>
    <a href="application-development/index.html">Application manual</a>
</li>


<li>
    <a href="tutorials/index.html">Tutorials</a>
</li>

			</ul>
			<div class="hidden-xs hidden-sm navbar-text navbar-center">
							</div>
		</div>
	</div>
</nav>

<main>
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-1.0" data-hotdoc-ref="design/rtp.html" class="page_container" id="page-wrapper">
<script src="assets/js/utils.js"></script>

<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
	<script src="assets/js/navigation.js"></script>
			<script src="assets/js/sitemap.js"></script>
	</div>

<div id="body">
	<div id="main">
				    <div id="page-description" data-hotdoc-source="rtp.md" data-hotdoc-role="main">
        <h1 id="rtp">RTP</h1>
<p>These design docs detail some of the lower-level mechanism of certain parts
of GStreamer's RTP stack. For a higher-level overview see the <a href="rtp.html">RTP and RTSP
support</a> section.</p>
<h1 id="rtp-auxiliary-stream-design">RTP auxiliary stream design</h1>
<h2 id="auxiliary-elements">Auxiliary elements</h2>
<p>There are two kind of auxiliary elements, sender and receiver. Let's
call them rtpauxsend and rtpauxreceive.</p>
<p>rtpauxsend has always one sink pad and can have unlimited requested src
pads. If only src pad then it works in SSRC-multiplexed mode, if several
src pads then it works in session multiplexed mode.</p>
<p>rtpauxreceive has always one ssrc pad and can have unlimited requested
sink pads. If only one sink pad then it works in SSRC-multiplexed mode,
if several sink pads then it works in session multiplexed mode.</p>
<h2 id="rtpbin-and-auxiliary-elements">Rtpbin and auxiliary elements</h2>
<h3 id="basic-mechanism">Basic mechanism</h3>
<p>rtpbin knows for which session ids the given auxiliary element belong
to. It's done through "set-aux-send", for rtpauxsend kind, and through
"set-aux-receive" for rtpauxreceive kind. You can call those signals as
much as needed for each auxiliary element. So for aux elements that work
in SSRC-multiplexed mode this signal action is called only one time.</p>
<p>The user has to call those action signals before to request the
differents rtpbin pads. rtpbin is in charge to link those auxiliary
elements with the sessions, and on receiver side, rtpbin has also to
handle the link with ssrcdemux.</p>
<p>rtpbin never knows if the given rtpauxsend is actually a rtprtxsend
element or another aux element. rtpbin never knows if the given
rtpauxreceive is actually a rtprtxreceive element or another aux
element. rtpbin has to be kept generic so that more aux elements can be
added later without changing rtpbin.</p>
<p>It's currently not possible to use rtpbin with auxiliary stream from
gst-launch. We can discuss about having the ability for rtpbin to
instanciate itself the special aux elements rtprtxsend and rtprtxreceive
but they need to be configured ("payload-type" and "payload-types"
properties) to make retransmission work. So having several rtprtxsend
and rtprtxreceive in a rtpbin would require a lot of properties to
manage them form rtpbin. And for each auxiliary elements.</p>
<p>If you want to use rtprtxreceive and rtprtpsend from gst-launch you have
to use rtpsession, ssrcdemux and rtpjitterbuffer elements yourself. See
gtk-doc of rtprtxreceive for an example.</p>
<h3 id="requesting-the-rtpbins-pads-on-the-pipeline-receiver-side">Requesting the rtpbin's pads on the pipeline receiver side</h3>
<p>If rtpauxreceive is set for session, i, j, k then it has to call
rtpbin::"set-aux-receive" 3 times giving those ids and this aux element.
It has to be done before requesting the <code>recv_rtp_sink_i</code>,
<code>recv_rtp_sink_j</code>, <code>recv_rtp_sink_k</code>. For a concrete case
rtprtxreceive, if the user wants it for session i, then it has to call
rtpbin::"set-aux-receive" one time giving i and this aux element. Then
the user can request <code>recv_rtp_sink_i</code> pad.</p>
<p>Calling rtpbin::"set-aux-receive" does not create the session. It add
the given session id and aux element to a hashtable(key:session id,
value: aux element). Then when the user ask for
<code>rtpbin.recv_rtp_sink_i</code>, rtpbin lookup if there is an aux element for
this i session id. If yes it requests a sink pad to this aux element and
links it with the <code>recv_rtp_src</code> pad of the new gstrtpsession. rtpbin
also checks that this aux element is connected only one time to
ssrcdemux. Because rtpauxreceive has only one source pad. Each call to
request <code>rtpbin.recv_rtp_sink_k</code> will also creates
<code>rtpbin.recv_rtp_src_k_ssrc_pt</code> as usual. So that the user have it
when then it requests rtpbin. (from gst-launch) or using
<code>on_rtpbinreceive_pad_added</code> callback from an application.</p>
<h3 id="requesting-the-rtpbins-pads-on-the-pipeline-sender-side">Requesting the rtpbin's pads on the pipeline sender side</h3>
<p>For the sender this is similar but a bit more complicated to implement.
When the user asks for <code>rtpbin.send_rtp_sink_i</code>, rtpbin will lookup in
its second map (key:session id, value: aux send element). If there is
one aux element, then it will set the sink pad of this aux sender
element to be the ghost pad <code>rtpbin.send_rtp_sink_i</code> that the user
asked. rtpbin will also request a src pad of this aux element to connect
it to <code>gstrtpsession_i</code>. It will automatically create
<code>rtpbin.send_rtp_src_i</code> the usuall way. Then if the user asks
<code>rtpbin.send_rtp_src_k</code>, then rtpbin will also lookup in that map and
request another source pad of the aux element and connect it to the new
<code>gstrtpsession_k</code>.</p>
<h1 id="rtp-collision-design">RTP collision design</h1>
<h2 id="gstrtpcollision">GstRTPCollision</h2>
<p>Custon upstream event which contains the ssrc marked as collided.</p>
<p>This event is generated on both pipeline sender and receiver side by the
gstrtpsession element when it detects a conflict between ssrc. (same
session id and same ssrc)</p>
<p>It's an upstream event so that means this event is for now only useful
on pipeline sender side. Because elements generating packets with the
collided SSRC are placed upstream from the gstrtpsession.</p>
<h2 id="rtppayloader">rtppayloader</h2>
<p>When handling a <code>GstRTPCollision</code> event, the rtppayloader has to choose
another ssrc.</p>
<h2 id="bye-only-the-corresponding-source-not-the-whole-session">BYE only the corresponding source, not the whole session.</h2>
<p>When a collision happens for the given ssrc, the associated source is
marked bye. But we make sure that the whole session is not itself set
bye. Because internally, gstrtpsession can manages several sources and
all have their own distinct ssrc.</p>
<h1 id="rtp-retransmission-design">RTP retransmission design</h1>
<h2 id="gstrtpretransmissionrequest">GstRTPRetransmissionRequest</h2>
<p>Custom upstream event which mainly contains the ssrc and the seqnum of
the packet which is asked to be retransmisted.</p>
<p>On the pipeline receiver side this event is generated by the
gstrtpjitterbuffer element. Then it is translated to a NACK to be sent
over the network.</p>
<p>On the pipeline sender side, this event is generated by the
gstrtpsession element when it receives a NACK from the network.</p>
<h2 id="rtprtxsend-element">rtprtxsend element</h2>
<h3 id="basic-mechanism1">Basic mechanism</h3>
<p>rtprtxsend keeps a history of rtp packets that it has already sent. When
it receives the event <code>GstRTPRetransmissionRequest</code> from the downstream
gstrtpsession element, it loopkup the requested seqnum in its stored
packets. If the packet is present in its history, it will create a RTX
packet according to RFC 4588. Then this rtx packet is pushed to its src
pad as other packets.</p>
<p>rtprtxsend works in SSRC-multiplexed mode, so it has one always sink and
src pad.</p>
<h3 id="building-retransmission-packet-fron-original-packet">Building retransmission packet fron original packet</h3>
<p>A rtx packet is mostly the same as an orignal packet, except it has its
own ssrc and its own seqnum. That's why rtprtxsend works in
SSRC-multiplexed mode. It also means that the same session is used.
Another difference between rtx packet and its original is that it
inserts the original seqnum (OSN: 2 bytes) at the beginning of the
payload. Also rtprtxsend builds rtx packet without padding, to let other
elements do that. The last difference is the payload type. For now the
user has to set it through the rtx-payload-type property. Later it will
be automatically retreive this information from SDP. See fmtp field as
specifies in the RPC4588 (a=fmtp:99 apt=98) fmtp is the payload type of
the retransmission stream and apt the payload type of its associated
master stream.</p>
<h3 id="retransmission-ssrc-and-seqnum">Retransmission ssrc and seqnum</h3>
<p>To choose <code>rtx_ssrc</code> it randomly selects a number between 0 and 2^32-1
until it is different than <code>master_ssrc</code>. <code>rtx_seqnum</code> is randomly
selected between 0 and 2^16-1</p>
<h3 id="deeper-in-the-stored-buffer-history">Deeper in the stored buffer history</h3>
<p>For the history it uses a GSequence with 2^15-1 as its maximum size.
Which is resonable as the default value is 100. It contains the packets
in reverse order they have been sent (head:newest, tail:oldest)
GSequence allows to add and remove an element in constant time (like a
queue). Also GSequence allows to do a binary search when rtprtxsend
lookup in its history. It's important if it receives a lot of requests
or if the history is large.</p>
<h3 id="pending-rtx-packets">Pending rtx packets</h3>
<p>When looking up in its history, if seqnum is found then it pushes the
buffer into a GQueue to its tail. Before to send the current master
stream packet, rtprtxsend sends all the buffers which are in this
GQueue. Taking care of converting them to rtx packets. This way, rtx
packets are sent in the same order they have been requested.
(<code>g_list_foreach</code> traverse the queue from head to tail) The <code>GQueue</code> is
cleared between sending 2 master stream packets. So for this <code>GQueue</code> to
contain more than one element, it means that rtprtxsend receives more
than one rtx request between sending 2 master packets.</p>
<h3 id="collision">Collision</h3>
<p>When handling a <code>GstRTPCollision</code> event, if the ssrc is its rtx ssrc then
rtprtxsend clear its history and its pending retransmission queue. Then
it chooses a <code>rtx_ssrc</code> until it's different than master ssrc. If the
<code>GstRTPCollision</code> event does not contain its rtx ssrc, for example its
master ssrc or other, then it just forwards the event to upstream. So
that it can be handled by the rtppayloader.</p>
<h2 id="rtprtxreceive-element">Rtprtxreceive element</h2>
<h3 id="basic-mechanism2">Basic mechanism</h3>
<p>The same rtprtxreceive instance can receive several master streams and
several retransmission streams. So it will try to dynamically associate
a rtx ssrc with its master ssrc. So that it can reconstruct the original
from the proper rtx packet.</p>
<p>The algorithm is based on the fact that seqnums of different streams
(considering all master and all rtx streams) evolve at a different rate.
It means that the initial seqnum is random for each one and the offset
could also be different. So that they are statistically all different at
a given time. If bad luck then the association is delayed to the next
rtx request.</p>
<p>The algorithm also needs to know if a given packet is a rtx packet or
not. To know this information there is the <code>rtx-payload-types</code> property.
For now the user as to configure it but later it will be automatically
retreive this information from SDP. It needs to know if the current
packet is rtx or not in order to know if it can extract the OSN from the
payload. Otherwise it would extract the OSN even on master streams which
means nothing and so it could do bad things. In theory maybe it could
work but we have this information in SDP so why not using it to avoid
bad associations.</p>
<p>Note that it also means that several master streams can have the same
payload type. And also several rtx streams can have the same payload
type. So the information from SDP which gives us which rtx payload type
belong to a give master payload type is not enough to do the association
between rtx ssrc and master ssrc.</p>
<p>rtprtxreceive works in SSRC-multiplexed mode, so it has one always sink
and src pad.</p>
<h3 id="deeper-in-the-association-algorithm">Deeper in the association algorithm</h3>
<p>When it receives a <code>GstRTPRetransmissionRequest</code> event it will remember
the ssrc and the seqnum from this request.</p>
<p>On incoming packets, if the packet has its ssrc already associated then
it knows if the ssrc is an rtx ssrc or a master stream ssrc. If this is
a rtx packet then it recontructs the original and pushs the result to
src pad as if it was a master packet.</p>
<p>If the ssrc is not yet associated rtprtxreceive checks the payload type.
if the packet has its payload type marked as rtx then it will extract
the OSN (original seqnum number) and lookup in its stored requests if a
seqnum matchs. If found, then it associates the current ssrc to the
master ssrc marked in the request. If not found it just drops the
packet. Then it removes the request from the stored requests.</p>
<p>If there are 2 requests with the same seqnum and different ssrc, then
the couple seqnum,ssrc is removed from the stored requests. A stored
request actually means that actually the couple seqnum,ssrc is stored.
If it's happens the request is droped but it avoids to do bad
associations. In this case the association is just delayed to the next
request.</p>
<h3 id="building-original-packet-from-rtx-packet">Building original packet from rtx packet</h3>
<p>Header, extensions, payload and padding are mostly the same. Except that
the OSN is removed from the payload. Then ssrc, seqnum, and original
payload type are correctly set. Original payload type is actually also
stored when the rtx request is handled.</p>

    </div>
        




		
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
	<hr>
	<div id="footer">
		    

	</div>
</div>

<div id="toc-column">
	
		<div class="edit-button">
		

	</div>
		<div id="toc-wrapper">
		<nav id="toc"></nav>
	</div>
</div>
</div>
</main>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>
