fragment_downloaded_cb({"url": "../../../build/subprojects/gst-docs/gstbasesrc.html#GstBaseSrc", "fragment": "This is a generic base class for source elements. The following types of sources are supported \nThe source can be configured to operate in any Gst.Format with the GstBase.BaseSrc.prototype.set_format method. The currently set format determines the format of the internal Gst.Segment and any Gst.EventType.prototype.segment events. The default format for GstBase.BaseSrc is Gst.Format.prototype.bytes. \nGstBase.BaseSrc always supports push mode scheduling. If the following conditions are met it also supports pull mode scheduling \nIf all the conditions are met for operating in pull mode GstBase.BaseSrc is automatically seekable in push mode as well. The following conditions must be met to make the element seekable in push mode when the format is not Gst.Format.prototype.bytes \nWhen the element does not meet the requirements to operate in pull mode the offset and length in the GstBaseSrcClass.create method should be ignored. It is recommended to subclass GstBase.PushSrc instead in this situation. If the element can operate in pull mode but only with specific offsets and lengths it is allowed to generate an error when the wrong values are passed to the GstBaseSrcClass.create function. \nGstBase.BaseSrc has support for live sources. Live sources are sources that when paused discard data such as audio or video capture devices. A typical live source also produces data at a fixed rate and thus provides a clock to publish this rate. Use GstBase.BaseSrc.prototype.set_live to activate the live source mode. \nA live source does not produce data in the PAUSED state. This means that the GstBaseSrcClass.create method will not be called in PAUSED but only in PLAYING. To signal the pipeline that the element will not produce data the return value from the READY to PAUSED state will be Gst.StateChangeReturn.prototype.no_preroll. \nA typical live source will timestamp the buffers it creates with the current running time of the pipeline. This is one reason why a live source can only produce data in the PLAYING state when the clock is actually distributed and running. \nLive sources that synchronize and block on the clock an audio source for example can use GstBase.BaseSrc.prototype.wait_playing when the GstBaseSrcClass.create function was interrupted by a state change to PAUSED. \nThe GstBaseSrcClass.get_times method can be used to implement pseudo live sources. It only makes sense to implement the GstBaseSrcClass.get_times function if the source is a live source. The GstBaseSrcClass.get_times function should return timestamps starting from as if it were a non live source. The base class will make sure that the timestamps are transformed into the current running_time. The base source will then wait for the calculated running_time before pushing out the buffer. \nFor live sources the base class will by default report a latency of For pseudo live sources the base class will by default measure the difference between the first buffer timestamp and the start time of get_times and will report this value as the latency. Subclasses should override the query function when this behaviour is not acceptable. \nThere is only support in GstBase.BaseSrc for exactly one source pad which should be named src A source implementation subclass of GstBase.BaseSrc should install a pad template in its class_init function like so \nApplications that record from a live source may want to stop recording in a controlled way so that the recording is stopped but the data already in the pipeline is processed to the end remember that many live sources would go on recording forever otherwise For that to happen the application needs to make the source stop recording and send an EOS event down the pipeline. The application would then wait for an EOS message posted on the pipeline s bus to know when all data has been processed and the pipeline can safely be stopped. \nAn application may send an EOS event to a source element to make it perform the EOS logic send EOS event downstream or post a Gst.MessageType.prototype.segment_done on the bus This can typically be done with the Gst.Element.prototype.send_event function on the element or its parent bin. \nAfter the EOS has been sent to the element the application should wait for an EOS message to be posted on the pipeline s bus. Once this EOS message is received it may safely shut down the entire pipeline. \n"});