fragment_downloaded_cb({"url": "gst-plugins-bad-plugins-1.0/element-srtpenc.html#srtpenc1", "fragment": "srtpenc \ngstrtpenc acts as an encoder that adds security to RTP and RTCP packets in the form of encryption and authentication. It outs SRTP and SRTCP. \nAn application can request multiple RTP and RTCP pads to protect but every sink pad requested must receive packets from the same source identical SSRC If a packet received contains a different SSRC a warning is emited and the valid SSRC is forced on the packet. \nThis element uses libsrtp library. When receiving the first packet the library is initialized with a new stream based on the SSRC It uses the default RTP and RTCP encryption and authentication mechanisms unless the user has set the relevant properties first. It also uses a master key that MUST be set by property key at the beginning. The master key must be of a maximum length of characters characters for the salt plus the key The encryption and authentication mecanisms available are \nEncryption properties rtp cipher and rtcp cipher \nAuthentication properties rtp auth and rtcp auth \nNote that for SRTP protection authentication is mandatory non null if encryption is used non null \nWhen requested to create a sink pad a linked source pad is created. Each packet received is first analysed checked for valid SSRC then its buffer is protected with libsrtp then pushed on the source pad. If protection failed or the stream could not be created the buffer is dropped and a warning is emitted. The packets pushed on the source pad are of type application x srtp or application x srtcp \nWhen the maximum usage of the master key is reached a soft limit signal is sent to the user. The user must then set a new master key by property. If the hard limit is reached a flag is set and every subsequent packet is dropped until a new key is set and the stream has been updated. \nIf a stream is to be shared between multiple clients it is also possible to request the internal SRTP rollover counter for a given SSRC. The rollover counter should be then transmitted and used by the clients to authenticate and decrypt the packets. Failing to do that the clients will start with a rollover counter of which will probably be incorrect if the stream has been transmitted for a while to other clients. \n"});