fragment_downloaded_cb({"url": "application-development/highlevel/playback-components.html#page-description", "fragment": "GStreamer includes several higher level components to simplify an application developer s life. All of the components discussed here for now are targetted at media playback. The idea of each of these components is to integrate as closely as possible with a GStreamer pipeline but to hide the complexity of media type detection and several other rather complex topics that have been discussed in Advanced GStreamer concepts. \nWe currently recommend people to use either playbin see Playbin or decodebin see Decodebin depending on their needs. Playbin is the recommended solution for everything related to simple playback of media that should just work. Decodebin is a more flexible autoplugger that could be used to add more advanced features such as playlist support crossfading of audio tracks and so on. Its programming interface is more low level than that of playbin though. \nPlaybin is an element that can be created using the standard GStreamer API e.g. gst_element_factory_make The factory is conveniently called playbin By being a GstPipeline and thus a GstElement playbin automatically supports all of the features of this class including error handling tag support state handling getting stream positions seeking and so on. \nSetting up a playbin pipeline is as simple as creating an instance of the playbin element setting a file location using the uri property on playbin and then setting the element to the GST_STATE_PLAYING state the location has to be a valid URI so protocol location e.g. file tmp my.ogg or http www.example.org stream.ogg Internally playbin will set up a pipeline to playback the media location. \nPlaybin has several features that have been discussed previously \nSettable video and audio output using the video sink and audio sink properties \nMostly controllable and trackable as a GstElement including error handling eos handling tag handling state handling through the GstBus media position handling and seeking. \nBuffers network sources with buffer fullness notifications being passed through the GstBus. \nSupports visualizations for audio only media. \nSupports subtitles both in the media as well as from separate files. For separate subtitle files use the suburi property. \nSupports stream selection and disabling. If your media has multiple audio or subtitle tracks you can dynamically choose which one to play back or decide to turn it off altogether which is especially useful to turn off subtitles For each of those use the current text and other related properties. \nFor convenience it is possible to test playbin on the commandline using the command gst launch playbin uri file path to file \nDecodebin is the actual autoplugger backend of playbin which was discussed in the previous section. Decodebin will in short accept input from a source that is linked to its sinkpad and will try to detect the media type contained in the stream and set up decoder routines for each of those. It will automatically select decoders. For each decoded stream it will emit the pad added signal to let the client know about the newly found decoded stream. For unknown streams which might be the whole stream it will emit the unknown type signal. The application is then responsible for reporting the error to the user. \nDecodebin similar to playbin supports the following features \nCan decode an unlimited number of contained streams to decoded output pads. \nIs handled as a GstElement in all ways including tag or error forwarding and state handling. \nAlthough decodebin is a good autoplugger there s a whole lot of things that it does not do and is not intended to do \nTaking care of input streams with a known media type e.g. a DVD an audio CD or such \nSelection of streams e.g. which audio track to play in case of multi language media streams \nOverlaying subtitles over a decoded video stream. \nDecodebin can be easily tested on the commandline e.g. by using the command gst launch filesrc location file.ogg decodebin audioconvert audioresample autoaudiosink. \nThe uridecodebin element is very similar to decodebin only that it automatically plugs a source plugin based on the protocol of the URI given. \nUridecodebin will also automatically insert buffering elements when the uri is a slow network source. The buffering element will post BUFFERING messages that the application needs to handle as explained in Buffering. The following properties can be used to configure the buffering method \nThe buffer size property allows you to configure a maximum size in bytes for the buffer element. \nThe buffer duration property allows you to configure a maximum size in time for the buffer element. The time will be estimated based on the bitrate of the network. \nWith the download property you can enable the download buffering method as described in Download buffering. Setting this option to TRUE will only enable download buffering for selected formats such as quicktime flash video avi and webm. \nYou can also enable buffering on the parsed demuxed data with the use buffering property. This is interesting to enable buffering on slower random access media such as a network file server. \nURIDecodebin can be easily tested on the commandline e.g. by using the command gst launch uridecodebin uri file file.ogg audioconvert audioresample autoaudiosink. \nThe playsink element is a powerful sink element. It has request pads for raw decoded audio video and text and it will configure itself to play the media streams. It has the following features \nIt exposes GstStreamVolume GstVideoOverlay GstNavigation and GstColorBalance interfaces and automatically plugs software elements to implement the interfaces when needed. \nIt will automatically plug conversion elements. \nCan optionally render visualizations when there is no video input. \nConfigurable sink elements. \nConfigurable audio video sync offset to fine tune synchronization in badly muxed files. \nSupport for taking a snapshot of the last video frame. \nBelow is an example of how you can use playsink. We use a uridecodebin element to decode into raw audio and video streams which we then link to the playsink request pads. We only link the first audio and video pads you could use an input selector to link all pads. \nThis example will show audio and video depending on what you give it. Try this example on an audio file and you will see that it shows visualizations. You can change the visualization at runtime by changing the vis plugin property. \n"});