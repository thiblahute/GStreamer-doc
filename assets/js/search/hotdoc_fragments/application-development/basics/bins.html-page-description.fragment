fragment_downloaded_cb({"url": "application-development/basics/bins.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"bins.md\">\n        <h1 id=\"bins\">Bins</h1>\n<p>A bin is a container element. You can add elements to a bin. Since a bin\nis an element itself, a bin can be handled in the same way as any other\nelement. Therefore, the whole previous chapter (<a href=\"elements.html\">Elements</a>) applies\nto bins as well.</p>\n<h2 id=\"what-are-bins\">What are bins</h2>\n<p>Bins allow you to combine a group of linked elements into one logical\nelement. You do not deal with the individual elements anymore but with\njust one element, the bin. We will see that this is extremely powerful\nwhen you are going to construct complex pipelines since it allows you to\nbreak up the pipeline in smaller chunks.</p>\n<p>The bin will also manage the elements contained in it. It will perform\nstate changes on the elements as well as collect and forward bus\nmessages.</p>\n<p><img src=\"images/bin-element.png\" alt=\"Visualisation of a bin with some elements in it\" title=\"fig:\" id=\"visualisation-of-a-bin-with-some-elements-in-it\"></p>\n<p>There is one specialized type of bin available to the GStreamer\nprogrammer:</p>\n<ul>\n<li>A pipeline: a generic container that manages the synchronization and\nbus messages of the contained elements. The toplevel bin has to be a\npipeline, every application thus needs at least one of these.</li>\n</ul>\n<h2 id=\"creating-a-bin\">Creating a bin</h2>\n<p>Bins are created in the same way that other elements are created, i.e.\nusing an element factory. There are also convenience functions available\n(<code>gst_bin_new ()</code> and <code>gst_pipeline_new ()</code>). To add elements to a bin\nor remove elements from a bin, you can use <code>gst_bin_add ()</code> and\n<code>gst_bin_remove ()</code>. Note that the bin that you add an element to will\ntake ownership of that element. If you destroy the bin, the element will\nbe dereferenced with it. If you remove an element from a bin, it will be\ndereferenced automatically.</p>\n<pre><code>#include &lt;gst/gst.h&gt;\n\nint\nmain (int   argc,\n      char *argv[])\n{\n  GstElement *bin, *pipeline, *source, *sink;\n\n  /* init */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* create */\n  pipeline = gst_pipeline_new (\"my_pipeline\");\n  bin = gst_bin_new (\"my_bin\");\n  source = gst_element_factory_make (\"fakesrc\", \"source\");\n  sink = gst_element_factory_make (\"fakesink\", \"sink\");\n\n  /* First add the elements to the bin */\n  gst_bin_add_many (GST_BIN (bin), source, sink, NULL);\n  /* add the bin to the pipeline */\n  gst_bin_add (GST_BIN (pipeline), bin);\n\n  /* link the elements */\n  gst_element_link (source, sink);\n\n[..]\n\n}\n\n</code></pre>\n<p>There are various functions to lookup elements in a bin. The most\ncommonly used are <code>gst_bin_get_by_name ()</code> and <code>gst_bin_get_by_interface ()</code>. You can also iterate over all elements that a bin contains using\nthe function <code>gst_bin_iterate_elements ()</code>. See the API references of\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstBin.html\"><code>GstBin</code></a>\nfor details.</p>\n<h2 id=\"custom-bins\">Custom bins</h2>\n<p>The application programmer can create custom bins packed with elements\nto perform a specific task. This allows you, for example, to write an\nOgg/Vorbis decoder with just the following lines of code:</p>\n<pre><code>int\nmain (int   argc,\n      char *argv[])\n{\n  GstElement *player;\n\n  /* init */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* create player */\n  player = gst_element_factory_make (\"oggvorbisplayer\", \"player\");\n\n  /* set the source audio file */\n  g_object_set (player, \"location\", \"helloworld.ogg\", NULL);\n\n  /* start playback */\n  gst_element_set_state (GST_ELEMENT (player), GST_STATE_PLAYING);\n[..]\n}\n\n</code></pre>\n<p>(This is a silly example of course, there already exists a much more\npowerful and versatile custom bin like this: the playbin element.)</p>\n<p>Custom bins can be created with a plugin or from the application. You\nwill find more information about creating custom bin in the <a href=\"../../plugin-development/index.html\">Plugin\nWriter's Guide</a></p>\n<p>Examples of such custom bins are the playbin and uridecodebin elements\nfrom<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-base-plugins/html/index.html\">gst-plugins-base</a>.</p>\n<h2 id=\"bins-manage-states-of-their-children\">Bins manage states of their children</h2>\n<p>Bins manage the state of all elements contained in them. If you set a\nbin (or a pipeline, which is a special top-level type of bin) to a\ncertain target state using <code>gst_element_set_state ()</code>, it will make sure\nall elements contained within it will also be set to this state. This\nmeans it's usually only necessary to set the state of the top-level\npipeline to start up the pipeline or shut it down.</p>\n<p>The bin will perform the state changes on all its children from the sink\nelement to the source element. This ensures that the downstream element\nis ready to receive data when the upstream element is brought to PAUSED\nor PLAYING. Similarly when shutting down, the sink elements will be set\nto READY or NULL first, which will cause the upstream elements to\nreceive a FLUSHING error and stop the streaming threads before the\nelements are set to the READY or NULL state.</p>\n<p>Note, however, that if elements are added to a bin or pipeline that's\nalready running, , e.g. from within a \"pad-added\" signal callback, its\nstate will not automatically be brought in line with the current state\nor target state of the bin or pipeline it was added to. Instead, you\nhave to need to set it to the desired target state yourself using\n<code>gst_element_set_state ()</code> or <code>gst_element_sync_state_with_parent ()</code>\nwhen adding elements to an already-running pipeline.</p>\n\n        \n\n    </div>\n\n\n        "});