fragment_downloaded_cb({"url": "application-development/basics/init.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"init.md\">\n<h1 id=\"initializing-gstreamer\">Initializing GStreamer</h1>\n<p>When writing a GStreamer application, you can simply include <code>gst/gst.h</code>\nto get access to the library functions. Besides that, you will also need\nto initialize the GStreamer library.</p>\n<h2 id=\"simple-initialization\">Simple initialization</h2>\n<p>Before the GStreamer libraries can be used, <code>gst_init</code> has to be called\nfrom the main application. This call will perform the necessary\ninitialization of the library as well as parse the GStreamer-specific\ncommand line options.</p>\n<p>A typical program [1] would have code to initialize GStreamer that\nlooks like this:</p>\n<pre><code class=\"language-c\">\n#include &lt;stdio.h&gt;\n#include &lt;gst/gst.h&gt;\n\nint\nmain (int   argc,\n      char *argv[])\n{\n  const gchar *nano_str;\n  guint major, minor, micro, nano;\n\n  gst_init (&amp;argc, &amp;argv);\n\n  gst_version (&amp;major, &amp;minor, &amp;micro, &amp;nano);\n\n  if (nano == 1)\n    nano_str = \"(CVS)\";\n  else if (nano == 2)\n    nano_str = \"(Prerelease)\";\n  else\n    nano_str = \"\";\n\n  printf (\"This program is linked against GStreamer %d.%d.%d %s\\n\",\n          major, minor, micro, nano_str);\n\n  return 0;\n}\n\n\n</code></pre>\n<p>Use the <code>GST_VERSION_MAJOR</code>, <code>GST_VERSION_MINOR</code> and <code>GST_VERSION_MICRO</code>\nmacros to get the GStreamer version you are building against, or use the\nfunction <code>gst_version</code> to get the version your application is linked\nagainst. GStreamer currently uses a scheme where versions with the same\nmajor and minor versions are API-/ and ABI-compatible.</p>\n<p>It is also possible to call the <code>gst_init</code> function with two <code>NULL</code>\narguments, in which case no command line options will be parsed by\nGStreamer.</p>\n<h2 id=\"the-goption-interface\">The GOption interface</h2>\n<p>You can also use a GOption table to initialize your own parameters as\nshown in the next example:</p>\n<pre><code class=\"language-c\">\n#include &lt;gst/gst.h&gt;\n\nint\nmain (int   argc,\n      char *argv[])\n{\n  gboolean silent = FALSE;\n  gchar *savefile = NULL;\n  GOptionContext *ctx;\n  GError *err = NULL;\n  GOptionEntry entries[] = {\n    { \"silent\", 's', 0, G_OPTION_ARG_NONE, &amp;silent,\n      \"do not output status information\", NULL },\n    { \"output\", 'o', 0, G_OPTION_ARG_STRING, &amp;savefile,\n      \"save xml representation of pipeline to FILE and exit\", \"FILE\" },\n    { NULL }\n  };\n\n  ctx = g_option_context_new (\"- Your application\");\n  g_option_context_add_main_entries (ctx, entries, NULL);\n  g_option_context_add_group (ctx, gst_init_get_option_group ());\n  if (!g_option_context_parse (ctx, &amp;argc, &amp;argv, &amp;err)) {\n    g_print (\"Failed to initialize: %s\\n\", err-&gt;message);\n    g_clear_error (&amp;err);\n    g_option_context_free (ctx);\n    return 1;\n  }\n  g_option_context_free (ctx);\n\n  printf (\"Run me with --help to see the Application options appended.\\n\");\n\n  return 0;\n}\n\n\n</code></pre>\n<p>As shown in this fragment, you can use a\n<a href=\"http://developer.gnome.org/glib/stable/glib-Commandline-option-parser.html\">GOption</a>\ntable to define your application-specific command line options, and pass\nthis table to the GLib initialization function along with the option\ngroup returned from the function <code>gst_init_get_option_group</code>. Your\napplication options will be parsed in addition to the standard GStreamer\noptions.</p>\n<ol>\n<li>The code for this example is automatically extracted from the\ndocumentation and built under <code>tests/examples/manual</code> in the\nGStreamer tarball.</li>\n</ol>\n\n</div>\n\n\n\t"});