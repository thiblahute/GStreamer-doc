fragment_downloaded_cb({"url": "application-development/basics/bus.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"bus.md\">\n<h1 id=\"bus\">Bus</h1>\n<p>A bus is a simple system that takes care of forwarding messages from the\nstreaming threads to an application in its own thread context. The\nadvantage of a bus is that an application does not need to be\nthread-aware in order to use GStreamer, even though GStreamer itself is\nheavily threaded.</p>\n<p>Every pipeline contains a bus by default, so applications do not need to\ncreate a bus or anything. The only thing applications should do is set a\nmessage handler on a bus, which is similar to a signal handler to an\nobject. When the mainloop is running, the bus will periodically be\nchecked for new messages, and the callback will be called when any\nmessage is available.</p>\n<h2 id=\"how-to-use-a-bus\">How to use a bus</h2>\n<p>There are two different ways to use a bus:</p>\n<ul>\n<li>\n<p>Run a GLib/Gtk+ main loop (or iterate the default GLib main context\nyourself regularly) and attach some kind of watch to the bus. This\nway the GLib main loop will check the bus for new messages and\nnotify you whenever there are messages.</p>\n<p>Typically you would use <code>gst_bus_add_watch ()</code> or\n<code>gst_bus_add_signal_watch ()</code> in this case.</p>\n<p>To use a bus, attach a message handler to the bus of a pipeline\nusing <code>gst_bus_add_watch ()</code>. This handler will be called whenever\nthe pipeline emits a message to the bus. In this handler, check the\nsignal type (see next section) and do something accordingly. The\nreturn value of the handler should be TRUE to keep the handler\nattached to the bus, return FALSE to remove it.</p>\n</li>\n<li>\n<p>Check for messages on the bus yourself. This can be done using\n<code>gst_bus_peek ()</code> and/or <code>gst_bus_poll ()</code>.</p>\n</li>\n</ul>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\nstatic GMainLoop *loop;\n\nstatic gboolean\nmy_bus_callback (GstBus     *bus,\n         GstMessage *message,\n         gpointer    data)\n{\n  g_print (\"Got %s message\\n\", GST_MESSAGE_TYPE_NAME (message));\n\n  switch (GST_MESSAGE_TYPE (message)) {\n    case GST_MESSAGE_ERROR: {\n      GError *err;\n      gchar *debug;\n\n      gst_message_parse_error (message, &amp;err, &amp;debug);\n      g_print (\"Error: %s\\n\", err-&gt;message);\n      g_error_free (err);\n      g_free (debug);\n\n      g_main_loop_quit (loop);\n      break;\n    }\n    case GST_MESSAGE_EOS:\n      /* end-of-stream */\n      g_main_loop_quit (loop);\n      break;\n    default:\n      /* unhandled message */\n      break;\n  }\n\n  /* we want to be notified again the next time there is a message\n   * on the bus, so returning TRUE (FALSE means we want to stop watching\n   * for messages on the bus and our callback should not be called again)\n   */\n  return TRUE;\n}\n\ngint\nmain (gint   argc,\n      gchar *argv[])\n{\n  GstElement *pipeline;\n  GstBus *bus;\n  guint bus_watch_id;\n\n  /* init */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* create pipeline, add handler */\n  pipeline = gst_pipeline_new (\"my_pipeline\");\n\n  /* adds a watch for new message on our pipeline's message bus to\n   * the default GLib main context, which is the main context that our\n   * GLib main loop is attached to below\n   */\n  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));\n  bus_watch_id = gst_bus_add_watch (bus, my_bus_callback, NULL);\n  gst_object_unref (bus);\n\n  /* [...] */\n\n  /* create a mainloop that runs/iterates the default GLib main context\n   * (context NULL), in other words: makes the context check if anything\n   * it watches for has happened. When a message has been posted on the\n   * bus, the default main context will automatically call our\n   * my_bus_callback() function to notify us of that message.\n   * The main loop will be run until someone calls g_main_loop_quit()\n   */\n  loop = g_main_loop_new (NULL, FALSE);\n  g_main_loop_run (loop);\n\n  /* clean up */\n  gst_element_set_state (pipeline, GST_STATE_NULL);\n  gst_object_unref (pipeline);\n  g_source_remove (bus_watch_id);\n  g_main_loop_unref (loop);\n\n  return 0;\n}\n\n</code></pre>\n<p>It is important to know that the handler will be called in the thread\ncontext of the mainloop. This means that the interaction between the\npipeline and application over the bus is <em>asynchronous</em>, and thus not\nsuited for some real-time purposes, such as cross-fading between audio\ntracks, doing (theoretically) gapless playback or video effects. All\nsuch things should be done in the pipeline context, which is easiest by\nwriting a GStreamer plug-in. It is very useful for its primary purpose,\nthough: passing messages from pipeline to application. The advantage of\nthis approach is that all the threading that GStreamer does internally\nis hidden from the application and the application developer does not\nhave to worry about thread issues at all.</p>\n<p>Note that if you're using the default GLib mainloop integration, you\ncan, instead of attaching a watch, connect to the \u201cmessage\u201d signal on\nthe bus. This way you don't have to <code>switch()</code> on all possible message\ntypes; just connect to the interesting signals in form of\n\u201cmessage::&lt;type&gt;\u201d, where &lt;type&gt; is a specific message type (see\nthe next section for an explanation of message types).</p>\n<p>The above snippet could then also be written as:</p>\n<pre><code class=\"language-c\">GstBus *bus;\n\n[..]\n\nbus = gst_pipeline_get_bus (GST_PIPELINE (pipeline);\ngst_bus_add_signal_watch (bus);\ng_signal_connect (bus, \"message::error\", G_CALLBACK (cb_message_error), NULL);\ng_signal_connect (bus, \"message::eos\", G_CALLBACK (cb_message_eos), NULL);\n\n[..]\n\n</code></pre>\n<p>If you aren't using GLib mainloop, the asynchronous message signals\nwon't be available by default. You can however install a custom sync\nhandler that wakes up the custom mainloop and that uses\n<code>gst_bus_async_signal_func ()</code> to emit the signals. (see also\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstBus.html\">documentation</a>\nfor details)</p>\n<h2 id=\"message-types\">Message types</h2>\n<p>GStreamer has a few pre-defined message types that can be passed over\nthe bus. The messages are extensible, however. Plug-ins can define\nadditional messages, and applications can decide to either have specific\ncode for those or ignore them. All applications are strongly recommended\nto at least handle error messages by providing visual feedback to the\nuser.</p>\n<p>All messages have a message source, type and timestamp. The message\nsource can be used to see which element emitted the message. For some\nmessages, for example, only the ones emitted by the top-level pipeline\nwill be interesting to most applications (e.g. for state-change\nnotifications). Below is a list of all messages and a short explanation\nof what they do and how to parse message-specific content.</p>\n<ul>\n<li>\n<p>Error, warning and information notifications: those are used by\nelements if a message should be shown to the user about the state of\nthe pipeline. Error messages are fatal and terminate the\ndata-passing. The error should be repaired to resume pipeline\nactivity. Warnings are not fatal, but imply a problem nevertheless.\nInformation messages are for non-problem notifications. All those\nmessages contain a <code>GError</code> with the main error type and message,\nand optionally a debug string. Both can be extracted using\n<code>gst_message_parse_error()</code>, <code>_parse_warning ()</code> and <code>_parse_info ()</code>.\nBoth error and debug strings should be freed after use.</p>\n</li>\n<li>\n<p>End-of-stream notification: this is emitted when the stream has\nended. The state of the pipeline will not change, but further media\nhandling will stall. Applications can use this to skip to the next\nsong in their playlist. After end-of-stream, it is also possible to\nseek back in the stream. Playback will then continue automatically.\nThis message has no specific arguments.</p>\n</li>\n<li>\n<p>Tags: emitted when metadata was found in the stream. This can be\nemitted multiple times for a pipeline (e.g. once for descriptive\nmetadata such as artist name or song title, and another one for\nstream-information, such as samplerate and bitrate). Applications\nshould cache metadata internally. <code>gst_message_parse_tag()</code> should be\nused to parse the taglist, which should be <code>gst_tag_list_unref ()</code>'ed\nwhen no longer needed.</p>\n</li>\n<li>\n<p>State-changes: emitted after a successful state change.\n<code>gst_message_parse_state_changed ()</code> can be used to parse the old\nand new state of this transition.</p>\n</li>\n<li>\n<p>Buffering: emitted during caching of network-streams. One can\nmanually extract the progress (in percent) from the message by\nextracting the \u201cbuffer-percent\u201d property from the structure returned\nby <code>gst_message_get_structure()</code>. See also <a href=\"../advanced/buffering.html\">Buffering</a></p>\n</li>\n<li>\n<p>Element messages: these are special messages that are unique to\ncertain elements and usually represent additional features. The\nelement's documentation should mention in detail which element\nmessages a particular element may send. As an example, the 'qtdemux'\nQuickTime demuxer element may send a 'redirect' element message on\ncertain occasions if the stream contains a redirect instruction.</p>\n</li>\n<li>\n<p>Application-specific messages: any information on those can be\nextracted by getting the message structure (see above) and reading\nits fields. Usually these messages can safely be ignored.</p>\n<p>Application messages are primarily meant for internal use in\napplications in case the application needs to marshal information\nfrom some thread into the main thread. This is particularly useful\nwhen the application is making use of element signals (as those\nsignals will be emitted in the context of the streaming thread).</p>\n</li>\n</ul>\n\n</div>\n\n\n\t"});