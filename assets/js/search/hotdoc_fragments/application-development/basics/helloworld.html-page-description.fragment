fragment_downloaded_cb({"url": "application-development/basics/helloworld.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"helloworld.md\">\n        <h1 id=\"your-first-application\">Your first application</h1>\n<p>This chapter will summarize everything you've learned in the previous\nchapters. It describes all aspects of a simple GStreamer application,\nincluding initializing libraries, creating elements, packing elements\ntogether in a pipeline and playing this pipeline. By doing all this, you\nwill be able to build a simple Ogg/Vorbis audio player.</p>\n<h2 id=\"hello-world\">Hello world</h2>\n<p>We're going to create a simple first application, a simple Ogg/Vorbis\ncommand-line audio player. For this, we will use only standard GStreamer\ncomponents. The player will read a file specified on the command-line.\nLet's get started!</p>\n<p>We've learned, in <a href=\"init.html\">Initializing GStreamer</a>, that the\nfirst thing to do in your application is to initialize GStreamer by\ncalling <code>gst_init ()</code>. Also, make sure that the application includes\n<code>gst/gst.h</code> so all function names and objects are properly defined. Use\n<code>#include &lt;gst/gst.h&gt;</code> to do that.</p>\n<p>Next, you'll want to create the different elements using\n<code>gst_element_factory_make ()</code>. For an Ogg/Vorbis audio player, we'll\nneed a source element that reads files from a disk. GStreamer includes\nthis element under the name \u201cfilesrc\u201d. Next, we'll need something to\nparse the file and decode it into raw audio. GStreamer has two elements\nfor this: the first parses Ogg streams into elementary streams (video,\naudio) and is called \u201coggdemux\u201d. The second is a Vorbis audio decoder,\nit's conveniently called \u201cvorbisdec\u201d. Since \u201coggdemux\u201d creates dynamic\npads for each elementary stream, you'll need to set a \u201cpad-added\u201d event\nhandler on the \u201coggdemux\u201d element, like you've learned in <a href=\"pads.html#dynamic-or-sometimes-pads\">Dynamic (or\nsometimes) pads</a>, to link the\nOgg demuxer and the Vorbis decoder elements together. At last, we'll\nalso need an audio output element, we will use \u201cautoaudiosink\u201d, which\nautomatically detects your audio device.</p>\n<p>The last thing left to do is to add all elements into a container\nelement, a <code>GstPipeline</code>, and wait until we've played the whole song.\nWe've previously learned how to add elements to a container bin in\n<a href=\"bins.html\">Bins</a>, and we've learned about element states in\n<a href=\"elements.html#element-states\">Element States</a>. We will also attach a message handler to\nthe pipeline bus so we can retrieve errors and detect the end-of-stream.</p>\n<p>Let's now add all the code together to get our very first audio player:</p>\n<pre><code class=\"language-c\">\n#include &lt;gst/gst.h&gt;\n#include &lt;glib.h&gt;\n\n\nstatic gboolean\nbus_call (GstBus     *bus,\n          GstMessage *msg,\n          gpointer    data)\n{\n  GMainLoop *loop = (GMainLoop *) data;\n\n  switch (GST_MESSAGE_TYPE (msg)) {\n\n    case GST_MESSAGE_EOS:\n      g_print (\"End of stream\\n\");\n      g_main_loop_quit (loop);\n      break;\n\n    case GST_MESSAGE_ERROR: {\n      gchar  *debug;\n      GError *error;\n\n      gst_message_parse_error (msg, &amp;error, &amp;debug);\n      g_free (debug);\n\n      g_printerr (\"Error: %s\\n\", error-&gt;message);\n      g_error_free (error);\n\n      g_main_loop_quit (loop);\n      break;\n    }\n    default:\n      break;\n  }\n\n  return TRUE;\n}\n\n\nstatic void\non_pad_added (GstElement *element,\n              GstPad     *pad,\n              gpointer    data)\n{\n  GstPad *sinkpad;\n  GstElement *decoder = (GstElement *) data;\n\n  /* We can now link this pad with the vorbis-decoder sink pad */\n  g_print (\"Dynamic pad created, linking demuxer/decoder\\n\");\n\n  sinkpad = gst_element_get_static_pad (decoder, \"sink\");\n\n  gst_pad_link (pad, sinkpad);\n\n  gst_object_unref (sinkpad);\n}\n\n\n\nint\nmain (int   argc,\n      char *argv[])\n{\n  GMainLoop *loop;\n\n  GstElement *pipeline, *source, *demuxer, *decoder, *conv, *sink;\n  GstBus *bus;\n  guint bus_watch_id;\n\n  /* Initialisation */\n  gst_init (&amp;argc, &amp;argv);\n\n  loop = g_main_loop_new (NULL, FALSE);\n\n\n  /* Check input arguments */\n  if (argc != 2) {\n    g_printerr (\"Usage: %s &lt;Ogg/Vorbis filename&gt;\\n\", argv[0]);\n    return -1;\n  }\n\n\n  /* Create gstreamer elements */\n  pipeline = gst_pipeline_new (\"audio-player\");\n  source   = gst_element_factory_make (\"filesrc\",       \"file-source\");\n  demuxer  = gst_element_factory_make (\"oggdemux\",      \"ogg-demuxer\");\n  decoder  = gst_element_factory_make (\"vorbisdec\",     \"vorbis-decoder\");\n  conv     = gst_element_factory_make (\"audioconvert\",  \"converter\");\n  sink     = gst_element_factory_make (\"autoaudiosink\", \"audio-output\");\n\n  if (!pipeline || !source || !demuxer || !decoder || !conv || !sink) {\n    g_printerr (\"One element could not be created. Exiting.\\n\");\n    return -1;\n  }\n\n  /* Set up the pipeline */\n\n  /* we set the input filename to the source element */\n  g_object_set (G_OBJECT (source), \"location\", argv[1], NULL);\n\n  /* we add a message handler */\n  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));\n  bus_watch_id = gst_bus_add_watch (bus, bus_call, loop);\n  gst_object_unref (bus);\n\n  /* we add all elements into the pipeline */\n  /* file-source | ogg-demuxer | vorbis-decoder | converter | alsa-output */\n  gst_bin_add_many (GST_BIN (pipeline),\n                    source, demuxer, decoder, conv, sink, NULL);\n\n  /* we link the elements together */\n  /* file-source -&gt; ogg-demuxer ~&gt; vorbis-decoder -&gt; converter -&gt; alsa-output */\n  gst_element_link (source, demuxer);\n  gst_element_link_many (decoder, conv, sink, NULL);\n  g_signal_connect (demuxer, \"pad-added\", G_CALLBACK (on_pad_added), decoder);\n\n  /* note that the demuxer will be linked to the decoder dynamically.\n     The reason is that Ogg may contain various streams (for example\n     audio and video). The source pad(s) will be created at run time,\n     by the demuxer when it detects the amount and nature of streams.\n     Therefore we connect a callback function which will be executed\n     when the \"pad-added\" is emitted.*/\n\n\n  /* Set the pipeline to \"playing\" state*/\n  g_print (\"Now playing: %s\\n\", argv[1]);\n  gst_element_set_state (pipeline, GST_STATE_PLAYING);\n\n\n  /* Iterate */\n  g_print (\"Running...\\n\");\n  g_main_loop_run (loop);\n\n\n  /* Out of the main loop, clean up nicely */\n  g_print (\"Returned, stopping playback\\n\");\n  gst_element_set_state (pipeline, GST_STATE_NULL);\n\n  g_print (\"Deleting pipeline\\n\");\n  gst_object_unref (GST_OBJECT (pipeline));\n  g_source_remove (bus_watch_id);\n  g_main_loop_unref (loop);\n\n  return 0;\n}\n\n\n</code></pre>\n<p>We now have created a complete pipeline. We can visualise the pipeline\nas follows:</p>\n<p><img src=\"images/hello-world.png\" alt='The \"hello world\" pipeline' title=\"fig:\" id=\"the-hello-world-pipeline\"></p>\n<h2 id=\"compiling-and-running-helloworldc\">Compiling and Running helloworld.c</h2>\n<p>To compile the helloworld example, use: <code>gcc -Wall helloworld.c -o helloworld $(pkg-config --cflags --libs gstreamer-1.0)</code>. GStreamer makes use of\n<code>pkg-config</code> to get compiler and linker flags needed to compile this\napplication.</p>\n<p>If you're running a non-standard installation (ie. you've installed\nGStreamer from source yourself instead of using pre-built packages),\nmake sure the <code>PKG_CONFIG_PATH</code> environment variable is set to the\ncorrect location (<code>$libdir/pkgconfig</code>).</p>\n<p>In the unlikely case that you are using an uninstalled GStreamer setup\n(ie. gst-uninstalled), you will need to use libtool to build the hello\nworld program, like this: <code>libtool --mode=link gcc -Wall helloworld.c -o helloworld $(pkg-config --cflags --libs gstreamer-1.0)</code>.</p>\n<p>You can run this example application with <code>./helloworld file.ogg</code>. Substitute <code>file.ogg</code> with your favourite Ogg/Vorbis file.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This concludes our first example. As you see, setting up a pipeline is\nvery low-level but powerful. You will see later in this manual how you\ncan create a more powerful media player with even less effort using\nhigher-level interfaces. We will discuss all that in <a href=\"../advanced/index.html\">Higher-level\ninterfaces for GStreamer applications</a>. We will\nfirst, however, go more in-depth into more advanced GStreamer internals.</p>\n<p>It should be clear from the example that we can very easily replace the\n\u201cfilesrc\u201d element with some other element that reads data from a\nnetwork, or some other data source element that is better integrated\nwith your desktop environment. Also, you can use other decoders and\nparsers/demuxers to support other media types. You can use another audio\nsink if you're not running Linux, but Mac OS X, Windows or FreeBSD, or\nyou can instead use a filesink to write audio files to disk instead of\nplaying them back. By using an audio card source, you can even do audio\ncapture instead of playback. All this shows the reusability of GStreamer\nelements, which is its greatest advantage.</p>\n\n        \n\n    </div>\n\n\n        "});