fragment_downloaded_cb({"url": "application-development/basics/helloworld.html#page-description", "fragment": "This chapter will summarize everything you ve learned in the previous chapters. It describes all aspects of a simple GStreamer application including initializing libraries creating elements packing elements together in a pipeline and playing this pipeline. By doing all this you will be able to build a simple Ogg Vorbis audio player. \nWe re going to create a simple first application a simple Ogg Vorbis command line audio player. For this we will use only standard GStreamer components. The player will read a file specified on the command line. Let s get started \nWe ve learned in Initializing GStreamer that the first thing to do in your application is to initialize GStreamer by calling gst_init Also make sure that the application includes gst gst.h so all function names and objects are properly defined. Use include gst gst.h to do that. \nNext you ll want to create the different elements using gst_element_factory_make For an Ogg Vorbis audio player we ll need a source element that reads files from a disk. GStreamer includes this element under the name filesrc Next we ll need something to parse the file and decode it into raw audio. GStreamer has two elements for this the first parses Ogg streams into elementary streams video audio and is called oggdemux The second is a Vorbis audio decoder it s conveniently called vorbisdec Since oggdemux creates dynamic pads for each elementary stream you ll need to set a pad added event handler on the oggdemux element like you ve learned in Dynamic or sometimes pads to link the Ogg demuxer and the Vorbis decoder elements together. At last we ll also need an audio output element we will use autoaudiosink which automatically detects your audio device. \nThe last thing left to do is to add all elements into a container element a GstPipeline and wait until we ve played the whole song. We ve previously learned how to add elements to a container bin in Bins and we ve learned about element states in Element States. We will also attach a message handler to the pipeline bus so we can retrieve errors and detect the end of stream. \nLet s now add all the code together to get our very first audio player \nWe now have created a complete pipeline. We can visualise the pipeline as follows \n\nTo compile the helloworld example use gcc Wall helloworld.c o helloworld pkg config cflags libs gstreamer GStreamer makes use of pkg config to get compiler and linker flags needed to compile this application. \nIf you re running a non standard installation ie. you ve installed GStreamer from source yourself instead of using pre built packages make sure the PKG_CONFIG_PATH environment variable is set to the correct location libdir pkgconfig \nIn the unlikely case that you are using an uninstalled GStreamer setup ie. gst uninstalled you will need to use libtool to build the hello world program like this libtool mode link gcc Wall helloworld.c o helloworld pkg config cflags libs gstreamer \nYou can run this example application with helloworld file.ogg. Substitute file.ogg with your favourite Ogg Vorbis file. \nThis concludes our first example. As you see setting up a pipeline is very low level but powerful. You will see later in this manual how you can create a more powerful media player with even less effort using higher level interfaces. We will discuss all that in Higher level interfaces for GStreamer applications. We will first however go more in depth into more advanced GStreamer internals. \nIt should be clear from the example that we can very easily replace the filesrc element with some other element that reads data from a network or some other data source element that is better integrated with your desktop environment. Also you can use other decoders and parsers demuxers to support other media types. You can use another audio sink if you re not running Linux but Mac OS X Windows or FreeBSD or you can instead use a filesink to write audio files to disk instead of playing them back. By using an audio card source you can even do audio capture instead of playback. All this shows the reusability of GStreamer elements which is its greatest advantage. \n"});