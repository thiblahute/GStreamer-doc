fragment_downloaded_cb({"url": "application-development/basics/pads.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"pads.md\">\n<h1 id=\"pads-and-capabilities\">Pads and capabilities</h1>\n<p>As we have seen in <a href=\"elements.html\">Elements</a>, the pads are the\nelement's interface to the outside world. Data streams from one\nelement's source pad to another element's sink pad. The specific type of\nmedia that the element can handle will be exposed by the pad's\ncapabilities. We will talk more on capabilities later in this chapter\n(see <a href=\"../../#capabilities-of-a-pad\">Capabilities of a pad</a>).</p>\n<h2 id=\"pads\">Pads</h2>\n<p>A pad type is defined by two properties: its direction and its\navailability. As we've mentioned before, GStreamer defines two pad\ndirections: source pads and sink pads. This terminology is defined from\nthe view of within the element: elements receive data on their sink pads\nand generate data on their source pads. Schematically, sink pads are\ndrawn on the left side of an element, whereas source pads are drawn on\nthe right side of an element. In such graphs, data flows from left to\nright. [1]</p>\n<p>Pad directions are very simple compared to pad availability. A pad can\nhave any of three availabilities: always, sometimes and on request. The\nmeaning of those three types is exactly as it says: always pads always\nexist, sometimes pad exist only in certain cases (and can disappear\nrandomly), and on-request pads appear only if explicitly requested by\napplications.</p>\n<h3 id=\"dynamic-or-sometimes-pads\">Dynamic (or sometimes) pads</h3>\n<p>Some elements might not have all of their pads when the element is\ncreated. This can happen, for example, with an Ogg demuxer element. The\nelement will read the Ogg stream and create dynamic pads for each\ncontained elementary stream (vorbis, theora) when it detects such a\nstream in the Ogg stream. Likewise, it will delete the pad when the\nstream ends. This principle is very useful for demuxer elements, for\nexample.</p>\n<p>Running gst-inspect oggdemux will show that the element has only one\npad: a sink pad called 'sink'. The other pads are \u201cdormant\u201d. You can see\nthis in the pad template because there is an \u201cExists: Sometimes\u201d\nproperty. Depending on the type of Ogg file you play, the pads will be\ncreated. We will see that this is very important when you are going to\ncreate dynamic pipelines. You can attach a signal handler to an element\nto inform you when the element has created a new pad from one of its\n\u201csometimes\u201d pad templates. The following piece of code is an example\nof how to do this:</p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\nstatic void\ncb_new_pad (GstElement *element,\n        GstPad     *pad,\n        gpointer    data)\n{\n  gchar *name;\n\n  name = gst_pad_get_name (pad);\n  g_print (\"A new pad %s was created\\n\", name);\n  g_free (name);\n\n  /* here, you would setup a new pad link for the newly created pad */\n[..]\n\n}\n\nint\nmain (int   argc,\n      char *argv[])\n{\n  GstElement *pipeline, *source, *demux;\n  GMainLoop *loop;\n\n  /* init */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* create elements */\n  pipeline = gst_pipeline_new (\"my_pipeline\");\n  source = gst_element_factory_make (\"filesrc\", \"source\");\n  g_object_set (source, \"location\", argv[1], NULL);\n  demux = gst_element_factory_make (\"oggdemux\", \"demuxer\");\n\n  /* you would normally check that the elements were created properly */\n\n  /* put together a pipeline */\n  gst_bin_add_many (GST_BIN (pipeline), source, demux, NULL);\n  gst_element_link_pads (source, \"src\", demux, \"sink\");\n\n  /* listen for newly created pads */\n  g_signal_connect (demux, \"pad-added\", G_CALLBACK (cb_new_pad), NULL);\n\n  /* start the pipeline */\n  gst_element_set_state (GST_ELEMENT (pipeline), GST_STATE_PLAYING);\n  loop = g_main_loop_new (NULL, FALSE);\n  g_main_loop_run (loop);\n\n[..]\n\n}\n\n</code></pre>\n<p>It is not uncommon to add elements to the pipeline only from within the\n\"pad-added\" callback. If you do this, don't forget to set the state of\nthe newly-added elements to the target state of the pipeline using\n<code>gst_element_set_state ()</code> or <code>gst_element_sync_state_with_parent ()</code>.</p>\n<h3 id=\"request-pads\">Request pads</h3>\n<p>An element can also have request pads. These pads are not created\nautomatically but are only created on demand. This is very useful for\nmultiplexers, aggregators and tee elements. Aggregators are elements\nthat merge the content of several input streams together into one output\nstream. Tee elements are the reverse: they are elements that have one\ninput stream and copy this stream to each of their output pads, which\nare created on request. Whenever an application needs another copy of\nthe stream, it can simply request a new output pad from the tee element.</p>\n<p>The following piece of code shows how you can request a new output pad\nfrom a \u201ctee\u201d element:</p>\n<pre><code class=\"language-c\">static void\nsome_function (GstElement *tee)\n{\n  GstPad * pad;\n  gchar *name;\n\n  pad = gst_element_get_request_pad (tee, \"src%d\");\n  name = gst_pad_get_name (pad);\n  g_print (\"A new pad %s was created\\n\", name);\n  g_free (name);\n\n  /* here, you would link the pad */\n\n  /* [..] */\n\n  /* and, after doing that, free our reference */\n  gst_object_unref (GST_OBJECT (pad));\n}\n</code></pre>\n<p>The <code>gst_element_get_request_pad ()</code> method can be used to get a pad\nfrom the element based on the name of the pad template. It is also\npossible to request a pad that is compatible with another pad template.\nThis is very useful if you want to link an element to a multiplexer\nelement and you need to request a pad that is compatible. The method\n<code>gst_element_get_compatible_pad ()</code> can be used to request a compatible\npad, as shown in the next example. It will request a compatible pad from\nan Ogg multiplexer from any input.</p>\n<pre><code class=\"language-c\">static void\nlink_to_multiplexer (GstPad     *tolink_pad,\n                     GstElement *mux)\n{\n  GstPad *pad;\n  gchar *srcname, *sinkname;\n\n  srcname = gst_pad_get_name (tolink_pad);\n  pad = gst_element_get_compatible_pad (mux, tolink_pad, NULL);\n  gst_pad_link (tolink_pad, pad);\n  sinkname = gst_pad_get_name (pad);\n  gst_object_unref (GST_OBJECT (pad));\n\n  g_print (\"A new pad %s was created and linked to %s\\n\", sinkname, srcname);\n  g_free (sinkname);\n  g_free (srcname);\n}\n</code></pre>\n<h2 id=\"capabilities-of-a-pad\">Capabilities of a pad</h2>\n<p>Since the pads play a very important role in how the element is viewed\nby the outside world, a mechanism is implemented to describe the data\nthat can flow or currently flows through the pad by using capabilities.\nHere, we will briefly describe what capabilities are and how to use\nthem, enough to get an understanding of the concept. For an in-depth\nlook into capabilities and a list of all capabilities defined in\nGStreamer, see the <a href=\"../../plugin-development/index.html\">Plugin Writers Guide</a></p>\n<p>Capabilities are attached to pad templates and to pads. For pad\ntemplates, it will describe the types of media that may stream over a\npad created from this template. For pads, it can either be a list of\npossible caps (usually a copy of the pad template's capabilities), in\nwhich case the pad is not yet negotiated, or it is the type of media\nthat currently streams over this pad, in which case the pad has been\nnegotiated already.</p>\n<h3 id=\"dissecting-capabilities\">Dissecting capabilities</h3>\n<p>A pad's capabilities are described in a <code>GstCaps</code> object. Internally, a\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/gstreamer-GstCaps.html\"><code>GstCaps</code></a>\nwill contain one or more\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/gstreamer-GstStructure.html\"><code>GstStructure</code></a>\nthat will describe one media type. A negotiated pad will have\ncapabilities set that contain exactly <em>one</em> structure. Also, this\nstructure will contain only <em>fixed</em> values. These constraints are not\ntrue for unnegotiated pads or pad templates.</p>\n<p>As an example, below is a dump of the capabilities of the \u201cvorbisdec\u201d\nelement, which you will get by running <code>gst-inspect vorbisdec</code>. You will\nsee two pads: a source and a sink pad. Both of these pads are always\navailable, and both have capabilities attached to them. The sink pad\nwill accept vorbis-encoded audio data, with the media type\n\u201caudio/x-vorbis\u201d. The source pad will be used to send raw (decoded)\naudio samples to the next element, with a raw audio media type (in this\ncase, \u201caudio/x-raw\u201d). The source pad will also contain properties for\nthe audio samplerate and the amount of channels, plus some more that you\ndon't need to worry about for now.</p>\n<pre><code>\nPad Templates:\n  SRC template: 'src'\n    Availability: Always\n    Capabilities:\n      audio/x-raw\n                 format: F32LE\n                   rate: [ 1, 2147483647 ]\n               channels: [ 1, 256 ]\n\n  SINK template: 'sink'\n    Availability: Always\n    Capabilities:\n      audio/x-vorbis\n\n</code></pre>\n<h3 id=\"properties-and-values\">Properties and values</h3>\n<p>Properties are used to describe extra information for capabilities. A\nproperty consists of a key (a string) and a value. There are different\npossible value types that can be used:</p>\n<ul>\n<li>\n<p>Basic types, this can be pretty much any <code>GType</code> registered with\nGlib. Those properties indicate a specific, non-dynamic value for\nthis property. Examples include:</p>\n<ul>\n<li>\n<p>An integer value (<code>G_TYPE_INT</code>): the property has this exact\nvalue.</p>\n</li>\n<li>\n<p>A boolean value (<code>G_TYPE_BOOLEAN</code>): the property is either TRUE\nor FALSE.</p>\n</li>\n<li>\n<p>A float value (<code>G_TYPE_FLOAT</code>): the property has this exact\nfloating point value.</p>\n</li>\n<li>\n<p>A string value (<code>G_TYPE_STRING</code>): the property contains a UTF-8\nstring.</p>\n</li>\n<li>\n<p>A fraction value (<code>GST_TYPE_FRACTION</code>): contains a fraction\nexpressed by an integer numerator and denominator.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Range types are <code>GType</code>s registered by GStreamer to indicate a range\nof possible values. They are used for indicating allowed audio\nsamplerate values or supported video sizes. The two types defined in\nGStreamer are:</p>\n<ul>\n<li>\n<p>An integer range value (<code>GST_TYPE_INT_RANGE</code>): the property\ndenotes a range of possible integers, with a lower and an upper\nboundary. The \u201cvorbisdec\u201d element, for example, has a rate\nproperty that can be between 8000 and 50000.</p>\n</li>\n<li>\n<p>A float range value (<code>GST_TYPE_FLOAT_RANGE</code>): the property\ndenotes a range of possible floating point values, with a lower\nand an upper boundary.</p>\n</li>\n<li>\n<p>A fraction range value (<code>GST_TYPE_FRACTION_RANGE</code>): the property\ndenotes a range of possible fraction values, with a lower and an\nupper boundary.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>A list value (<code>GST_TYPE_LIST</code>): the property can take any value from\na list of basic values given in this list.</p>\n<p>Example: caps that express that either a sample rate of 44100 Hz and\na sample rate of 48000 Hz is supported would use a list of integer\nvalues, with one value being 44100 and one value being 48000.</p>\n</li>\n<li>\n<p>An array value (<code>GST_TYPE_ARRAY</code>): the property is an array of\nvalues. Each value in the array is a full value on its own, too. All\nvalues in the array should be of the same elementary type. This\nmeans that an array can contain any combination of integers, lists\nof integers, integer ranges together, and the same for floats or\nstrings, but it can not contain both floats and ints at the same\ntime.</p>\n<p>Example: for audio where there are more than two channels involved\nthe channel layout needs to be specified (for one and two channel\naudio the channel layout is implicit unless stated otherwise in the\ncaps). So the channel layout would be an array of integer enum\nvalues where each enum value represents a loudspeaker position.\nUnlike a <code>GST_TYPE_LIST</code>, the values in an array will be interpreted\nas a whole.</p>\n</li>\n</ul>\n<h2 id=\"what-capabilities-are-used-for\">What capabilities are used for</h2>\n<p>Capabilities (short: caps) describe the type of data that is streamed\nbetween two pads, or that one pad (template) supports. This makes them\nvery useful for various purposes:</p>\n<ul>\n<li>\n<p>Autoplugging: automatically finding elements to link to a pad based\non its capabilities. All autopluggers use this method.</p>\n</li>\n<li>\n<p>Compatibility detection: when two pads are linked, GStreamer can\nverify if the two pads are talking about the same media type. The\nprocess of linking two pads and checking if they are compatible is\ncalled \u201ccaps negotiation\u201d.</p>\n</li>\n<li>\n<p>Metadata: by reading the capabilities from a pad, applications can\nprovide information about the type of media that is being streamed\nover the pad, which is information about the stream that is\ncurrently being played back.</p>\n</li>\n<li>\n<p>Filtering: an application can use capabilities to limit the possible\nmedia types that can stream between two pads to a specific subset of\ntheir supported stream types. An application can, for example, use\n\u201cfiltered caps\u201d to set a specific (fixed or non-fixed) video size\nthat should stream between two pads. You will see an example of\nfiltered caps later in this manual, in <a href=\"../advanced/pipeline-manipulation.html#manually-adding-or-removing-data-fromto-a-pipeline\">Manually adding or removing\ndata from/to a pipeline</a>.\nYou can do caps filtering by inserting a capsfilter element into\nyour pipeline and setting its \u201ccaps\u201d property. Caps filters are\noften placed after converter elements like audioconvert,\naudioresample, videoconvert or videoscale to force those converters\nto convert data to a specific output format at a certain point in a\nstream.</p>\n</li>\n</ul>\n<h3 id=\"using-capabilities-for-metadata\">Using capabilities for metadata</h3>\n<p>A pad can have a set (i.e. one or more) of capabilities attached to it.\nCapabilities (<code>GstCaps</code>) are represented as an array of one or more\n<code>GstStructure</code>s, and each <code>GstStructure</code> is an array of fields where\neach field consists of a field name string (e.g. \"width\") and a typed\nvalue (e.g. <code>G_TYPE_INT</code> or <code>GST_TYPE_INT_RANGE</code>).</p>\n<p>Note that there is a distinct difference between the <em>possible</em>\ncapabilities of a pad (ie. usually what you find as caps of pad\ntemplates as they are shown in gst-inspect), the <em>allowed</em> caps of a pad\n(can be the same as the pad's template caps or a subset of them,\ndepending on the possible caps of the peer pad) and lastly <em>negotiated</em>\ncaps (these describe the exact format of a stream or buffer and contain\nexactly one structure and have no variable bits like ranges or lists,\nie. they are fixed caps).</p>\n<p>You can get values of properties in a set of capabilities by querying\nindividual properties of one structure. You can get a structure from a\ncaps using <code>gst_caps_get_structure ()</code> and the number of structures in a\n<code>GstCaps</code> using <code>gst_caps_get_size ()</code>.</p>\n<p>Caps are called <em>simple caps</em> when they contain only one structure, and\n<em>fixed caps</em> when they contain only one structure and have no variable\nfield types (like ranges or lists of possible values). Two other special\ntypes of caps are <em>ANY caps</em> and <em>empty caps</em>.</p>\n<p>Here is an example of how to extract the width and height from a set of\nfixed video caps:</p>\n<pre><code class=\"language-c\">static void\nread_video_props (GstCaps *caps)\n{\n  gint width, height;\n  const GstStructure *str;\n\n  g_return_if_fail (gst_caps_is_fixed (caps));\n\n  str = gst_caps_get_structure (caps, 0);\n  if (!gst_structure_get_int (str, \"width\", &amp;width) ||\n      !gst_structure_get_int (str, \"height\", &amp;height)) {\n    g_print (\"No width/height available\\n\");\n    return;\n  }\n\n  g_print (\"The video size of this set of capabilities is %dx%d\\n\",\n       width, height);\n}\n\n</code></pre>\n<h3 id=\"creating-capabilities-for-filtering\">Creating capabilities for filtering</h3>\n<p>While capabilities are mainly used inside a plugin to describe the media\ntype of the pads, the application programmer often also has to have\nbasic understanding of capabilities in order to interface with the\nplugins, especially when using filtered caps. When you're using filtered\ncaps or fixation, you're limiting the allowed types of media that can\nstream between two pads to a subset of their supported media types. You\ndo this using a <code>capsfilter</code> element in your pipeline. In order to do\nthis, you also need to create your own <code>GstCaps</code>. The easiest way to do\nthis is by using the convenience function <code>gst_caps_new_simple ()</code>:</p>\n<pre><code class=\"language-c\">static gboolean\nlink_elements_with_filter (GstElement *element1, GstElement *element2)\n{\n  gboolean link_ok;\n  GstCaps *caps;\n\n  caps = gst_caps_new_simple (\"video/x-raw\",\n          \"format\", G_TYPE_STRING, \"I420\",\n          \"width\", G_TYPE_INT, 384,\n          \"height\", G_TYPE_INT, 288,\n          \"framerate\", GST_TYPE_FRACTION, 25, 1,\n          NULL);\n\n  link_ok = gst_element_link_filtered (element1, element2, caps);\n  gst_caps_unref (caps);\n\n  if (!link_ok) {\n    g_warning (\"Failed to link element1 and element2!\");\n  }\n\n  return link_ok;\n}\n\n</code></pre>\n<p>This will force the data flow between those two elements to a certain\nvideo format, width, height and framerate (or the linking will fail if\nthat cannot be achieved in the context of the elements involved). Keep\nin mind that when you use <code>gst_element_link_filtered ()</code> it will automatically create a\n<code>capsfilter</code> element for you and insert it into your bin or pipeline\nbetween the two elements you want to connect (this is important if you\never want to disconnect those elements because then you will have to\ndisconnect both elements from the capsfilter instead).</p>\n<p>In some cases, you will want to create a more elaborate set of\ncapabilities to filter a link between two pads. Then, this function is\ntoo simplistic and you'll want to use the method <code>gst_caps_new_full ()</code>:</p>\n<pre><code class=\"language-c\">static gboolean\nlink_elements_with_filter (GstElement *element1, GstElement *element2)\n{\n  gboolean link_ok;\n  GstCaps *caps;\n\n  caps = gst_caps_new_full (\n      gst_structure_new (\"video/x-raw\",\n             \"width\", G_TYPE_INT, 384,\n             \"height\", G_TYPE_INT, 288,\n             \"framerate\", GST_TYPE_FRACTION, 25, 1,\n             NULL),\n      gst_structure_new (\"video/x-bayer\",\n             \"width\", G_TYPE_INT, 384,\n             \"height\", G_TYPE_INT, 288,\n             \"framerate\", GST_TYPE_FRACTION, 25, 1,\n             NULL),\n      NULL);\n\n  link_ok = gst_element_link_filtered (element1, element2, caps);\n  gst_caps_unref (caps);\n\n  if (!link_ok) {\n    g_warning (\"Failed to link element1 and element2!\");\n  }\n\n  return link_ok;\n}\n\n</code></pre>\n<p>See the API references for the full API of\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/gstreamer-GstStructure.html\"><code>GstStructure</code></a>\nand\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/gstreamer-GstCaps.html\"><code>GstCaps</code></a>.</p>\n<h2 id=\"ghost-pads\">Ghost pads</h2>\n<p>You can see from <a href=\"../../#visualisation-of-a-gstbin-------element-without-ghost-pads\">Visualisation of a GstBin element without ghost\npads</a> how a\nbin has no pads of its own. This is where \"ghost pads\" come into play.</p>\n<p><img src=\"images/bin-element-noghost.png\" alt=\"Visualisation of a GstBin element without ghost pads\" title=\"fig:\" id=\"visualisation-of-a-gstbin-element-without-ghost-pads\"></p>\n<p>A ghost pad is a pad from some element in the bin that can be accessed\ndirectly from the bin as well. Compare it to a symbolic link in UNIX\nfilesystems. Using ghost pads on bins, the bin also has a pad and can\ntransparently be used as an element in other parts of your code.</p>\n<p><img src=\"images/bin-element-ghost.png\" alt=\"Visualisation of a GstBin element with a ghost pad\" title=\"fig:\" id=\"visualisation-of-a-gstbin-element-with-a-ghost-pad\"></p>\n<p><a href=\"../../#visualisation-of-a-gstbin-------element-with-a-ghost-pad\">Visualisation of a GstBin element with a ghost\npad</a> is a\nrepresentation of a ghost pad. The sink pad of element one is now also a\npad of the bin. Because ghost pads look and work like any other pads,\nthey can be added to any type of elements, not just to a <code>GstBin</code>, just\nlike ordinary pads.</p>\n<p>A ghostpad is created using the function <code>gst_ghost_pad_new ()</code>:</p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\nint\nmain (int   argc,\n      char *argv[])\n{\n  GstElement *bin, *sink;\n  GstPad *pad;\n\n  /* init */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* create element, add to bin */\n  sink = gst_element_factory_make (\"fakesink\", \"sink\");\n  bin = gst_bin_new (\"mybin\");\n  gst_bin_add (GST_BIN (bin), sink);\n\n  /* add ghostpad */\n  pad = gst_element_get_static_pad (sink, \"sink\");\n  gst_element_add_pad (bin, gst_ghost_pad_new (\"sink\", pad));\n  gst_object_unref (GST_OBJECT (pad));\n\n[..]\n\n}\n\n</code></pre>\n<p>In the above example, the bin now also has a pad: the pad called \u201csink\u201d\nof the given element. The bin can, from here on, be used as a substitute\nfor the sink element. You could, for example, link another element to\nthe bin.</p>\n<ol>\n<li>In reality, there is no objection to data flowing from a source pad\nto the sink pad of an element upstream (to the left of this element\nin drawings). Data will, however, always flow from a source pad of\none element to the sink pad of another.</li>\n</ol>\n\n</div>\n\n\n\t"});