fragment_downloaded_cb({"url": "application-development/advanced/autoplugging.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"autoplugging.md\">\n<h1 id=\"autoplugging\">Autoplugging</h1>\n<p>In <a href=\"../basics/helloworld.html\">Your first application</a>, you've learned to\nbuild a simple media player for Ogg/Vorbis files. By using alternative\nelements, you are able to build media players for other media types,\nsuch as Ogg/Speex, MP3 or even video formats. However, you would rather\nwant to build an application that can automatically detect the media\ntype of a stream and automatically generate the best possible pipeline\nby looking at all available elements in a system. This process is called\nautoplugging, and GStreamer contains high-quality autopluggers. If\nyou're looking for an autoplugger, don't read any further and go to\n<a href=\"../highlevel/playback-components.html\">Playback Components</a>. This chapter will\nexplain the <em>concept</em> of autoplugging and typefinding. It will explain\nwhat systems GStreamer includes to dynamically detect the type of a\nmedia stream, and how to generate a pipeline of decoder elements to\nplayback this media. The same principles can also be used for\ntranscoding. Because of the full dynamicity of this concept, GStreamer\ncan be automatically extended to support new media types without needing\nany adaptations to its autopluggers.</p>\n<p>We will first introduce the concept of Media types as a dynamic and\nextendible way of identifying media streams. After that, we will\nintroduce the concept of typefinding to find the type of a media stream.\nLastly, we will explain how autoplugging and the GStreamer registry can\nbe used to setup a pipeline that will convert media from one mediatype\nto another, for example for media decoding.</p>\n<h2 id=\"media-types-as-a-way-to-identify-streams\">Media types as a way to identify streams</h2>\n<p>We have previously introduced the concept of capabilities as a way for\nelements (or, rather, pads) to agree on a media type when streaming data\nfrom one element to the next (see <a href=\"../basics/pads.html#capabilities-of-a-pad\">Capabilities of a pad</a>)). We have\nexplained that a capability is a combination of a media type and a set of\nproperties. For most container formats (those are the files that you will find\non your hard disk; Ogg, for example, is a container format), no properties are\nneeded to describe the stream. Only a media type is needed. A full list\nof media types and accompanying properties can be found in <a href=\"../../plugin-development/advanced/media-types.html\">the Plugin\nWriter's Guide</a>.</p>\n<p>An element must associate a media type to its source and sink pads when\nit is loaded into the system. GStreamer knows about the different\nelements and what type of data they expect and emit through the\nGStreamer registry. This allows for very dynamic and extensible element\ncreation as we will see.</p>\n<p>In <a href=\"../basics/helloworld.html\">Your first application</a>, we've learned to\nbuild a music player for Ogg/Vorbis files. Let's look at the media types\nassociated with each pad in this pipeline. <a href=\"../../#the-hello-world-pipeline-with-media-types\">The Hello world pipeline\nwith media types</a> shows what\nmedia type belongs to each pad in this pipeline.</p>\n<p><img src=\"images/mime-world.png\" alt=\"The Hello world pipeline with media types\" title=\"fig:\" id=\"the-hello-world-pipeline-with-media-types\"></p>\n<p>Now that we have an idea how GStreamer identifies known media streams,\nwe can look at methods GStreamer uses to setup pipelines for media\nhandling and for media type detection.</p>\n<h2 id=\"media-stream-type-detection\">Media stream type detection</h2>\n<p>Usually, when loading a media stream, the type of the stream is not\nknown. This means that before we can choose a pipeline to decode the\nstream, we first need to detect the stream type. GStreamer uses the\nconcept of typefinding for this. Typefinding is a normal part of a\npipeline, it will read data for as long as the type of a stream is\nunknown. During this period, it will provide data to all plugins that\nimplement a typefinder. When one of the typefinders recognizes the\nstream, the typefind element will emit a signal and act as a passthrough\nmodule from that point on. If no type was found, it will emit an error\nand further media processing will stop.</p>\n<p>Once the typefind element has found a type, the application can use this\nto plug together a pipeline to decode the media stream. This will be\ndiscussed in the next section.</p>\n<p>Plugins in GStreamer can, as mentioned before, implement typefinder\nfunctionality. A plugin implementing this functionality will submit a\nmedia type, optionally a set of file extensions commonly used for this\nmedia type, and a typefind function. Once this typefind function inside\nthe plugin is called, the plugin will see if the data in this media\nstream matches a specific pattern that marks the media type identified\nby that media type. If it does, it will notify the typefind element of\nthis fact, telling which mediatype was recognized and how certain we are\nthat this stream is indeed that mediatype. Once this run has been\ncompleted for all plugins implementing a typefind functionality, the\ntypefind element will tell the application what kind of media stream it\nthinks to have recognized.</p>\n<p>The following code should explain how to use the typefind element. It\nwill print the detected media type, or tell that the media type was not\nfound. The next section will introduce more useful behaviours, such as\nplugging together a decoding pipeline.</p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\n[.. my_bus_callback goes here ..]\n\nstatic gboolean\nidle_exit_loop (gpointer data)\n{\n  g_main_loop_quit ((GMainLoop *) data);\n\n  /* once */\n  return FALSE;\n}\n\nstatic void\ncb_typefound (GstElement *typefind,\n          guint       probability,\n          GstCaps    *caps,\n          gpointer    data)\n{\n  GMainLoop *loop = data;\n  gchar *type;\n\n  type = gst_caps_to_string (caps);\n  g_print (\"Media type %s found, probability %d%%\\n\", type, probability);\n  g_free (type);\n\n  /* since we connect to a signal in the pipeline thread context, we need\n   * to set an idle handler to exit the main loop in the mainloop context.\n   * Normally, your app should not need to worry about such things. */\n  g_idle_add (idle_exit_loop, loop);\n}\n\ngint\nmain (gint   argc,\n      gchar *argv[])\n{\n  GMainLoop *loop;\n  GstElement *pipeline, *filesrc, *typefind, *fakesink;\n  GstBus *bus;\n\n  /* init GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n  loop = g_main_loop_new (NULL, FALSE);\n\n  /* check args */\n  if (argc != 2) {\n    g_print (\"Usage: %s &lt;filename&gt;\\n\", argv[0]);\n    return -1;\n  }\n\n  /* create a new pipeline to hold the elements */\n  pipeline = gst_pipeline_new (\"pipe\");\n\n  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));\n  gst_bus_add_watch (bus, my_bus_callback, NULL);\n  gst_object_unref (bus);\n\n  /* create file source and typefind element */\n  filesrc = gst_element_factory_make (\"filesrc\", \"source\");\n  g_object_set (G_OBJECT (filesrc), \"location\", argv[1], NULL);\n  typefind = gst_element_factory_make (\"typefind\", \"typefinder\");\n  g_signal_connect (typefind, \"have-type\", G_CALLBACK (cb_typefound), loop);\n  fakesink = gst_element_factory_make (\"fakesink\", \"sink\");\n\n  /* setup */\n  gst_bin_add_many (GST_BIN (pipeline), filesrc, typefind, fakesink, NULL);\n  gst_element_link_many (filesrc, typefind, fakesink, NULL);\n  gst_element_set_state (GST_ELEMENT (pipeline), GST_STATE_PLAYING);\n  g_main_loop_run (loop);\n\n  /* unset */\n  gst_element_set_state (GST_ELEMENT (pipeline), GST_STATE_NULL);\n  gst_object_unref (GST_OBJECT (pipeline));\n\n  return 0;\n}\n\n</code></pre>\n<p>Once a media type has been detected, you can plug an element (e.g. a\ndemuxer or decoder) to the source pad of the typefind element, and\ndecoding of the media stream will start right after.</p>\n<h2 id=\"dynamically-autoplugging-a-pipeline\">Dynamically autoplugging a pipeline</h2>\n<p>See <a href=\"../highlevel/playback-components.html\">Playback Components</a> for using the\nhigh level object that you can use to dynamically construct pipelines.</p>\n\n</div>\n\n\n        "});