fragment_downloaded_cb({"url": "application-development/advanced/pipeline-manipulation.html#grabbing-data-with-appsink", "fragment": "Grabbing data with appsink \nUnlike appsrc appsink is a little easier to use. It also supports a pull and push based model of getting data from the pipeline. \nThe normal way of retrieving samples from appsink is by using the gst_app_sink_pull_sample and gst_app_sink_pull_preroll methods or by using the pull sample and pull preroll signals. These methods block until a sample becomes available in the sink or when the sink is shut down or reaches EOS. \nAppsink will internally use a queue to collect buffers from the streaming thread. If the application is not pulling samples fast enough this queue will consume a lot of memory over time. The max buffers property can be used to limit the queue size. The drop property controls whether the streaming thread blocks or if older buffers are dropped when the maximum queue size is reached. Note that blocking the streaming thread can negatively affect real time performance and should be avoided. \nIf a blocking behaviour is not desirable setting the emit signals property to TRUE will make appsink emit the new sample and new preroll signals when a sample can be pulled without blocking. \nThe caps property on appsink can be used to control the formats that appsink can receive. This property can contain non fixed caps the format of the pulled samples can be obtained by getting the sample caps. \nIf one of the pull preroll or pull sample methods return NULL the appsink is stopped or in the EOS state. You can check for the EOS state with the eos property or with the gst_app_sink_is_eos method. \nThe eos signal can also be used to be informed when the EOS state is reached to avoid polling. \nConsider configuring the following properties in the appsink \nThe sync property if you want to have the sink base class synchronize the buffer against the pipeline clock before handing you the sample. \nEnable Quality of Service with the qos property. If you are dealing with raw video frames and let the base class sycnhronize on the clock it might be a good idea to also let the base class send QOS events upstream. \nThe caps property that contains the accepted caps. Upstream elements will try to convert the format so that it matches the configured caps on appsink. You must still check the GstSample to get the actual caps of the buffer. \n"});