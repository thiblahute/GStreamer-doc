fragment_downloaded_cb({"url": "application-development/advanced/metadata.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"metadata.md\">\n<h1 id=\"metadata\">Metadata</h1>\n<p>GStreamer makes a clear distinction between two types of metadata, and\nhas support for both types. The first is stream tags, which describe the\ncontent of a stream in a non-technical way. Examples include the author\nof a song, the title of that very same song or the album it is a part\nof. The other type of metadata is stream-info, which is a somewhat\ntechnical description of the properties of a stream. This can include\nvideo size, audio samplerate, codecs used and so on. Tags are handled\nusing the GStreamer tagging system. Stream-info can be retrieved from a\n<code>GstPad</code> by getting the current (negotiated) <code>GstCaps</code> for that pad.</p>\n<h2 id=\"metadata-reading\">Metadata reading</h2>\n<p>Stream information can most easily be read by reading it from a\n<code>GstPad</code>. This has already been discussed before in <a href=\"../basics/pads.html#using-capabilities-for-metadata\">Using capabilities\nfor metadata</a>.\nTherefore, we will skip it here. Note that this requires access to all\npads of which you want stream information.</p>\n<p>Tag reading is done through a bus in GStreamer, which has been discussed\npreviously in <a href=\"../basics/bus.html\">Bus</a>. You can listen for\n<code>GST_MESSAGE_TAG</code> messages and handle them as you wish.</p>\n<p>Note, however, that the <code>GST_MESSAGE_TAG</code> message may be fired multiple\ntimes in the pipeline. It is the application's responsibility to put all\nthose tags together and display them to the user in a nice, coherent\nway. Usually, using <code>gst_tag_list_merge ()</code> is a good enough way of\ndoing this; make sure to empty the cache when loading a new song, or\nafter every few minutes when listening to internet radio. Also, make\nsure you use <code>GST_TAG_MERGE_PREPEND</code> as merging mode, so that a new\ntitle (which came in later) has a preference over the old one for\ndisplay.</p>\n<p>The following example will extract tags from a file and print them:</p>\n<pre><code class=\"language-c\">/* compile with:\n * gcc -o tags tags.c `pkg-config --cflags --libs gstreamer-1.0` */\n#include &lt;gst/gst.h&gt;\n\nstatic void\nprint_one_tag (const GstTagList * list, const gchar * tag, gpointer user_data)\n{\n  int i, num;\n\n  num = gst_tag_list_get_tag_size (list, tag);\n  for (i = 0; i &lt; num; ++i) {\n    const GValue *val;\n\n    /* Note: when looking for specific tags, use the gst_tag_list_get_xyz() API,\n     * we only use the GValue approach here because it is more generic */\n    val = gst_tag_list_get_value_index (list, tag, i);\n    if (G_VALUE_HOLDS_STRING (val)) {\n      g_print (\"\\t%20s : %s\\n\", tag, g_value_get_string (val));\n    } else if (G_VALUE_HOLDS_UINT (val)) {\n      g_print (\"\\t%20s : %u\\n\", tag, g_value_get_uint (val));\n    } else if (G_VALUE_HOLDS_DOUBLE (val)) {\n      g_print (\"\\t%20s : %g\\n\", tag, g_value_get_double (val));\n    } else if (G_VALUE_HOLDS_BOOLEAN (val)) {\n      g_print (\"\\t%20s : %s\\n\", tag,\n          (g_value_get_boolean (val)) ? \"true\" : \"false\");\n    } else if (GST_VALUE_HOLDS_BUFFER (val)) {\n      GstBuffer *buf = gst_value_get_buffer (val);\n      guint buffer_size = gst_buffer_get_size (buf);\n\n      g_print (\"\\t%20s : buffer of size %u\\n\", tag, buffer_size);\n    } else if (GST_VALUE_HOLDS_DATE_TIME (val)) {\n      GstDateTime *dt = g_value_get_boxed (val);\n      gchar *dt_str = gst_date_time_to_iso8601_string (dt);\n\n      g_print (\"\\t%20s : %s\\n\", tag, dt_str);\n      g_free (dt_str);\n    } else {\n      g_print (\"\\t%20s : tag of type '%s'\\n\", tag, G_VALUE_TYPE_NAME (val));\n    }\n  }\n}\n\nstatic void\non_new_pad (GstElement * dec, GstPad * pad, GstElement * fakesink)\n{\n  GstPad *sinkpad;\n\n  sinkpad = gst_element_get_static_pad (fakesink, \"sink\");\n  if (!gst_pad_is_linked (sinkpad)) {\n    if (gst_pad_link (pad, sinkpad) != GST_PAD_LINK_OK)\n      g_error (\"Failed to link pads!\");\n  }\n  gst_object_unref (sinkpad);\n}\n\nint\nmain (int argc, char ** argv)\n{\n  GstElement *pipe, *dec, *sink;\n  GstMessage *msg;\n  gchar *uri;\n\n  gst_init (&amp;argc, &amp;argv);\n\n  if (argc &lt; 2)\n    g_error (\"Usage: %s FILE or URI\", argv[0]);\n\n  if (gst_uri_is_valid (argv[1])) {\n    uri = g_strdup (argv[1]);\n  } else {\n    uri = gst_filename_to_uri (argv[1], NULL);\n  }\n\n  pipe = gst_pipeline_new (\"pipeline\");\n\n  dec = gst_element_factory_make (\"uridecodebin\", NULL);\n  g_object_set (dec, \"uri\", uri, NULL);\n  gst_bin_add (GST_BIN (pipe), dec);\n\n  sink = gst_element_factory_make (\"fakesink\", NULL);\n  gst_bin_add (GST_BIN (pipe), sink);\n\n  g_signal_connect (dec, \"pad-added\", G_CALLBACK (on_new_pad), sink);\n\n  gst_element_set_state (pipe, GST_STATE_PAUSED);\n\n  while (TRUE) {\n    GstTagList *tags = NULL;\n\n    msg = gst_bus_timed_pop_filtered (GST_ELEMENT_BUS (pipe),\n        GST_CLOCK_TIME_NONE,\n        GST_MESSAGE_ASYNC_DONE | GST_MESSAGE_TAG | GST_MESSAGE_ERROR);\n\n    if (GST_MESSAGE_TYPE (msg) != GST_MESSAGE_TAG) /* error or async_done */\n      break;\n\n    gst_message_parse_tag (msg, &amp;tags);\n\n    g_print (\"Got tags from element %s:\\n\", GST_OBJECT_NAME (msg-&gt;src));\n    gst_tag_list_foreach (tags, print_one_tag, NULL);\n    g_print (\"\\n\");\n    gst_tag_list_unref (tags);\n\n    gst_message_unref (msg);\n  }\n\n  if (GST_MESSAGE_TYPE (msg) == GST_MESSAGE_ERROR) {\n    GError *err = NULL;\n\n    gst_message_parse_error (msg, &amp;err, NULL);\n    g_printerr (\"Got error: %s\\n\", err-&gt;message);\n    g_error_free (err);\n  }\n\n  gst_message_unref (msg);\n  gst_element_set_state (pipe, GST_STATE_NULL);\n  gst_object_unref (pipe);\n  g_free (uri);\n  return 0;\n}\n\n</code></pre>\n<h2 id=\"tag-writing\">Tag writing</h2>\n<p>Tag writing is done using the\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstTagSetter.html\"><code>GstTagSetter</code></a>\ninterface. All that's required is a tag-set-supporting element in your\npipeline. In order to see if any of the elements in your pipeline\nsupports tag writing, you can use the function\n<code>gst_bin_iterate_all_by_interface (pipeline, GST_TYPE_TAG_SETTER)</code>. On the resulting element, usually an encoder or\nmuxer, you can use <code>gst_tag_setter_merge ()</code> (with a taglist) or <code>gst_tag_setter_add ()</code> (with individual tags) to set tags on it.</p>\n<p>A nice extra feature in GStreamer tag support is that tags are preserved\nin pipelines. This means that if you transcode one file containing tags\ninto another media type, and that new media type supports tags too, then\nthe tags will be handled as part of the data stream and be merged into\nthe newly written media file, too.</p>\n\n</div>\n\n\n\t"});