fragment_downloaded_cb({"url": "application-development/advanced/buffering.html#stream-buffering", "fragment": "Stream buffering \nIn this case we are reading from a slow network source into a buffer element such as queue2 \nThe buffer element has a low and high watermark expressed in bytes. The buffer uses the watermarks as follows \nThe buffer element will post BUFFERING messages until the high watermark is hit. This instructs the application to keep the pipeline PAUSED which will eventually block the srcpad from pushing while data is prerolled in the sinks. \nWhen the high watermark is hit a BUFFERING message with will be posted which instructs the application to continue playback. \nWhen during playback the low watermark is hit the queue will start posting BUFFERING messages again making the application PAUSE the pipeline again until the high watermark is hit again. This is called the rebuffering stage. \nDuring playback the queue level will fluctuate between the high and the low watermark as a way to compensate for network irregularities. \nThis buffering method is usable when the demuxer operates in push mode. Seeking in the stream requires the seek to happen in the network source. It is mostly desirable when the total duration of the file is not known such as in live streaming or when efficient seeking is not possible required. \nThe problem is configuring a good low and high watermark. Here are some ideas \nIt is possible to measure the network bandwidth and configure the low high watermarks in such a way that buffering takes a fixed amount of time. \nThe queue2 element in GStreamer core has the max size time property that together with the use rate estimate property does exactly that. Also the playbin buffer duration property uses the rate estimate to scale the amount of data that is buffered. \nBased on the codec bitrate it is also possible to set the watermarks in such a way that a fixed amount of data is buffered before playback starts. Normally the buffering element doesn t know about the bitrate of the stream but it can get this with a query. \nStart with a fixed amount of bytes measure the time between rebuffering and increase the queue size until the time between rebuffering is within the application s chosen limits. \nThe buffering element can be inserted anywhere in the pipeline. You could for example insert the buffering element before a decoder. This would make it possible to set the low high watermarks based on time. \nThe buffering flag on playbin performs buffering on the parsed data. Another advantage of doing the buffering at a later stage is that you can let the demuxer operate in pull mode. When reading data from a slow network drive with filesrc this can be an interesting way to buffer. \n"});