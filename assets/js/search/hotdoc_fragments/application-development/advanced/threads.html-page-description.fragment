fragment_downloaded_cb({"url": "application-development/advanced/threads.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"threads.md\">\n        <h1 id=\"threads\">Threads</h1>\n<p>GStreamer is inherently multi-threaded, and is fully thread-safe. Most\nthreading internals are hidden from the application, which should make\napplication development easier. However, in some cases, applications may\nwant to have influence on some parts of those. GStreamer allows\napplications to force the use of multiple threads over some parts of a\npipeline. See <a href=\"../../#when-would-you-want-to-force-a-thread\">When would you want to force a\nthread?</a>.</p>\n<p>GStreamer can also notify you when threads are created so that you can\nconfigure things such as the thread priority or the threadpool to use.\nSee <a href=\"../../#configuring-threads-in-gstreamer\">Configuring Threads in\nGStreamer</a>.</p>\n<h2 id=\"scheduling-in-gstreamer\">Scheduling in GStreamer</h2>\n<p>Each element in the GStreamer pipeline decides how it is going to be\nscheduled. Elements can choose if their pads are to be scheduled\npush-based or pull-based. An element can, for example, choose to start a\nthread to start pulling from the sink pad or/and start pushing on the\nsource pad. An element can also choose to use the upstream or downstream\nthread for its data processing in push and pull mode respectively.\nGStreamer does not pose any restrictions on how the element chooses to\nbe scheduled. See the Plugin Writer Guide for more details.</p>\n<p>What will happen in any case is that some elements will start a thread\nfor their data processing, called the \u201cstreaming threads\u201d. The streaming\nthreads, or <code>GstTask</code> objects, are created from a <code>GstTaskPool</code> when the\nelement needs to make a streaming thread. In the next section we see how\nwe can receive notifications of the tasks and pools.</p>\n<h2 id=\"configuring-threads-in-gstreamer\">Configuring Threads in GStreamer</h2>\n<p>A STREAM_STATUS message is posted on the bus to inform you about the\nstatus of the streaming threads. You will get the following information\nfrom the message:</p>\n<ul>\n<li>\n<p>When a new thread is about to be created, you will be notified of\nthis with a GST_STREAM_STATUS_TYPE_CREATE type. It is then\npossible to configure a <code>GstTaskPool</code> in the <code>GstTask</code>. The custom\ntaskpool will provide custom threads for the task to implement the\nstreaming threads.</p>\n<p>This message needs to be handled synchronously if you want to\nconfigure a custom taskpool. If you don't configure the taskpool on\nthe task when this message returns, the task will use its default\npool.</p>\n</li>\n<li>\n<p>When a thread is entered or left. This is the moment where you could\nconfigure thread priorities. You also get a notification when a\nthread is destroyed.</p>\n</li>\n<li>\n<p>You get messages when the thread starts, pauses and stops. This\ncould be used to visualize the status of streaming threads in a gui\napplication.</p>\n</li>\n</ul>\n<p>We will now look at some examples in the next sections.</p>\n<h3 id=\"boost-priority-of-a-thread\">Boost priority of a thread</h3>\n<pre><code>        .----------.    .----------.\n        | faksesrc |    | fakesink |\n        |         src-&gt;sink        |\n        '----------'    '----------'\n\n</code></pre>\n<p>Let's look at the simple pipeline above. We would like to boost the\npriority of the streaming thread. It will be the fakesrc element that\nstarts the streaming thread for generating the fake data pushing them to\nthe peer fakesink. The flow for changing the priority would go like\nthis:</p>\n<ul>\n<li>\n<p>When going from READY to PAUSED state, fakesrc will require a\nstreaming thread for pushing data into the fakesink. It will post a\nSTREAM_STATUS message indicating its requirement for a streaming\nthread.</p>\n</li>\n<li>\n<p>The application will react to the STREAM_STATUS messages with a\nsync bus handler. It will then configure a custom <code>GstTaskPool</code> on\nthe <code>GstTask</code> inside the message. The custom taskpool is responsible\nfor creating the threads. In this example we will make a thread with\na higher priority.</p>\n</li>\n<li>\n<p>Alternatively, since the sync message is called in the thread\ncontext, you can use thread ENTER/LEAVE notifications to change the\npriority or scheduling pollicy of the current thread.</p>\n</li>\n</ul>\n<p>In a first step we need to implement a custom <code>GstTaskPool</code> that we can\nconfigure on the task. Below is the implementation of a <code>GstTaskPool</code>\nsubclass that uses pthreads to create a SCHED_RR real-time thread. Note\nthat creating real-time threads might require extra priveleges.</p>\n<pre><code class=\"language-c\">#include &lt;pthread.h&gt;\n\ntypedef struct\n{\n  pthread_t thread;\n} TestRTId;\n\nG_DEFINE_TYPE (TestRTPool, test_rt_pool, GST_TYPE_TASK_POOL);\n\nstatic void\ndefault_prepare (GstTaskPool * pool, GError ** error)\n{\n  /* we don't do anything here. We could construct a pool of threads here that\n   * we could reuse later but we don't */\n}\n\nstatic void\ndefault_cleanup (GstTaskPool * pool)\n{\n}\n\nstatic gpointer\ndefault_push (GstTaskPool * pool, GstTaskPoolFunction func, gpointer data,\n    GError ** error)\n{\n  TestRTId *tid;\n  gint res;\n  pthread_attr_t attr;\n  struct sched_param param;\n\n  tid = g_slice_new0 (TestRTId);\n\n  pthread_attr_init (&amp;attr);\n  if ((res = pthread_attr_setschedpolicy (&amp;attr, SCHED_RR)) != 0)\n    g_warning (\"setschedpolicy: failure: %p\", g_strerror (res));\n\n  param.sched_priority = 50;\n  if ((res = pthread_attr_setschedparam (&amp;attr, &amp;param)) != 0)\n    g_warning (\"setschedparam: failure: %p\", g_strerror (res));\n\n  if ((res = pthread_attr_setinheritsched (&amp;attr, PTHREAD_EXPLICIT_SCHED)) != 0)\n    g_warning (\"setinheritsched: failure: %p\", g_strerror (res));\n\n  res = pthread_create (&amp;tid-&gt;thread, &amp;attr, (void *(*)(void *)) func, data);\n\n  if (res != 0) {\n    g_set_error (error, G_THREAD_ERROR, G_THREAD_ERROR_AGAIN,\n        \"Error creating thread: %s\", g_strerror (res));\n    g_slice_free (TestRTId, tid);\n    tid = NULL;\n  }\n\n  return tid;\n}\n\nstatic void\ndefault_join (GstTaskPool * pool, gpointer id)\n{\n  TestRTId *tid = (TestRTId *) id;\n\n  pthread_join (tid-&gt;thread, NULL);\n\n  g_slice_free (TestRTId, tid);\n}\n\nstatic void\ntest_rt_pool_class_init (TestRTPoolClass * klass)\n{\n  GstTaskPoolClass *gsttaskpool_class;\n\n  gsttaskpool_class = (GstTaskPoolClass *) klass;\n\n  gsttaskpool_class-&gt;prepare = default_prepare;\n  gsttaskpool_class-&gt;cleanup = default_cleanup;\n  gsttaskpool_class-&gt;push = default_push;\n  gsttaskpool_class-&gt;join = default_join;\n}\n\nstatic void\ntest_rt_pool_init (TestRTPool * pool)\n{\n}\n\nGstTaskPool *\ntest_rt_pool_new (void)\n{\n  GstTaskPool *pool;\n\n  pool = g_object_new (TEST_TYPE_RT_POOL, NULL);\n\n  return pool;\n}\n\n\n\n</code></pre>\n<p>The important function to implement when writing an taskpool is the\n\u201cpush\u201d function. The implementation should start a thread that calls\nthe given function. More involved implementations might want to keep\nsome threads around in a pool because creating and destroying threads is\nnot always the fastest operation.</p>\n<p>In a next step we need to actually configure the custom taskpool when\nthe fakesrc needs it. For this we intercept the STREAM_STATUS messages\nwith a sync handler.</p>\n<pre><code class=\"language-c\">\n\nstatic GMainLoop* loop;\n\nstatic void\non_stream_status (GstBus     *bus,\n                  GstMessage *message,\n                  gpointer    user_data)\n{\n  GstStreamStatusType type;\n  GstElement *owner;\n  const GValue *val;\n  GstTask *task = NULL;\n\n  gst_message_parse_stream_status (message, &amp;type, &amp;owner);\n\n  val = gst_message_get_stream_status_object (message);\n\n  /* see if we know how to deal with this object */\n  if (G_VALUE_TYPE (val) == GST_TYPE_TASK) {\n    task = g_value_get_object (val);\n  }\n\n  switch (type) {\n    case GST_STREAM_STATUS_TYPE_CREATE:\n      if (task) {\n        GstTaskPool *pool;\n\n        pool = test_rt_pool_new();\n\n        gst_task_set_pool (task, pool);\n      }\n      break;\n    default:\n      break;\n  }\n}\n\nstatic void\non_error (GstBus     *bus,\n          GstMessage *message,\n          gpointer    user_data)\n{\n  g_message (\"received ERROR\");\n  g_main_loop_quit (loop);\n}\n\nstatic void\non_eos (GstBus     *bus,\n        GstMessage *message,\n        gpointer    user_data)\n{\n  g_main_loop_quit (loop);\n}\n\nint\nmain (int argc, char *argv[])\n{\n  GstElement *bin, *fakesrc, *fakesink;\n  GstBus *bus;\n  GstStateChangeReturn ret;\n\n  gst_init (&amp;argc, &amp;argv);\n\n  /* create a new bin to hold the elements */\n  bin = gst_pipeline_new (\"pipeline\");\n  g_assert (bin);\n\n  /* create a source */\n  fakesrc = gst_element_factory_make (\"fakesrc\", \"fakesrc\");\n  g_assert (fakesrc);\n  g_object_set (fakesrc, \"num-buffers\", 50, NULL);\n\n  /* and a sink */\n  fakesink = gst_element_factory_make (\"fakesink\", \"fakesink\");\n  g_assert (fakesink);\n\n  /* add objects to the main pipeline */\n  gst_bin_add_many (GST_BIN (bin), fakesrc, fakesink, NULL);\n\n  /* link the elements */\n  gst_element_link (fakesrc, fakesink);\n\n  loop = g_main_loop_new (NULL, FALSE);\n\n  /* get the bus, we need to install a sync handler */\n  bus = gst_pipeline_get_bus (GST_PIPELINE (bin));\n  gst_bus_enable_sync_message_emission (bus);\n  gst_bus_add_signal_watch (bus);\n\n  g_signal_connect (bus, \"sync-message::stream-status\",\n      (GCallback) on_stream_status, NULL);\n  g_signal_connect (bus, \"message::error\",\n      (GCallback) on_error, NULL);\n  g_signal_connect (bus, \"message::eos\",\n      (GCallback) on_eos, NULL);\n\n  /* start playing */\n  ret = gst_element_set_state (bin, GST_STATE_PLAYING);\n  if (ret != GST_STATE_CHANGE_SUCCESS) {\n    g_message (\"failed to change state\");\n    return -1;\n  }\n\n  /* Run event loop listening for bus messages until EOS or ERROR */\n  g_main_loop_run (loop);\n\n  /* stop the bin */\n  gst_element_set_state (bin, GST_STATE_NULL);\n  gst_object_unref (bus);\n  g_main_loop_unref (loop);\n\n  return 0;\n}\n\n\n\n</code></pre>\n<p>Note that this program likely needs root permissions in order to create\nreal-time threads. When the thread can't be created, the state change\nfunction will fail, which we catch in the application above.</p>\n<p>When there are multiple threads in the pipeline, you will receive\nmultiple STREAM_STATUS messages. You should use the owner of the\nmessage, which is likely the pad or the element that starts the thread,\nto figure out what the function of this thread is in the context of the\napplication.</p>\n<h2 id=\"when-would-you-want-to-force-a-thread\">When would you want to force a thread?</h2>\n<p>We have seen that threads are created by elements but it is also\npossible to insert elements in the pipeline for the sole purpose of\nforcing a new thread in the pipeline.</p>\n<p>There are several reasons to force the use of threads. However, for\nperformance reasons, you never want to use one thread for every element\nout there, since that will create some overhead. Let's now list some\nsituations where threads can be particularly useful:</p>\n<ul>\n<li>\n<p>Data buffering, for example when dealing with network streams or\nwhen recording data from a live stream such as a video or audio\ncard. Short hickups elsewhere in the pipeline will not cause data\nloss. See also <a href=\"buffering.html#stream-buffering\">Stream buffering</a> about network\nbuffering with queue2.</p>\n<p><img src=\"images/thread-buffering.png\" alt=\"Data buffering, from a networked source\" title=\"fig:\" id=\"data-buffering-from-a-networked-source\"></p>\n</li>\n<li>\n<p>Synchronizing output devices, e.g. when playing a stream containing\nboth video and audio data. By using threads for both outputs, they\nwill run independently and their synchronization will be better.</p>\n<p><img src=\"images/thread-synchronizing.png\" alt=\"Synchronizing audio and video sinks\" title=\"fig:\" id=\"synchronizing-audio-and-video-sinks\"></p>\n</li>\n</ul>\n<p>Above, we've mentioned the \u201cqueue\u201d element several times now. A queue is\nthe thread boundary element through which you can force the use of\nthreads. It does so by using a classic provider/consumer model as\nlearned in threading classes at universities all around the world. By\ndoing this, it acts both as a means to make data throughput between\nthreads threadsafe, and it can also act as a buffer. Queues have several\n<code>GObject</code> properties to be configured for specific uses. For example,\nyou can set lower and upper thresholds for the element. If there's less\ndata than the lower threshold (default: disabled), it will block output.\nIf there's more data than the upper threshold, it will block input or\n(if configured to do so) drop data.</p>\n<p>To use a queue (and therefore force the use of two distinct threads in\nthe pipeline), one can simply create a \u201cqueue\u201d element and put this in\nas part of the pipeline. GStreamer will take care of all threading\ndetails internally.</p>\n\n        \n\n    </div>\n\n\n        "});