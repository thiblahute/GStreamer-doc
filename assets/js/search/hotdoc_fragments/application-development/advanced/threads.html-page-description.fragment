fragment_downloaded_cb({"url": "application-development/advanced/threads.html#page-description", "fragment": "GStreamer is inherently multi threaded and is fully thread safe. Most threading internals are hidden from the application which should make application development easier. However in some cases applications may want to have influence on some parts of those. GStreamer allows applications to force the use of multiple threads over some parts of a pipeline. See When would you want to force a thread \nGStreamer can also notify you when threads are created so that you can configure things such as the thread priority or the threadpool to use. See Configuring Threads in GStreamer. \nEach element in the GStreamer pipeline decides how it is going to be scheduled. Elements can choose if their pads are to be scheduled push based or pull based. An element can for example choose to start a thread to start pulling from the sink pad or and start pushing on the source pad. An element can also choose to use the upstream or downstream thread for its data processing in push and pull mode respectively. GStreamer does not pose any restrictions on how the element chooses to be scheduled. See the Plugin Writer Guide for more details. \nWhat will happen in any case is that some elements will start a thread for their data processing called the streaming threads The streaming threads or GstTask objects are created from a GstTaskPool when the element needs to make a streaming thread. In the next section we see how we can receive notifications of the tasks and pools. \nA STREAM_STATUS message is posted on the bus to inform you about the status of the streaming threads. You will get the following information from the message \nWhen a new thread is about to be created you will be notified of this with a GST_STREAM_STATUS_TYPE_CREATE type. It is then possible to configure a GstTaskPool in the GstTask. The custom taskpool will provide custom threads for the task to implement the streaming threads. \nThis message needs to be handled synchronously if you want to configure a custom taskpool. If you don t configure the taskpool on the task when this message returns the task will use its default pool. \nWhen a thread is entered or left. This is the moment where you could configure thread priorities. You also get a notification when a thread is destroyed. \nYou get messages when the thread starts pauses and stops. This could be used to visualize the status of streaming threads in a gui application. \nWe will now look at some examples in the next sections. \nLet s look at the simple pipeline above. We would like to boost the priority of the streaming thread. It will be the fakesrc element that starts the streaming thread for generating the fake data pushing them to the peer fakesink. The flow for changing the priority would go like this \nWhen going from READY to PAUSED state fakesrc will require a streaming thread for pushing data into the fakesink. It will post a STREAM_STATUS message indicating its requirement for a streaming thread. \nThe application will react to the STREAM_STATUS messages with a sync bus handler. It will then configure a custom GstTaskPool on the GstTask inside the message. The custom taskpool is responsible for creating the threads. In this example we will make a thread with a higher priority. \nAlternatively since the sync message is called in the thread context you can use thread ENTER LEAVE notifications to change the priority or scheduling pollicy of the current thread. \nIn a first step we need to implement a custom GstTaskPool that we can configure on the task. Below is the implementation of a GstTaskPool subclass that uses pthreads to create a SCHED_RR real time thread. Note that creating real time threads might require extra priveleges. \nThe important function to implement when writing an taskpool is the push function. The implementation should start a thread that calls the given function. More involved implementations might want to keep some threads around in a pool because creating and destroying threads is not always the fastest operation. \nIn a next step we need to actually configure the custom taskpool when the fakesrc needs it. For this we intercept the STREAM_STATUS messages with a sync handler. \nNote that this program likely needs root permissions in order to create real time threads. When the thread can t be created the state change function will fail which we catch in the application above. \nWhen there are multiple threads in the pipeline you will receive multiple STREAM_STATUS messages. You should use the owner of the message which is likely the pad or the element that starts the thread to figure out what the function of this thread is in the context of the application. \nWe have seen that threads are created by elements but it is also possible to insert elements in the pipeline for the sole purpose of forcing a new thread in the pipeline. \nThere are several reasons to force the use of threads. However for performance reasons you never want to use one thread for every element out there since that will create some overhead. Let s now list some situations where threads can be particularly useful \nData buffering for example when dealing with network streams or when recording data from a live stream such as a video or audio card. Short hickups elsewhere in the pipeline will not cause data loss. See also Stream buffering about network buffering with queue2. \n\nSynchronizing output devices e.g. when playing a stream containing both video and audio data. By using threads for both outputs they will run independently and their synchronization will be better. \n\nAbove we ve mentioned the queue element several times now. A queue is the thread boundary element through which you can force the use of threads. It does so by using a classic provider consumer model as learned in threading classes at universities all around the world. By doing this it acts both as a means to make data throughput between threads threadsafe and it can also act as a buffer. Queues have several GObject properties to be configured for specific uses. For example you can set lower and upper thresholds for the element. If there s less data than the lower threshold default disabled it will block output. If there s more data than the upper threshold it will block input or if configured to do so drop data. \nTo use a queue and therefore force the use of two distinct threads in the pipeline one can simply create a queue element and put this in as part of the pipeline. GStreamer will take care of all threading details internally. \n"});