fragment_downloaded_cb({"url": "application-development/advanced/pipeline-manipulation.html#page-description", "fragment": "Manually adding or removing data from to a pipeline \nChanging format in a PLAYING pipeline \nDynamically changing the pipeline \nChanging elements in a pipeline \nMany people have expressed the wish to use their own sources to inject data into a pipeline. Some people have also expressed the wish to grab the output in a pipeline and take care of the actual output inside their application. While either of these methods are strongly discouraged GStreamer offers support for this. Beware You need to know what you are doing. Since you don t have any support from a base class you need to thoroughly understand state changes and synchronization. If it doesn t work there are a million ways to shoot yourself in the foot. It s always better to simply write a plugin and have the base class manage it. See the Plugin Writer s Guide for more information on this topic. Also see the next section which will explain how to embed plugins statically in your application. \nThere s two possible elements that you can use for the above mentioned purposes. Those are called appsrc an imaginary source and appsink an imaginary sink The same method applies to each of those elements. Here we will discuss how to use those elements to insert using appsrc or grab using appsink data from a pipeline and how to set negotiation. \nBoth appsrc and appsink provide sets of API. One API uses standard GObject action signals and properties. The same API is also available as a regular C api. The C api is more performant but requires you to link to the app library in order to use the elements. \nIt is also possible to dynamically change the format in a pipeline while PLAYING. This can simply be done by changing the caps property on a capsfilter. The capsfilter will send a RECONFIGURE event upstream that will make the upstream element attempt to renegotiate a new format and allocator. This only works if the upstream element is not using fixed caps on the source pad. \nBelow is an example of how you can change the caps of a pipeline while in the PLAYING state \nNote how we use gst_bus_poll with a small timeout to get messages and also introduce a short sleep. \nIt is possible to set multiple caps for the capsfilter separated with a The capsfilter will try to renegotiate to the first possible format from the list. \nIn this section we talk about some techniques for dynamically modifying the pipeline. We are talking specifically about changing the pipeline while it is in the PLAYING state without interrupting the flow. \nThere are some important things to consider when building dynamic pipelines \nWhen removing elements from the pipeline make sure that there is no dataflow on unlinked pads because that will cause a fatal pipeline error. Always block source pads in push mode or sink pads in pull mode before unlinking pads. See also Changing elements in a pipeline. \nWhen adding elements to a pipeline make sure to put the element into the right state usually the same state as the parent before allowing dataflow the element. When an element is newly created it is in the NULL state and will return an error when it receives data. See also Changing elements in a pipeline. \nWhen adding elements to a pipeline GStreamer will by default set the clock and base time on the element to the current values of the pipeline. This means that the element will be able to construct the same pipeline running time as the other elements in the pipeline. This means that sinks will synchronize buffers like the other sinks in the pipeline and that sources produce buffers with a running time that matches the other sources. \nWhen unlinking elements from an upstream chain always make sure to flush any queued data in the element by sending an EOS event down the element sink pad s and by waiting that the EOS leaves the elements with an event probe \nIf you do not do this you will lose the data which is buffered by the unlinked element. This can result in a simple frame loss one or more video frames several milliseconds of audio However if you remove a muxer and in some cases an encoder or similar elements from the pipeline you risk getting a corrupted file which could not be played properly as some relevant metadata header seek index tables internal sync tags will not be stored or updated properly. \nSee also Changing elements in a pipeline. \nA live source will produce buffers with a running time of the current running time in the pipeline. \nA pipeline without a live source produces buffers with a running time starting from Likewise after a flushing seek those pipelines reset the running time back to \nThe running time can be changed with gst_pad_set_offset It is important to know the running time of the elements in the pipeline in order to maintain synchronization. \nAdding elements might change the state of the pipeline. Adding a non prerolled sink for example brings the pipeline back to the prerolling state. Removing a non prerolled sink for example might change the pipeline to PAUSED and PLAYING state. \nAdding a live source cancels the preroll stage and put the pipeline to the playing state. Adding a live source or other live elements might also change the latency of a pipeline. \nAdding or removing elements to the pipeline might change the clock selection of the pipeline. If the newly added element provides a clock it might be worth changing the clock in the pipeline to the new clock. If on the other hand the element that provides the clock for the pipeline is removed a new clock has to be selected. \nAdding and removing elements might cause upstream or downstream elements to renegotiate caps and or allocators. You don t really need to do anything from the application plugins largely adapt themself to the new pipeline topology in order to optimize their formats and allocation strategy. \nWhat is important is that when you add remove or change elements in the pipeline it is possible that the pipeline needs to negotiate a new format and this can fail. Usually you can fix this by inserting the right converter elements where needed. See also Changing elements in a pipeline. \nGStreamer offers support for doing about any dynamic pipeline modification but it requires you to know a bit of details before you can do this without causing pipeline errors. In the following sections we will demonstrate a couple of typical use cases. \nIn the next example we look at the following chain of elements \nWe want to change element2 by element4 while the pipeline is in the PLAYING state. Let s say that element2 is a visualization and that you want to switch the visualization in the pipeline. \nWe can t just unlink element2 s sinkpad from element1 s source pad because that would leave element1 s source pad unlinked and would cause a streaming error in the pipeline when data is pushed on the source pad. The technique is to block the dataflow from element1 s source pad before we change element2 by element4 and then resume dataflow as shown in the following steps \nBlock element1 s source pad with a blocking pad probe. When the pad is blocked the probe callback will be called. \nInside the block callback nothing is flowing between element1 and element2 and nothing will flow until unblocked. \nUnlink element1 and element2. \nMake sure data is flushed out of element2. Some elements might internally keep some data you need to make sure not to lose data by forcing it out of element2. You can do this by pushing EOS into element2 like this \nPut an event probe on element2 s source pad. \nSend EOS to element2 s sinkpad. This makes sure the all the data inside element2 is forced out. \nWait for the EOS event to appear on element2 s source pad. When the EOS is received drop it and remove the event probe. \nUnlink element2 and element3. You can now also remove element2 from the pipeline and set the state to NULL. \nAdd element4 to the pipeline if not already added. Link element4 and element3. Link element1 and element4. \nMake sure element4 is in the same state as the rest of the elements in the pipeline. It should be at least in the PAUSED state before it can receive buffers and events. \nUnblock element1 s source pad probe. This will let new data into element4 and continue streaming. \nThe above algorithm works when the source pad is blocked i.e. when there is dataflow in the pipeline. If there is no dataflow there is also no point in changing the element just yet so this algorithm can be used in the PAUSED state as well. \nLet show you how this works with an example. This example changes the video effect on a simple pipeline every second. \nNote how we added videoconvert elements before and after the effect. This is needed because some elements might operate in different colorspaces than other elements. By inserting the conversion elements you ensure that the right format can be negotiated at any time. \n"});