fragment_downloaded_cb({"url": "application-development/advanced/pipeline-manipulation.html#inserting-data-with-appsrc", "fragment": "Inserting data with appsrc \nFirst we look at some examples for appsrc which lets you insert data into the pipeline from the application. Appsrc has some configuration options that define how it will operate. You should decide about the following configurations \nWill the appsrc operate in push or pull mode. The stream type property can be used to control this. stream type of random access will activate pull mode scheduling while the other stream types activate push mode. \nThe caps of the buffers that appsrc will push out. This needs to be configured with the caps property. The caps must be set to a fixed caps and will be used to negotiate a format downstream. \nIf the appsrc operates in live mode or not. This can be configured with the is live property. When operating in live mode it is important to configure the min latency and max latency in appsrc. The min latency should be set to the amount of time it takes between capturing a buffer and when it is pushed inside appsrc. In live mode you should timestamp the buffers with the pipeline running time when the first byte of the buffer was captured before feeding them to appsrc. You can let appsrc do the timestaping with the do timestamp property but then the min latency must be set to because it timestamps based on the running time when the buffer entered appsrc \nThe format of the SEGMENT event that appsrc will push. The format has implications for how the running time of the buffers will be calculated so you must be sure you understand this. For live sources you probably want to set the format property to GST_FORMAT_TIME. For non live source it depends on the media type that you are handling. If you plan to timestamp the buffers you should probably put a GST_FORMAT_TIME format otherwise GST_FORMAT_BYTES might be appropriate. \nIf appsrc operates in random access mode it is important to configure the size property of appsrc with the number of bytes in the stream. This will allow downstream elements to know the size of the media and alows them to seek to the end of the stream when needed. \nThe main way of handling data to appsrc is by using the function gst_app_src_push_buffer or by emiting the push buffer action signal. This will put the buffer onto a queue from which appsrc will read from in its streaming thread. It is important to note that data transport will not happen from the thread that performed the push buffer call. \nThe max bytes property controls how much data can be queued in appsrc before appsrc considers the queue full. A filled internal queue will always signal the enough data signal which signals the application that it should stop pushing data into appsrc. The block property will cause appsrc to block the push buffer method until free data becomes available again. \nWhen the internal queue is running out of data the need data signal is emitted which signals the application that it should start pushing more data into appsrc. \nIn addition to the need data and enough data signals appsrc can emit the seek data signal when the stream mode property is set to seekable or random access The signal argument will contain the new desired position in the stream expressed in the unit set with the format property. After receiving the seek data signal the application should push buffers from the new position. \nWhen the last byte is pushed into appsrc you must call gst_app_src_end_of_stream to make it send an EOS downstream. \nThese signals allow the application to operate appsrc in push and pull mode as will be explained next. \n"});