fragment_downloaded_cb({"url": "application-development/advanced/buffering.html#page-description", "fragment": "The purpose of buffering is to accumulate enough data in a pipeline so that playback can occur smoothly and without interruptions. It is typically done when reading from a slow and non live network source but can also be used for live sources. \nGStreamer provides support for the following use cases \nBuffering up to a specific amount of data in memory before starting playback so that network fluctuations are minimized. See Stream buffering. \nDownload of the network file to a local disk with fast seeking in the downloaded data. This is similar to the quicktime youtube players. See Download buffering. \nCaching of semi live streams to a local on disk ringbuffer with seeking in the cached area. This is similar to tivo like timeshifting. See Timeshift buffering. \nGStreamer can provide the application with progress reports about the current buffering state as well as let the application decide on how to buffer and when the buffering stops. \nIn the most simple case the application has to listen for BUFFERING messages on the bus. If the percent indicator inside the BUFFERING message is smaller than the pipeline is buffering. When a message is received with percent buffering is complete. In the buffering state the application should keep the pipeline in the PAUSED state. When buffering completes it can put the pipeline back in the PLAYING state. \nWhat follows is an example of how the message handler could deal with the BUFFERING messages. We will see more advanced methods in Buffering strategies. \nIn this case we are reading from a slow network source into a buffer element such as queue2 \nThe buffer element has a low and high watermark expressed in bytes. The buffer uses the watermarks as follows \nThe buffer element will post BUFFERING messages until the high watermark is hit. This instructs the application to keep the pipeline PAUSED which will eventually block the srcpad from pushing while data is prerolled in the sinks. \nWhen the high watermark is hit a BUFFERING message with will be posted which instructs the application to continue playback. \nWhen during playback the low watermark is hit the queue will start posting BUFFERING messages again making the application PAUSE the pipeline again until the high watermark is hit again. This is called the rebuffering stage. \nDuring playback the queue level will fluctuate between the high and the low watermark as a way to compensate for network irregularities. \nThis buffering method is usable when the demuxer operates in push mode. Seeking in the stream requires the seek to happen in the network source. It is mostly desirable when the total duration of the file is not known such as in live streaming or when efficient seeking is not possible required. \nThe problem is configuring a good low and high watermark. Here are some ideas \nIt is possible to measure the network bandwidth and configure the low high watermarks in such a way that buffering takes a fixed amount of time. \nThe queue2 element in GStreamer core has the max size time property that together with the use rate estimate property does exactly that. Also the playbin buffer duration property uses the rate estimate to scale the amount of data that is buffered. \nBased on the codec bitrate it is also possible to set the watermarks in such a way that a fixed amount of data is buffered before playback starts. Normally the buffering element doesn t know about the bitrate of the stream but it can get this with a query. \nStart with a fixed amount of bytes measure the time between rebuffering and increase the queue size until the time between rebuffering is within the application s chosen limits. \nThe buffering element can be inserted anywhere in the pipeline. You could for example insert the buffering element before a decoder. This would make it possible to set the low high watermarks based on time. \nThe buffering flag on playbin performs buffering on the parsed data. Another advantage of doing the buffering at a later stage is that you can let the demuxer operate in pull mode. When reading data from a slow network drive with filesrc this can be an interesting way to buffer. \nIf we know the server is streaming a fixed length file to the client the application can choose to download the entire file on disk. The buffer element will provide a push or pull based srcpad to the demuxer to navigate in the downloaded file. \nThis mode is only suitable when the client can determine the length of the file on the server. \nIn this case buffering messages will be emitted as usual when the requested range is not within the downloaded area buffersize. The buffering message will also contain an indication that incremental download is being performed. This flag can be used to let the application control the buffering in a more intelligent way using the BUFFERING query for example. See Buffering strategies. \nIn this mode a fixed size ringbuffer is kept to download the server content. This allows for seeking in the buffered data. Depending on the size of the ringbuffer one can seek further back in time. \nThis mode is suitable for all live streams. As with the incremental download mode buffering messages are emitted along with an indication that timeshifting download is in progress. \nIn live pipelines we usually introduce some fixed latency between the capture and the playback elements. This latency can be introduced by a queue such as a jitterbuffer or by other means in the audiosink \nBuffering messages can be emitted in those live pipelines as well and serve as an indication to the user of the latency buffering. The application usually does not react to these buffering messages with a state change. \nWhat follows are some ideas for implementing different buffering strategies based on the buffering messages and buffering query. \nWe would like to buffer enough data in the pipeline so that playback continues without interruptions. What we need to know to implement this is know the total remaining playback time in the file and the total remaining download time. If the buffering time is less than the playback time we can start playback without interruptions. \nWe have all this information available with the DURATION POSITION and BUFFERING queries. We need to periodically execute the buffering query to get the current buffering status. We also need to have a large enough buffer to hold the complete file worst case. It is best to use this buffering strategy with download buffering see Download buffering \nThis is what the code would look like \nSee how we set the pipeline to the PAUSED state first. We will receive buffering messages during the preroll state when buffering is needed. When we are prerolled on_message_async_done we see if buffering is going on if not we start playback. If buffering was going on we start a timeout to poll the buffering state. If the estimated time to download is less than the remaining playback time we start playback. \n"});