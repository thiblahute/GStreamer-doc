fragment_downloaded_cb({"url": "application-development/advanced/buffering.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"buffering.md\">\n        <h1 id=\"buffering\">Buffering</h1>\n<p>The purpose of buffering is to accumulate enough data in a pipeline so\nthat playback can occur smoothly and without interruptions. It is\ntypically done when reading from a (slow) and non-live network source\nbut can also be used for live sources.</p>\n<p>GStreamer provides support for the following use cases:</p>\n<ul>\n<li>\n<p>Buffering up to a specific amount of data, in memory, before\nstarting playback so that network fluctuations are minimized. See\n<a href=\"../../#stream-buffering\">Stream buffering</a>.</p>\n</li>\n<li>\n<p>Download of the network file to a local disk with fast seeking in\nthe downloaded data. This is similar to the quicktime/youtube\nplayers. See <a href=\"../../#download-buffering\">Download buffering</a>.</p>\n</li>\n<li>\n<p>Caching of (semi)-live streams to a local, on disk, ringbuffer with\nseeking in the cached area. This is similar to tivo-like\ntimeshifting. See <a href=\"../../#timeshift-buffering\">Timeshift buffering</a>.</p>\n</li>\n</ul>\n<p>GStreamer can provide the application with progress reports about the\ncurrent buffering state as well as let the application decide on how to\nbuffer and when the buffering stops.</p>\n<p>In the most simple case, the application has to listen for BUFFERING\nmessages on the bus. If the percent indicator inside the BUFFERING\nmessage is smaller than 100, the pipeline is buffering. When a message\nis received with 100 percent, buffering is complete. In the buffering\nstate, the application should keep the pipeline in the PAUSED state.\nWhen buffering completes, it can put the pipeline (back) in the PLAYING\nstate.</p>\n<p>What follows is an example of how the message handler could deal with\nthe BUFFERING messages. We will see more advanced methods in <a href=\"../../#buffering-strategies\">Buffering\nstrategies</a>.</p>\n<pre><code class=\"language-c\">\n  [...]\n\n  switch (GST_MESSAGE_TYPE (message)) {\n    case GST_MESSAGE_BUFFERING:{\n      gint percent;\n\n      /* no state management needed for live pipelines */\n      if (is_live)\n        break;\n\n      gst_message_parse_buffering (message, &amp;percent);\n\n      if (percent == 100) {\n        /* a 100% message means buffering is done */\n        buffering = FALSE;\n        /* if the desired state is playing, go back */\n        if (target_state == GST_STATE_PLAYING) {\n          gst_element_set_state (pipeline, GST_STATE_PLAYING);\n        }\n      } else {\n        /* buffering busy */\n        if (!buffering &amp;&amp; target_state == GST_STATE_PLAYING) {\n          /* we were not buffering but PLAYING, PAUSE  the pipeline. */\n          gst_element_set_state (pipeline, GST_STATE_PAUSED);\n        }\n        buffering = TRUE;\n      }\n      break;\n    case ...\n\n  [...]\n\n\n</code></pre>\n<h2 id=\"stream-buffering\">Stream buffering</h2>\n<pre><code>      +---------+     +---------+     +-------+\n      | httpsrc |     | buffer  |     | demux |\n      |        src - sink      src - sink     ....\n      +---------+     +---------+     +-------+\n\n</code></pre>\n<p>In this case we are reading from a slow network source into a buffer\nelement (such as queue2).</p>\n<p>The buffer element has a low and high watermark expressed in bytes. The\nbuffer uses the watermarks as follows:</p>\n<ul>\n<li>\n<p>The buffer element will post BUFFERING messages until the high\nwatermark is hit. This instructs the application to keep the\npipeline PAUSED, which will eventually block the srcpad from pushing\nwhile data is prerolled in the sinks.</p>\n</li>\n<li>\n<p>When the high watermark is hit, a BUFFERING message with 100% will\nbe posted, which instructs the application to continue playback.</p>\n</li>\n<li>\n<p>When during playback, the low watermark is hit, the queue will start\nposting BUFFERING messages again, making the application PAUSE the\npipeline again until the high watermark is hit again. This is called\nthe rebuffering stage.</p>\n</li>\n<li>\n<p>During playback, the queue level will fluctuate between the high and\nthe low watermark as a way to compensate for network irregularities.</p>\n</li>\n</ul>\n<p>This buffering method is usable when the demuxer operates in push mode.\nSeeking in the stream requires the seek to happen in the network source.\nIt is mostly desirable when the total duration of the file is not known,\nsuch as in live streaming or when efficient seeking is not\npossible/required.</p>\n<p>The problem is configuring a good low and high watermark. Here are some\nideas:</p>\n<ul>\n<li>\n<p>It is possible to measure the network bandwidth and configure the\nlow/high watermarks in such a way that buffering takes a fixed\namount of time.</p>\n<p>The queue2 element in GStreamer core has the max-size-time property\nthat, together with the use-rate-estimate property, does exactly\nthat. Also the playbin buffer-duration property uses the rate\nestimate to scale the amount of data that is buffered.</p>\n</li>\n<li>\n<p>Based on the codec bitrate, it is also possible to set the\nwatermarks in such a way that a fixed amount of data is buffered\nbefore playback starts. Normally, the buffering element doesn't know\nabout the bitrate of the stream but it can get this with a query.</p>\n</li>\n<li>\n<p>Start with a fixed amount of bytes, measure the time between\nrebuffering and increase the queue size until the time between\nrebuffering is within the application's chosen limits.</p>\n</li>\n</ul>\n<p>The buffering element can be inserted anywhere in the pipeline. You\ncould, for example, insert the buffering element before a decoder. This\nwould make it possible to set the low/high watermarks based on time.</p>\n<p>The buffering flag on playbin, performs buffering on the parsed data.\nAnother advantage of doing the buffering at a later stage is that you\ncan let the demuxer operate in pull mode. When reading data from a slow\nnetwork drive (with filesrc) this can be an interesting way to buffer.</p>\n<h2 id=\"download-buffering\">Download buffering</h2>\n<pre><code>      +---------+     +---------+     +-------+\n      | httpsrc |     | buffer  |     | demux |\n      |        src - sink      src - sink     ....\n      +---------+     +----|----+     +-------+\n                           V\n                          file\n\n</code></pre>\n<p>If we know the server is streaming a fixed length file to the client,\nthe application can choose to download the entire file on disk. The\nbuffer element will provide a push or pull based srcpad to the demuxer\nto navigate in the downloaded file.</p>\n<p>This mode is only suitable when the client can determine the length of\nthe file on the server.</p>\n<p>In this case, buffering messages will be emitted as usual when the\nrequested range is not within the downloaded area + buffersize. The\nbuffering message will also contain an indication that incremental\ndownload is being performed. This flag can be used to let the\napplication control the buffering in a more intelligent way, using the\nBUFFERING query, for example. See <a href=\"../../#buffering-strategies\">Buffering\nstrategies</a>.</p>\n<h2 id=\"timeshift-buffering\">Timeshift buffering</h2>\n<pre><code>      +---------+     +---------+     +-------+\n      | httpsrc |     | buffer  |     | demux |\n      |        src - sink      src - sink     ....\n      +---------+     +----|----+     +-------+\n                           V\n                       file-ringbuffer\n\n</code></pre>\n<p>In this mode, a fixed size ringbuffer is kept to download the server\ncontent. This allows for seeking in the buffered data. Depending on the\nsize of the ringbuffer one can seek further back in time.</p>\n<p>This mode is suitable for all live streams. As with the incremental\ndownload mode, buffering messages are emitted along with an indication\nthat timeshifting download is in progress.</p>\n<h2 id=\"live-buffering\">Live buffering</h2>\n<p>In live pipelines we usually introduce some fixed latency between the\ncapture and the playback elements. This latency can be introduced by a\nqueue (such as a jitterbuffer) or by other means (in the audiosink).</p>\n<p>Buffering messages can be emitted in those live pipelines as well and\nserve as an indication to the user of the latency buffering. The\napplication usually does not react to these buffering messages with a\nstate change.</p>\n<h2 id=\"buffering-strategies\">Buffering strategies</h2>\n<p>What follows are some ideas for implementing different buffering\nstrategies based on the buffering messages and buffering query.</p>\n<h3 id=\"norebuffer-strategy\">No-rebuffer strategy</h3>\n<p>We would like to buffer enough data in the pipeline so that playback\ncontinues without interruptions. What we need to know to implement this\nis know the total remaining playback time in the file and the total\nremaining download time. If the buffering time is less than the playback\ntime, we can start playback without interruptions.</p>\n<p>We have all this information available with the DURATION, POSITION and\nBUFFERING queries. We need to periodically execute the buffering query\nto get the current buffering status. We also need to have a large enough\nbuffer to hold the complete file, worst case. It is best to use this\nbuffering strategy with download buffering (see <a href=\"../../#download-buffering\">Download\nbuffering</a>).</p>\n<p>This is what the code would look like:</p>\n<pre><code class=\"language-c\">\n\n#include &lt;gst/gst.h&gt;\n\nGstState target_state;\nstatic gboolean is_live;\nstatic gboolean is_buffering;\n\nstatic gboolean\nbuffer_timeout (gpointer data)\n{\n  GstElement *pipeline = data;\n  GstQuery *query;\n  gboolean busy;\n  gint percent;\n  gint64 estimated_total;\n  gint64 position, duration;\n  guint64 play_left;\n\n  query = gst_query_new_buffering (GST_FORMAT_TIME);\n\n  if (!gst_element_query (pipeline, query))\n    return TRUE;\n\n  gst_query_parse_buffering_percent (query, &amp;busy, &amp;percent);\n  gst_query_parse_buffering_range (query, NULL, NULL, NULL, &amp;estimated_total);\n\n  if (estimated_total == -1)\n    estimated_total = 0;\n\n  /* calculate the remaining playback time */\n  if (!gst_element_query_position (pipeline, GST_FORMAT_TIME, &amp;position))\n    position = -1;\n  if (!gst_element_query_duration (pipeline, GST_FORMAT_TIME, &amp;duration))\n    duration = -1;\n\n  if (duration != -1 &amp;&amp; position != -1)\n    play_left = GST_TIME_AS_MSECONDS (duration - position);\n  else\n    play_left = 0;\n\n  g_message (\"play_left %\" G_GUINT64_FORMAT\", estimated_total %\" G_GUINT64_FORMAT\n      \", percent %d\", play_left, estimated_total, percent);\n\n  /* we are buffering or the estimated download time is bigger than the\n   * remaining playback time. We keep buffering. */\n  is_buffering = (busy || estimated_total * 1.1 &gt; play_left);\n\n  if (!is_buffering)\n    gst_element_set_state (pipeline, target_state);\n\n  return is_buffering;\n}\n\nstatic void\non_message_buffering (GstBus *bus, GstMessage *message, gpointer user_data)\n{\n  GstElement *pipeline = user_data;\n  gint percent;\n\n  /* no state management needed for live pipelines */\n  if (is_live)\n    return;\n\n  gst_message_parse_buffering (message, &amp;percent);\n\n  if (percent &lt; 100) {\n    /* buffering busy */\n    if (!is_buffering) {\n      is_buffering = TRUE;\n      if (target_state == GST_STATE_PLAYING) {\n        /* we were not buffering but PLAYING, PAUSE  the pipeline. */\n        gst_element_set_state (pipeline, GST_STATE_PAUSED);\n      }\n    }\n  }\n}\n\nstatic void\non_message_async_done (GstBus *bus, GstMessage *message, gpointer user_data)\n{\n  GstElement *pipeline = user_data;\n\n  if (!is_buffering)\n    gst_element_set_state (pipeline, target_state);\n  else\n    g_timeout_add (500, buffer_timeout, pipeline);\n}\n\ngint\nmain (gint   argc,\n      gchar *argv[])\n{\n  GstElement *pipeline;\n  GMainLoop *loop;\n  GstBus *bus;\n  GstStateChangeReturn ret;\n\n  /* init GStreamer */\n  gst_init (&amp;amp;argc, &amp;amp;argv);\n  loop = g_main_loop_new (NULL, FALSE);\n\n  /* make sure we have a URI */\n  if (argc != 2) {\n    g_print (\"Usage: %s &amp;lt;URI&amp;gt;\\n\", argv[0]);\n    return -1;\n  }\n\n  /* set up */\n  pipeline = gst_element_factory_make (\"playbin\", \"pipeline\");\n  g_object_set (G_OBJECT (pipeline), \"uri\", argv[1], NULL);\n  g_object_set (G_OBJECT (pipeline), \"flags\", 0x697 , NULL);\n\n  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));\n  gst_bus_add_signal_watch (bus);\n\n  g_signal_connect (bus, \"message::buffering\",\n    (GCallback) on_message_buffering, pipeline);\n  g_signal_connect (bus, \"message::async-done\",\n    (GCallback) on_message_async_done, pipeline);\n  gst_object_unref (bus);\n\n  is_buffering = FALSE;\n  target_state = GST_STATE_PLAYING;\n  ret = gst_element_set_state (pipeline, GST_STATE_PAUSED);\n\n  switch (ret) {\n    case GST_STATE_CHANGE_SUCCESS:\n      is_live = FALSE;\n      break;\n\n    case GST_STATE_CHANGE_FAILURE:\n      g_warning (\"failed to PAUSE\");\n      return -1;\n\n    case GST_STATE_CHANGE_NO_PREROLL:\n      is_live = TRUE;\n      break;\n\n    default:\n      break;\n  }\n\n  /* now run */\n  g_main_loop_run (loop);\n\n  /* also clean up */\n  gst_element_set_state (pipeline, GST_STATE_NULL);\n  gst_object_unref (GST_OBJECT (pipeline));\n  g_main_loop_unref (loop);\n\n  return 0;\n}\n\n\n\n</code></pre>\n<p>See how we set the pipeline to the PAUSED state first. We will receive\nbuffering messages during the preroll state when buffering is needed.\nWhen we are prerolled (on_message_async_done) we see if buffering is\ngoing on, if not, we start playback. If buffering was going on, we start\na timeout to poll the buffering state. If the estimated time to download\nis less than the remaining playback time, we start playback.</p>\n\n        \n\n    </div>\n\n\n        "});