fragment_downloaded_cb({"url": "application-development/appendix/porting.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"porting.md\">\n<h1 id=\"porting-08-applications-to-010\">Porting 0.8 applications to 0.10</h1>\n<p>This section of the appendix will discuss shortly what changes to\napplications will be needed to quickly and conveniently port most\napplications from GStreamer-0.8 to GStreamer-0.10, with references to\nthe relevant sections in this Application Development Manual where\nneeded. With this list, it should be possible to port simple\napplications to GStreamer-0.10 in less than a day.</p>\n<h2 id=\"list-of-changes\">List of changes</h2>\n<ul>\n<li>\n<p>Most functions returning an object or an object property have been\nchanged to return its own reference rather than a constant reference\nof the one owned by the object itself. The reason for this change is\nprimarily thread safety. This means, effectively, that return values\nof functions such as <code>gst_element_get_pad ()</code>, <code>gst_pad_get_name ()</code>\nand many more like these have to be free'ed or unreferenced after\nuse. Check the API references of each function to know for sure\nwhether return values should be free'ed or not. It is important that\nall objects derived from GstObject are ref'ed/unref'ed using\ngst_object_ref() and gst_object_unref() respectively (instead of\ng_object_ref/unref).</p>\n</li>\n<li>\n<p>Applications should no longer use signal handlers to be notified of\nerrors, end-of-stream and other similar pipeline events. Instead,\nthey should use the <code>GstBus</code>, which has been discussed in\n<a href=\"../basics/bus.html\">Bus</a>. The bus will take care that the messages will\nbe delivered in the context of a main loop, which is almost\ncertainly the application's main thread. The big advantage of this\nis that applications no longer need to be thread-aware; they don't\nneed to use <code>g_idle_add ()</code> in the signal handler and do the actual\nreal work in the idle-callback. GStreamer now does all that internally.</p>\n</li>\n<li>\n<p>Related to this, <code>gst_bin_iterate ()</code> has been removed. Pipelines\nwill iterate in their own thread, and applications can simply run a\n<code>GMainLoop</code> (or call the mainloop of their UI toolkit, such as\n<code>gtk_main ()</code>).</p>\n</li>\n<li>\n<p>State changes can be delayed (ASYNC). Due to the new fully threaded\nnature of GStreamer-0.10, state changes are not always immediate, in\nparticular changes including the transition from READY to PAUSED\nstate. This means two things in the context of porting applications:\nfirst of all, it is no longer always possible to do\n<code>gst_element_set_state ()</code> and check for a return value of\nGST_STATE_CHANGE_SUCCESS, as the state change might be delayed\n(ASYNC) and the result will not be known until later. You should\nstill check for GST_STATE_CHANGE_FAILURE right away, it is just\nno longer possible to assume that everything that is not SUCCESS\nmeans failure. Secondly, state changes might not be immediate, so\nyour code needs to take that into account. You can wait for a state\nchange to complete if you use GST_CLOCK_TIME_NONE as timeout\ninterval with <code>gst_element_get_state ()</code>.</p>\n</li>\n<li>\n<p>In 0.8, events and queries had to manually be sent to sinks in\npipelines (unless you were using playbin). This is no longer the\ncase in 0.10. In 0.10, queries and events can be sent to toplevel\npipelines, and the pipeline will do the dispatching internally for\nyou. This means less bookkeeping in your application. For a short\ncode example, see [Position tracking and seeking][queries-and-events].\nRelated, seeking is now threadsafe, and your video output will show the new\nvideo position's frame while seeking, providing a better user experience.</p>\n</li>\n<li>\n<p>The <code>GstThread</code> object has been removed. Applications can now simply\nput elements in a pipeline with optionally some \u201cqueue\u201d elements in\nbetween for buffering, and GStreamer will take care of creating\nthreads internally. It is still possible to have parts of a pipeline\nrun in different threads than others, by using the \u201cqueue\u201d element.\nSee <a href=\"../advanced/threads.html\">Threads</a> for details.</p>\n</li>\n<li>\n<p>Filtered caps -&gt; capsfilter element (the pipeline syntax for\ngst-launch has not changed though).</p>\n</li>\n<li>\n<p>libgstgconf-0.10.la does not exist. Use the \u201cgconfvideosink\u201d and\n\u201cgconfaudiosink\u201d elements instead, which will do live-updates and\nrequire no library linking.</p>\n</li>\n<li>\n<p>The \u201cnew-pad\u201d and \u201cstate-change\u201d signals on <code>GstElement</code> were\nrenamed to \u201cpad-added\u201d and \u201cstate-changed\u201d.</p>\n</li>\n<li>\n<p><code>gst_init_get_popt_table ()</code> has been removed in favour of the new\nGOption command line option API that was added to GLib 2.6.\n<code>gst_init_get_option_group ()</code> is the new GOption-based equivalent\nto <code>gst_init_get_ptop_table ()</code>.</p>\n</li>\n</ul>\n\n</div>\n\n\n\t"});