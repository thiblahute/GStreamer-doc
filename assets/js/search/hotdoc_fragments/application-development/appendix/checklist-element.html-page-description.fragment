fragment_downloaded_cb({"url": "application-development/appendix/checklist-element.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"checklist-element.md\">\n        <h1 id=\"things-to-check-when-writing-an-application\">Things to check when writing an application</h1>\n<p>This chapter contains a fairly random selection of things that can be\nuseful to keep in mind when writing GStreamer-based applications. It's\nup to you how much you're going to use the information provided here. We\nwill shortly discuss how to debug pipeline problems using GStreamer\napplications. Also, we will touch upon how to acquire knowledge about\nplugins and elements and how to test simple pipelines before building\napplications around them.</p>\n<h2 id=\"good-programming-habits\">Good programming habits</h2>\n<ul>\n<li>\n<p>Always add a <code>GstBus</code> handler to your pipeline. Always report errors\nin your application, and try to do something with warnings and\ninformation messages, too.</p>\n</li>\n<li>\n<p>Always check return values of GStreamer functions. Especially, check\nreturn values of <code>gst_element_link ()</code> and <code>gst_element_set_state ()</code>.</p>\n</li>\n<li>\n<p>Dereference return values of all functions returning a non-base\ntype, such as <code>gst_element_get_pad ()</code>. Also, always free non-const\nstring returns, such as <code>gst_object_get_name ()</code>.</p>\n</li>\n<li>\n<p>Always use your pipeline object to keep track of the current state\nof your pipeline. Don't keep private variables in your application.\nAlso, don't update your user interface if a user presses the \u201cplay\u201d\nbutton. Instead, listen for the \u201cstate-changed\u201d message on the\n<code>GstBus</code> and only update the user interface whenever this message is\nreceived.</p>\n</li>\n<li>\n<p>Report all bugs that you find in GStreamer bugzilla at\n<a href=\"http://bugzilla.gnome.org\">http://bugzilla.gnome.org/</a>.</p>\n</li>\n</ul>\n<h2 id=\"debugging\">Debugging</h2>\n<p>Applications can make use of the extensive GStreamer debugging system to\ndebug pipeline problems. Elements will write output to this system to\nlog what they're doing. It's not used for error reporting, but it is\nvery useful for tracking what an element is doing exactly, which can\ncome in handy when debugging application issues (such as failing seeks,\nout-of-sync media, etc.).</p>\n<p>Most GStreamer-based applications accept the commandline option\n<code>--gst-debug=LIST</code> and related family members. The list consists of a\ncomma-separated list of category/level pairs, which can set the\ndebugging level for a specific debugging category. For example,\n<code>--gst-debug=oggdemux:5</code> would turn on debugging for the Ogg demuxer\nelement. You can use wildcards as well. A debugging level of 0 will turn\noff all debugging, and a level of 9 will turn on all debugging.\nIntermediate values only turn on some debugging (based on message\nseverity; 2, for example, will only display errors and warnings). Here's\na list of all available options:</p>\n<ul>\n<li>\n<p><code>--gst-debug-help</code> will print available debug categories and exit.</p>\n</li>\n<li>\n<p><code>--gst-debug-level=LEVEL</code> will set the default debug level (which\ncan range from 0 (no output) to 9 (everything)).</p>\n</li>\n<li>\n<p><code>--gst-debug=LIST</code> takes a comma-separated list of\ncategory_name:level pairs to set specific levels for the individual\ncategories. Example: <code>GST_AUTOPLUG:5,avidemux:3</code>. Alternatively, you\ncan also set the <code>GST_DEBUG</code> environment variable, which has the\nsame effect.</p>\n</li>\n<li>\n<p><code>--gst-debug-no-color</code> will disable color debugging. You can also\nset the GST_DEBUG_NO_COLOR environment variable to 1 if you want\nto disable colored debug output permanently. Note that if you are\ndisabling color purely to avoid messing up your pager output, try\nusing <code>less -R</code>.</p>\n</li>\n<li>\n<p><code>--gst-debug-color-mode=MODE</code> will change debug log coloring mode.\nMODE can be one of the following: <code>on</code>, <code>off</code>, <code>auto</code>, <code>disable</code>,\n<code>unix</code>. You can also set the GST_DEBUG_COLOR_MODE environment\nvariable if you want to change colored debug output permanently.\nNote that if you are disabling color purely to avoid messing up your\npager output, try using <code>less -R</code>.</p>\n</li>\n<li>\n<p><code>--gst-debug-disable</code> disables debugging altogether.</p>\n</li>\n<li>\n<p><code>--gst-plugin-spew</code> enables printout of errors while loading\nGStreamer plugins.</p>\n</li>\n</ul>\n<h2 id=\"conversion-plugins\">Conversion plugins</h2>\n<p>GStreamer contains a bunch of conversion plugins that most applications\nwill find useful. Specifically, those are videoscalers (videoscale),\ncolorspace convertors (videoconvert), audio format convertors and\nchannel resamplers (audioconvert) and audio samplerate convertors\n(audioresample). Those convertors don't do anything when not required,\nthey will act in passthrough mode. They will activate when the hardware\ndoesn't support a specific request, though. All applications are\nrecommended to use those elements.</p>\n<h2 id=\"utility-applications-provided-with-gstreamer\">Utility applications provided with GStreamer</h2>\n<p>GStreamer comes with a default set of command-line utilities that can\nhelp in application development. We will discuss only <code>gst-launch</code> and\n<code>gst-inspect</code> here.</p>\n<h3 id=\"gstlaunch\"><code>gst-launch</code></h3>\n<p><code>gst-launch</code> is a simple script-like commandline application that can be\nused to test pipelines. For example, the command <code>gst-launch audiotestsrc ! audioconvert ! audio/x-raw,channels=2 ! alsasink</code> will run a pipeline which generates a\nsine-wave audio stream and plays it to your ALSA audio card.\n<code>gst-launch</code> also allows the use of threads (will be used automatically\nas required or as queue elements are inserted in the pipeline) and bins\n(using brackets, so \u201c(\u201d and \u201c)\u201d). You can use dots to imply padnames on\nelements, or even omit the padname to automatically select a pad. Using\nall this, the pipeline <code>gst-launch filesrc location=file.ogg ! oggdemux name=d d. ! queue ! theoradec ! videoconvert ! xvimagesink d. ! queue ! vorbisdec ! audioconvert ! audioresample ! alsasink</code> will play an Ogg file containing a Theora video-stream and a Vorbis\naudio-stream. You can also use autopluggers such as decodebin on the\ncommandline. See the manual page of <code>gst-launch</code> for more information.</p>\n<h3 id=\"gstinspect\"><code>gst-inspect</code></h3>\n<p><code>gst-inspect</code> can be used to inspect all properties, signals, dynamic\nparameters and the object hierarchy of an element. This can be very\nuseful to see which <code>GObject</code> properties or which signals (and using\nwhat arguments) an element supports. Run <code>gst-inspect fakesrc</code> to get an\nidea of what it does. See the manual page of <code>gst-inspect</code> for more\ninformation.</p>\n\n        \n\n    </div>\n\n\n        "});