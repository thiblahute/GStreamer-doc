fragment_downloaded_cb({"url": "application-development/introduction/basics.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"basics.md\">\n<h1 id=\"foundations\">Foundations</h1>\n<p>This chapter of the guide introduces the basic concepts of GStreamer.\nUnderstanding these concepts will be important in reading any of the\nrest of this guide, all of them assume understanding of these basic\nconcepts.</p>\n<h2 id=\"elements\">Elements</h2>\n<p>An <em>element</em> is the most important class of objects in GStreamer. You\nwill usually create a chain of elements linked together and let data\nflow through this chain of elements. An element has one specific\nfunction, which can be the reading of data from a file, decoding of this\ndata or outputting this data to your sound card (or anything else). By\nchaining together several such elements, you create a <em>pipeline</em> that\ncan do a specific task, for example media playback or capture. GStreamer\nships with a large collection of elements by default, making the\ndevelopment of a large variety of media applications possible. If\nneeded, you can also write new elements. That topic is explained in\ngreat deal in the <em>GStreamer Plugin Writer's Guide</em>.</p>\n<h2 id=\"pads\">Pads</h2>\n<p><em>Pads</em> are element's input and output, where you can connect other\nelements. They are used to negotiate links and data flow between\nelements in GStreamer. A pad can be viewed as a \u201cplug\u201d or \u201cport\u201d on an\nelement where links may be made with other elements, and through which\ndata can flow to or from those elements. Pads have specific data\nhandling capabilities: a pad can restrict the type of data that flows\nthrough it. Links are only allowed between two pads when the allowed\ndata types of the two pads are compatible. Data types are negotiated\nbetween pads using a process called <em>caps negotiation</em>. Data types are\ndescribed as a <code>GstCaps</code>.</p>\n<p>An analogy may be helpful here. A pad is similar to a plug or jack on a\nphysical device. Consider, for example, a home theater system consisting\nof an amplifier, a DVD player, and a (silent) video projector. Linking\nthe DVD player to the amplifier is allowed because both devices have\naudio jacks, and linking the projector to the DVD player is allowed\nbecause both devices have compatible video jacks. Links between the\nprojector and the amplifier may not be made because the projector and\namplifier have different types of jacks. Pads in GStreamer serve the\nsame purpose as the jacks in the home theater system.</p>\n<p>For the most part, all data in GStreamer flows one way through a link\nbetween elements. Data flows out of one element through one or more\n<em>source pads</em>, and elements accept incoming data through one or more\n<em>sink pads</em>. Source and sink elements have only source and sink pads,\nrespectively. Data usually means buffers (described by the\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/gstreamer-GstBuffer.html\"><code>GstBuffer</code></a>\nobject) and events (described by the\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/gstreamer-GstEvent.html\"><code>GstEvent</code></a>\nobject).</p>\n<h2 id=\"bins-and-pipelines\">Bins and pipelines</h2>\n<p>A <em>bin</em> is a container for a collection of elements. Since bins are\nsubclasses of elements themselves, you can mostly control a bin as if it\nwere an element, thereby abstracting away a lot of complexity for your\napplication. You can, for example change state on all elements in a bin\nby changing the state of that bin itself. Bins also forward bus messages\nfrom their contained children (such as error messages, tag messages or\nEOS messages).</p>\n<p>A <em>pipeline</em> is a top-level bin. It provides a bus for the application\nand manages the synchronization for its children. As you set it to\nPAUSED or PLAYING state, data flow will start and media processing will\ntake place. Once started, pipelines will run in a separate thread until\nyou stop them or the end of the data stream is reached.</p>\n<p><img src=\"images/simple-player.png\" alt=\"GStreamer pipeline for a simple ogg player\" title=\"fig:\" id=\"gstreamer-pipeline-for-a-simple-ogg-player\"></p>\n<h2 id=\"communication\">Communication</h2>\n<p>GStreamer provides several mechanisms for communication and data\nexchange between the <em>application</em> and the <em>pipeline</em>.</p>\n<ul>\n<li>\n<p><em>buffers</em> are objects for passing streaming data between elements in\nthe pipeline. Buffers always travel from sources to sinks\n(downstream).</p>\n</li>\n<li>\n<p><em>events</em> are objects sent between elements or from the application\nto elements. Events can travel upstream and downstream. Downstream\nevents can be synchronised to the data flow.</p>\n</li>\n<li>\n<p><em>messages</em> are objects posted by elements on the pipeline's message\nbus, where they will be held for collection by the application.\nMessages can be intercepted synchronously from the streaming thread\ncontext of the element posting the message, but are usually handled\nasynchronously by the application from the application's main\nthread. Messages are used to transmit information such as errors,\ntags, state changes, buffering state, redirects etc. from elements\nto the application in a thread-safe way.</p>\n</li>\n<li>\n<p><em>queries</em> allow applications to request information such as duration\nor current playback position from the pipeline. Queries are always\nanswered synchronously. Elements can also use queries to request\ninformation from their peer elements (such as the file size or\nduration). They can be used both ways within a pipeline, but\nupstream queries are more common.</p>\n</li>\n</ul>\n<p><img src=\"images/communication.png\" alt=\"GStreamer pipeline with different communication flows\" title=\"fig:\" id=\"gstreamer-pipeline-with-different-communication-flows\"></p>\n\n</div>\n\n\n        "});