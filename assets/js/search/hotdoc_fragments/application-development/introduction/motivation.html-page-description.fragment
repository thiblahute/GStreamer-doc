fragment_downloaded_cb({"url": "application-development/introduction/motivation.html#page-description", "fragment": "GStreamer provides a clean interface to \nThe application programmer who wants to build a media pipeline. The programmer can use an extensive set of powerful tools to create media pipelines without writing a single line of code. Performing complex media manipulations becomes very easy. \nThe plugin programmer. Plugin programmers are provided a clean and simple API to create self contained plugins. An extensive debugging and tracing mechanism has been integrated. GStreamer also comes with an extensive set of real life plugins that serve as examples too. \nGStreamer adheres to GObject the GLib object model. A programmer familiar with GLib or GTK will be comfortable with GStreamer. \nGStreamer uses the mechanism of signals and object properties. \nAll objects can be queried at runtime for their various properties and capabilities. \nGStreamer intends to be similar in programming methodology to GTK This applies to the object model ownership of objects reference counting etc. \nAll GStreamer Objects can be extended using the GObject inheritance methods. \nAll plugins are loaded dynamically and can be extended and upgraded independently. \nPlugins are shared libraries that are loaded at runtime. Since all the properties of the plugin can be set using the GObject properties there is no need and in fact no way to have any header files installed for the plugins. \nSpecial care has been taken to make plugins completely self contained. All relevant aspects of plugins can be queried at run time. \nHigh performance is obtained by \nusing GLib s GSlice allocator \nextremely light weight links between plugins. Data can travel the pipeline with minimal overhead. Data passing between plugins only involves a pointer dereference in a typical pipeline. \nproviding a mechanism to directly work on the target memory. A plugin can for example directly write to the X server s shared memory space. Buffers can also point to arbitrary memory such as a sound card s internal hardware buffer. \nrefcounting and copy on write minimize usage of memcpy. Sub buffers efficiently split buffers into manageable pieces. \ndedicated streaming threads with scheduling handled by the kernel. \nallowing hardware acceleration by using specialized plugins. \nusing a plugin registry with the specifications of the plugins so that the plugin loading can be delayed until the plugin is actually used. \nThe core of GStreamer is essentially media agnostic. It only knows about bytes and blocks and only contains basic elements. The core of GStreamer is functional enough to even implement low level system tools like cp. \nAll of the media handling functionality is provided by plugins external to the core. These tell the core how to handle specific types of media. \nGStreamer also wants to be an easy framework where codec developers can experiment with different algorithms speeding up the development of open and free multimedia codecs like those developed by the Xiph.Org Foundation such as Theora and Vorbis \n"});