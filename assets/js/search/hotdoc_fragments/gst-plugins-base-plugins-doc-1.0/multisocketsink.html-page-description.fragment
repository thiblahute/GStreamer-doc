fragment_downloaded_cb({"url": "gst-plugins-base-plugins-doc-1.0/multisocketsink.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"multisocketsink\">\n<h1 id=\"multisocketsink\">multisocketsink</h1><p>This plugin writes incoming data to a set of file descriptors. The\nfile descriptors can be added to multisocketsink by emitting the <a href=\"multisocketsink.html#GstMultiSocketSink::add\">add</a> signal.\nFor each descriptor added, the <a href=\"multisocketsink.html#GstMultiSocketSink::client-added\">client-added</a> signal will be called.</p>\n<p>A client can also be added with the <a href=\"multisocketsink.html#GstMultiSocketSink::add-full\">add-full</a> signal\nthat allows for more control over what and how much data a client\ninitially receives.</p>\n<p>Clients can be removed from multisocketsink by emitting the <a href=\"multisocketsink.html#GstMultiSocketSink::remove\">remove</a> signal. For\neach descriptor removed, the <a href=\"multisocketsink.html#GstMultiSocketSink::client-removed\">client-removed</a> signal will be called. The\n<a href=\"multisocketsink.html#GstMultiSocketSink::client-removed\">client-removed</a> signal can also be fired when multisocketsink decides that a\nclient is not active anymore or, depending on the value of the\nGstMultiSocketSink:recover-policy property, if the client is reading too slowly.\nIn all cases, multisocketsink will never close a file descriptor itself.\nThe user of multisocketsink is responsible for closing all file descriptors.\nThis can for example be done in response to the GstMultiSocketSink::client-fd-removed signal.\nNote that multisocketsink still has a reference to the file descriptor when the\n<a href=\"multisocketsink.html#GstMultiSocketSink::client-removed\">client-removed</a> signal is emitted, so that \"get-stats\" can be performed on\nthe descriptor; it is therefore not safe to close the file descriptor in\nthe <a href=\"multisocketsink.html#GstMultiSocketSink::client-removed\">client-removed</a> signal handler, and you should use the\nGstMultiSocketSink::client-fd-removed signal to safely close the fd.</p>\n<p>Multisocketsink internally keeps a queue of the incoming buffers and uses a\nseparate thread to send the buffers to the clients. This ensures that no\nclient write can block the pipeline and that clients can read with different\nspeeds.</p>\n<p>When adding a client to multisocketsink, the GstMultiSocketSink:sync-method property will define\nwhich buffer in the queued buffers will be sent first to the client. Clients\ncan be sent the most recent buffer (which might not be decodable by the\nclient if it is not a keyframe), the next keyframe received in\nmultisocketsink (which can take some time depending on the keyframe rate), or the\nlast received keyframe (which will cause a simple burst-on-connect).\nMultisocketsink will always keep at least one keyframe in its internal buffers\nwhen the sync-mode is set to latest-keyframe.</p>\n<p>There are additional values for the GstMultiSocketSink:sync-method\nproperty to allow finer control over burst-on-connect behaviour. By selecting\nthe 'burst' method a minimum burst size can be chosen, 'burst-keyframe'\nadditionally requires that the burst begin with a keyframe, and\n'burst-with-keyframe' attempts to burst beginning with a keyframe, but will\nprefer a minimum burst size even if it requires not starting with a keyframe.</p>\n<p>Multisocketsink can be instructed to keep at least a minimum amount of data\nexpressed in time or byte units in its internal queues with the\nGstMultiSocketSink:time-min and GstMultiSocketSink:bytes-min properties respectively.\nThese properties are useful if the application adds clients with the\n<a href=\"multisocketsink.html#GstMultiSocketSink::add-full\">add-full</a> signal to make sure that a burst connect can\nactually be honored.</p>\n<p>When streaming data, clients are allowed to read at a different rate than\nthe rate at which multisocketsink receives data. If the client is reading too\nfast, no data will be send to the client until multisocketsink receives more\ndata. If the client, however, reads too slowly, data for that client will be\nqueued up in multisocketsink. Two properties control the amount of data\n(buffers) that is queued in multisocketsink: GstMultiSocketSink:buffers-max and\nGstMultiSocketSink:buffers-soft-max. A client that falls behind by\nGstMultiSocketSink:buffers-max is removed from multisocketsink forcibly.</p>\n<p>A client with a lag of at least GstMultiSocketSink:buffers-soft-max enters the recovery\nprocedure which is controlled with the GstMultiSocketSink:recover-policy property.\nA recover policy of NONE will do nothing, RESYNC_LATEST will send the most recently\nreceived buffer as the next buffer for the client, RESYNC_SOFT_LIMIT\npositions the client to the soft limit in the buffer queue and\nRESYNC_KEYFRAME positions the client at the most recent keyframe in the\nbuffer queue.</p>\n<p>multisocketsink will by default synchronize on the clock before serving the\nbuffers to the clients. This behaviour can be disabled by setting the sync\nproperty to FALSE. Multisocketsink will by default not do QoS and will never\ndrop late buffers.</p>\n\n</div>\n\n\n"});