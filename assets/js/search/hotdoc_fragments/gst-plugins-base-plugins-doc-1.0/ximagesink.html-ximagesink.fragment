fragment_downloaded_cb({"url": "gst-plugins-base-plugins-doc-1.0/ximagesink.html#ximagesink", "fragment": "<div class=\"base_symbol_container\" data-hotdoc-tags=\"\" id=\"ximagesink\">\n\t\t<h3 id=\"ximagesink2\">\n\tximagesink\n</h3>\n\n\t\t<div class=\"hierarchy_container\">\n\t<div class=\"hierarchy_details\">\n<pre>\n<a title=\"GObject\" href=\"https://developer.gnome.org/gobject/unstable/gobject-The-Base-Object-Type.html#GObject-struct\">GObject</a>\n    <span class=\"lineart\">\u2570\u2500\u2500</span><a title=\"GInitiallyUnowned\" href=\"https://developer.gnome.org/gobject/unstable/gobject-The-Base-Object-Type.html#GInitiallyUnowned\">GInitiallyUnowned</a>\n        <span class=\"lineart\">\u2570\u2500\u2500</span><a title=\"GstObject\" href=\"../libgstreamer-doc-1.0/c/gstobject.html#GstObject\">GstObject</a>\n            <span class=\"lineart\">\u2570\u2500\u2500</span><a title=\"GstElement\" href=\"../libgstreamer-doc-1.0/c/gstelement.html#GstElement\">GstElement</a>\n                <span class=\"lineart\">\u2570\u2500\u2500</span><a title=\"GstBaseSink\" href=\"../libgstbase-doc-1.0/c/gstbasesink.html#GstBaseSink\">GstBaseSink</a>\n                    <span class=\"lineart\">\u2570\u2500\u2500</span><a title=\"GstVideoSink\" href=\"../gst-plugins-base-video-doc-1.0/c/gstvideosink.html#GstVideoSink\">GstVideoSink</a>\n                        <span class=\"lineart\">\u2570\u2500\u2500</span>ximagesink\n</pre>\n\n</div>\n\n</div>\n\n<div class=\"class_details\">\n\t<p>XImageSink renders video frames to a drawable (XWindow) on a local or remote\ndisplay. This element can receive a Window ID from the application through\nthe <a href=\"../gst-plugins-base-video-doc-1.0/c/videooverlay.html#GstVideoOverlay\">GstVideoOverlay</a> interface and will then render video frames in this\ndrawable. If no Window ID was provided by the application, the element will\ncreate its own internal window and render into it.</p>\n<h2 id=\"scaling1\">Scaling</h2>\n<p>As standard XImage rendering to a drawable is not scaled, XImageSink will use\nreverse caps negotiation to try to get scaled video frames for the drawable.\nThis is accomplished by asking the peer pad if it accepts some different caps\nwhich in most cases implies that there is a scaling element in the pipeline,\nor that an element generating the video frames can generate them with a\ndifferent geometry. This mechanism is handled during buffer allocations, for\neach allocation request the video sink will check the drawable geometry, look\nat the <a href=\"ximagesink.html#GstXImageSink:force-aspect-ratio\">force-aspect-ratio</a> property, calculate the geometry of\ndesired video frames and then check that the peer pad accept those new caps.\nIf it does it will then allocate a buffer in video memory with this new\ngeometry and return it with the new caps.</p>\n<h2 id=\"events1\">Events</h2>\n<p>XImageSink creates a thread to handle events coming from the drawable. There\nare several kind of events that can be grouped in 2 big categories: input\nevents and window state related events. Input events will be translated to\nnavigation events and pushed upstream for other elements to react on them.\nThis includes events such as pointer moves, key press/release, clicks etc...\nOther events are used to handle the drawable appearance even when the data\nis not flowing (GST_STATE_PAUSED). That means that even when the element is\npaused, it will receive expose events from the drawable and draw the latest\nframe with correct borders/aspect-ratio.</p>\n<h2 id=\"pixel-aspect-ratio1\">Pixel aspect ratio</h2>\n<p>When changing state to GST_STATE_READY, XImageSink will open a connection to\nthe display specified in the <a href=\"ximagesink.html#GstXImageSink:display\">display</a> property or the default\ndisplay if nothing specified. Once this connection is open it will inspect\nthe display configuration including the physical display geometry and\nthen calculate the pixel aspect ratio. When caps negotiation will occur, the\nvideo sink will set the calculated pixel aspect ratio on the caps to make\nsure that incoming video frames will have the correct pixel aspect ratio for\nthis display. Sometimes the calculated pixel aspect ratio can be wrong, it is\nthen possible to enforce a specific pixel aspect ratio using the\n<a href=\"ximagesink.html#GstXImageSink:pixel-aspect-ratio\">pixel-aspect-ratio</a> property.</p>\n<h2 id=\"examples1\">Examples</h2>\n<pre><code>gst-launch-1.0 -v videotestsrc ! queue ! ximagesink\n</code></pre>\n<p>A pipeline to test reverse negotiation. When the test video signal appears\nyou can resize the window and see that scaled buffers of the desired size are\ngoing to arrive with a short delay. This illustrates how buffers of desired\nsize are allocated along the way. If you take away the queue, scaling will\nhappen almost immediately.</p>\n<pre><code>gst-launch-1.0 -v videotestsrc ! navigationtest ! videoconvert ! ximagesink\n</code></pre>\n<p>A pipeline to test navigation events.\nWhile moving the mouse pointer over the test signal you will see a black box\nfollowing the mouse pointer. If you press the mouse button somewhere on the\nvideo and release it somewhere else a green box will appear where you pressed\nthe button and a red one where you released it. (The navigationtest element\nis part of gst-plugins-good.)</p>\n<pre><code>gst-launch-1.0 -v videotestsrc ! video/x-raw, pixel-aspect-ratio=(fraction)4/3 ! videoscale ! ximagesink\n</code></pre>\n<p>This is faking a 4/3 pixel aspect ratio caps on video frames produced by\nvideotestsrc, in most cases the pixel aspect ratio of the display will be\n1/1. This means that videoscale will have to do the scaling to convert\nincoming frames to a size that will match the display pixel aspect ratio\n(from 320x240 to 320x180 in this case). Note that you might have to escape\nsome characters for your shell like '(fraction)'.</p>\n\n</div>\n\n</div>\n\n\n"});