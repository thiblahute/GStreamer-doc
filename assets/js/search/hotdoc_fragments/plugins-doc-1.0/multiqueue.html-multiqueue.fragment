fragment_downloaded_cb({"url": "plugins-doc-1.0/multiqueue.html#multiqueue", "fragment": "<div class=\"base_symbol_container\" data-hotdoc-tags=\"\" id=\"multiqueue\">\n\t\t<h3 id=\"multiqueue2\">\n\tmultiqueue\n</h3>\n\n\t\t<div class=\"hierarchy_container\">\n\t<div class=\"hierarchy_details\">\n<pre>\n<a title=\"GObject\" href=\"https://developer.gnome.org/gobject/unstable/gobject-The-Base-Object-Type.html#GObject-struct\">GObject</a>\n    <span class=\"lineart\">\u2570\u2500\u2500</span><a title=\"GInitiallyUnowned\" href=\"https://developer.gnome.org/gobject/unstable/gobject-The-Base-Object-Type.html#GInitiallyUnowned\">GInitiallyUnowned</a>\n        <span class=\"lineart\">\u2570\u2500\u2500</span><a title=\"GstObject\" href=\"../libgstreamer-doc-1.0/c/gstobject.html#GstObject\">GstObject</a>\n            <span class=\"lineart\">\u2570\u2500\u2500</span><a title=\"GstElement\" href=\"../libgstreamer-doc-1.0/c/gstelement.html#GstElement\">GstElement</a>\n                <span class=\"lineart\">\u2570\u2500\u2500</span>multiqueue\n</pre>\n\n</div>\n\n</div>\n\n<div class=\"class_details\">\n\t<p>Multiqueue is similar to a normal <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer-plugins/html/gstreamer-plugins-queue.html#GstQueue-struct\">GstQueue</a> with the following additional\nfeatures:</p>\n<ol>\n<li>Multiple streamhandling</li>\n</ol>\n<ul>\n<li>The element handles queueing data on more than one stream at once. To\nachieve such a feature it has request sink pads (sink%u) and\n'sometimes' src pads (src%u). When requesting a given sinkpad with <a href=\"../libgstreamer-doc-1.0/c/gstelement.html#gst_element_request_pad\">gst_element_request_pad</a>,\nthe associated srcpad for that stream will be created.\nExample: requesting sink1 will generate src1.</li>\n</ul>\n<ol start=\"2\">\n<li>Non-starvation on multiple stream</li>\n</ol>\n<ul>\n<li>If more than one stream is used with the element, the streams' queues\nwill be dynamically grown (up to a limit), in order to ensure that no\nstream is risking data starvation. This guarantees that at any given\ntime there are at least N bytes queued and available for each individual\nstream. If an EOS event comes through a srcpad, the associated queue will be\nconsidered as 'not-empty' in the queue-size-growing algorithm.</li>\n</ul>\n<ol start=\"3\">\n<li>Non-linked srcpads graceful handling</li>\n</ol>\n<ul>\n<li>In order to better support dynamic switching between streams, the multiqueue\n(unlike the current GStreamer queue) continues to push buffers on non-linked\npads rather than shutting down. In addition, to prevent a non-linked stream from very quickly consuming all\navailable buffers and thus 'racing ahead' of the other streams, the element\nmust ensure that buffers and inlined events for a non-linked stream are pushed\nin the same order as they were received, relative to the other streams\ncontrolled by the element. This means that a buffer cannot be pushed to a\nnon-linked pad any sooner than buffers in any other stream which were received\nbefore it.</li>\n</ul>\n<p>Data is queued until one of the limits specified by the\n<a href=\"multiqueue.html#GstMultiQueue:max-size-buffers\">max-size-buffers</a>, <a href=\"multiqueue.html#GstMultiQueue:max-size-bytes\">max-size-bytes</a> and/or\n<a href=\"multiqueue.html#GstMultiQueue:max-size-time\">max-size-time</a> properties has been reached. Any attempt to push\nmore buffers into the queue will block the pushing thread until more space\nbecomes available. <a href=\"multiqueue.html#GstMultiQueue:extra-size-buffers\">extra-size-buffers</a>,</p>\n<p><a href=\"multiqueue.html#GstMultiQueue:extra-size-bytes\">extra-size-bytes</a> and <a href=\"multiqueue.html#GstMultiQueue:extra-size-time\">extra-size-time</a> are\ncurrently unused.</p>\n<p>The default queue size limits are 5 buffers, 10MB of data, or\ntwo second worth of data, whichever is reached first. Note that the number\nof buffers will dynamically grow depending on the fill level of\nother queues.</p>\n<p>The <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer-plugins/html/gstreamer-plugins-multiqueue.html#GstMultiQueue-underrun\">GstMultiQueue::underrun</a> signal is emitted when all of the queues\nare empty. The <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer-plugins/html/gstreamer-plugins-multiqueue.html#GstMultiQueue-overrun\">GstMultiQueue::overrun</a> signal is emitted when one of the\nqueues is filled.\nBoth signals are emitted from the context of the streaming thread.</p>\n<p>When using <a href=\"multiqueue.html#GstMultiQueue:sync-by-running-time\">sync-by-running-time</a> the unlinked streams will\nbe throttled by the highest running-time of linked streams. This allows\nfurther relinking of those unlinked streams without them being in the\nfuture (i.e. to achieve gapless playback).\nWhen dealing with streams which have got different consumption requirements\ndownstream (ex: video decoders which will consume more buffer (in time) than\naudio decoders), it is recommended to group streams of the same type\nby using the pad \"group-id\" property. This will further throttle streams\nin time within that group.</p>\n\n</div>\n\n</div>\n\n\n"});