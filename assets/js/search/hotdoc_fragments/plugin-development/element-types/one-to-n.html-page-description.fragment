fragment_downloaded_cb({"url": "plugin-development/element-types/one-to-n.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"one-to-n.md\">\n        <h1 id=\"writing-a-demuxer-or-parser\">Writing a Demuxer or Parser</h1>\n<p>Demuxers are the 1-to-N elements that need very special care. They are\nresponsible for timestamping raw, unparsed data into elementary video or\naudio streams, and there are many things that you can optimize or do\nwrong. Here, several culprits will be mentioned and common solutions\nwill be offered. Parsers are demuxers with only one source pad. Also,\nthey only cut the stream into buffers, they don't touch the data\notherwise.</p>\n<p>As mentioned previously in <a href=\"../advanced/negotiation.html\">Caps negotiation</a>,\ndemuxers should use fixed caps, since their data type will not change.</p>\n<p>As discussed in <a href=\"../advanced/scheduling.html\">Different scheduling modes</a>,\ndemuxer elements can be written in multiple ways:</p>\n<ul>\n<li>\n<p>They can be the driving force of the pipeline, by running their own\ntask. This works particularly well for elements that need random\naccess, for example an AVI demuxer.</p>\n</li>\n<li>\n<p>They can also run in push-based mode, which means that an upstream\nelement drives the pipeline. This works particularly well for\nstreams that may come from network, such as Ogg.</p>\n</li>\n</ul>\n<p>In addition, audio parsers with one output can, in theory, also be\nwritten in random access mode. Although simple playback will mostly work\nif your element only accepts one mode, it may be required to implement\nmultiple modes to work in combination with all sorts of applications,\nsuch as editing. Also, performance may become better if you implement\nmultiple modes. See <a href=\"../advanced/scheduling.html\">Different scheduling modes</a>\nto see how an element can accept multiple scheduling modes.</p>\n\n        \n\n    </div>\n\n\n        "});