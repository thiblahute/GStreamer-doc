fragment_downloaded_cb({"url": "plugin-development/introduction/preface.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"preface.md\">\n<h1 id=\"preface\">Preface</h1>\n<h2 id=\"what-is-gstreamer\">What is GStreamer?</h2>\n<p>GStreamer is a framework for creating streaming media applications. The\nfundamental design comes from the video pipeline at Oregon Graduate\nInstitute, as well as some ideas from DirectShow.</p>\n<p>GStreamer's development framework makes it possible to write any type of\nstreaming multimedia application. The GStreamer framework is designed to\nmake it easy to write applications that handle audio or video or both.\nIt isn't restricted to audio and video, and can process any kind of data\nflow. The pipeline design is made to have little overhead above what the\napplied filters induce. This makes GStreamer a good framework for\ndesigning even high-end audio applications which put high demands on\nlatency or performance.</p>\n<p>One of the most obvious uses of GStreamer is using it to build a media\nplayer. GStreamer already includes components for building a media\nplayer that can support a very wide variety of formats, including MP3,\nOgg/Vorbis, MPEG-1/2, AVI, Quicktime, mod, and more. GStreamer, however,\nis much more than just another media player. Its main advantages are\nthat the pluggable components can be mixed and matched into arbitrary\npipelines so that it's possible to write a full-fledged video or audio\nediting application.</p>\n<p>The framework is based on plugins that will provide the various codec\nand other functionality. The plugins can be linked and arranged in a\npipeline. This pipeline defines the flow of the data.</p>\n<p>The GStreamer core function is to provide a framework for plugins, data\nflow, synchronization and media type handling/negotiation. It also\nprovides an API to write applications using the various plugins.</p>\n<h2 id=\"who-should-read-this-guide\">Who Should Read This Guide?</h2>\n<p>This guide explains how to write new modules for GStreamer. The guide is\nrelevant to several groups of people:</p>\n<ul>\n<li>\n<p>Anyone who wants to add support for new ways of processing data in\nGStreamer. For example, a person in this group might want to create\na new data format converter, a new visualization tool, or a new\ndecoder or encoder.</p>\n</li>\n<li>\n<p>Anyone who wants to add support for new input and output devices.\nFor example, people in this group might want to add the ability to\nwrite to a new video output system or read data from a digital\ncamera or special microphone.</p>\n</li>\n<li>\n<p>Anyone who wants to extend GStreamer in any way. You need to have an\nunderstanding of how the plugin system works before you can\nunderstand the constraints that the plugin system places on the rest\nof the code. Also, you might be surprised after reading this at how\nmuch can be done with plugins.</p>\n</li>\n</ul>\n<p>This guide is not relevant to you if you only want to use the existing\nfunctionality of GStreamer, or if you just want to use an application\nthat uses GStreamer. If you are only interested in using existing\nplugins to write a new application - and there are quite a lot of\nplugins already - you might want to check the <em>GStreamer Application\nDevelopment Manual</em>. If you are just trying to get help with a GStreamer\napplication, then you should check with the user manual for that\nparticular application.</p>\n<h2 id=\"preliminary-reading\">Preliminary Reading</h2>\n<p>This guide assumes that you are somewhat familiar with the basic\nworkings of GStreamer. For a gentle introduction to programming concepts\nin GStreamer, you may wish to read the <em>GStreamer Application\nDevelopment Manual</em> first. Also check out the other documentation\navailable on the <a href=\"http://gstreamer.freedesktop.org/documentation/\">GStreamer web\nsite</a>.</p>\n<p>In order to understand this manual, you will need to have a basic\nunderstanding of the C language. Since GStreamer adheres to the GObject\nprogramming model, this guide also assumes that you understand the\nbasics of <a href=\"http://developer.gnome.org/gobject/stable/pt01.html\">GObject</a>\nprogramming. You may also want to have a look at Eric Harlow's book\n<em>Developing Linux Applications with GTK+ and GDK</em>.</p>\n<h2 id=\"structure-of-this-guide\">Structure of This Guide</h2>\n<p>To help you navigate through this guide, it is divided into several\nlarge parts. Each part addresses a particular broad topic concerning\nGStreamer plugin development. The parts of this guide are laid out in\nthe following order:</p>\n<ul>\n<li>\n<p><a href=\"../basics/index.html\">Building a Plugin</a> - Introduction to the\nstructure of a plugin, using an example audio filter for\nillustration.</p>\n<p>This part covers all the basic steps you generally need to perform\nto build a plugin, such as registering the element with GStreamer\nand setting up the basics so it can receive data from and send data\nto neighbour elements. The discussion begins by giving examples of\ngenerating the basic structures and registering an element in\n<a href=\"../basics/boiler.html\">Constructing the Boilerplate</a>. Then,\nyou will learn how to write the code to get a basic filter plugin\nworking in <a href=\"../basics/pads.html\">Specifying the pads</a>, <a href=\"../basics/chainfn.html\">The chain function</a>\nand <a href=\"../basics/states.html\">What are states?</a>.</p>\n<p>After that, we will show some of the GObject concepts on how to make\nan element configurable for applications and how to do\napplication-element interaction in <a href=\"../basics/args.html\">Adding\nProperties</a> and <a href=\"../basics/signals.html\">Signals</a>. Next, you will learn to\nbuild a quick test application to test all that you've just learned\nin <a href=\"../basics/testapp.html\">Building a Test Application</a>. We\nwill just touch upon basics here. For full-blown application\ndevelopment, you should look at <a href=\"../../application-development/index.html\">the Application Development\nManual</a>.</p>\n</li>\n<li>\n<p><a href=\"../advanced/index.html\">Advanced Filter Concepts</a> - Information on\nadvanced features of GStreamer plugin development.</p>\n<p>After learning about the basic steps, you should be able to create a\nfunctional audio or video filter plugin with some nice features.\nHowever, GStreamer offers more for plugin writers. This part of the\nguide includes chapters on more advanced topics, such as scheduling,\nmedia type definitions in GStreamer, clocks, interfaces and tagging.\nSince these features are purpose-specific, you can read them in any\norder, most of them don't require knowledge from other sections.</p>\n<p>The first chapter, named <a href=\"../advanced/scheduling.html\">Different scheduling\nmodes</a>, will explain some of the basics of\nelement scheduling. It is not very in-depth, but is mostly some sort\nof an introduction on why other things work as they do. Read this\nchapter if you're interested in GStreamer internals. Next, we will\napply this knowledge and discuss another type of data transmission\nthan what you learned in <a href=\"../basics/chainfn.html\">The chain function</a>: <a href=\"../advanced/scheduling.html\">Different\nscheduling modes</a>. Loop-based elements will give you\nmore control over input rate. This is useful when writing, for\nexample, muxers or demuxers.</p>\n<p>Next, we will discuss media identification in GStreamer in <a href=\"../advanced/media-types.html\">Media Types\nand Properties</a>. You will learn how to\ndefine new media types and get to know a list of standard media\ntypes defined in GStreamer.</p>\n<p>In the next chapter, you will learn the concept of request- and\nsometimes-pads, which are pads that are created dynamically, either\nbecause the application asked for it (request) or because the media\nstream requires it (sometimes). This will be in <a href=\"../advanced/request.html\">Request and\nSometimes pads</a>.</p>\n<p>The next chapter, <a href=\"../advanced/clock.html\">Clocking</a>, will\nexplain the concept of clocks in GStreamer. You need this\ninformation when you want to know how elements should achieve\naudio/video synchronization.</p>\n<p>The next few chapters will discuss advanced ways of doing\napplication-element interaction. Previously, we learned on the\nGObject-ways of doing this in <a href=\"../basics/args.html\">Adding Properties</a> and\n<a href=\"../basics/signals.html\">Signals</a>. We will discuss dynamic\nparameters, which are a way of defining element behaviour over time\nin advance, in <a href=\"../advanced/dparams.html\">Supporting Dynamic Parameters</a>.\nNext, you will learn about interfaces in <a href=\"../advanced/interfaces.html\">Interfaces</a>.\nInterfaces are very target- specific ways of application-element\ninteraction, based on GObject's GInterface. Lastly, you will learn about\nhow metadata is handled in GStreamer in <a href=\"../advanced/tagging.html\">Tagging (Metadata and\nStreaminfo)</a>.</p>\n<p>The last chapter, <a href=\"../advanced/events.html\">Events: Seeking, Navigation and More</a>, will\ndiscuss the concept of events in GStreamer. Events are another way of\ndoing application-element interaction. They take care of seeking, for\nexample. They are also yet another a way in which elements\ninteract with each other, such as letting each other know about\nmedia stream discontinuities, forwarding tags inside a pipeline and\nso on.</p>\n</li>\n<li>\n<p><a href=\"../element-types/index.html\">Creating special element types</a> - Explanation of\nwriting other plugin types.</p>\n<p>Because the first two parts of the guide use an audio filter as an\nexample, the concepts introduced apply to filter plugins. But many\nof the concepts apply equally to other plugin types, including\nsources, sinks, and autopluggers. This part of the guide presents\nthe issues that arise when working on these more specialized plugin\ntypes. The chapter starts with a special focus on elements that can\nbe written using a base-class (<a href=\"../element-types/base-classes.html\">Pre-made base classes</a>),\nand later also goes into writing special types of elements in <a href=\"../element-types/one-to-n.html\">Writing a\nDemuxer or Parser</a>, <a href=\"../element-types/n-to-one.html\">Writing a N-to-1 Element or Muxer</a>\nand <a href=\"../element-types/manager.html\">Writing a Manager</a>.</p>\n</li>\n<li>\n<p><a href=\"../appendix/index.html\">Appendices</a> - Further information for plugin developers.</p>\n<p>The appendices contain some information that stubbornly refuses to\nfit cleanly in other sections of the guide. Most of this section is\nnot yet finished.</p>\n</li>\n</ul>\n<p>The remainder of this introductory part of the guide presents a short\noverview of the basic concepts involved in GStreamer plugin development.\nTopics covered include <a href=\"basics.html#elements-and-plugins\">Elements and Plugins</a>,\n<a href=\"basics.html#pads\">Pads</a>, <a href=\"basics.html#gstminiobject-buffers-and-events\">GstMiniObject, Buffers and Events</a>\nand <a href=\"basics.html#media-types-and-properties\">Media types and Properties</a>. If you are already\nfamiliar with this information, you can use this short overview to\nrefresh your memory, or you can skip to <a href=\"../basics/index.html\">Building a Plugin</a>.</p>\n<p>As you can see, there a lot to learn, so let's get started!</p>\n<ul>\n<li>\n<p>Creating compound and complex elements by extending from a GstBin.\nThis will allow you to create plugins that have other plugins\nembedded in them.</p>\n</li>\n<li>\n<p>Adding new media types to the registry along with typedetect\nfunctions. This will allow your plugin to operate on a completely\nnew media type.</p>\n</li>\n</ul>\n\n</div>\n\n\n        "});