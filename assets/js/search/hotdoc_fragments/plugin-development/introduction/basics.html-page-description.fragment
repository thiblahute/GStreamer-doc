fragment_downloaded_cb({"url": "plugin-development/introduction/basics.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"basics.md\">\n<h1 id=\"foundations\">Foundations</h1>\n<p>This chapter of the guide introduces the basic concepts of GStreamer.\nUnderstanding these concepts will help you grok the issues involved in\nextending GStreamer. Many of these concepts are explained in greater\ndetail in the <em>GStreamer Application Development Manual</em>; the basic\nconcepts presented here serve mainly to refresh your memory.</p>\n<h2 id=\"elements-and-plugins\">Elements and Plugins</h2>\n<p>Elements are at the core of GStreamer. In the context of plugin\ndevelopment, an <em>element</em> is an object derived from the <a href=\"../../gstreamer/html/GstElement.html\"><code>GstElement</code></a> class. Elements\nprovide some sort of functionality when linked with other elements: For\nexample, a source element provides data to a stream, and a filter\nelement acts on the data in a stream. Without elements, GStreamer is\njust a bunch of conceptual pipe fittings with nothing to link. A large\nnumber of elements ship with GStreamer, but extra elements can also be\nwritten.</p>\n<p>Just writing a new element is not entirely enough, however: You will\nneed to encapsulate your element in a <em>plugin</em> to enable GStreamer to\nuse it. A plugin is essentially a loadable block of code, usually called\na shared object file or a dynamically linked library. A single plugin\nmay contain the implementation of several elements, or just a single\none. For simplicity, this guide concentrates primarily on plugins\ncontaining one element.</p>\n<p>A <em>filter</em> is an important type of element that processes a stream of\ndata. Producers and consumers of data are called <em>source</em> and <em>sink</em>\nelements, respectively. <em>Bin</em> elements contain other elements. One type\nof bin is responsible for synchronization of the elements that they\ncontain so that data flows smoothly. Another type of bin, called\n<em>autoplugger</em> elements, automatically add other elements to the bin and\nlinks them together so that they act as a filter between two arbitrary\nstream types.</p>\n<p>The plugin mechanism is used everywhere in GStreamer, even if only the\nstandard packages are being used. A few very basic functions reside in\nthe core library, and all others are implemented in plugins. A plugin\nregistry is used to store the details of the plugins in an binary\nregistry file. This way, a program using GStreamer does not have to load\nall plugins to determine which are needed. Plugins are only loaded when\ntheir provided elements are requested.</p>\n<p>See the <em>GStreamer Library Reference</em> for the current implementation\ndetails of <a href=\"../../gstreamer/html/GstElement.html\"><code>GstElement</code></a> and\n<a href=\"../../gstreamer/html/GstPlugin.html\"><code>GstPlugin</code></a>.</p>\n<h2 id=\"pads\">Pads</h2>\n<p><em>Pads</em> are used to negotiate links and data flow between elements in\nGStreamer. A pad can be viewed as a \u201cplace\u201d or \u201cport\u201d on an element\nwhere links may be made with other elements, and through which data can\nflow to or from those elements. Pads have specific data handling\ncapabilities: A pad can restrict the type of data that flows through it.\nLinks are only allowed between two pads when the allowed data types of\nthe two pads are compatible.</p>\n<p>An analogy may be helpful here. A pad is similar to a plug or jack on a\nphysical device. Consider, for example, a home theater system consisting\nof an amplifier, a DVD player, and a (silent) video projector. Linking\nthe DVD player to the amplifier is allowed because both devices have\naudio jacks, and linking the projector to the DVD player is allowed\nbecause both devices have compatible video jacks. Links between the\nprojector and the amplifier may not be made because the projector and\namplifier have different types of jacks. Pads in GStreamer serve the\nsame purpose as the jacks in the home theater system.</p>\n<p>For the most part, all data in GStreamer flows one way through a link\nbetween elements. Data flows out of one element through one or more\n<em>source pads</em>, and elements accept incoming data through one or more\n<em>sink pads</em>. Source and sink elements have only source and sink pads,\nrespectively.</p>\n<p>See the <em>GStreamer Library Reference</em> for the current implementation\ndetails of a <a href=\"../../gstreamer/html/GstPad.html\"><code>GstPad</code></a>.</p>\n<h2 id=\"gstminiobject-buffers-and-events\">GstMiniObject, Buffers and Events</h2>\n<p>All streams of data in GStreamer are chopped up into chunks that are\npassed from a source pad on one element to a sink pad on another\nelement. <em>GstMiniObject</em> is the structure used to hold these chunks of\ndata.</p>\n<p>GstMiniObject contains the following important types:</p>\n<ul>\n<li>\n<p>An exact type indicating what type of data (event, buffer, ...) this\nGstMiniObject is.</p>\n</li>\n<li>\n<p>A reference count indicating the number of elements currently\nholding a reference to the miniobject. When the reference count\nfalls to zero, the miniobject will be disposed, and its memory will\nbe freed in some sense (see below for more details).</p>\n</li>\n</ul>\n<p>For data transport, there are two types of GstMiniObject defined: events\n(control) and buffers (content).</p>\n<p>Buffers may contain any sort of data that the two linked pads know how\nto handle. Normally, a buffer contains a chunk of some sort of audio or\nvideo data that flows from one element to another.</p>\n<p>Buffers also contain metadata describing the buffer's contents. Some of\nthe important types of metadata are:</p>\n<ul>\n<li>\n<p>Pointers to one or more GstMemory objects. GstMemory objects are\nrefcounted objects that encapsulate a region of memory.</p>\n</li>\n<li>\n<p>A timestamp indicating the preferred display timestamp of the\ncontent in the buffer.</p>\n</li>\n</ul>\n<p>Events contain information on the state of the stream flowing between\nthe two linked pads. Events will only be sent if the element explicitly\nsupports them, else the core will (try to) handle the events\nautomatically. Events are used to indicate, for example, a media type,\nthe end of a media stream or that the cache should be flushed.</p>\n<p>Events may contain several of the following items:</p>\n<ul>\n<li>\n<p>A subtype indicating the type of the contained event.</p>\n</li>\n<li>\n<p>The other contents of the event depend on the specific event type.</p>\n</li>\n</ul>\n<p>Events will be discussed extensively in <a href=\"../advanced/events.html\">Events: Seeking, Navigation and\nMore</a>. Until then, the only event that\nwill be used is the <em>EOS</em> event, which is used to indicate the end-of-stream\n(usually end-of-file).</p>\n<p>See the <em>GStreamer Library Reference</em> for the current implementation\ndetails of a\n<a href=\"../../gstreamer/html/gstreamer-GstMiniObject.html\"><code>GstMiniObject</code></a>,\n<a href=\"../../gstreamer/html/GstBuffer.html\"><code>GstBuffer</code></a> and\n<a href=\"../../gstreamer/html/GstEvent.html\"><code>GstEvent</code></a>.</p>\n<h3 id=\"buffer-allocation\">Buffer Allocation</h3>\n<p>Buffers are able to store chunks of memory of several different types.\nThe most generic type of buffer contains memory allocated by malloc().\nSuch buffers, although convenient, are not always very fast, since data\noften needs to be specifically copied into the buffer.</p>\n<p>Many specialized elements create buffers that point to special memory.\nFor example, the filesrc element usually maps a file into the address\nspace of the application (using mmap()), and creates buffers that point\ninto that address range. These buffers created by filesrc act exactly\nlike generic buffers, except that they are read-only. The buffer freeing\ncode automatically determines the correct method of freeing the\nunderlying memory. Downstream elements that receive these kinds of\nbuffers do not need to do anything special to handle or unreference it.</p>\n<p>Another way an element might get specialized buffers is to request them\nfrom a downstream peer through a GstBufferPool or GstAllocator. Elements\ncan ask a GstBufferPool or GstAllocator from the downstream peer\nelement. If downstream is able to provide these objects, upstream can\nuse them to allocate buffers. See more in <a href=\"../advanced/allocation.html\">Memory\nallocation</a>.</p>\n<p>Many sink elements have accelerated methods for copying data to\nhardware, or have direct access to hardware. It is common for these\nelements to be able to create a GstBufferPool or GstAllocator for their\nupstream peers. One such example is ximagesink. It creates buffers that\ncontain XImages. Thus, when an upstream peer copies data into the\nbuffer, it is copying directly into the XImage, enabling ximagesink to\ndraw the image directly to the screen instead of having to copy data\ninto an XImage first.</p>\n<p>Filter elements often have the opportunity to either work on a buffer\nin-place, or work while copying from a source buffer to a destination\nbuffer. It is optimal to implement both algorithms, since the GStreamer\nframework can choose the fastest algorithm as appropriate. Naturally,\nthis only makes sense for strict filters -- elements that have exactly\nthe same format on source and sink pads.</p>\n<h2 id=\"media-types-and-properties\">Media types and Properties</h2>\n<p>GStreamer uses a type system to ensure that the data passed between\nelements is in a recognized format. The type system is also important\nfor ensuring that the parameters required to fully specify a format\nmatch up correctly when linking pads between elements. Each link that is\nmade between elements has a specified type and optionally a set of\nproperties. See more about caps negotiation in <a href=\"../advanced/negotiation.html\">Caps\nnegotiation</a>.</p>\n<h3 id=\"the-basic-types\">The Basic Types</h3>\n<p>GStreamer already supports many basic media types. Following is a table\nof a few of the basic types used for buffers in GStreamer. The table\ncontains the name (\"media type\") and a description of the type, the\nproperties associated with the type, and the meaning of each property. A\nfull list of supported types is included in <a href=\"../advanced/media-types.html#list-of-defined-types\">List of Defined\nTypes</a>.</p>\n<table>\n<caption>Table of Example Types</caption>\n<thead>\n<tr class=\"header\">\n<th>Media Type</th>\n<th>Description</th>\n<th>Property</th>\n<th>Property Type</th>\n<th>Property Values</th>\n<th>Property Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>audio/*</td>\n<td><em>All audio types</em></td>\n<td>rate</td>\n<td>integer</td>\n<td>greater than 0</td>\n<td>The sample rate of the data, in samples (per channel) per second.</td>\n</tr>\n<tr class=\"even\">\n<td>channels</td>\n<td>integer</td>\n<td>greater than 0</td>\n<td>The number of channels of audio data.</td>\n</tr>\n<tr class=\"odd\">\n<td>audio/x-raw</td>\n<td>Unstructured and uncompressed raw integer audio data.</td>\n<td>format</td>\n<td>string</td>\n<td>S8 U8 S16LE S16BE U16LE U16BE S24_32LE S24_32BE U24_32LE U24_32BE S32LE S32BE U32LE U32BE S24LE S24BE U24LE U24BE S20LE S20BE U20LE U20BE S18LE S18BE U18LE U18BE F32LE F32BE F64LE F64BE</td>\n<td>The format of the sample data.</td>\n</tr>\n<tr class=\"even\">\n<td>audio/mpeg</td>\n<td>Audio data compressed using the MPEG audio encoding scheme.</td>\n<td>mpegversion</td>\n<td>integer</td>\n<td>1, 2 or 4</td>\n<td>The MPEG-version used for encoding the data. The value 1 refers to MPEG-1, -2 and -2.5 layer 1, 2 or 3. The values 2 and 4 refer to the MPEG-AAC audio encoding schemes.</td>\n</tr>\n<tr class=\"odd\">\n<td>framed</td>\n<td>boolean</td>\n<td>0 or 1</td>\n<td>A true value indicates that each buffer contains exactly one frame. A false value indicates that frames and buffers do not necessarily match up.</td>\n</tr>\n<tr class=\"even\">\n<td>layer</td>\n<td>integer</td>\n<td>1, 2, or 3</td>\n<td>The compression scheme layer used to compress the data <em>(only if mpegversion=1)</em>.</td>\n</tr>\n<tr class=\"odd\">\n<td>bitrate</td>\n<td>integer</td>\n<td>greater than 0</td>\n<td>The bitrate, in bits per second. For VBR (variable bitrate) MPEG data, this is the average bitrate.</td>\n</tr>\n<tr class=\"even\">\n<td>audio/x-vorbis</td>\n<td>Vorbis audio data</td>\n<td></td>\n<td></td>\n<td></td>\n<td>There are currently no specific properties defined for this type.</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n\n\n\t"});