fragment_downloaded_cb({"url": "plugin-development/basics/states.html#managing-filter-state", "fragment": "Managing filter state \nIf at all possible your element should derive from one of the new base classes Pre made base classes There are ready made general purpose base classes for different types of sources sinks and filter transformation elements. In addition to those specialised base classes exist for audio and video elements and others. \nIf you use a base class you will rarely have to handle state changes yourself. All you have to do is override the base class s start and stop virtual functions might be called differently depending on the base class and the base class will take care of everything for you. \nIf however you do not derive from a ready made base class but from GstElement or some other class not built on top of a base class you will most likely have to implement your own state change function to be notified of state changes. This is definitively necessary if your plugin is a demuxer or a muxer as there are no base classes for muxers or demuxers yet. \nAn element can be notified of state changes through a virtual function pointer. Inside this function the element can initialize any sort of specific data needed by the element and it can optionally fail to go from one state to another. \nDo not g_assert for unhandled state changes this is taken care of by the GstElement base class. \nNote that upwards NULL READY READY PAUSED PAUSED PLAYING and downwards PLAYING PAUSED PAUSED READY READY NULL state changes are handled in two separate blocks with the downwards state change handled only after we have chained up to the parent class s state change function. This is necessary in order to safely handle concurrent access by multiple threads. \nThe reason for this is that in the case of downwards state changes you don t want to destroy allocated resources while your plugin s chain function for example is still accessing those resources in another thread. Whether your chain function might be running or not depends on the state of your plugin s pads and the state of those pads is closely linked to the state of the element. Pad states are handled in the GstElement class s state change function including proper locking that s why it is essential to chain up before destroying allocated resources. \n"});