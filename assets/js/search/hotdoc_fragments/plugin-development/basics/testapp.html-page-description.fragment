fragment_downloaded_cb({"url": "plugin-development/basics/testapp.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"testapp.md\">\n        <h1 id=\"building-a-test-application\">Building a Test Application</h1>\n<p>Often, you will want to test your newly written plugin in an as small\nsetting as possible. Usually, <code>gst-launch-1.0</code> is a good first step at\ntesting a plugin. If you have not installed your plugin in a directory\nthat GStreamer searches, then you will need to set the plugin path.\nEither set GST_PLUGIN_PATH to the directory containing your plugin, or\nuse the command-line option --gst-plugin-path. If you based your plugin\noff of the gst-plugin template, then this will look something like <code>gst-launch-1.0 --gst-plugin-path=$HOME/gst-template/gst-plugin/src/.libs TESTPIPELINE</code> However, you will often need more testing features than gst-launch-1.0\ncan provide, such as seeking, events, interactivity and more. Writing\nyour own small testing program is the easiest way to accomplish this.\nThis section explains - in a few words - how to do that. For a complete\napplication development guide, see the <a href=\"../../application-development/index.html\">Application Development\nManual</a>.</p>\n<p>At the start, you need to initialize the GStreamer core library by\ncalling <code>gst_init ()</code>. You can alternatively call\n<code>gst_init_get_option_group ()</code>, which will return a pointer to\nGOptionGroup. You can then use GOption to handle the initialization, and\nthis will finish the GStreamer initialization.</p>\n<p>You can create elements using <code>gst_element_factory_make ()</code>, where the\nfirst argument is the element type that you want to create, and the\nsecond argument is a free-form name. The example at the end uses a\nsimple filesource - decoder - soundcard output pipeline, but you can use\nspecific debugging elements if that's necessary. For example, an\n<code>identity</code> element can be used in the middle of the pipeline to act as a\ndata-to-application transmitter. This can be used to check the data for\nmisbehaviours or correctness in your test application. Also, you can use\na <code>fakesink</code> element at the end of the pipeline to dump your data to the\nstdout (in order to do this, set the <code>dump</code> property to TRUE). Lastly,\nyou can use valgrind to check for memory errors.</p>\n<p>During linking, your test application can use filtered caps as a way to\ndrive a specific type of data to or from your element. This is a very\nsimple and effective way of checking multiple types of input and output\nin your element.</p>\n<p>Note that during running, you should listen for at least the \u201cerror\u201d and\n\u201ceos\u201d messages on the bus and/or your plugin/element to check for\ncorrect handling of this. Also, you should add events into the pipeline\nand make sure your plugin handles these correctly (with respect to\nclocking, internal caching, etc.).</p>\n<p>Never forget to clean up memory in your plugin or your test application.\nWhen going to the NULL state, your element should clean up allocated\nmemory and caches. Also, it should close down any references held to\npossible support libraries. Your application should <code>unref ()</code> the\npipeline and make sure it doesn't crash.</p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\nstatic gboolean\nbus_call (GstBus     *bus,\n      GstMessage *msg,\n      gpointer    data)\n{\n  GMainLoop *loop = data;\n\n  switch (GST_MESSAGE_TYPE (msg)) {\n    case GST_MESSAGE_EOS:\n      g_print (\"End-of-stream\\n\");\n      g_main_loop_quit (loop);\n      break;\n    case GST_MESSAGE_ERROR: {\n      gchar *debug = NULL;\n      GError *err = NULL;\n\n      gst_message_parse_error (msg, &amp;err, &amp;debug);\n\n      g_print (\"Error: %s\\n\", err-&gt;message);\n      g_error_free (err);\n\n      if (debug) {\n        g_print (\"Debug details: %s\\n\", debug);\n        g_free (debug);\n      }\n\n      g_main_loop_quit (loop);\n      break;\n    }\n    default:\n      break;\n  }\n\n  return TRUE;\n}\n\ngint\nmain (gint   argc,\n      gchar *argv[])\n{\n  GstStateChangeReturn ret;\n  GstElement *pipeline, *filesrc, *decoder, *filter, *sink;\n  GstElement *convert1, *convert2, *resample;\n  GMainLoop *loop;\n  GstBus *bus;\n  guint watch_id;\n\n  /* initialization */\n  gst_init (&amp;argc, &amp;argv);\n  loop = g_main_loop_new (NULL, FALSE);\n  if (argc != 2) {\n    g_print (\"Usage: %s &lt;mp3 filename&gt;\\n\", argv[0]);\n    return 01;\n  }\n\n  /* create elements */\n  pipeline = gst_pipeline_new (\"my_pipeline\");\n\n  /* watch for messages on the pipeline's bus (note that this will only\n   * work like this when a GLib main loop is running) */\n  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));\n  watch_id = gst_bus_add_watch (bus, bus_call, loop);\n  gst_object_unref (bus);\n\n  filesrc  = gst_element_factory_make (\"filesrc\", \"my_filesource\");\n  decoder  = gst_element_factory_make (\"mad\", \"my_decoder\");\n\n  /* putting an audioconvert element here to convert the output of the\n   * decoder into a format that my_filter can handle (we are assuming it\n   * will handle any sample rate here though) */\n  convert1 = gst_element_factory_make (\"audioconvert\", \"audioconvert1\");\n\n  /* use \"identity\" here for a filter that does nothing */\n  filter   = gst_element_factory_make (\"my_filter\", \"my_filter\");\n\n  /* there should always be audioconvert and audioresample elements before\n   * the audio sink, since the capabilities of the audio sink usually vary\n   * depending on the environment (output used, sound card, driver etc.) */\n  convert2 = gst_element_factory_make (\"audioconvert\", \"audioconvert2\");\n  resample = gst_element_factory_make (\"audioresample\", \"audioresample\");\n  sink     = gst_element_factory_make (\"pulsesink\", \"audiosink\");\n\n  if (!sink || !decoder) {\n    g_print (\"Decoder or output could not be found - check your install\\n\");\n    return -1;\n  } else if (!convert1 || !convert2 || !resample) {\n    g_print (\"Could not create audioconvert or audioresample element, \"\n             \"check your installation\\n\");\n    return -1;\n  } else if (!filter) {\n    g_print (\"Your self-written filter could not be found. Make sure it \"\n             \"is installed correctly in $(libdir)/gstreamer-1.0/ or \"\n             \"~/.gstreamer-1.0/plugins/ and that gst-inspect-1.0 lists it. \"\n             \"If it doesn't, check with 'GST_DEBUG=*:2 gst-inspect-1.0' for \"\n             \"the reason why it is not being loaded.\");\n    return -1;\n  }\n\n  g_object_set (G_OBJECT (filesrc), \"location\", argv[1], NULL);\n\n  gst_bin_add_many (GST_BIN (pipeline), filesrc, decoder, convert1, filter,\n                    convert2, resample, sink, NULL);\n\n  /* link everything together */\n  if (!gst_element_link_many (filesrc, decoder, convert1, filter, convert2,\n                              resample, sink, NULL)) {\n    g_print (\"Failed to link one or more elements!\\n\");\n    return -1;\n  }\n\n  /* run */\n  ret = gst_element_set_state (pipeline, GST_STATE_PLAYING);\n  if (ret == GST_STATE_CHANGE_FAILURE) {\n    GstMessage *msg;\n\n    g_print (\"Failed to start up pipeline!\\n\");\n\n    /* check if there is an error message with details on the bus */\n    msg = gst_bus_poll (bus, GST_MESSAGE_ERROR, 0);\n    if (msg) {\n      GError *err = NULL;\n\n      gst_message_parse_error (msg, &amp;err, NULL);\n      g_print (\"ERROR: %s\\n\", err-&gt;message);\n      g_error_free (err);\n      gst_message_unref (msg);\n    }\n    return -1;\n  }\n\n  g_main_loop_run (loop);\n\n  /* clean up */\n  gst_element_set_state (pipeline, GST_STATE_NULL);\n  gst_object_unref (pipeline);\n  g_source_remove (watch_id);\n  g_main_loop_unref (loop);\n\n  return 0;\n}\n\n</code></pre>\n\n        \n\n    </div>\n\n\n        "});