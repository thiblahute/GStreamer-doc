fragment_downloaded_cb({"url": "plugin-development/basics/chainfn.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"chainfn.md\">\n<h1 id=\"the-chain-function\">The chain function</h1>\n<p>The chain function is the function in which all data processing takes\nplace. In the case of a simple filter, <code>_chain ()</code> functions are mostly\nlinear functions - so for each incoming buffer, one buffer will go out,\ntoo. Below is a very simple implementation of a chain function:</p>\n<pre><code class=\"language-c\">\nstatic GstFlowReturn gst_my_filter_chain (GstPad    *pad,\n                                          GstObject *parent,\n                                          GstBuffer *buf);\n\n[..]\n\nstatic void\ngst_my_filter_init (GstMyFilter * filter)\n{\n[..]\n  /* configure chain function on the pad before adding\n   * the pad to the element */\n  gst_pad_set_chain_function (filter-&gt;sinkpad,\n      gst_my_filter_chain);\n[..]\n}\n\nstatic GstFlowReturn\ngst_my_filter_chain (GstPad    *pad,\n                     GstObject *parent,\n             GstBuffer *buf)\n{\n  GstMyFilter *filter = GST_MY_FILTER (parent);\n\n  if (!filter-&gt;silent)\n    g_print (\"Have data of size %\" G_GSIZE_FORMAT\" bytes!\\n\",\n        gst_buffer_get_size (buf));\n\n  return gst_pad_push (filter-&gt;srcpad, buf);\n}\n</code></pre>\n<p>Obviously, the above doesn't do much useful. Instead of printing that\nthe data is in, you would normally process the data there. Remember,\nhowever, that buffers are not always writeable.</p>\n<p>In more advanced elements (the ones that do event processing), you may\nwant to additionally specify an event handling function, which will be\ncalled when stream-events are sent (such as caps, end-of-stream,\nnewsegment, tags, etc.).</p>\n<pre><code>static void\ngst_my_filter_init (GstMyFilter * filter)\n{\n[..]\n  gst_pad_set_event_function (filter-&gt;sinkpad,\n      gst_my_filter_sink_event);\n[..]\n}\n\n\n\nstatic gboolean\ngst_my_filter_sink_event (GstPad    *pad,\n                  GstObject *parent,\n                  GstEvent  *event)\n{\n  GstMyFilter *filter = GST_MY_FILTER (parent);\n\n  switch (GST_EVENT_TYPE (event)) {\n    case GST_EVENT_CAPS:\n      /* we should handle the format here */\n      break;\n    case GST_EVENT_EOS:\n      /* end-of-stream, we should close down all stream leftovers here */\n      gst_my_filter_stop_processing (filter);\n      break;\n    default:\n      break;\n  }\n\n  return gst_pad_event_default (pad, parent, event);\n}\n\nstatic GstFlowReturn\ngst_my_filter_chain (GstPad    *pad,\n             GstObject *parent,\n             GstBuffer *buf)\n{\n  GstMyFilter *filter = GST_MY_FILTER (parent);\n  GstBuffer *outbuf;\n\n  outbuf = gst_my_filter_process_data (filter, buf);\n  gst_buffer_unref (buf);\n  if (!outbuf) {\n    /* something went wrong - signal an error */\n    GST_ELEMENT_ERROR (GST_ELEMENT (filter), STREAM, FAILED, (NULL), (NULL));\n    return GST_FLOW_ERROR;\n  }\n\n  return gst_pad_push (filter-&gt;srcpad, outbuf);\n}\n</code></pre>\n<p>In some cases, it might be useful for an element to have control over\nthe input data rate, too. In that case, you probably want to write a\nso-called <em>loop-based</em> element. Source elements (with only source pads)\ncan also be <em>get-based</em> elements. These concepts will be explained in\nthe advanced section of this guide, and in the section that specifically\ndiscusses source pads.</p>\n\n</div>\n\n\n        "});