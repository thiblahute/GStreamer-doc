fragment_downloaded_cb({"url": "plugin-development/basics/testapp.html#building-a-test-application", "fragment": "Building a Test Application \nOften you will want to test your newly written plugin in an as small setting as possible. Usually gst launch is a good first step at testing a plugin. If you have not installed your plugin in a directory that GStreamer searches then you will need to set the plugin path. Either set GST_PLUGIN_PATH to the directory containing your plugin or use the command line option gst plugin path. If you based your plugin off of the gst plugin template then this will look something like gst launch gst plugin path HOME gst template gst plugin src libs TESTPIPELINE However you will often need more testing features than gst launch can provide such as seeking events interactivity and more. Writing your own small testing program is the easiest way to accomplish this. This section explains in a few words how to do that. For a complete application development guide see the Application Development Manual. \nAt the start you need to initialize the GStreamer core library by calling gst_init You can alternatively call gst_init_get_option_group which will return a pointer to GOptionGroup. You can then use GOption to handle the initialization and this will finish the GStreamer initialization. \nYou can create elements using gst_element_factory_make where the first argument is the element type that you want to create and the second argument is a free form name. The example at the end uses a simple filesource decoder soundcard output pipeline but you can use specific debugging elements if that s necessary. For example an identity element can be used in the middle of the pipeline to act as a data to application transmitter. This can be used to check the data for misbehaviours or correctness in your test application. Also you can use a fakesink element at the end of the pipeline to dump your data to the stdout in order to do this set the dump property to TRUE Lastly you can use valgrind to check for memory errors. \nDuring linking your test application can use filtered caps as a way to drive a specific type of data to or from your element. This is a very simple and effective way of checking multiple types of input and output in your element. \nNote that during running you should listen for at least the error and eos messages on the bus and or your plugin element to check for correct handling of this. Also you should add events into the pipeline and make sure your plugin handles these correctly with respect to clocking internal caching etc. \nNever forget to clean up memory in your plugin or your test application. When going to the NULL state your element should clean up allocated memory and caches. Also it should close down any references held to possible support libraries. Your application should unref the pipeline and make sure it doesn t crash. \n"});