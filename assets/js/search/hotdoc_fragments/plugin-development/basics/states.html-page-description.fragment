fragment_downloaded_cb({"url": "plugin-development/basics/states.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"states.md\">\n        <h1 id=\"what-are-states\">What are states?</h1>\n<p>A state describes whether the element instance is initialized, whether\nit is ready to transfer data and whether it is currently handling data.\nThere are four states defined in GStreamer:</p>\n<ul>\n<li>\n<p><code>GST_STATE_NULL</code></p>\n</li>\n<li>\n<p><code>GST_STATE_READY</code></p>\n</li>\n<li>\n<p><code>GST_STATE_PAUSED</code></p>\n</li>\n<li>\n<p><code>GST_STATE_PLAYING</code></p>\n</li>\n</ul>\n<p>which will from now on be referred to simply as \u201cNULL\u201d, \u201cREADY\u201d,\n\u201cPAUSED\u201d and \u201cPLAYING\u201d.</p>\n<p><code>GST_STATE_NULL</code> is the default state of an element. In this state, it\nhas not allocated any runtime resources, it has not loaded any runtime\nlibraries and it can obviously not handle data.</p>\n<p><code>GST_STATE_READY</code> is the next state that an element can be in. In the\nREADY state, an element has all default resources (runtime-libraries,\nruntime-memory) allocated. However, it has not yet allocated or defined\nanything that is stream-specific. When going from NULL to READY state\n(<code>GST_STATE_CHANGE_NULL_TO_READY</code>), an element should allocate any\nnon-stream-specific resources and should load runtime-loadable libraries\n(if any). When going the other way around (from READY to NULL,\n<code>GST_STATE_CHANGE_READY_TO_NULL</code>), an element should unload these\nlibraries and free all allocated resources. Examples of such resources\nare hardware devices. Note that files are generally streams, and these\nshould thus be considered as stream-specific resources; therefore, they\nshould <em>not</em> be allocated in this state.</p>\n<p><code>GST_STATE_PAUSED</code> is the state in which an element is ready to accept\nand handle data. For most elements this state is the same as PLAYING.\nThe only exception to this rule are sink elements. Sink elements only\naccept one single buffer of data and then block. At this point the\npipeline is 'prerolled' and ready to render data immediately.</p>\n<p><code>GST_STATE_PLAYING</code> is the highest state that an element can be in. For\nmost elements this state is exactly the same as PAUSED, they accept and\nprocess events and buffers with data. Only sink elements need to\ndifferentiate between PAUSED and PLAYING state. In PLAYING state, sink\nelements actually render incoming data, e.g. output audio to a sound\ncard or render video pictures to an image sink.</p>\n<h2 id=\"managing-filter-state\">Managing filter state</h2>\n<p>If at all possible, your element should derive from one of the new base\nclasses (<a href=\"../element-types/base-classes.html\">Pre-made base classes</a>). There are\nready-made general purpose base classes for different types of sources,\nsinks and filter/transformation elements. In addition to those,\nspecialised base classes exist for audio and video elements and others.</p>\n<p>If you use a base class, you will rarely have to handle state changes\nyourself. All you have to do is override the base class's start() and\nstop() virtual functions (might be called differently depending on the\nbase class) and the base class will take care of everything for you.</p>\n<p>If, however, you do not derive from a ready-made base class, but from\nGstElement or some other class not built on top of a base class, you\nwill most likely have to implement your own state change function to be\nnotified of state changes. This is definitively necessary if your plugin\nis a demuxer or a muxer, as there are no base classes for muxers or\ndemuxers yet.</p>\n<p>An element can be notified of state changes through a virtual function\npointer. Inside this function, the element can initialize any sort of\nspecific data needed by the element, and it can optionally fail to go\nfrom one state to another.</p>\n<p>Do not g_assert for unhandled state changes; this is taken care of by\nthe GstElement base class.</p>\n<pre><code>static GstStateChangeReturn\ngst_my_filter_change_state (GstElement *element, GstStateChange transition);\n\nstatic void\ngst_my_filter_class_init (GstMyFilterClass *klass)\n{\n  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);\n\n  element_class-&gt;change_state = gst_my_filter_change_state;\n}\n\n\n\nstatic GstStateChangeReturn\ngst_my_filter_change_state (GstElement *element, GstStateChange transition)\n{\n  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;\n  GstMyFilter *filter = GST_MY_FILTER (element);\n\n  switch (transition) {\n    case GST_STATE_CHANGE_NULL_TO_READY:\n      if (!gst_my_filter_allocate_memory (filter))\n        return GST_STATE_CHANGE_FAILURE;\n      break;\n    default:\n      break;\n  }\n\n  ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);\n  if (ret == GST_STATE_CHANGE_FAILURE)\n    return ret;\n\n  switch (transition) {\n    case GST_STATE_CHANGE_READY_TO_NULL:\n      gst_my_filter_free_memory (filter);\n      break;\n    default:\n      break;\n  }\n\n  return ret;\n}\n</code></pre>\n<p>Note that upwards (NULL=&gt;READY, READY=&gt;PAUSED, PAUSED=&gt;PLAYING) and\ndownwards (PLAYING=&gt;PAUSED, PAUSED=&gt;READY, READY=&gt;NULL) state changes\nare handled in two separate blocks with the downwards state change\nhandled only after we have chained up to the parent class's state change\nfunction. This is necessary in order to safely handle concurrent access\nby multiple threads.</p>\n<p>The reason for this is that in the case of downwards state changes you\ndon't want to destroy allocated resources while your plugin's chain\nfunction (for example) is still accessing those resources in another\nthread. Whether your chain function might be running or not depends on\nthe state of your plugin's pads, and the state of those pads is closely\nlinked to the state of the element. Pad states are handled in the\nGstElement class's state change function, including proper locking,\nthat's why it is essential to chain up before destroying allocated\nresources.</p>\n\n        \n\n    </div>\n\n\n        "});