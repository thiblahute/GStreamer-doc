fragment_downloaded_cb({"url": "plugin-development/basics/boiler.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"boiler.md\">\n<h1 id=\"constructing-the-boilerplate\">Constructing the Boilerplate</h1>\n<p>In this chapter you will learn how to construct the bare minimum code\nfor a new plugin. Starting from ground zero, you will see how to get the\nGStreamer template source. Then you will learn how to use a few basic\ntools to copy and modify a template plugin to create a new plugin. If\nyou follow the examples here, then by the end of this chapter you will\nhave a functional audio filter plugin that you can compile and use in\nGStreamer applications.</p>\n<h2 id=\"getting-the-gstreamer-plugin-templates\">Getting the GStreamer Plugin Templates</h2>\n<p>There are currently two ways to develop a new plugin for GStreamer: You\ncan write the entire plugin by hand, or you can copy an existing plugin\ntemplate and write the plugin code you need. The second method is by far\nthe simpler of the two, so the first method will not even be described\nhere. (Errm, that is, \u201cit is left as an exercise to the reader.\u201d)</p>\n<p>The first step is to check out a copy of the <code>gst-template</code> git module\nto get an important tool and the source code template for a basic\nGStreamer plugin. To check out the <code>gst-template</code> module, make sure you\nare connected to the internet, and type the following commands at a\ncommand\nconsole:</p>\n<pre><code>shell $ git clone git://anongit.freedesktop.org/gstreamer/gst-template.git\nInitialized empty Git repository in /some/path/gst-template/.git/\nremote: Counting objects: 373, done.\nremote: Compressing objects: 100% (114/114), done.\nremote: Total 373 (delta 240), reused 373 (delta 240)\nReceiving objects: 100% (373/373), 75.16 KiB | 78 KiB/s, done.\nResolving deltas: 100% (240/240), done.\n\n</code></pre>\n<p>This command will check out a series of files and directories into\n<code>gst-template</code>. The template you will be using is in the\n<code>gst-template/gst-plugin/</code> directory. You should look over the files in\nthat directory to get a general idea of the structure of a source tree\nfor a plugin.</p>\n<p>If for some reason you can't access the git repository, you can also\n<a href=\"http://cgit.freedesktop.org/gstreamer/gst-template/commit/\">download a snapshot of the latest\nrevision</a>\nvia the cgit web interface.</p>\n<h2 id=\"using-the-project-stamp\">Using the Project Stamp</h2>\n<p>The first thing to do when making a new element is to specify some basic\ndetails about it: what its name is, who wrote it, what version number it\nis, etc. We also need to define an object to represent the element and\nto store the data the element needs. These details are collectively\nknown as the <em>boilerplate</em>.</p>\n<p>The standard way of defining the boilerplate is simply to write some\ncode, and fill in some structures. As mentioned in the previous section,\nthe easiest way to do this is to copy a template and add functionality\naccording to your needs. To help you do so, there is a tool in the\n<code>./gst-plugin/tools/</code> directory. This tool, <code>make_element</code>, is a command\nline utility that creates the boilerplate code for you.</p>\n<p>To use <code>make_element</code>, first open up a terminal window. Change to the\n<code>gst-template/gst-plugin/src</code> directory, and then run the <code>make_element</code>\ncommand. The arguments to the <code>make_element</code> are:</p>\n<ol>\n<li>\n<p>the name of the plugin, and</p>\n</li>\n<li>\n<p>the source file that the tool will use. By default, <code>gstplugin</code> is\nused.</p>\n</li>\n</ol>\n<p>For example, the following commands create the MyFilter plugin based on\nthe plugin template and put the output files in the\n<code>gst-template/gst-plugin/src</code> directory:</p>\n<pre><code>shell $ cd gst-template/gst-plugin/src\nshell $ ../tools/make_element MyFilter\n\n</code></pre>\n<blockquote>\n<p><strong>Note</strong></p>\n<p>Capitalization is important for the name of the plugin. Keep in mind\nthat under some operating systems, capitalization is also important\nwhen specifying directory and file names in general.</p>\n</blockquote>\n<p>The last command creates two files: <code>gstmyfilter.c</code> and <code>gstmyfilter.h</code>.</p>\n<blockquote>\n<p><strong>Note</strong></p>\n<p>It is recommended that you create a copy of the <code>gst-plugin</code> directory\nbefore continuing.</p>\n</blockquote>\n<p>Now one needs to adjust the <code>Makefile.am</code> to use the new filenames and\nrun <code>autogen.sh</code> from the parent directory to bootstrap the build\nenvironment. After that, the project can be built and installed using\nthe well known <code>make &amp;&amp; sudo make install</code> commands.</p>\n<blockquote>\n<p><strong>Note</strong></p>\n<p>Be aware that by default <code>autogen.sh</code> and <code>configure</code> would choose\n<code>/usr/local</code> as a default location. One would need to add\n<code>/usr/local/lib/gstreamer-1.0</code> to <code>GST_PLUGIN_PATH</code> in order to make\nthe new plugin show up in a gstreamer that's been installed from\npackages.</p>\n</blockquote>\n<blockquote>\n<p><strong>Note</strong></p>\n<p>FIXME: this section is slightly outdated. gst-template is still useful\nas an example for a minimal plugin build system skeleton. However, for\ncreating elements the tool gst-element-maker from gst-plugins-bad is\nrecommended these days.</p>\n</blockquote>\n<h2 id=\"examining-the-basic-code\">Examining the Basic Code</h2>\n<p>First we will examine the code you would be likely to place in a header\nfile (although since the interface to the code is entirely defined by\nthe plugin system, and doesn't depend on reading a header file, this is\nnot crucial.)</p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\n/* Definition of structure storing data for this element. */\ntypedef struct _GstMyFilter {\n  GstElement element;\n\n  GstPad *sinkpad, *srcpad;\n\n  gboolean silent;\n\n\n\n} GstMyFilter;\n\n/* Standard definition defining a class for this element. */\ntypedef struct _GstMyFilterClass {\n  GstElementClass parent_class;\n} GstMyFilterClass;\n\n/* Standard macros for defining types for this element.  */\n#define GST_TYPE_MY_FILTER (gst_my_filter_get_type())\n#define GST_MY_FILTER(obj) \\\n  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MY_FILTER,GstMyFilter))\n#define GST_MY_FILTER_CLASS(klass) \\\n  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MY_FILTER,GstMyFilterClass))\n#define GST_IS_MY_FILTER(obj) \\\n  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MY_FILTER))\n#define GST_IS_MY_FILTER_CLASS(klass) \\\n  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MY_FILTER))\n\n/* Standard function returning type information. */\nGType gst_my_filter_get_type (void);\n\n</code></pre>\n<p>Using this header file, you can use the following macro to setup the\n<code>GObject</code> basics in your source file so that all functions will be\ncalled appropriately:</p>\n<pre><code class=\"language-c\">#include \"filter.h\"\n\nG_DEFINE_TYPE (GstMyFilter, gst_my_filter, GST_TYPE_ELEMENT);\n\n</code></pre>\n<h2 id=\"element-metadata\">Element metadata</h2>\n<p>The Element metadata provides extra element information. It is\nconfigured with <code>gst_element_class_set_metadata</code> or\n<code>gst_element_class_set_static_metadata</code> which takes the following\nparameters:</p>\n<ul>\n<li>\n<p>A long, English, name for the element.</p>\n</li>\n<li>\n<p>The type of the element, see the docs/design/draft-klass.txt\ndocument in the GStreamer core source tree for details and examples.</p>\n</li>\n<li>\n<p>A brief description of the purpose of the element.</p>\n</li>\n<li>\n<p>The name of the author of the element, optionally followed by a\ncontact email address in angle brackets.</p>\n</li>\n</ul>\n<p>For example:</p>\n<pre><code class=\"language-c\">gst_element_class_set_static_metadata (klass,\n  \"An example plugin\",\n  \"Example/FirstExample\",\n  \"Shows the basic structure of a plugin\",\n  \"your name &lt;your.name@your.isp&gt;\");\n\n</code></pre>\n<p>The element details are registered with the plugin during the\n<code>_class_init ()</code> function, which is part of the GObject system. The\n<code>_class_init ()</code> function should be set for this GObject in the function\nwhere you register the type with GLib.</p>\n<pre><code class=\"language-c\">static void\ngst_my_filter_class_init (GstMyFilterClass * klass)\n{\n  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);\n\n[..]\n  gst_element_class_set_static_metadata (element_klass,\n    \"An example plugin\",\n    \"Example/FirstExample\",\n    \"Shows the basic structure of a plugin\",\n    \"your name &lt;your.name@your.isp&gt;\");\n\n}\n\n</code></pre>\n<h2 id=\"gststaticpadtemplate\">GstStaticPadTemplate</h2>\n<p>A GstStaticPadTemplate is a description of a pad that the element will\n(or might) create and use. It contains:</p>\n<ul>\n<li>\n<p>A short name for the pad.</p>\n</li>\n<li>\n<p>Pad direction.</p>\n</li>\n<li>\n<p>Existence property. This indicates whether the pad exists always (an\n\u201calways\u201d pad), only in some cases (a \u201csometimes\u201d pad) or only if the\napplication requested such a pad (a \u201crequest\u201d pad).</p>\n</li>\n<li>\n<p>Supported types by this element (capabilities).</p>\n</li>\n</ul>\n<p>For example:</p>\n<pre><code class=\"language-c\">static GstStaticPadTemplate sink_factory =\nGST_STATIC_PAD_TEMPLATE (\n  \"sink\",\n  GST_PAD_SINK,\n  GST_PAD_ALWAYS,\n  GST_STATIC_CAPS (\"ANY\")\n);\n\n\n\n</code></pre>\n<p>Those pad templates are registered during the <code>_class_init ()</code> function\nwith the <code>gst_element_class_add_pad_template ()</code>. For this function you\nneed a handle the <code>GstPadTemplate</code> which you can create from the static\npad template with <code>gst_static_pad_template_get ()</code>. See below for more\ndetails on this.</p>\n<p>Pads are created from these static templates in the element's <code>_init ()</code>\nfunction using <code>gst_pad_new_from_static_template ()</code>. In order to create\na new pad from this template using <code>gst_pad_new_from_static_template ()</code>, you will need to declare the pad template as a global variable. More on\nthis subject in <a href=\"pads.html\">Specifying the pads</a>.</p>\n<pre><code>static GstStaticPadTemplate sink_factory = [..],\n    src_factory = [..];\n\nstatic void\ngst_my_filter_class_init (GstMyFilterClass * klass)\n{\n  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);\n[..]\n\n  gst_element_class_add_pad_template (element_class,\n    gst_static_pad_template_get (&amp;src_factory));\n  gst_element_class_add_pad_template (element_class,\n    gst_static_pad_template_get (&amp;sink_factory));\n}\n</code></pre>\n<p>The last argument in a template is its type or list of supported types.\nIn this example, we use 'ANY', which means that this element will accept\nall input. In real-life situations, you would set a media type and\noptionally a set of properties to make sure that only supported input\nwill come in. This representation should be a string that starts with a\nmedia type, then a set of comma-separates properties with their\nsupported values. In case of an audio filter that supports raw integer\n16-bit audio, mono or stereo at any samplerate, the correct template\nwould look like this:</p>\n<pre><code class=\"language-c\">\nstatic GstStaticPadTemplate sink_factory =\nGST_STATIC_PAD_TEMPLATE (\n  \"sink\",\n  GST_PAD_SINK,\n  GST_PAD_ALWAYS,\n  GST_STATIC_CAPS (\n    \"audio/x-raw, \"\n      \"format = (string) \" GST_AUDIO_NE (S16) \", \"\n      \"channels = (int) { 1, 2 }, \"\n      \"rate = (int) [ 8000, 96000 ]\"\n  )\n);\n\n\n</code></pre>\n<p>Values surrounded by curly brackets (\u201c{\u201d and \u201c}\u201d) are lists, values\nsurrounded by square brackets (\u201c[\u201d and \u201c]\u201d) are ranges. Multiple sets\nof types are supported too, and should be separated by a semicolon\n(\u201c;\u201d). Later, in the chapter on pads, we will see how to use types\nto know the exact format of a stream: <a href=\"pads.html\">Specifying the pads</a>.</p>\n<h2 id=\"constructor-functions\">Constructor Functions</h2>\n<p>Each element has two functions which are used for construction of an\nelement. The <code>_class_init()</code> function, which is used to initialise the\nclass only once (specifying what signals, arguments and virtual\nfunctions the class has and setting up global state); and the <code>_init()</code>\nfunction, which is used to initialise a specific instance of this type.</p>\n<h2 id=\"the-plugin_init-function\">The plugin_init function</h2>\n<p>Once we have written code defining all the parts of the plugin, we need\nto write the plugin_init() function. This is a special function, which\nis called as soon as the plugin is loaded, and should return TRUE or\nFALSE depending on whether it loaded initialized any dependencies\ncorrectly. Also, in this function, any supported element type in the\nplugin should be registered.</p>\n<pre><code class=\"language-c\">\n\nstatic gboolean\nplugin_init (GstPlugin *plugin)\n{\n  return gst_element_register (plugin, \"my_filter\",\n                   GST_RANK_NONE,\n                   GST_TYPE_MY_FILTER);\n}\n\nGST_PLUGIN_DEFINE (\n  GST_VERSION_MAJOR,\n  GST_VERSION_MINOR,\n  my_filter,\n  \"My filter plugin\",\n  plugin_init,\n  VERSION,\n  \"LGPL\",\n  \"GStreamer\",\n  \"http://gstreamer.net/\"\n)\n\n\n\n</code></pre>\n<p>Note that the information returned by the plugin_init() function will\nbe cached in a central registry. For this reason, it is important that\nthe same information is always returned by the function: for example, it\nmust not make element factories available based on runtime conditions.\nIf an element can only work in certain conditions (for example, if the\nsoundcard is not being used by some other process) this must be\nreflected by the element being unable to enter the READY state if\nunavailable, rather than the plugin attempting to deny existence of the\nplugin.</p>\n\n</div>\n\n\n        "});