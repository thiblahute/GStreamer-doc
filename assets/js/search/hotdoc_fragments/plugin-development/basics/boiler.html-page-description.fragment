fragment_downloaded_cb({"url": "plugin-development/basics/boiler.html#page-description", "fragment": "In this chapter you will learn how to construct the bare minimum code for a new plugin. Starting from ground zero you will see how to get the GStreamer template source. Then you will learn how to use a few basic tools to copy and modify a template plugin to create a new plugin. If you follow the examples here then by the end of this chapter you will have a functional audio filter plugin that you can compile and use in GStreamer applications. \nThere are currently two ways to develop a new plugin for GStreamer You can write the entire plugin by hand or you can copy an existing plugin template and write the plugin code you need. The second method is by far the simpler of the two so the first method will not even be described here. Errm that is it is left as an exercise to the reader. \nThe first step is to check out a copy of the gst template git module to get an important tool and the source code template for a basic GStreamer plugin. To check out the gst template module make sure you are connected to the internet and type the following commands at a command console \nThis command will check out a series of files and directories into gst template. The template you will be using is in the gst template gst plugin directory. You should look over the files in that directory to get a general idea of the structure of a source tree for a plugin. \nIf for some reason you can t access the git repository you can also download a snapshot of the latest revision via the cgit web interface. \nThe first thing to do when making a new element is to specify some basic details about it what its name is who wrote it what version number it is etc. We also need to define an object to represent the element and to store the data the element needs. These details are collectively known as the boilerplate. \nThe standard way of defining the boilerplate is simply to write some code and fill in some structures. As mentioned in the previous section the easiest way to do this is to copy a template and add functionality according to your needs. To help you do so there is a tool in the gst plugin tools directory. This tool make_element is a command line utility that creates the boilerplate code for you. \nTo use make_element first open up a terminal window. Change to the gst template gst plugin src directory and then run the make_element command. The arguments to the make_element are \nthe name of the plugin and \nthe source file that the tool will use. By default gstplugin is used. \nFor example the following commands create the MyFilter plugin based on the plugin template and put the output files in the gst template gst plugin src directory \nNote \nCapitalization is important for the name of the plugin. Keep in mind that under some operating systems capitalization is also important when specifying directory and file names in general. \nThe last command creates two files gstmyfilter.c and gstmyfilter.h. \nNote \nIt is recommended that you create a copy of the gst plugin directory before continuing. \nNow one needs to adjust the Makefile.am to use the new filenames and run autogen.sh from the parent directory to bootstrap the build environment. After that the project can be built and installed using the well known make sudo make install commands. \nNote \nBe aware that by default autogen.sh and configure would choose usr local as a default location. One would need to add usr local lib gstreamer to GST_PLUGIN_PATH in order to make the new plugin show up in a gstreamer that s been installed from packages. \nNote \nFIXME this section is slightly outdated. gst template is still useful as an example for a minimal plugin build system skeleton. However for creating elements the tool gst element maker from gst plugins bad is recommended these days. \nFirst we will examine the code you would be likely to place in a header file although since the interface to the code is entirely defined by the plugin system and doesn t depend on reading a header file this is not crucial. \nUsing this header file you can use the following macro to setup the GObject basics in your source file so that all functions will be called appropriately \nThe Element metadata provides extra element information. It is configured with gst_element_class_set_metadata or gst_element_class_set_static_metadata which takes the following parameters \nA long English name for the element. \nThe type of the element see the docs design draft klass.txt document in the GStreamer core source tree for details and examples. \nA brief description of the purpose of the element. \nThe name of the author of the element optionally followed by a contact email address in angle brackets. \nFor example \nThe element details are registered with the plugin during the _class_init function which is part of the GObject system. The _class_init function should be set for this GObject in the function where you register the type with GLib. \nA GstStaticPadTemplate is a description of a pad that the element will or might create and use. It contains \nA short name for the pad. \nPad direction. \nExistence property. This indicates whether the pad exists always an always pad only in some cases a sometimes pad or only if the application requested such a pad a request pad \nSupported types by this element capabilities \nFor example \nThose pad templates are registered during the _class_init function with the gst_element_class_add_pad_template For this function you need a handle the GstPadTemplate which you can create from the static pad template with gst_static_pad_template_get See below for more details on this. \nPads are created from these static templates in the element s _init function using gst_pad_new_from_static_template In order to create a new pad from this template using gst_pad_new_from_static_template you will need to declare the pad template as a global variable. More on this subject in Specifying the pads. \nThe last argument in a template is its type or list of supported types. In this example we use ANY which means that this element will accept all input. In real life situations you would set a media type and optionally a set of properties to make sure that only supported input will come in. This representation should be a string that starts with a media type then a set of comma separates properties with their supported values. In case of an audio filter that supports raw integer bit audio mono or stereo at any samplerate the correct template would look like this \nValues surrounded by curly brackets and are lists values surrounded by square brackets and are ranges. Multiple sets of types are supported too and should be separated by a semicolon Later in the chapter on pads we will see how to use types to know the exact format of a stream Specifying the pads. \nEach element has two functions which are used for construction of an element. The _class_init function which is used to initialise the class only once specifying what signals arguments and virtual functions the class has and setting up global state and the _init function which is used to initialise a specific instance of this type. \nOnce we have written code defining all the parts of the plugin we need to write the plugin_init function. This is a special function which is called as soon as the plugin is loaded and should return TRUE or FALSE depending on whether it loaded initialized any dependencies correctly. Also in this function any supported element type in the plugin should be registered. \nNote that the information returned by the plugin_init function will be cached in a central registry. For this reason it is important that the same information is always returned by the function for example it must not make element factories available based on runtime conditions. If an element can only work in certain conditions for example if the soundcard is not being used by some other process this must be reflected by the element being unable to enter the READY state if unavailable rather than the plugin attempting to deny existence of the plugin. \n"});