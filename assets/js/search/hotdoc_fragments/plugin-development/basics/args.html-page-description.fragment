fragment_downloaded_cb({"url": "plugin-development/basics/args.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"args.md\">\n        <h1 id=\"adding-properties\">Adding Properties</h1>\n<p>The primary and most important way of controlling how an element\nbehaves, is through GObject properties. GObject properties are defined\nin the <code>_class_init ()</code> function. The element optionally implements a\n<code>_get_property ()</code> and a <code>_set_property ()</code> function. These functions\nwill be notified if an application changes or requests the value of a\nproperty, and can then fill in the value or take action required for\nthat property to change value internally.</p>\n<p>You probably also want to keep an instance variable around with the\ncurrently configured value of the property that you use in the get and\nset functions. Note that <code>GObject</code> will not automatically set your\ninstance variable to the default value, you will have to do that in the\n<code>_init ()</code> function of your element.</p>\n<pre><code class=\"language-c\">\n/* properties */\nenum {\n  PROP_0,\n  PROP_SILENT\n  /* FILL ME */\n};\n\nstatic void gst_my_filter_set_property  (GObject      *object,\n                         guint         prop_id,\n                         const GValue *value,\n                         GParamSpec   *pspec);\nstatic void gst_my_filter_get_property  (GObject      *object,\n                         guint         prop_id,\n                         GValue       *value,\n                         GParamSpec   *pspec);\n\nstatic void\ngst_my_filter_class_init (GstMyFilterClass *klass)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (klass);\n\n  /* define virtual function pointers */\n  object_class-&gt;set_property = gst_my_filter_set_property;\n  object_class-&gt;get_property = gst_my_filter_get_property;\n\n  /* define properties */\n  g_object_class_install_property (object_class, PROP_SILENT,\n    g_param_spec_boolean (\"silent\", \"Silent\",\n              \"Whether to be very verbose or not\",\n              FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));\n}\n\nstatic void\ngst_my_filter_set_property (GObject      *object,\n                guint         prop_id,\n                const GValue *value,\n                GParamSpec   *pspec)\n{\n  GstMyFilter *filter = GST_MY_FILTER (object);\n\n  switch (prop_id) {\n    case PROP_SILENT:\n      filter-&gt;silent = g_value_get_boolean (value);\n      g_print (\"Silent argument was changed to %s\\n\",\n           filter-&gt;silent ? \"true\" : \"false\");\n      break;\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n  }\n}\n\nstatic void\ngst_my_filter_get_property (GObject    *object,\n                guint       prop_id,\n                GValue     *value,\n                GParamSpec *pspec)\n{\n  GstMyFilter *filter = GST_MY_FILTER (object);\n\n  switch (prop_id) {\n    case PROP_SILENT:\n      g_value_set_boolean (value, filter-&gt;silent);\n      break;\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n  }\n}\n</code></pre>\n<p>The above is a very simple example of how properties are used. Graphical\napplications will use these properties and will display a\nuser-controllable widget with which these properties can be changed.\nThis means that - for the property to be as user-friendly as possible -\nyou should be as exact as possible in the definition of the property.\nNot only in defining ranges in between which valid properties can be\nlocated (for integers, floats, etc.), but also in using very descriptive\n(better yet: internationalized) strings in the definition of the\nproperty, and if possible using enums and flags instead of integers. The\nGObject documentation describes these in a very complete way, but below,\nwe'll give a short example of where this is useful. Note that using\nintegers here would probably completely confuse the user, because they\nmake no sense in this context. The example is stolen from videotestsrc.</p>\n<pre><code class=\"language-c\">typedef enum {\n  GST_VIDEOTESTSRC_SMPTE,\n  GST_VIDEOTESTSRC_SNOW,\n  GST_VIDEOTESTSRC_BLACK\n} GstVideotestsrcPattern;\n\n[..]\n\n#define GST_TYPE_VIDEOTESTSRC_PATTERN (gst_videotestsrc_pattern_get_type ())\nstatic GType\ngst_videotestsrc_pattern_get_type (void)\n{\n  static GType videotestsrc_pattern_type = 0;\n\n  if (!videotestsrc_pattern_type) {\n    static GEnumValue pattern_types[] = {\n      { GST_VIDEOTESTSRC_SMPTE, \"SMPTE 100% color bars\",    \"smpte\" },\n      { GST_VIDEOTESTSRC_SNOW,  \"Random (television snow)\", \"snow\"  },\n      { GST_VIDEOTESTSRC_BLACK, \"0% Black\",                 \"black\" },\n      { 0, NULL, NULL },\n    };\n\n    videotestsrc_pattern_type =\n    g_enum_register_static (\"GstVideotestsrcPattern\",\n                pattern_types);\n  }\n\n  return videotestsrc_pattern_type;\n}\n\n[..]\n\nstatic void\ngst_videotestsrc_class_init (GstvideotestsrcClass *klass)\n{\n[..]\n  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_PATTERN,\n    g_param_spec_enum (\"pattern\", \"Pattern\",\n               \"Type of test pattern to generate\",\n                       GST_TYPE_VIDEOTESTSRC_PATTERN, GST_VIDEOTESTSRC_SMPTE,\n                       G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));\n[..]\n}\n\n</code></pre>\n\n        \n\n    </div>\n\n\n        "});