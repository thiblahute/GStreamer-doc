fragment_downloaded_cb({"url": "plugin-development/appendix/checklist-element.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"checklist-element.md\">\n        <h1 id=\"things-to-check-when-writing-an-element\">Things to check when writing an element</h1>\n<p>This chapter contains a fairly random selection of things to take care\nof when writing an element. It's up to you how far you're going to stick\nto those guidelines. However, keep in mind that when you're writing an\nelement and hope for it to be included in the mainstream GStreamer\ndistribution, it <em>has to</em> meet those requirements. As far as possible,\nwe will try to explain why those requirements are set.</p>\n<h2 id=\"about-states\">About states</h2>\n<ul>\n<li>\n<p>Make sure the state of an element gets reset when going to <code>NULL</code>.\nIdeally, this should set all object properties to their original\nstate. This function should also be called from _init.</p>\n</li>\n<li>\n<p>Make sure an element forgets <em>everything</em> about its contained stream\nwhen going from <code>PAUSED</code> to <code>READY</code>. In <code>READY</code>, all stream states\nare reset. An element that goes from <code>PAUSED</code> to <code>READY</code> and back to\n<code>PAUSED</code> should start reading the stream from the start again.</p>\n</li>\n<li>\n<p>People that use <code>gst-launch</code> for testing have the tendency to not\ncare about cleaning up. This is <em>wrong</em>. An element should be tested\nusing various applications, where testing not only means to \u201cmake\nsure it doesn't crash\u201d, but also to test for memory leaks using\ntools such as <code>valgrind</code>. Elements have to be reusable in a pipeline\nafter having been reset.</p>\n</li>\n</ul>\n<h2 id=\"debugging\">Debugging</h2>\n<ul>\n<li>\n<p>Elements should <em>never</em> use their standard output for debugging\n(using functions such as <code>printf ()</code> or <code>g_print ()</code>). Instead, elements should use the logging\nfunctions provided by GStreamer, named <code>GST_DEBUG ()</code>, <code>GST_LOG ()</code>,\n<code>GST_INFO ()</code>, <code>GST_WARNING ()</code> and <code>GST_ERROR ()</code>. The various\nlogging levels can be turned on and off at runtime and can thus be\nused for solving issues as they turn up. Instead of <code>GST_LOG ()</code> (as\nan example), you can also use <code>GST_LOG_OBJECT ()</code> to print the object that you're logging output for.</p>\n</li>\n<li>\n<p>Ideally, elements should use their own debugging category. Most\nelements use the following code to do that:</p>\n<pre><code class=\"language-c\">GST_DEBUG_CATEGORY_STATIC (myelement_debug);\n#define GST_CAT_DEFAULT myelement_debug\n\n[..]\n\nstatic void\ngst_myelement_class_init (GstMyelementClass *klass)\n{\n[..]\n  GST_DEBUG_CATEGORY_INIT (myelement_debug, \"myelement\",\n               0, \"My own element\");\n}\n\n</code></pre>\n<p>At runtime, you can turn on debugging using the commandline option\n<code>--gst-debug=myelement:5</code>.</p>\n</li>\n<li>\n<p>Elements should use GST_DEBUG_FUNCPTR when setting pad functions\nor overriding element class methods, for example:</p>\n<pre><code class=\"language-c\">gst_pad_set_event_func (myelement-&gt;srcpad,\n    GST_DEBUG_FUNCPTR (my_element_src_event));\n\n</code></pre>\n<p>This makes debug output much easier to read later on.</p>\n</li>\n<li>\n<p>Elements that are aimed for inclusion into one of the GStreamer\nmodules should ensure consistent naming of the element name,\nstructures and function names. For example, if the element type is\nGstYellowFooDec, functions should be prefixed with\ngst_yellow_foo_dec_ and the element should be registered as\n'yellowfoodec'. Separate words should be separate in this scheme, so\nit should be GstFooDec and gst_foo_dec, and not GstFoodec and\ngst_foodec.</p>\n</li>\n</ul>\n<h2 id=\"querying-events-and-the-like\">Querying, events and the like</h2>\n<ul>\n<li>\n<p>All elements to which it applies (sources, sinks, demuxers) should\nimplement query functions on their pads, so that applications and\nneighbour elements can request the current position, the stream\nlength (if known) and so on.</p>\n</li>\n<li>\n<p>Elements should make sure they forward events they do not handle\nwith gst_pad_event_default (pad, parent, event) instead of just\ndropping them. Events should never be dropped unless specifically\nintended.</p>\n</li>\n<li>\n<p>Elements should make sure they forward queries they do not handle\nwith gst_pad_query_default (pad, parent, query) instead of just\ndropping them.</p>\n</li>\n</ul>\n<h2 id=\"testing-your-element\">Testing your element</h2>\n<ul>\n<li>\n<p><code>gst-launch</code> is <em>not</em> a good tool to show that your element is\nfinished. Applications such as Rhythmbox and Totem (for GNOME) or\nAmaroK (for KDE) <em>are</em>. <code>gst-launch</code> will not test various things\nsuch as proper clean-up on reset, event handling, querying and so\non.</p>\n</li>\n<li>\n<p>Parsers and demuxers should make sure to check their input. Input\ncannot be trusted. Prevent possible buffer overflows and the like.\nFeel free to error out on unrecoverable stream errors. Test your\ndemuxer using stream corruption elements such as <code>breakmydata</code>\n(included in gst-plugins). It will randomly insert, delete and\nmodify bytes in a stream, and is therefore a good test for\nrobustness. If your element crashes when adding this element, your\nelement needs fixing. If it errors out properly, it's good enough.\nIdeally, it'd just continue to work and forward data as much as\npossible.</p>\n</li>\n<li>\n<p>Demuxers should not assume that seeking works. Be prepared to work\nwith unseekable input streams (e.g. network sources) as well.</p>\n</li>\n<li>\n<p>Sources and sinks should be prepared to be assigned another clock\nthen the one they expose themselves. Always use the provided clock\nfor synchronization, else you'll get A/V sync issues.</p>\n</li>\n</ul>\n\n        \n\n    </div>\n\n\n        "});