fragment_downloaded_cb({"url": "plugin-development/advanced/media-types.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"media-types.md\">\n        <h1 id=\"media-types-and-properties\">Media Types and Properties</h1>\n<p>There is a very large set of possible media types that may be used to pass\ndata between elements. Indeed, each new element that is defined may use\na new data format (though unless at least one other element recognises\nthat format, it will be most likely be useless since nothing will be\nable to link with it).</p>\n<p>In order for media types to be useful, and for systems like autopluggers to\nwork, it is necessary that all elements agree on the media type definitions,\nand which properties are required for each media type. The GStreamer framework\nitself simply provides the ability to define media types and parameters, but\ndoes not fix the meaning of media types and parameters, and does not enforce\nstandards on the creation of new media types. This is a matter for a policy to\ndecide, not technical systems to enforce.</p>\n<p>For now, the policy is simple:</p>\n<ul>\n<li>\n<p>Do not create a new media type if you could use one which already exists.</p>\n</li>\n<li>\n<p>If creating a new media type, discuss it first with the other GStreamer\ndevelopers, on at least one of: IRC, mailing lists.</p>\n</li>\n<li>\n<p>Try to ensure that the name for a new format is as unlikely to\nconflict with anything else created already, and is not a more\ngeneralised name than it should be. For example: \"audio/compressed\"\nwould be too generalised a name to represent audio data compressed\nwith an mp3 codec. Instead \"audio/mp3\" might be an appropriate name,\nor \"audio/compressed\" could exist and have a property indicating the\ntype of compression used.</p>\n</li>\n<li>\n<p>Ensure that, when you do create a new media type, you specify it clearly,\nand get it added to the list of known media types so that other developers\ncan use the media type correctly when writing their elements.</p>\n</li>\n</ul>\n<h2 id=\"building-a-simple-format-for-testing\">Building a Simple Format for Testing</h2>\n<p>If you need a new format that has not yet been defined in our <a href=\"../../#list-of-defined-types\">List of\nDefined Types</a>, you will want to have some\ngeneral guidelines on media type naming, properties and such. A media\ntype would ideally be equivalent to the Mime-type defined by IANA; else,\nit should be in the form type/x-name, where type is the sort of data\nthis media type handles (audio, video, ...) and name should be something\nspecific for this specific type. Audio and video media types should try\nto support the general audio/video properties (see the list), and can\nuse their own properties, too. To get an idea of what properties we\nthink are useful, see (again) the list.</p>\n<p>Take your time to find the right set of properties for your type. There\nis no reason to hurry. Also, experimenting with this is generally a good\nidea. Experience learns that theoretically thought-out types are good,\nbut they still need practical use to assure that they serve their needs.\nMake sure that your property names do not clash with similar properties\nused in other types. If they match, make sure they mean the same thing;\nproperties with different types but the same names are <em>not</em> allowed.</p>\n<h2 id=\"typefind-functions-and-autoplugging\">Typefind Functions and Autoplugging</h2>\n<p>With only <em>defining</em> the types, we're not yet there. In order for a\nrandom data file to be recognized and played back as such, we need a way\nof recognizing their type out of the blue. For this purpose,\n\u201ctypefinding\u201d was introduced. Typefinding is the process of detecting\nthe type of a data stream. Typefinding consists of two separate parts:\nfirst, there's an unlimited number of functions that we call <em>typefind\nfunctions</em>, which are each able to recognize one or more types from an\ninput stream. Then, secondly, there's a small engine which registers and\ncalls each of those functions. This is the typefind core. On top of this\ntypefind core, you would normally write an autoplugger, which is able to\nuse this type detection system to dynamically build a pipeline around an\ninput stream. Here, we will focus only on typefind functions.</p>\n<p>A typefind function usually lives in\n<code>gst-plugins-base/gst/typefind/gsttypefindfunctions.c</code>, unless there's a\ngood reason (like library dependencies) to put it elsewhere. The reason\nfor this centralization is to reduce the number of plugins that need to\nbe loaded in order to detect a stream's type. Below is an example that\nwill recognize AVI files, which start with a \u201cRIFF\u201d tag, then the size\nof the file and then an \u201cAVI\u201d tag:</p>\n<pre><code class=\"language-c\">static void\ngst_my_typefind_function (GstTypeFind *tf,\n              gpointer     data)\n{\n  guint8 *data = gst_type_find_peek (tf, 0, 12);\n\n  if (data &amp;&amp;\n      GUINT32_FROM_LE (&amp;((guint32 *) data)[0]) == GST_MAKE_FOURCC ('R','I','F','F') &amp;&amp;\n      GUINT32_FROM_LE (&amp;((guint32 *) data)[2]) == GST_MAKE_FOURCC ('A','V','I',' ')) {\n    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM,\n               gst_caps_new_simple (\"video/x-msvideo\", NULL));\n  }\n}\n\nstatic gboolean\nplugin_init (GstPlugin *plugin)\n{\n  if (!gst_type_find_register (plugin, \"\", GST_RANK_PRIMARY,\n                   gst_my_typefind_function, \"avi\",\n                   gst_caps_new_simple (\"video/x-msvideo\",\n                            NULL), NULL))\n    return FALSE;\n}\n\n</code></pre>\n<p>Note that <code>gst-plugins/gst/typefind/gsttypefindfunctions.c</code> has some\nsimplification macros to decrease the amount of code. Make good use of\nthose if you want to submit typefinding patches with new typefind\nfunctions.</p>\n<p>Autoplugging has been discussed in great detail in the Application\nDevelopment Manual.</p>\n<h2 id=\"list-of-defined-media-types\">List of Defined Media Types</h2>\n<p>Below is a list of all the defined types in GStreamer. They are split up\nin separate tables for audio, video, container, subtitle and other\ntypes, for the sake of readability. Below each table might follow a list\nof notes that apply to that table. In the definition of each type, we\ntry to follow the types and rules as defined by\n<a href=\"http://www.iana.org/assignments/media-types\">IANA</a> for as far as\npossible.</p>\n<p>Jump directly to a specific table:</p>\n<ul>\n<li>\n<p><a href=\"../../#table-of-audio-types\">Table of Audio Types</a></p>\n</li>\n<li>\n<p><a href=\"../../#table-of-video-types\">Table of Video Types</a></p>\n</li>\n<li>\n<p><a href=\"../../#table-of-container-types\">Table of Container Types</a></p>\n</li>\n<li>\n<p><a href=\"../../#table-of-subtitle-types\">Table of Subtitle Types</a></p>\n</li>\n<li>\n<p><a href=\"../../#table-of-other-types\">Table of Other Types</a></p>\n</li>\n</ul>\n<p>Note that many of the properties are not <em>required</em>, but rather\n<em>optional</em> properties. This means that most of these properties can be\nextracted from the container header, but that - in case the container\nheader does not provide these - they can also be extracted by parsing\nthe stream header or the stream content. The policy is that your element\nshould provide the data that it knows about by only parsing its own\ncontent, not another element's content. Example: the AVI header provides\nsamplerate of the contained audio stream in the header. MPEG system\nstreams don't. This means that an AVI stream demuxer would provide\nsamplerate as a property for MPEG audio streams, whereas an MPEG demuxer\nwould not. A decoder needing this data would require a stream parser in\nbetween two extract this from the header or calculate it from the\nstream.</p>\n<table>\n<caption>Table of Audio Types</caption>\n<colgroup>\n<col width=\"14%\">\n<col width=\"85%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Media Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><em>All audio types.</em></td>\n</tr>\n<tr class=\"even\">\n<td>audio/*</td>\n<td><em>All audio types</em></td>\n</tr>\n<tr class=\"odd\">\n<td>channels</td>\n<td>integer</td>\n</tr>\n<tr class=\"even\">\n<td>channel-mask</td>\n<td>bitmask</td>\n</tr>\n<tr class=\"odd\">\n<td>format</td>\n<td>string</td>\n</tr>\n<tr class=\"even\">\n<td>layout</td>\n<td>string</td>\n</tr>\n<tr class=\"odd\">\n<td><em>All raw audio types.</em></td>\n</tr>\n<tr class=\"even\">\n<td>audio/x-raw</td>\n<td>Unstructured and uncompressed raw audio data.</td>\n</tr>\n<tr class=\"odd\">\n<td><em>All encoded audio types.</em></td>\n</tr>\n<tr class=\"even\">\n<td>audio/x-ac3</td>\n<td>AC-3 or A52 audio streams.</td>\n</tr>\n<tr class=\"odd\">\n<td>audio/x-adpcm</td>\n<td>ADPCM Audio streams.</td>\n</tr>\n<tr class=\"even\">\n<td>block_align</td>\n<td>integer</td>\n</tr>\n<tr class=\"odd\">\n<td>audio/x-cinepak</td>\n<td>Audio as provided in a Cinepak (Quicktime) stream.</td>\n</tr>\n<tr class=\"even\">\n<td>audio/x-dv</td>\n<td>Audio as provided in a Digital Video stream.</td>\n</tr>\n<tr class=\"odd\">\n<td>audio/x-flac</td>\n<td>Free Lossless Audio codec (FLAC).</td>\n</tr>\n<tr class=\"even\">\n<td>audio/x-gsm</td>\n<td>Data encoded by the GSM codec.</td>\n</tr>\n<tr class=\"odd\">\n<td>audio/x-alaw</td>\n<td>A-Law Audio.</td>\n</tr>\n<tr class=\"even\">\n<td>audio/x-mulaw</td>\n<td>Mu-Law Audio.</td>\n</tr>\n<tr class=\"odd\">\n<td>audio/x-mace</td>\n<td>MACE Audio (used in Quicktime).</td>\n</tr>\n<tr class=\"even\">\n<td>audio/mpeg</td>\n<td>Audio data compressed using the MPEG audio encoding scheme.</td>\n</tr>\n<tr class=\"odd\">\n<td>framed</td>\n<td>boolean</td>\n</tr>\n<tr class=\"even\">\n<td>layer</td>\n<td>integer</td>\n</tr>\n<tr class=\"odd\">\n<td>bitrate</td>\n<td>integer</td>\n</tr>\n<tr class=\"even\">\n<td>audio/x-qdm2</td>\n<td>Data encoded by the QDM version 2 codec.</td>\n</tr>\n<tr class=\"odd\">\n<td>audio/x-pn-realaudio</td>\n<td>Realmedia Audio data.</td>\n</tr>\n<tr class=\"even\">\n<td>audio/x-speex</td>\n<td>Data encoded by the Speex audio codec</td>\n</tr>\n<tr class=\"odd\">\n<td>audio/x-vorbis</td>\n<td>Vorbis audio data</td>\n</tr>\n<tr class=\"even\">\n<td>audio/x-wma</td>\n<td>Windows Media Audio</td>\n</tr>\n<tr class=\"odd\">\n<td>audio/x-paris</td>\n<td>Ensoniq PARIS audio</td>\n</tr>\n<tr class=\"even\">\n<td>audio/x-svx</td>\n<td>Amiga IFF / SVX8 / SV16 audio</td>\n</tr>\n<tr class=\"odd\">\n<td>audio/x-nist</td>\n<td>Sphere NIST audio</td>\n</tr>\n<tr class=\"even\">\n<td>audio/x-voc</td>\n<td>Sound Blaster VOC audio</td>\n</tr>\n<tr class=\"odd\">\n<td>audio/x-ircam</td>\n<td>Berkeley/IRCAM/CARL audio</td>\n</tr>\n<tr class=\"even\">\n<td>audio/x-w64</td>\n<td>Sonic Foundry's 64 bit RIFF/WAV</td>\n</tr>\n</tbody>\n</table>\n<table>\n<caption>Table of Video Types</caption>\n<colgroup>\n<col width=\"14%\">\n<col width=\"85%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Media Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><em>All video types.</em></td>\n</tr>\n<tr class=\"even\">\n<td>video/*</td>\n<td><em>All video types</em></td>\n</tr>\n<tr class=\"odd\">\n<td>height</td>\n<td>integer</td>\n</tr>\n<tr class=\"even\">\n<td>framerate</td>\n<td>fraction</td>\n</tr>\n<tr class=\"odd\">\n<td>max-framerate</td>\n<td>fraction</td>\n</tr>\n<tr class=\"even\">\n<td>views</td>\n<td>integer</td>\n</tr>\n<tr class=\"odd\">\n<td>interlace-mode</td>\n<td>string</td>\n</tr>\n<tr class=\"even\">\n<td>chroma-site</td>\n<td>string</td>\n</tr>\n<tr class=\"odd\">\n<td>colorimetry</td>\n<td>string</td>\n</tr>\n<tr class=\"even\">\n<td>pixel-aspect-ratio</td>\n<td>fraction</td>\n</tr>\n<tr class=\"odd\">\n<td>format</td>\n<td>string</td>\n</tr>\n<tr class=\"even\">\n<td><em>All raw video types.</em></td>\n</tr>\n<tr class=\"odd\">\n<td>video/x-raw</td>\n<td>Unstructured and uncompressed raw video data.</td>\n</tr>\n<tr class=\"even\">\n<td><em>All encoded video types.</em></td>\n</tr>\n<tr class=\"odd\">\n<td>video/x-3ivx</td>\n<td>3ivx video.</td>\n</tr>\n<tr class=\"even\">\n<td>video/x-divx</td>\n<td>DivX video.</td>\n</tr>\n<tr class=\"odd\">\n<td>video/x-dv</td>\n<td>Digital Video.</td>\n</tr>\n<tr class=\"even\">\n<td>video/x-ffv</td>\n<td>FFMpeg video.</td>\n</tr>\n<tr class=\"odd\">\n<td>video/x-h263</td>\n<td>H-263 video.</td>\n</tr>\n<tr class=\"even\">\n<td>h263version</td>\n<td>string</td>\n</tr>\n<tr class=\"odd\">\n<td>video/x-h264</td>\n<td>H-264 video.</td>\n</tr>\n<tr class=\"even\">\n<td>video/x-huffyuv</td>\n<td>Huffyuv video.</td>\n</tr>\n<tr class=\"odd\">\n<td>video/x-indeo</td>\n<td>Indeo video.</td>\n</tr>\n<tr class=\"even\">\n<td>video/x-intel-h263</td>\n<td>H-263 video.</td>\n</tr>\n<tr class=\"odd\">\n<td>video/x-jpeg</td>\n<td>Motion-JPEG video.</td>\n</tr>\n<tr class=\"even\">\n<td>video/mpeg</td>\n<td>MPEG video.</td>\n</tr>\n<tr class=\"odd\">\n<td>systemstream</td>\n<td>boolean</td>\n</tr>\n<tr class=\"even\">\n<td>video/x-msmpeg</td>\n<td>Microsoft MPEG-4 video deviations.</td>\n</tr>\n<tr class=\"odd\">\n<td>video/x-msvideocodec</td>\n<td>Microsoft Video 1 (oldish codec).</td>\n</tr>\n<tr class=\"even\">\n<td>video/x-pn-realvideo</td>\n<td>Realmedia video.</td>\n</tr>\n<tr class=\"odd\">\n<td>video/x-rle</td>\n<td>RLE animation format.</td>\n</tr>\n<tr class=\"even\">\n<td>depth</td>\n<td>integer</td>\n</tr>\n<tr class=\"odd\">\n<td>palette_data</td>\n<td>GstBuffer</td>\n</tr>\n<tr class=\"even\">\n<td>video/x-svq</td>\n<td>Sorensen Video.</td>\n</tr>\n<tr class=\"odd\">\n<td>video/x-tarkin</td>\n<td>Tarkin video.</td>\n</tr>\n<tr class=\"even\">\n<td>video/x-theora</td>\n<td>Theora video.</td>\n</tr>\n<tr class=\"odd\">\n<td>video/x-vp3</td>\n<td>VP-3 video.</td>\n</tr>\n<tr class=\"even\">\n<td>video/x-wmv</td>\n<td>Windows Media Video</td>\n</tr>\n<tr class=\"odd\">\n<td>video/x-xvid</td>\n<td>XviD video.</td>\n</tr>\n<tr class=\"even\">\n<td><em>All image types.</em></td>\n</tr>\n<tr class=\"odd\">\n<td>image/gif</td>\n<td>Graphics Interchange Format.</td>\n</tr>\n<tr class=\"even\">\n<td>image/jpeg</td>\n<td>Joint Picture Expert Group Image.</td>\n</tr>\n<tr class=\"odd\">\n<td>image/png</td>\n<td>Portable Network Graphics Image.</td>\n</tr>\n<tr class=\"even\">\n<td>image/tiff</td>\n<td>Tagged Image File Format.</td>\n</tr>\n</tbody>\n</table>\n<table>\n<caption>Table of Container Types</caption>\n<colgroup>\n<col width=\"14%\">\n<col width=\"85%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Media Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>video/x-ms-asf</td>\n<td>Advanced Streaming Format (ASF).</td>\n</tr>\n<tr class=\"even\">\n<td>video/x-msvideo</td>\n<td>AVI.</td>\n</tr>\n<tr class=\"odd\">\n<td>video/x-dv</td>\n<td>Digital Video.</td>\n</tr>\n<tr class=\"even\">\n<td>video/x-matroska</td>\n<td>Matroska.</td>\n</tr>\n<tr class=\"odd\">\n<td>video/mpeg</td>\n<td>Motion Pictures Expert Group System Stream.</td>\n</tr>\n<tr class=\"even\">\n<td>application/ogg</td>\n<td>Ogg.</td>\n</tr>\n<tr class=\"odd\">\n<td>video/quicktime</td>\n<td>Quicktime.</td>\n</tr>\n<tr class=\"even\">\n<td>application/vnd.rn-realmedia</td>\n<td>RealMedia.</td>\n</tr>\n<tr class=\"odd\">\n<td>audio/x-wav</td>\n<td>WAV.</td>\n</tr>\n</tbody>\n</table>\n<table>\n<caption>Table of Subtitle Types</caption>\n<colgroup>\n<col width=\"14%\">\n<col width=\"85%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Media Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<table>\n<caption>Table of Other Types</caption>\n<colgroup>\n<col width=\"14%\">\n<col width=\"85%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Media Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n\n        \n\n    </div>\n\n\n        "});