fragment_downloaded_cb({"url": "plugin-development/advanced/media-types.html#page-description", "fragment": "There is a very large set of possible media types that may be used to pass data between elements. Indeed each new element that is defined may use a new data format though unless at least one other element recognises that format it will be most likely be useless since nothing will be able to link with it \nIn order for media types to be useful and for systems like autopluggers to work it is necessary that all elements agree on the media type definitions and which properties are required for each media type. The GStreamer framework itself simply provides the ability to define media types and parameters but does not fix the meaning of media types and parameters and does not enforce standards on the creation of new media types. This is a matter for a policy to decide not technical systems to enforce. \nFor now the policy is simple \nDo not create a new media type if you could use one which already exists. \nIf creating a new media type discuss it first with the other GStreamer developers on at least one of IRC mailing lists. \nTry to ensure that the name for a new format is as unlikely to conflict with anything else created already and is not a more generalised name than it should be. For example audio compressed would be too generalised a name to represent audio data compressed with an mp3 codec. Instead audio mp3 might be an appropriate name or audio compressed could exist and have a property indicating the type of compression used. \nEnsure that when you do create a new media type you specify it clearly and get it added to the list of known media types so that other developers can use the media type correctly when writing their elements. \nIf you need a new format that has not yet been defined in our List of Defined Types you will want to have some general guidelines on media type naming properties and such. A media type would ideally be equivalent to the Mime type defined by IANA else it should be in the form type x name where type is the sort of data this media type handles audio video and name should be something specific for this specific type. Audio and video media types should try to support the general audio video properties see the list and can use their own properties too. To get an idea of what properties we think are useful see again the list. \nTake your time to find the right set of properties for your type. There is no reason to hurry. Also experimenting with this is generally a good idea. Experience learns that theoretically thought out types are good but they still need practical use to assure that they serve their needs. Make sure that your property names do not clash with similar properties used in other types. If they match make sure they mean the same thing properties with different types but the same names are not allowed. \nWith only defining the types we re not yet there. In order for a random data file to be recognized and played back as such we need a way of recognizing their type out of the blue. For this purpose typefinding was introduced. Typefinding is the process of detecting the type of a data stream. Typefinding consists of two separate parts first there s an unlimited number of functions that we call typefind functions which are each able to recognize one or more types from an input stream. Then secondly there s a small engine which registers and calls each of those functions. This is the typefind core. On top of this typefind core you would normally write an autoplugger which is able to use this type detection system to dynamically build a pipeline around an input stream. Here we will focus only on typefind functions. \nA typefind function usually lives in gst plugins base gst typefind gsttypefindfunctions.c unless there s a good reason like library dependencies to put it elsewhere. The reason for this centralization is to reduce the number of plugins that need to be loaded in order to detect a stream s type. Below is an example that will recognize AVI files which start with a RIFF tag then the size of the file and then an AVI tag \nNote that gst plugins gst typefind gsttypefindfunctions.c has some simplification macros to decrease the amount of code. Make good use of those if you want to submit typefinding patches with new typefind functions. \nAutoplugging has been discussed in great detail in the Application Development Manual. \nBelow is a list of all the defined types in GStreamer. They are split up in separate tables for audio video container subtitle and other types for the sake of readability. Below each table might follow a list of notes that apply to that table. In the definition of each type we try to follow the types and rules as defined by IANA for as far as possible. \nJump directly to a specific table \nTable of Audio Types \nTable of Video Types \nTable of Container Types \nTable of Subtitle Types \nTable of Other Types \nNote that many of the properties are not required but rather optional properties. This means that most of these properties can be extracted from the container header but that in case the container header does not provide these they can also be extracted by parsing the stream header or the stream content. The policy is that your element should provide the data that it knows about by only parsing its own content not another element s content. Example the AVI header provides samplerate of the contained audio stream in the header. MPEG system streams don t. This means that an AVI stream demuxer would provide samplerate as a property for MPEG audio streams whereas an MPEG demuxer would not. A decoder needing this data would require a stream parser in between two extract this from the header or calculate it from the stream. \n"});