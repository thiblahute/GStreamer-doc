fragment_downloaded_cb({"url": "plugin-development/advanced/dparams.html#page-description", "fragment": "Warning this part describes and is outdated. \nSometimes object properties are not powerful enough to control the parameters that affect the behaviour of your element. When this is the case you can mark these parameters as being Controllable. Aware applications can use the controller subsystem to dynamically adjust the property values over time. \nThe controller subsystem is contained within the gstcontroller library. You need to include the header in your element s source file \nEven though the gstcontroller library may be linked into the host application you should make sure it is initialized in your plugin_init function \nIt makes no sense for all GObject parameter to be real time controlled. Therefore the next step is to mark controllable parameters. This is done by using the special flag GST_PARAM_CONTROLLABLE. when setting up GObject params in the _class_init method. \nIn the last section we learned how to mark GObject params as controllable. Application developers can then queue parameter changes for these parameters. The approach the controller subsystem takes is to make plugins responsible for pulling the changes in. This requires just one action \nThis call makes all parameter changes for the given timestamp active by adjusting the GObject properties of the element. Its up to the element to determine the synchronisation rate. \nFor video processing elements it is the best to synchronise for every frame. That means one would add the gst_object_sync_values call described in the previous section to the data processing function of the element. \nFor audio processing elements the case is not as easy as for video processing elements. The problem here is that audio has a much higher rate. For PAL video one will e.g. process full frames per second but for standard audio it will be samples. It is rarely useful to synchronise controllable parameters that often. The easiest solution is also to have just one synchronisation call per buffer processing. This makes the control rate depend on the buffer size. \nElements that need a specific control rate need to break their data processing loop to synchronise every n samples. \n"});