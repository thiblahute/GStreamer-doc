fragment_downloaded_cb({"url": "plugin-development/advanced/dparams.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"dparams.md\">\n<h1 id=\"supporting-dynamic-parameters\">Supporting Dynamic Parameters</h1>\n<p>Warning, this part describes 0.10 and is outdated.</p>\n<p>Sometimes object properties are not powerful enough to control the\nparameters that affect the behaviour of your element. When this is the\ncase you can mark these parameters as being Controllable. Aware\napplications can use the controller subsystem to dynamically adjust the\nproperty values over time.</p>\n<h2 id=\"getting-started\">Getting Started</h2>\n<p>The controller subsystem is contained within the <code>gstcontroller</code>\nlibrary. You need to include the header in your element's source file:</p>\n<pre><code class=\"language-c\">...\n#include &lt;gst/gst.h&gt;\n#include &lt;gst/controller/gstcontroller.h&gt;\n...\n\n</code></pre>\n<p>Even though the <code>gstcontroller</code> library may be linked into the host\napplication, you should make sure it is initialized in your\n<code>plugin_init</code> function:</p>\n<pre><code class=\"language-c\">  static gboolean\n  plugin_init (GstPlugin *plugin)\n  {\n    ...\n    /* initialize library */\n    gst_controller_init (NULL, NULL);\n    ...\n  }\n\n</code></pre>\n<p>It makes no sense for all GObject parameter to be real-time controlled.\nTherefore the next step is to mark controllable parameters. This is done\nby using the special flag <code>GST_PARAM_CONTROLLABLE</code>. when setting up\nGObject params in the <code>_class_init</code> method.</p>\n<pre><code class=\"language-c\">  g_object_class_install_property (gobject_class, PROP_FREQ,\n      g_param_spec_double (\"freq\", \"Frequency\", \"Frequency of test signal\",\n          0.0, 20000.0, 440.0,\n          G_PARAM_READWRITE | GST_PARAM_CONTROLLABLE | G_PARAM_STATIC_STRINGS));\n\n</code></pre>\n<h2 id=\"the-data-processing-loop\">The Data Processing Loop</h2>\n<p>In the last section we learned how to mark GObject params as\ncontrollable. Application developers can then queue parameter changes\nfor these parameters. The approach the controller subsystem takes is to\nmake plugins responsible for pulling the changes in. This requires just\none action:</p>\n<pre><code class=\"language-c\">    gst_object_sync_values(element,timestamp);\n\n</code></pre>\n<p>This call makes all parameter-changes for the given timestamp active by\nadjusting the GObject properties of the element. Its up to the element\nto determine the synchronisation rate.</p>\n<h3 id=\"the-data-processing-loop-for-video-elements\">The Data Processing Loop for Video Elements</h3>\n<p>For video processing elements it is the best to synchronise for every\nframe. That means one would add the <code>gst_object_sync_values()</code> call\ndescribed in the previous section to the data processing function of the\nelement.</p>\n<h3 id=\"the-data-processing-loop-for-audio-elements\">The Data Processing Loop for Audio Elements</h3>\n<p>For audio processing elements the case is not as easy as for video\nprocessing elements. The problem here is that audio has a much higher\nrate. For PAL video one will e.g. process 25 full frames per second, but\nfor standard audio it will be 44100 samples. It is rarely useful to\nsynchronise controllable parameters that often. The easiest solution is\nalso to have just one synchronisation call per buffer processing. This\nmakes the control-rate depend on the buffer size.</p>\n<p>Elements that need a specific control-rate need to break their data\nprocessing loop to synchronise every n-samples.</p>\n\n</div>\n\n\n        "});