fragment_downloaded_cb({"url": "plugin-development/advanced/negotiation.html#page-description", "fragment": "Caps negotiation is the act of finding a media format GstCaps between elements that they can handle. This process in GStreamer can in most cases find an optimal solution for the complete pipeline. In this section we explain how this works. \nIn GStreamer negotiation of the media format always follows the following simple rules \nA downstream element suggest a format on its sinkpad and places the suggestion in the result of the CAPS query performed on the sinkpad. See also Implementing a CAPS query function. \nAn upstream element decides on a format. It sends the selected media format downstream on its source pad with a CAPS event. Downstream elements reconfigure themselves to handle the media type in the CAPS event on the sinkpad. \nA downstream element can inform upstream that it would like to suggest a new format by sending a RECONFIGURE event upstream. The RECONFIGURE event simply instructs an upstream element to restart the negotiation phase. Because the element that sent out the RECONFIGURE event is now suggesting another format the format in the pipeline might change. \nIn addition to the CAPS and RECONFIGURE event and the CAPS query there is an ACCEPT_CAPS query to quickly check if a certain caps can be accepted by an element. \nAll negotiation follows these simple rules. Let s take a look at some typical uses cases and how negotiation happens. \nIn what follows we will look at some use cases for push mode scheduling. The pull mode scheduling negotiation phase is discussed in Pull mode Caps negotiation and is actually similar as we will see. \nSince the sink pads only suggest formats and the source pads need to decide the most complicated work is done in the source pads. We can identify caps negotiation use cases for the source pads \nFixed negotiation. An element can output one format only. See Fixed negotiation. \nTransform negotiation. There is a fixed transform between the input and output format of the element usually based on some element property. The caps that the element will produce depend on the upstream caps and the caps that the element can accept depend on the downstream caps. See Transform negotiation. \nDynamic negotiation. An element can output many formats. See Dynamic negotiation. \nIn this case the source pad can only produce a fixed format. Usually this format is encoded inside the media. No downstream element can ask for a different format the only way that the source pad will renegotiate is when the element decides to change the caps itself. \nElements that could implement fixed caps on their source pads are in general all elements that are not renegotiable. Examples include \nA typefinder since the type found is part of the actual data stream and can thus not be re negotiated. The typefinder will look at the stream of bytes figure out the type send a CAPS event with the caps and then push buffers of the type. \nPretty much all demuxers since the contained elementary data streams are defined in the file headers and thus not renegotiable. \nSome decoders where the format is embedded in the data stream and not part of the peercaps and where the decoder itself is not reconfigurable too. \nSome sources that produce a fixed format. \ngst_pad_use_fixed_caps is used on the source pad with fixed caps. As long as the pad is not negotiated the default CAPS query will return the caps presented in the padtemplate. As soon as the pad is negotiated the CAPS query will return the negotiated caps and nothing else These are the relevant code snippets for fixed caps source pads. \nThe fixed caps can then be set on the pad by calling gst_pad_set_caps \nThese types of elements also don t have a relation between the input format and the output format the input caps simply don t contain the information needed to produce the output caps. \nAll other elements that need to be configured for the format should implement full caps negotiation which will be explained in the next few sections. \nIn this negotiation technique there is a fixed transform between the element input caps and the output caps. This transformation could be parameterized by element properties but not by the content of the stream see Fixed negotiation for that use case \nThe caps that the element can accept depend on the fixed transformation downstream caps. The caps that the element can produce depend on the fixed transformation of the upstream caps. \nThis type of element can usually set caps on its source pad from the _event function on the sink pad when it received the CAPS event. This means that the caps transform function transforms a fixed caps into another fixed caps. Examples of elements include \nVideobox. It adds configurable border around a video frame depending on object properties. \nIdentity elements. All elements that don t change the format of the data only the content. Video and audio effects are an example. Other examples include elements that inspect the stream. \nSome decoders and encoders where the output format is defined by input format like mulawdec and mulawenc. These decoders usually have no headers that define the content of the stream. They are usually more like conversion elements. \nBelow is an example of a negotiation steps of a typical transform element. In the sink pad CAPS event handler we compute the caps for the source pad and set those. \nA last negotiation method is the most complex and powerful dynamic negotiation. \nLike with the transform negotiation in Transform negotiation dynamic negotiation will perform a transformation on the downstream upstream caps. Unlike the transform negotiation this transform will convert fixed caps to unfixed caps. This means that the sink pad input caps can be converted into unfixed multiple formats. The source pad will have to choose a format from all the possibilities. It would usually like to choose a format that requires the least amount of effort to produce but it does not have to be. The selection of the format should also depend on the caps that can be accepted downstream see a QUERY_CAPS function in Implementing a CAPS query function \nA typical flow goes like this \nCaps are received on the sink pad of the element. \nIf the element prefers to operate in passthrough mode check if downstream accepts the caps with the ACCEPT_CAPS query. If it does we can complete negotiation and we can operate in passthrough mode. \nCalculate the possible caps for the source pad. \nQuery the downstream peer pad for the list of possible caps. \nSelect from the downstream list the first caps that you can transform to and set this as the output caps. You might have to fixate the caps to some reasonable defaults to construct fixed caps. \nExamples of this type of elements include \nConverter elements such as videoconvert audioconvert audioresample videoscale \nSource elements such as audiotestsrc videotestsrc v4l2src pulsesrc \nLet s look at the example of an element that can convert between samplerates so where input and output samplerate don t have to be the same \nUpstream negotiation s primary use is to renegotiate part of an already negotiated pipeline to a new format. Some practical examples include to select a different video size because the size of the video window changed and the video output itself is not capable of rescaling or because the audio channel configuration changed. \nUpstream caps renegotiation is requested by sending a GST_EVENT_RECONFIGURE event upstream. The idea is that it will instruct the upstream element to reconfigure its caps by doing a new query for the allowed caps and then choosing a new caps. The element that sends out the RECONFIGURE event would influence the selection of the new caps by returning the new preferred caps from its GST_QUERY_CAPS query function. The RECONFIGURE event will set the GST_PAD_FLAG_NEED_RECONFIGURE on all pads that it travels over. \nIt is important to note here that different elements actually have different responsibilities here \nElements that want to propose a new format upstream need to first check if the new caps are acceptable upstream with an ACCEPT_CAPS query. Then they would send a RECONFIGURE event and be prepared to answer the CAPS query with the new preferred format. It should be noted that when there is no upstream element that can or wants to renegotiate the element needs to deal with the currently configured format. \nElements that operate in transform negotiation according to Transform negotiation pass the RECONFIGURE event upstream. Because these elements simply do a fixed transform based on the upstream caps they need to send the event upstream so that it can select a new format. \nElements that operate in fixed negotiation Fixed negotiation drop the RECONFIGURE event. These elements can t reconfigure and their output caps don t depend on the upstream caps so the event can be dropped. \nElements that can be reconfigured on the source pad source pads implementing dynamic negotiation in Dynamic negotiation should check its NEED_RECONFIGURE flag with gst_pad_check_reconfigure and it should start renegotiation when the function returns TRUE. \nA _query function with the GST_QUERY_CAPS query type is called when a peer element would like to know which formats this pad supports and in what order of preference. The return value should be all formats that this elements supports taking into account limitations of peer elements further downstream or upstream sorted by order of preference highest preference first. \nWRITEME the mechanism of pull mode negotiation is not yet fully understood. \nUsing all the knowledge you ve acquired by reading this chapter you should be able to write an element that does correct caps negotiation. If in doubt look at other elements of the same type in our git repository to get an idea of how they do what you want to do. \n"});