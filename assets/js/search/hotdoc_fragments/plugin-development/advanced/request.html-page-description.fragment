fragment_downloaded_cb({"url": "plugin-development/advanced/request.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"request.md\">\n<h1 id=\"request-and-sometimes-pads\">Request and Sometimes pads</h1>\n<p>Until now, we've only dealt with pads that are always available.\nHowever, there's also pads that are only being created in some cases, or\nonly if the application requests the pad. The first is called a\n<em>sometimes</em>; the second is called a <em>request</em> pad. The availability of a\npad (always, sometimes or request) can be seen in a pad's template. This\nchapter will discuss when each of the two is useful, how they are\ncreated and when they should be disposed.</p>\n<h2 id=\"sometimes-pads\">Sometimes pads</h2>\n<p>A \u201csometimes\u201d pad is a pad that is created under certain conditions, but\nnot in all cases. This mostly depends on stream content: demuxers will\ngenerally parse the stream header, decide what elementary (video, audio,\nsubtitle, etc.) streams are embedded inside the system stream, and will\nthen create a sometimes pad for each of those elementary streams. At its\nown choice, it can also create more than one instance of each of those\nper element instance. The only limitation is that each newly created pad\nshould have a unique name. Sometimes pads are disposed when the stream\ndata is disposed, too (i.e. when going from PAUSED to the READY state).\nYou should <em>not</em> dispose the pad on EOS, because someone might\nre-activate the pipeline and seek back to before the end-of-stream\npoint. The stream should still stay valid after EOS, at least until the\nstream data is disposed. In any case, the element is always the owner of\nsuch a pad.</p>\n<p>The example code below will parse a text file, where the first line is a\nnumber (n). The next lines all start with a number (0 to n-1), which is\nthe number of the source pad over which the data should be sent.</p>\n<pre><code>3\n0: foo\n1: bar\n0: boo\n2: bye\n\n</code></pre>\n<p>The code to parse this file and create the dynamic \u201csometimes\u201d pads,\nlooks like this:</p>\n<pre><code class=\"language-c\">\ntypedef struct _GstMyFilter {\n[..]\n  gboolean firstrun;\n  GList *srcpadlist;\n} GstMyFilter;\n\nstatic GstStaticPadTemplate src_factory =\nGST_STATIC_PAD_TEMPLATE (\n  \"src_%u\",\n  GST_PAD_SRC,\n  GST_PAD_SOMETIMES,\n  GST_STATIC_CAPS (\"ANY\")\n);\n\nstatic void\ngst_my_filter_class_init (GstMyFilterClass *klass)\n{\n  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);\n[..]\n  gst_element_class_add_pad_template (element_class,\n    gst_static_pad_template_get (&amp;src_factory));\n[..]\n}\n\nstatic void\ngst_my_filter_init (GstMyFilter *filter)\n{\n[..]\n  filter-&gt;firstrun = TRUE;\n  filter-&gt;srcpadlist = NULL;\n}\n\n/*\n * Get one line of data - without newline.\n */\n\nstatic GstBuffer *\ngst_my_filter_getline (GstMyFilter *filter)\n{\n  guint8 *data;\n  gint n, num;\n\n  /* max. line length is 512 characters - for safety */\n  for (n = 0; n &lt; 512; n++) {\n    num = gst_bytestream_peek_bytes (filter-&gt;bs, &amp;data, n + 1);\n    if (num != n + 1)\n      return NULL;\n\n    /* newline? */\n    if (data[n] == '\\n') {\n      GstBuffer *buf = gst_buffer_new_allocate (NULL, n + 1, NULL);\n\n      gst_bytestream_peek_bytes (filter-&gt;bs, &amp;data, n);\n      gst_buffer_fill (buf, 0, data, n);\n      gst_buffer_memset (buf, n, '\\0', 1);\n      gst_bytestream_flush_fast (filter-&gt;bs, n + 1);\n\n      return buf;\n    }\n  }\n}\n\nstatic void\ngst_my_filter_loopfunc (GstElement *element)\n{\n  GstMyFilter *filter = GST_MY_FILTER (element);\n  GstBuffer *buf;\n  GstPad *pad;\n  GstMapInfo map;\n  gint num, n;\n\n  /* parse header */\n  if (filter-&gt;firstrun) {\n    gchar *padname;\n    guint8 id;\n\n    if (!(buf = gst_my_filter_getline (filter))) {\n      gst_element_error (element, STREAM, READ, (NULL),\n             (\"Stream contains no header\"));\n      return;\n    }\n    gst_buffer_extract (buf, 0, &amp;id, 1);\n    num = atoi (id);\n    gst_buffer_unref (buf);\n\n    /* for each of the streams, create a pad */\n    for (n = 0; n &lt; num; n++) {\n      padname = g_strdup_printf (\"src_%u\", n);\n      pad = gst_pad_new_from_static_template (src_factory, padname);\n      g_free (padname);\n\n      /* here, you would set _event () and _query () functions */\n\n      /* need to activate the pad before adding */\n      gst_pad_set_active (pad, TRUE);\n\n      gst_element_add_pad (element, pad);\n      filter-&gt;srcpadlist = g_list_append (filter-&gt;srcpadlist, pad);\n    }\n  }\n\n  /* and now, simply parse each line and push over */\n  if (!(buf = gst_my_filter_getline (filter))) {\n    GstEvent *event = gst_event_new (GST_EVENT_EOS);\n    GList *padlist;\n\n    for (padlist = srcpadlist;\n         padlist != NULL; padlist = g_list_next (padlist)) {\n      pad = GST_PAD (padlist-&gt;data);\n      gst_pad_push_event (pad, gst_event_ref (event));\n    }\n    gst_event_unref (event);\n    /* pause the task here */\n    return;\n  }\n\n  /* parse stream number and go beyond the ':' in the data */\n  gst_buffer_map (buf, &amp;map, GST_MAP_READ);\n  num = atoi (map.data[0]);\n  if (num &gt;= 0 &amp;&amp; num &lt; g_list_length (filter-&gt;srcpadlist)) {\n    pad = GST_PAD (g_list_nth_data (filter-&gt;srcpadlist, num);\n\n    /* magic buffer parsing foo */\n    for (n = 0; map.data[n] != ':' &amp;&amp;\n                map.data[n] != '\\0'; n++) ;\n    if (map.data[n] != '\\0') {\n      GstBuffer *sub;\n\n      /* create region copy that starts right past the space. The reason\n       * that we don't just forward the data pointer is because the\n       * pointer is no longer the start of an allocated block of memory,\n       * but just a pointer to a position somewhere in the middle of it.\n       * That cannot be freed upon disposal, so we'd either crash or have\n       * a memleak. Creating a region copy is a simple way to solve that. */\n      sub = gst_buffer_copy_region (buf, GST_BUFFER_COPY_ALL,\n          n + 1, map.size - n - 1);\n      gst_pad_push (pad, sub);\n    }\n  }\n  gst_buffer_unmap (buf, &amp;map);\n  gst_buffer_unref (buf);\n}\n\n\n</code></pre>\n<p>Note that we use a lot of checks everywhere to make sure that the\ncontent in the file is valid. This has two purposes: first, the file\ncould be erroneous, in which case we prevent a crash. The second and\nmost important reason is that - in extreme cases - the file could be\nused maliciously to cause undefined behaviour in the plugin, which might\nlead to security issues. <em>Always</em> assume that the file could be used to\ndo bad things.</p>\n<h2 id=\"request-pads\">Request pads</h2>\n<p>\u201cRequest\u201d pads are similar to sometimes pads, except that request are\ncreated on demand of something outside of the element rather than\nsomething inside the element. This concept is often used in muxers,\nwhere - for each elementary stream that is to be placed in the output\nsystem stream - one sink pad will be requested. It can also be used in\nelements with a variable number of input or outputs pads, such as the\n<code>tee</code> (multi-output) or <code>input-selector</code> (multi-input) elements.</p>\n<p>To implement request pads, you need to provide a padtemplate with a\nGST_PAD_REQUEST presence and implement the <code>request_new_pad</code> virtual\nmethod in <code>GstElement</code>. To clean up, you will need to implement the\n<code>release_pad</code> virtual method.</p>\n<pre><code class=\"language-c\">\nstatic GstPad * gst_my_filter_request_new_pad   (GstElement     *element,\n                         GstPadTemplate *templ,\n                                                 const gchar    *name,\n                                                 const GstCaps  *caps);\n\nstatic void gst_my_filter_release_pad (GstElement *element,\n                                       GstPad *pad);\n\nstatic GstStaticPadTemplate sink_factory =\nGST_STATIC_PAD_TEMPLATE (\n  \"sink_%u\",\n  GST_PAD_SINK,\n  GST_PAD_REQUEST,\n  GST_STATIC_CAPS (\"ANY\")\n);\n\nstatic void\ngst_my_filter_class_init (GstMyFilterClass *klass)\n{\n  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);\n[..]\n  gst_element_class_add_pad_template (klass,\n    gst_static_pad_template_get (&amp;sink_factory));\n[..]\n  element_class-&gt;request_new_pad = gst_my_filter_request_new_pad;\n  element_class-&gt;release_pad = gst_my_filter_release_pad;\n}\n\nstatic GstPad *\ngst_my_filter_request_new_pad (GstElement     *element,\n                   GstPadTemplate *templ,\n                   const gchar    *name,\n                               const GstCaps  *caps)\n{\n  GstPad *pad;\n  GstMyFilterInputContext *context;\n\n  context = g_new0 (GstMyFilterInputContext, 1);\n  pad = gst_pad_new_from_template (templ, name);\n  gst_pad_set_element_private (pad, context);\n\n  /* normally, you would set _chain () and _event () functions here */\n\n  gst_element_add_pad (element, pad);\n\n  return pad;\n}\n\nstatic void\ngst_my_filter_release_pad (GstElement *element,\n                           GstPad *pad)\n{\n  GstMyFilterInputContext *context;\n\n  context = gst_pad_get_element_private (pad);\n  g_free (context);\n\n  gst_element_remove_pad (element, pad);\n}\n\n\n\n</code></pre>\n\n</div>\n\n\n        "});