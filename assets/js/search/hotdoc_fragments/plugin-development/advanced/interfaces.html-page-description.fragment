fragment_downloaded_cb({"url": "plugin-development/advanced/interfaces.html#page-description", "fragment": "Previously in the chapter Adding Properties we have introduced the concept of GObject properties of controlling an element s behaviour. This is very powerful but it has two big disadvantages first of all it is too generic and second it isn t dynamic. \nThe first disadvantage is related to the customizability of the end user interface that will be built to control the element. Some properties are more important than others. Some integer properties are better shown in a spin button widget whereas others would be better represented by a slider widget. Such things are not possible because the UI has no actual meaning in the application. A UI widget that represents a bitrate property is the same as a UI widget that represents the size of a video as long as both are of the same GParamSpec type. Another problem is that things like parameter grouping function grouping or parameter coupling are not really possible. \nThe second problem with parameters are that they are not dynamic. In many cases the allowed values for a property are not fixed but depend on things that can only be detected at runtime. The names of inputs for a TV card in a video4linux source element for example can only be retrieved from the kernel driver when we ve opened the device this only happens when the element goes into the READY state. This means that we cannot create an enum property type to show this to the user. \nThe solution to those problems is to create very specialized types of controls for certain often used controls. We use the concept of interfaces to achieve this. The basis of this all is the glib GTypeInterface type. For each case where we think it s useful we ve created interfaces which can be implemented by elements at their own will. \nOne important note interfaces do not replace properties. Rather interfaces should be built next to properties. There are two important reasons for this. First of all properties can be more easily introspected. Second properties can be specified on the commandline gst launch \nImplementing interfaces is initiated in the _get_type of your element. You can register one or more interfaces after having registered the type itself. Some interfaces have dependencies on other interfaces or can only be registered by certain types of elements. You will be notified of doing that wrongly when using the element it will quit with failed assertions which will explain what went wrong. If it does you need to register support for that interface before registering support for the interface that you re wanting to support. The example below explains how to add support for a simple interface with no further dependencies. \nOr more conveniently \nWRITEME \nWRITEME \nThe GstVideoOverlay interface is used for main purposes \nTo get a grab on the Window where the video sink element is going to render. This is achieved by either being informed about the Window identifier that the video sink element generated or by forcing the video sink element to use a specific Window identifier for rendering. \nTo force a redrawing of the latest video frame the video sink element displayed on the Window. Indeed if the GstPipeline is in GST _STATE _PAUSED state moving the Window around will damage its content. Application developers will want to handle the Expose events themselves and force the video sink element to refresh the Window s content. \nA plugin drawing video output in a video window will need to have that window at one stage or another. Passive mode simply means that no window has been given to the plugin before that stage so the plugin created the window by itself. In that case the plugin is responsible of destroying that window when it s not needed any more and it has to tell the applications that a window has been created so that the application can use it. This is done using the have window handle message that can be posted from the plugin with the gst_video_overlay_got_window_handle method. \nAs you probably guessed already active mode just means sending a video window to the plugin so that video output goes there. This is done using the gst_video_overlay_set_window_handle method. \nIt is possible to switch from one mode to another at any moment so the plugin implementing this interface has to handle all cases. There are only methods that plugins writers have to implement and they most probably look like that \nYou will also need to use the interface methods to post messages when needed such as when receiving a CAPS event where you will know the video geometry and maybe create the window. \nWRITEME \n"});