fragment_downloaded_cb({"url": "plugin-development/advanced/scheduling.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"scheduling.md\">\n<h1 id=\"different-scheduling-modes\">Different scheduling modes</h1>\n<p>The scheduling mode of a pad defines how data is retrieved from (source)\nor given to (sink) pads. GStreamer can operate in two scheduling mode,\ncalled push- and pull-mode. GStreamer supports elements with pads in any\nof the scheduling modes where not all pads need to be operating in the\nsame mode.</p>\n<p>So far, we have only discussed <code>_chain ()</code>-operating elements, i.e.\nelements that have a chain-function set on their sink pad and push\nbuffers on their source pad(s). We call this the push-mode because a\npeer element will use <code>gst_pad_push ()</code> on a srcpad, which will cause\nour <code>_chain ()</code>-function to be called, which in turn causes our element\nto push out a buffer on the source pad. The initiative to start the\ndataflow happens somewhere upstream when it pushes out a buffer and all\ndownstream elements get scheduled when their <code>_chain ()</code>-functions are\ncalled in turn.</p>\n<p>Before we explain pull-mode scheduling, let's first understand how the\ndifferent scheduling modes are selected and activated on a pad.</p>\n<h2 id=\"the-pad-activation-stage\">The pad activation stage</h2>\n<p>During the element state change of READY-&gt;PAUSED, the pads of an\nelement will be activated. This happens first on the source pads and\nthen on the sink pads of the element. GStreamer calls the <code>_activate ()</code>\nof a pad. By default this function will activate the pad in push-mode by\ncalling <code>gst_pad_activate_mode ()</code> with the GST_PAD_MODE_PUSH\nscheduling mode. It is possible to override the <code>_activate ()</code> of a pad\nand decide on a different scheduling mode. You can know in what\nscheduling mode a pad is activated by overriding the <code>_activate_mode ()</code>-function.</p>\n<p>GStreamer allows the different pads of an element to operate in\ndifferent scheduling modes. This allows for many different possible\nuse-cases. What follows is an overview of some typical use-cases.</p>\n<ul>\n<li>\n<p>If all pads of an element are activated in push-mode scheduling, the\nelement as a whole is operating in push-mode. For source elements\nthis means that they will have to start a task that pushes out\nbuffers on the source pad to the downstream elements. Downstream\nelements will have data pushed to them by upstream elements using\nthe sinkpads <code>_chain ()</code>-function which will push out buffers on the\nsource pads. Prerequisites for this scheduling mode are that a\nchain-function was set for each sinkpad using\n<code>gst_pad_set_chain_function ()</code> and that all downstream elements\noperate in the same mode.</p>\n</li>\n<li>\n<p>Alternatively, sinkpads can be the driving force behind a pipeline\nby operating in pull-mode, while the sourcepads of the element still\noperate in push-mode. In order to be the driving force, those pads\nstart a <code>GstTask</code> when they are activated. This task is a thread,\nwhich will call a function specified by the element. When called,\nthis function will have random data access (through\n<code>gst_pad_pull_range ()</code>) over all sinkpads, and can push data over\nthe sourcepads, which effectively means that this element controls\ndata flow in the pipeline. Prerequisites for this mode are that all\ndownstream elements can act in push mode, and that all upstream\nelements operate in pull-mode (see below).</p>\n<p>Source pads can be activated in PULL mode by a downstream element\nwhen they return GST_PAD_MODE_PULL from the\nGST_QUERY_SCHEDULING query. Prerequisites for this scheduling mode\nare that a getrange-function was set for the source pad using\n<code>gst_pad_set_getrange_function ()</code>.</p>\n</li>\n<li>\n<p>Lastly, all pads in an element can be activated in PULL-mode.\nHowever, contrary to the above, this does not mean that they start a\ntask on their own. Rather, it means that they are pull slave for the\ndownstream element, and have to provide random data access to it\nfrom their <code>_get_range ()</code>-function. Requirements are that the a\n<code>_get_range ()</code>-function was set on this pad using the function\n<code>gst_pad_set_getrange_function ()</code>. Also, if the element has any\nsinkpads, all those pads (and thereby their peers) need to operate\nin PULL access mode, too.</p>\n<p>When a sink element is activated in PULL mode, it should start a\ntask that calls <code>gst_pad_pull_range ()</code> on its sinkpad. It can only\ndo this when the upstream SCHEDULING query returns support for the\nGST_PAD_MODE_PULL scheduling mode.</p>\n</li>\n</ul>\n<p>In the next two sections, we will go closer into pull-mode scheduling\n(elements/pads driving the pipeline, and elements/pads providing random\naccess), and some specific use cases will be given.</p>\n<h2 id=\"pads-driving-the-pipeline\">Pads driving the pipeline</h2>\n<p>Sinkpads operating in pull-mode, with the sourcepads operating in\npush-mode (or it has no sourcepads when it is a sink), can start a task\nthat will drive the pipeline data flow. Within this task function, you\nhave random access over all of the sinkpads, and push data over the\nsourcepads. This can come in useful for several different kinds of\nelements:</p>\n<ul>\n<li>\n<p>Demuxers, parsers and certain kinds of decoders where data comes in\nunparsed (such as MPEG-audio or video streams), since those will\nprefer byte-exact (random) access from their input. If possible,\nhowever, such elements should be prepared to operate in push-mode\nmode, too.</p>\n</li>\n<li>\n<p>Certain kind of audio outputs, which require control over their\ninput data flow, such as the Jack sound server.</p>\n</li>\n</ul>\n<p>First you need to perform a SCHEDULING query to check if the upstream\nelement(s) support pull-mode scheduling. If that is possible, you can\nactivate the sinkpad in pull-mode. Inside the activate_mode function\nyou can then start the task.</p>\n<pre><code class=\"language-c\">#include \"filter.h\"\n#include &lt;string.h&gt;\n\nstatic gboolean gst_my_filter_activate      (GstPad      * pad,\n                                             GstObject   * parent);\nstatic gboolean gst_my_filter_activate_mode (GstPad      * pad,\n                                             GstObject   * parent,\n                                             GstPadMode    mode,\n                         gboolean      active);\nstatic void gst_my_filter_loop      (GstMyFilter * filter);\n\nG_DEFINE_TYPE (GstMyFilter, gst_my_filter, GST_TYPE_ELEMENT);\n\n\nstatic void\ngst_my_filter_init (GstMyFilter * filter)\n{\n\n[..]\n\n  gst_pad_set_activate_function (filter-&gt;sinkpad, gst_my_filter_activate);\n  gst_pad_set_activatemode_function (filter-&gt;sinkpad,\n      gst_my_filter_activate_mode);\n\n\n[..]\n}\n\n[..]\n\nstatic gboolean\ngst_my_filter_activate (GstPad * pad, GstObject * parent)\n{\n  GstQuery *query;\n  gboolean pull_mode;\n\n  /* first check what upstream scheduling is supported */\n  query = gst_query_new_scheduling ();\n\n  if (!gst_pad_peer_query (pad, query)) {\n    gst_query_unref (query);\n    goto activate_push;\n  }\n\n  /* see if pull-mode is supported */\n  pull_mode = gst_query_has_scheduling_mode_with_flags (query,\n      GST_PAD_MODE_PULL, GST_SCHEDULING_FLAG_SEEKABLE);\n  gst_query_unref (query);\n\n  if (!pull_mode)\n    goto activate_push;\n\n  /* now we can activate in pull-mode. GStreamer will also\n   * activate the upstream peer in pull-mode */\n  return gst_pad_activate_mode (pad, GST_PAD_MODE_PULL, TRUE);\n\nactivate_push:\n  {\n    /* something not right, we fallback to push-mode */\n    return gst_pad_activate_mode (pad, GST_PAD_MODE_PUSH, TRUE);\n  }\n}\n\nstatic gboolean\ngst_my_filter_activate_pull (GstPad    * pad,\n                 GstObject * parent,\n                 GstPadMode  mode,\n                 gboolean    active)\n{\n  gboolean res;\n  GstMyFilter *filter = GST_MY_FILTER (parent);\n\n  switch (mode) {\n    case GST_PAD_MODE_PUSH:\n      res = TRUE;\n      break;\n    case GST_PAD_MODE_PULL:\n      if (active) {\n        filter-&gt;offset = 0;\n        res = gst_pad_start_task (pad,\n            (GstTaskFunction) gst_my_filter_loop, filter, NULL);\n      } else {\n        res = gst_pad_stop_task (pad);\n      }\n      break;\n    default:\n      /* unknown scheduling mode */\n      res = FALSE;\n      break;\n  }\n  return res;\n}\n\n</code></pre>\n<p>Once started, your task has full control over input and output. The most\nsimple case of a task function is one that reads input and pushes that\nover its source pad. It's not all that useful, but provides some more\nflexibility than the old push-mode case that we've been looking at so\nfar.</p>\n<pre><code class=\"language-c\">    #define BLOCKSIZE 2048\n\n    static void\n    gst_my_filter_loop (GstMyFilter * filter)\n    {\n      GstFlowReturn ret;\n      guint64 len;\n      GstFormat fmt = GST_FORMAT_BYTES;\n      GstBuffer *buf = NULL;\n\n      if (!gst_pad_query_duration (filter-&gt;sinkpad, fmt, &amp;len)) {\n        GST_DEBUG_OBJECT (filter, \"failed to query duration, pausing\");\n        goto stop;\n      }\n\n       if (filter-&gt;offset &gt;= len) {\n        GST_DEBUG_OBJECT (filter, \"at end of input, sending EOS, pausing\");\n        gst_pad_push_event (filter-&gt;srcpad, gst_event_new_eos ());\n        goto stop;\n      }\n\n      /* now, read BLOCKSIZE bytes from byte offset filter-&gt;offset */\n      ret = gst_pad_pull_range (filter-&gt;sinkpad, filter-&gt;offset,\n          BLOCKSIZE, &amp;buf);\n\n      if (ret != GST_FLOW_OK) {\n        GST_DEBUG_OBJECT (filter, \"pull_range failed: %s\", gst_flow_get_name (ret));\n        goto stop;\n      }\n\n      /* now push buffer downstream */\n      ret = gst_pad_push (filter-&gt;srcpad, buf);\n\n      buf = NULL; /* gst_pad_push() took ownership of buffer */\n\n      if (ret != GST_FLOW_OK) {\n        GST_DEBUG_OBJECT (filter, \"pad_push failed: %s\", gst_flow_get_name (ret));\n        goto stop;\n      }\n\n      /* everything is fine, increase offset and wait for us to be called again */\n      filter-&gt;offset += BLOCKSIZE;\n      return;\n\n    stop:\n      GST_DEBUG_OBJECT (filter, \"pausing task\");\n      gst_pad_pause_task (filter-&gt;sinkpad);\n    }\n</code></pre>\n<h2 id=\"providing-random-access\">Providing random access</h2>\n<p>In the previous section, we have talked about how elements (or pads)\nthat are activated to drive the pipeline using their own task, must use\npull-mode scheduling on their sinkpads. This means that all pads linked\nto those pads need to be activated in pull-mode. Source pads activated\nin pull-mode must implement a <code>_get_range ()</code>-function set using\n<code>gst_pad_set_getrange_function ()</code>, and that function will be called\nwhen the peer pad requests some data with <code>gst_pad_pull_range ()</code>. The\nelement is then responsible for seeking to the right offset and\nproviding the requested data. Several elements can implement random\naccess:</p>\n<ul>\n<li>\n<p>Data sources, such as a file source, that can provide data from any\noffset with reasonable low latency.</p>\n</li>\n<li>\n<p>Filters that would like to provide a pull-mode scheduling over the\nwhole pipeline.</p>\n</li>\n<li>\n<p>Parsers who can easily provide this by skipping a small part of\ntheir input and are thus essentially \"forwarding\" getrange requests\nliterally without any own processing involved. Examples include tag\nreaders (e.g. ID3) or single output parsers, such as a WAVE parser.</p>\n</li>\n</ul>\n<p>The following example will show how a <code>_get_range ()</code>-function can be implemented in a source element:</p>\n<pre><code>#include \"filter.h\"\nstatic GstFlowReturn\n        gst_my_filter_get_range (GstPad     * pad,\n                     GstObject  * parent,\n                     guint64      offset,\n                     guint        length,\n                     GstBuffer ** buf);\n\nG_DEFINE_TYPE (GstMyFilter, gst_my_filter, GST_TYPE_ELEMENT);\n\n\n\nstatic void\ngst_my_filter_init (GstMyFilter * filter)\n{\n\n[..]\n\n  gst_pad_set_getrange_function (filter-&gt;srcpad,\n      gst_my_filter_get_range);\n\n[..]\n}\n\nstatic GstFlowReturn\ngst_my_filter_get_range (GstPad     * pad,\n             GstObject  * parent,\n             guint64      offset,\n             guint        length,\n             GstBuffer ** buf)\n{\n\n  GstMyFilter *filter = GST_MY_FILTER (parent);\n\n  [.. here, you would fill *buf ..]\n\n  return GST_FLOW_OK;\n}\n</code></pre>\n<p>In practice, many elements that could theoretically do random access,\nmay in practice often be activated in push-mode scheduling anyway, since\nthere is no downstream element able to start its own task. Therefore, in\npractice, those elements should implement both a <code>_get_range ()</code>-function and a <code>_chain ()</code>-function (for filters and parsers) or a <code>_get_range ()</code>-function and be prepared to start their own task by providing\n<code>_activate_* ()</code>-functions (for source elements).</p>\n\n</div>\n\n\n\t"});