fragment_downloaded_cb({"url": "plugin-development/advanced/qos.html#page-description", "fragment": "Quality of Service in GStreamer is about measuring and adjusting the real time performance of a pipeline. The real time performance is always measured relative to the pipeline clock and typically happens in the sinks when they synchronize buffers against the clock. \nWhen buffers arrive late in the sink i.e. when their running time is smaller than that of the clock we say that the pipeline is having a quality of service problem. These are a few possible reasons \nHigh CPU load there is not enough CPU power to handle the stream causing buffers to arrive late in the sink. \nNetwork problems \nOther resource problems such as disk load memory bottlenecks etc \nThe measurements result in QOS events that aim to adjust the datarate in one or more upstream elements. Two types of adjustments can be made \nShort time emergency corrections based on latest observation in the sinks. \nLong term rate corrections based on trends observed in the sinks. \nIt is also possible for the application to artificially introduce delay between synchronized buffers this is called throttling. It can be used to limit or reduce the framerate for example. \nElements that synchronize buffers on the pipeline clock will usually measure the current QoS. They will also need to keep some statistics in order to generate the QOS event. \nFor each buffer that arrives in the sink the element needs to calculate how late or how early it was. This is called the jitter. Negative jitter values mean that the buffer was early positive values mean that the buffer was late. the jitter value gives an indication of how early late a buffer was. \nA synchronizing element will also need to calculate how much time elapsed between receiving two consecutive buffers. We call this the processing time because that is the amount of time it takes for the upstream element to produce process the buffer. We can compare this processing time to the duration of the buffer to have a measurement of how fast upstream can produce data called the proportion. If for example upstream can produce a buffer in seconds of second long it is operating at twice the required speed. If on the other hand it takes seconds to produce a buffer with seconds worth of data upstream is producing buffers too slow and we won t be able to keep synchronization. Usually a running average is kept of the proportion. \nA synchronizing element also needs to measure its own performance in order to figure out if the performance problem is upstream of itself. \nThese measurements are used to construct a QOS event that is sent upstream. Note that a QoS event is sent for each buffer that arrives in the sink. \nAn element will have to install an event function on its source pads in order to receive QOS events. Usually the element will need to store the value of the QOS event and use them in the data processing function. The element will need to use a lock to protect these QoS values as shown in the example below. Also make sure to pass the QoS event upstream. \nWith the QoS values there are two types of corrections that an element can do \nThe timestamp and the jitter value in the QOS event can be used to perform a short term correction. If the jitter is positive the previous buffer arrived late and we can be sure that a buffer with a timestamp timestamp jitter is also going to be late. We can thus drop all buffers with a timestamp less than timestamp jitter. \nIf the buffer duration is known a better estimation for the next likely timestamp as timestamp jitter duration. \nA possible algorithm typically looks like this \nLong term corrections are a bit more difficult to perform. They rely on the value of the proportion in the QOS event. Elements should reduce the amount of resources they consume by the proportion field in the QoS message. \nHere are some possible strategies to achieve this \nPermanently dropping frames or reducing the CPU or bandwidth requirements of the element. Some decoders might be able to skip decoding of B frames. \nSwitch to lower quality processing or reduce the algorithmic complexity. Care should be taken that this doesn t introduce disturbing visual or audible glitches. \nSwitch to a lower quality source to reduce network bandwidth. \nAssign more CPU cycles to critical parts of the pipeline. This could for example be done by increasing the thread priority. \nIn all cases elements should be prepared to go back to their normal processing rate when the proportion member in the QOS event approaches the ideal proportion of again. \nElements synchronizing to the clock should expose a property to configure them in throttle mode. In throttle mode the time distance between buffers is kept to a configurable throttle interval. This means that effectively the buffer rate is limited to buffer per throttle interval. This can be used to limit the framerate for example. \nWhen an element is configured in throttling mode this is usually only implemented on sinks it should produce QoS events upstream with the jitter field set to the throttle interval. This should instruct upstream elements to skip or drop the remaining buffers in the configured throttle interval. \nThe proportion field is set to the desired slowdown needed to get the desired throttle interval. Implementations can use the QoS Throttle type the proportion and the jitter member to tune their implementations. \nThe default sink base class has the throttle time property for this feature. You can test this with gst launch videotestsrc xvimagesink throttle time \nIn addition to the QOS events that are sent between elements in the pipeline there are also QOS messages posted on the pipeline bus to inform the application of QoS decisions. The QOS message contains the timestamps of when something was dropped along with the amount of dropped vs processed items. Elements must post a QOS message under these conditions \nThe element dropped a buffer because of QoS reasons. \nAn element changes its processing strategy because of QoS reasons quality This could include a decoder that decides to drop every B frame to increase its processing speed or an effect element switching to a lower quality algorithm. \n"});