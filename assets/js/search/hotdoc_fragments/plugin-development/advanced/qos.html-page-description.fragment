fragment_downloaded_cb({"url": "plugin-development/advanced/qos.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"qos.md\">\n<h1 id=\"quality-of-service-qos\">Quality Of Service (QoS)</h1>\n<p>Quality of Service in GStreamer is about measuring and adjusting the\nreal-time performance of a pipeline. The real-time performance is always\nmeasured relative to the pipeline clock and typically happens in the\nsinks when they synchronize buffers against the clock.</p>\n<p>When buffers arrive late in the sink, i.e. when their running-time is\nsmaller than that of the clock, we say that the pipeline is having a\nquality of service problem. These are a few possible reasons:</p>\n<ul>\n<li>\n<p>High CPU load, there is not enough CPU power to handle the stream,\ncausing buffers to arrive late in the sink.</p>\n</li>\n<li>\n<p>Network problems</p>\n</li>\n<li>\n<p>Other resource problems such as disk load, memory bottlenecks etc</p>\n</li>\n</ul>\n<p>The measurements result in QOS events that aim to adjust the datarate in\none or more upstream elements. Two types of adjustments can be made:</p>\n<ul>\n<li>\n<p>Short time \"emergency\" corrections based on latest observation in\nthe sinks.</p>\n<p>Long term rate corrections based on trends observed in the sinks.</p>\n</li>\n</ul>\n<p>It is also possible for the application to artificially introduce delay\nbetween synchronized buffers, this is called throttling. It can be used\nto limit or reduce the framerate, for example.</p>\n<h2 id=\"measuring-qos\">Measuring QoS</h2>\n<p>Elements that synchronize buffers on the pipeline clock will usually\nmeasure the current QoS. They will also need to keep some statistics in\norder to generate the QOS event.</p>\n<p>For each buffer that arrives in the sink, the element needs to calculate\nhow late or how early it was. This is called the jitter. Negative jitter\nvalues mean that the buffer was early, positive values mean that the\nbuffer was late. the jitter value gives an indication of how early/late\na buffer was.</p>\n<p>A synchronizing element will also need to calculate how much time\nelapsed between receiving two consecutive buffers. We call this the\nprocessing time because that is the amount of time it takes for the\nupstream element to produce/process the buffer. We can compare this\nprocessing time to the duration of the buffer to have a measurement of\nhow fast upstream can produce data, called the proportion. If, for\nexample, upstream can produce a buffer in 0.5 seconds of 1 second long,\nit is operating at twice the required speed. If, on the other hand, it\ntakes 2 seconds to produce a buffer with 1 seconds worth of data,\nupstream is producing buffers too slow and we won't be able to keep\nsynchronization. Usually, a running average is kept of the proportion.</p>\n<p>A synchronizing element also needs to measure its own performance in\norder to figure out if the performance problem is upstream of itself.</p>\n<p>These measurements are used to construct a QOS event that is sent\nupstream. Note that a QoS event is sent for each buffer that arrives in\nthe sink.</p>\n<h2 id=\"handling-qos\">Handling QoS</h2>\n<p>An element will have to install an event function on its source pads in\norder to receive QOS events. Usually, the element will need to store the\nvalue of the QOS event and use them in the data processing function. The\nelement will need to use a lock to protect these QoS values as shown in\nthe example below. Also make sure to pass the QoS event upstream.</p>\n<pre><code class=\"language-c\">\n    [...]\n\n    case GST_EVENT_QOS:\n    {\n      GstQOSType type;\n      gdouble proportion;\n      GstClockTimeDiff diff;\n      GstClockTime timestamp;\n\n      gst_event_parse_qos (event, &amp;type, &amp;proportion, &amp;diff, &amp;timestamp);\n\n      GST_OBJECT_LOCK (decoder);\n      priv-&gt;qos_proportion = proportion;\n      priv-&gt;qos_timestamp = timestamp;\n      priv-&gt;qos_diff = diff;\n      GST_OBJECT_UNLOCK (decoder);\n\n      res = gst_pad_push_event (decoder-&gt;sinkpad, event);\n      break;\n    }\n\n    [...]\n\n\n</code></pre>\n<p>With the QoS values, there are two types of corrections that an element\ncan do:</p>\n<h3 id=\"short-term-correction\">Short term correction</h3>\n<p>The timestamp and the jitter value in the QOS event can be used to\nperform a short term correction. If the jitter is positive, the previous\nbuffer arrived late and we can be sure that a buffer with a timestamp &lt;\ntimestamp + jitter is also going to be late. We can thus drop all\nbuffers with a timestamp less than timestamp + jitter.</p>\n<p>If the buffer duration is known, a better estimation for the next likely\ntimestamp as: timestamp + 2 * jitter + duration.</p>\n<p>A possible algorithm typically looks like this:</p>\n<pre><code class=\"language-c\">\n  [...]\n\n  GST_OBJECT_LOCK (dec);\n  qos_proportion = priv-&gt;qos_proportion;\n  qos_timestamp = priv-&gt;qos_timestamp;\n  qos_diff = priv-&gt;qos_diff;\n  GST_OBJECT_UNLOCK (dec);\n\n  /* calculate the earliest valid timestamp */\n  if (G_LIKELY (GST_CLOCK_TIME_IS_VALID (qos_timestamp))) {\n    if (G_UNLIKELY (qos_diff &gt; 0)) {\n      earliest_time = qos_timestamp + 2 * qos_diff + frame_duration;\n    } else {\n      earliest_time = qos_timestamp + qos_diff;\n    }\n  } else {\n    earliest_time = GST_CLOCK_TIME_NONE;\n  }\n\n  /* compare earliest_time to running-time of next buffer */\n  if (earliest_time &gt; timestamp)\n    goto drop_buffer;\n\n  [...]\n\n\n</code></pre>\n<h3 id=\"long-term-correction\">Long term correction</h3>\n<p>Long term corrections are a bit more difficult to perform. They rely on\nthe value of the proportion in the QOS event. Elements should reduce the\namount of resources they consume by the proportion field in the QoS\nmessage.</p>\n<p>Here are some possible strategies to achieve this:</p>\n<ul>\n<li>\n<p>Permanently dropping frames or reducing the CPU or bandwidth\nrequirements of the element. Some decoders might be able to skip\ndecoding of B frames.</p>\n</li>\n<li>\n<p>Switch to lower quality processing or reduce the algorithmic\ncomplexity. Care should be taken that this doesn't introduce\ndisturbing visual or audible glitches.</p>\n</li>\n<li>\n<p>Switch to a lower quality source to reduce network bandwidth.</p>\n</li>\n<li>\n<p>Assign more CPU cycles to critical parts of the pipeline. This\ncould, for example, be done by increasing the thread priority.</p>\n</li>\n</ul>\n<p>In all cases, elements should be prepared to go back to their normal\nprocessing rate when the proportion member in the QOS event approaches\nthe ideal proportion of 1.0 again.</p>\n<h2 id=\"throttling\">Throttling</h2>\n<p>Elements synchronizing to the clock should expose a property to\nconfigure them in throttle mode. In throttle mode, the time distance\nbetween buffers is kept to a configurable throttle interval. This means\nthat effectively the buffer rate is limited to 1 buffer per throttle\ninterval. This can be used to limit the framerate, for example.</p>\n<p>When an element is configured in throttling mode (this is usually only\nimplemented on sinks) it should produce QoS events upstream with the\njitter field set to the throttle interval. This should instruct upstream\nelements to skip or drop the remaining buffers in the configured\nthrottle interval.</p>\n<p>The proportion field is set to the desired slowdown needed to get the\ndesired throttle interval. Implementations can use the QoS Throttle\ntype, the proportion and the jitter member to tune their\nimplementations.</p>\n<p>The default sink base class, has the \u201cthrottle-time\u201d property for this\nfeature. You can test this with: <code>gst-launch-1.0 videotestsrc ! xvimagesink throttle-time=500000000</code></p>\n<h2 id=\"qos-messages\">QoS Messages</h2>\n<p>In addition to the QOS events that are sent between elements in the\npipeline, there are also QOS messages posted on the pipeline bus to\ninform the application of QoS decisions. The QOS message contains the\ntimestamps of when something was dropped along with the amount of\ndropped vs processed items. Elements must post a QOS message under these\nconditions:</p>\n<ul>\n<li>\n<p>The element dropped a buffer because of QoS reasons.</p>\n</li>\n<li>\n<p>An element changes its processing strategy because of QoS reasons\n(quality). This could include a decoder that decides to drop every B\nframe to increase its processing speed or an effect element\nswitching to a lower quality algorithm.</p>\n</li>\n</ul>\n\n</div>\n\n\n        "});