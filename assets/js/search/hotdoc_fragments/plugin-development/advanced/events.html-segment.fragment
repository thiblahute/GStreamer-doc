fragment_downloaded_cb({"url": "plugin-development/advanced/events.html#segment", "fragment": "Segment \nA segment event is sent downstream to announce the range of valid timestamps in the stream and how they should be transformed into running time and stream time. A segment event must always be sent before the first buffer of data and after a flush see above \nThe first segment event is created by the element driving the pipeline like a source operating in push mode or a demuxer decoder operating pull based. This segment event then travels down the pipeline and may be transformed on the way a decoder for example might receive a segment event in BYTES format and might transform this into a segment event in TIMES format based on the average bitrate \nDepending on the element type the event can simply be forwarded using gst_pad_event_default or it should be parsed and a modified event should be sent on. The last is true for demuxers which generally have a byte to time conversion concept. Their input is usually byte based so the incoming event will have an offset in byte units GST_FORMAT_BYTES too. Elements downstream however expect segment events in time units so that it can be used to synchronize against the pipeline clock. Therefore demuxers and similar elements should not forward the event but parse it free it and send a segment event in time units GST_FORMAT_TIME further downstream. \nThe segment event is created using the function gst_event_new_segment See the API reference and design document for details about its parameters. \nElements parsing this event can use gst_event_parse_segment to extract the event details. Elements may find the GstSegment API useful to keep track of the current segment if they want to use it for output clipping for example \n"});