fragment_downloaded_cb({"url": "plugin-development/advanced/allocation.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"allocation.md\">\n        <h1 id=\"memory-allocation\">Memory allocation</h1>\n<p>Memory allocation and management is a very important topic in\nmultimedia. High definition video uses many megabytes to store one\nsingle frame of video. It is important to reuse the memory when possible\ninstead of constantly allocating and freeing the memory.</p>\n<p>Multimedia systems usually use special purpose chips, such as DSPs or\nGPUs to perform the heavy lifting (especially for video). These special\npurpose chips have usually strict requirements for the memory that they\ncan operate on and how the memory is accessed.</p>\n<p>This chapter talks about the memory management features that GStreamer\nplugins can use. We will first talk about the lowlevel <code>GstMemory</code>\nobject that manages access to a piece of memory. We then continue with\n<code>GstBuffer</code> that is used to exchange data between plugins (and the\napplication) and that uses <code>GstMemory</code>. We talk about <code>GstMeta</code> that can\nbe placed on buffers to give extra info about the buffer and its memory.\nFor efficiently managing buffers of the same size, we take a look at\n<code>GstBufferPool</code>. To conclude this chapter we take a look at the\nGST_QUERY_ALLOCATION query that is used to negotiate memory management\noptions between elements.</p>\n<h2 id=\"gstmemory\">GstMemory</h2>\n<p><code>GstMemory</code> is an object that manages a region of memory. The memory\nobject points to a region of memory of \u201cmaxsize\u201d. The area in this\nmemory starting at \u201coffset\u201d and for \u201csize\u201d bytes is the accessible\nregion in the memory. the maxsize of the memory can never be changed\nafter the object is created, however, the offset and size can be\nchanged.</p>\n<h3 id=\"gstallocator\">GstAllocator</h3>\n<p><code>GstMemory</code> objects are created by a <code>GstAllocator</code> object. Most\nallocators implement the default <code>gst_allocator_alloc()</code> method but some\nallocator might implement a different method, for example when\nadditional parameters are needed to allocate the specific memory.</p>\n<p>Different allocators exist for, for example, system memory, shared\nmemory and memory backed by a DMAbuf file descriptor. To implement\nsupport for a new kind of memory type, you must implement a new\nallocator object as shown below.</p>\n<h3 id=\"gstmemory-api-example\">GstMemory API example</h3>\n<p>Data access to the memory wrapped by the <code>GstMemory</code> object is always\nprotected with a <code>gst_memory_map()</code> and <code>gst_memory_unmap()</code> pair. An\naccess mode (read/write) must be given when mapping memory. The map\nfunction returns a pointer to the valid memory region that can then be\naccessed according to the requested access mode.</p>\n<p>Below is an example of making a <code>GstMemory</code> object and using the\n<code>gst_memory_map()</code> to access the memory region.</p>\n<pre><code class=\"language-c\">\n[...]\n\n  GstMemory *mem;\n  GstMapInfo info;\n  gint i;\n\n  /* allocate 100 bytes */\n  mem = gst_allocator_alloc (NULL, 100, NULL);\n\n  /* get access to the memory in write mode */\n  gst_memory_map (mem, &amp;info, GST_MAP_WRITE);\n\n  /* fill with pattern */\n  for (i = 0; i &lt; info.size; i++)\n    info.data[i] = i;\n\n  /* release memory */\n  gst_memory_unmap (mem, &amp;info);\n\n[...]\n\n\n</code></pre>\n<h3 id=\"implementing-a-gstallocator\">Implementing a GstAllocator</h3>\n<p>WRITEME</p>\n<h2 id=\"gstbuffer\">GstBuffer</h2>\n<p>A <code>GstBuffer</code> is an lightweight object that is passed from an upstream\nto a downstream element and contains memory and metadata. It represents\nthe multimedia content that is pushed or pull downstream by elements.</p>\n<p>The buffer contains one or more <code>GstMemory</code> objects that represent the\ndata in the buffer.</p>\n<p>Metadata in the buffer consists of:</p>\n<ul>\n<li>\n<p>DTS and PTS timestamps. These represent the decoding and\npresentation timestamps of the buffer content and is used by\nsynchronizing elements to schedule buffers. Both these timestamps\ncan be GST_CLOCK_TIME_NONE when unknown/undefined.</p>\n</li>\n<li>\n<p>The duration of the buffer contents. This duration can be\nGST_CLOCK_TIME_NONE when unknown/undefined.</p>\n</li>\n<li>\n<p>Media specific offsets and offset_end. For video this is the frame\nnumber in the stream and for audio the sample number. Other\ndefinitions for other media exist.</p>\n</li>\n<li>\n<p>Arbitrary structures via <code>GstMeta</code>, see below.</p>\n</li>\n</ul>\n<h3 id=\"gstbuffer-writability\">GstBuffer writability</h3>\n<p>A buffer is writable when the refcount of the object is exactly 1,\nmeaning that only one object is holding a ref to the buffer. You can\nonly modify anything in the buffer when the buffer is writable. This\nmeans that you need to call <code>gst_buffer_make_writable()</code> before changing\nthe timestamps, offsets, metadata or adding and removing memory blocks.</p>\n<h3 id=\"gstbuffer-api-examples\">GstBuffer API examples</h3>\n<p>You can create a buffer with <code>gst_buffer_new ()</code> and then add memory\nobjects to it or you can use a convenience function\n<code>gst_buffer_new_allocate ()</code> which combines the two. It's also possible\nto wrap existing memory with <code>gst_buffer_new_wrapped_full ()</code> where you\ncan give the function to call when the memory should be freed.</p>\n<p>You can access the memory of the buffer by getting and mapping the\n<code>GstMemory</code> objects individually or by using <code>gst_buffer_map ()</code>. The\nlatter merges all the memory into one big block and then gives you a\npointer to this block.</p>\n<p>Below is an example of how to create a buffer and access its memory.</p>\n<pre><code class=\"language-c\">\n[...]\n  GstBuffer *buffer;\n  GstMemory *mem;\n  GstMapInfo info;\n\n  /* make empty buffer */\n  buffer = gst_buffer_new ();\n\n  /* make memory holding 100 bytes */\n  mem = gst_allocator_alloc (NULL, 100, NULL);\n\n  /* add the buffer */\n  gst_buffer_append_memory (buffer, mem);\n\n[...]\n\n  /* get WRITE access to the memory and fill with 0xff */\n  gst_buffer_map (buffer, &amp;info, GST_MAP_WRITE);\n  memset (info.data, 0xff, info.size);\n  gst_buffer_unmap (buffer, &amp;info);\n\n[...]\n\n  /* free the buffer */\n  gst_buffer_unref (buffer);\n\n[...]\n\n\n</code></pre>\n<h2 id=\"gstmeta\">GstMeta</h2>\n<p>With the <code>GstMeta</code> system you can add arbitrary structures on buffers.\nThese structures describe extra properties of the buffer such as\ncropping, stride, region of interest etc.</p>\n<p>The metadata system separates API specification (what the metadata and\nits API look like) and the implementation (how it works). This makes it\npossible to make different implementations of the same API, for example,\ndepending on the hardware you are running on.</p>\n<h3 id=\"gstmeta-api-example\">GstMeta API example</h3>\n<p>After allocating a new buffer, you can add metadata to the buffer with\nthe metadata specific API. This means that you will need to link to the\nheader file where the metadata is defined to use its API.</p>\n<p>By convention, a metadata API with name <code>FooBar</code> should provide two\nmethods, a <code>gst_buffer_add_foo_bar_meta ()</code> and a\n<code>gst_buffer_get_foo_bar_meta ()</code>. Both functions should return a pointer\nto a <code>FooBarMeta</code> structure that contains the metadata fields. Some of\nthe <code>_add_*_meta ()</code> can have extra parameters that will usually be used\nto configure the metadata structure for you.</p>\n<p>Let's have a look at the metadata that is used to specify a cropping\nregion for video frames.</p>\n<pre><code class=\"language-c\">\n#include &lt;gst/video/gstvideometa.h&gt;\n\n[...]\n  GstVideoCropMeta *meta;\n\n  /* buffer points to a video frame, add some cropping metadata */\n  meta = gst_buffer_add_video_crop_meta (buffer);\n\n  /* configure the cropping metadata */\n  meta-&gt;x = 8;\n  meta-&gt;y = 8;\n  meta-&gt;width = 120;\n  meta-&gt;height = 80;\n[...]\n\n\n</code></pre>\n<p>An element can then use the metadata on the buffer when rendering the\nframe like this:</p>\n<pre><code class=\"language-c\">\n#include &lt;gst/video/gstvideometa.h&gt;\n\n[...]\n  GstVideoCropMeta *meta;\n\n  /* buffer points to a video frame, get the cropping metadata */\n  meta = gst_buffer_get_video_crop_meta (buffer);\n\n  if (meta) {\n    /* render frame with cropping */\n    _render_frame_cropped (buffer, meta-&gt;x, meta-&gt;y, meta-&gt;width, meta-&gt;height);\n  } else {\n    /* render frame */\n    _render_frame (buffer);\n  }\n[...]\n\n\n\n</code></pre>\n<h3 id=\"implementing-new-gstmeta\">Implementing new GstMeta</h3>\n<p>In the next sections we show how you can add new metadata to the system\nand use it on buffers.</p>\n<h4 id=\"define-the-metadata-api\">Define the metadata API</h4>\n<p>First we need to define what our API will look like and we will have to\nregister this API to the system. This is important because this API\ndefinition will be used when elements negotiate what kind of metadata\nthey will exchange. The API definition also contains arbitrary tags that\ngive hints about what the metadata contains. This is important when we\nsee how metadata is preserved when buffers pass through the pipeline.</p>\n<p>If you are making a new implementation of an existing API, you can skip\nthis step and move on to the implementation step.</p>\n<p>First we start with making the <code>my-example-meta.h</code> header file that will\ncontain the definition of the API and structure for our metadata.</p>\n<pre><code class=\"language-c\">\n#include &lt;gst/gst.h&gt;\n\ntypedef struct _MyExampleMeta MyExampleMeta;\n\nstruct _MyExampleMeta {\n  GstMeta       meta;\n\n  gint          age;\n  gchar        *name;\n};\n\nGType my_example_meta_api_get_type (void);\n#define MY_EXAMPLE_META_API_TYPE (my_example_meta_api_get_type())\n\n#define gst_buffer_get_my_example_meta(b) \\\n  ((MyExampleMeta*)gst_buffer_get_meta((b),MY_EXAMPLE_META_API_TYPE))\n\n\n</code></pre>\n<p>The metadata API definition consists of the definition of the structure\nthat holds a gint and a string. The first field in the structure must be\n<code>GstMeta</code>.</p>\n<p>We also define a <code>my_example_meta_api_get_type ()</code> function that will\nregister out metadata API definition. We also define a convenience macro\n<code>gst_buffer_get_my_example_meta ()</code> that simply finds and returns the\nmetadata with our new API.</p>\n<p>Next let's have a look at how the <code>my_example_meta_api_get_type ()</code>\nfunction is implemented in the <code>my-example-meta.c</code> file.</p>\n<pre><code class=\"language-c\">\n#include \"my-example-meta.h\"\n\nGType\nmy_example_meta_api_get_type (void)\n{\n  static volatile GType type;\n  static const gchar *tags[] = { \"foo\", \"bar\", NULL };\n\n  if (g_once_init_enter (&amp;type)) {\n    GType _type = gst_meta_api_type_register (\"MyExampleMetaAPI\", tags);\n    g_once_init_leave (&amp;type, _type);\n  }\n  return type;\n}\n\n\n</code></pre>\n<p>As you can see, it simply uses the <code>gst_meta_api_type_register ()</code>\nfunction to register a name for the api and some tags. The result is a\nnew pointer GType that defines the newly registered API.</p>\n<h4 id=\"implementing-a-metadata-api\">Implementing a metadata API</h4>\n<p>Next we can make an implementation for a registered metadata API GType.\nThe implementation detail of a metadata API are kept in a <code>GstMetaInfo</code>\nstructure that you will make available to the users of your metadata API\nimplementation with a <code>my_example_meta_get_info ()</code> function and a\nconvenience <code>MY_EXAMPLE_META_INFO</code> macro. You will also make a method to\nadd your metadata implementation to a <code>GstBuffer</code>. Your\n<code>my-example-meta.h</code> header file will need these additions:</p>\n<pre><code class=\"language-c\">\n[...]\n\n/* implementation */\nconst GstMetaInfo *my_example_meta_get_info (void);\n#define MY_EXAMPLE_META_INFO (my_example_meta_get_info())\n\nMyExampleMeta * gst_buffer_add_my_example_meta (GstBuffer      *buffer,\n                                                gint            age,\n                                                const gchar    *name);\n\n\n</code></pre>\n<p>Let's have a look at how these functions are implemented in the\n<code>my-example-meta.c</code> file.</p>\n<pre><code class=\"language-c\">\n[...]\n\nstatic gboolean\nmy_example_meta_init (GstMeta * meta, gpointer params, GstBuffer * buffer)\n{\n  MyExampleMeta *emeta = (MyExampleMeta *) meta;\n\n  emeta-&gt;age = 0;\n  emeta-&gt;name = NULL;\n\n  return TRUE;\n}\n\nstatic gboolean\nmy_example_meta_transform (GstBuffer * transbuf, GstMeta * meta,\n    GstBuffer * buffer, GQuark type, gpointer data)\n{\n  MyExampleMeta *emeta = (MyExampleMeta *) meta;\n\n  /* we always copy no matter what transform */\n  gst_buffer_add_my_example_meta (transbuf, emeta-&gt;age, emeta-&gt;name);\n\n  return TRUE;\n}\n\nstatic void\nmy_example_meta_free (GstMeta * meta, GstBuffer * buffer)\n{\n  MyExampleMeta *emeta = (MyExampleMeta *) meta;\n\n  g_free (emeta-&gt;name);\n  emeta-&gt;name = NULL;\n}\n\nconst GstMetaInfo *\nmy_example_meta_get_info (void)\n{\n  static const GstMetaInfo *meta_info = NULL;\n\n  if (g_once_init_enter (&amp;meta_info)) {\n    const GstMetaInfo *mi = gst_meta_register (MY_EXAMPLE_META_API_TYPE,\n        \"MyExampleMeta\",\n        sizeof (MyExampleMeta),\n        my_example_meta_init,\n        my_example_meta_free,\n        my_example_meta_transform);\n    g_once_init_leave (&amp;meta_info, mi);\n  }\n  return meta_info;\n}\n\nMyExampleMeta *\ngst_buffer_add_my_example_meta (GstBuffer   *buffer,\n                                gint         age,\n                                const gchar *name)\n{\n  MyExampleMeta *meta;\n\n  g_return_val_if_fail (GST_IS_BUFFER (buffer), NULL);\n\n  meta = (MyExampleMeta *) gst_buffer_add_meta (buffer,\n      MY_EXAMPLE_META_INFO, NULL);\n\n  meta-&gt;age = age;\n  meta-&gt;name = g_strdup (name);\n\n  return meta;\n}\n\n\n</code></pre>\n<p><code>gst_meta_register ()</code> registers the implementation details, like the\nAPI that you implement and the size of the metadata structure along with\nmethods to initialize and free the memory area. You can also implement a\ntransform function that will be called when a certain transformation\n(identified by the quark and quark specific data) is performed on a\nbuffer.</p>\n<p>Lastly, you implement a <code>gst_buffer_add_*_meta()</code> that adds the metadata\nimplementation to a buffer and sets the values of the metadata.</p>\n<h2 id=\"gstbufferpool\">GstBufferPool</h2>\n<p>The <code>GstBufferPool</code> object provides a convenient base class for managing\nlists of reusable buffers. Essential for this object is that all the\nbuffers have the same properties such as size, padding, metadata and\nalignment.</p>\n<p>A bufferpool object can be configured to manage a minimum and maximum\namount of buffers of a specific size. A bufferpool can also be\nconfigured to use a specific <code>GstAllocator</code> for the memory of the\nbuffers. There is support in the bufferpool to enable bufferpool\nspecific options, such as adding <code>GstMeta</code> to the buffers in the pool or\nsuch as enabling specific padding on the memory in the buffers.</p>\n<p>A Bufferpool can be inactivate and active. In the inactive state, you\ncan configure the pool. In the active state, you can't change the\nconfiguration anymore but you can acquire and release buffers from/to\nthe pool.</p>\n<p>In the following sections we take a look at how you can use a\nbufferpool.</p>\n<h3 id=\"gstbufferpool-api-example\">GstBufferPool API example</h3>\n<p>Many different bufferpool implementations can exist; they are all\nsubclasses of the base class <code>GstBufferPool</code>. For this example, we will\nassume we somehow have access to a bufferpool, either because we created\nit ourselves or because we were given one as a result of the ALLOCATION\nquery as we will see below.</p>\n<p>The bufferpool is initially in the inactive state so that we can\nconfigure it. Trying to configure a bufferpool that is not in the\ninactive state will fail. Likewise, trying to activate a bufferpool that\nis not configured will fail.</p>\n<pre><code class=\"language-c\">\n  GstStructure *config;\n\n[...]\n\n  /* get config structure */\n  config = gst_buffer_pool_get_config (pool);\n\n  /* set caps, size, minimum and maximum buffers in the pool */\n  gst_buffer_pool_config_set_params (config, caps, size, min, max);\n\n  /* configure allocator and parameters */\n  gst_buffer_pool_config_set_allocator (config, allocator, &amp;params);\n\n  /* store the updated configuration again */\n  gst_buffer_pool_set_config (pool, config);\n\n[...]\n\n\n</code></pre>\n<p>The configuration of the bufferpool is maintained in a generic\n<code>GstStructure</code> that can be obtained with <code>gst_buffer_pool_get_config()</code>.\nConvenience methods exist to get and set the configuration options in\nthis structure. After updating the structure, it is set as the current\nconfiguration in the bufferpool again with\n<code>gst_buffer_pool_set_config()</code>.</p>\n<p>The following options can be configured on a bufferpool:</p>\n<ul>\n<li>\n<p>The caps of the buffers to allocate.</p>\n</li>\n<li>\n<p>The size of the buffers. This is the suggested size of the buffers\nin the pool. The pool might decide to allocate larger buffers to add\npadding.</p>\n</li>\n<li>\n<p>The minimum and maximum amount of buffers in the pool. When minimum\nis set to &gt; 0, the bufferpool will pre-allocate this amount of\nbuffers. When maximum is not 0, the bufferpool will allocate up to\nmaximum amount of buffers.</p>\n</li>\n<li>\n<p>The allocator and parameters to use. Some bufferpools might ignore\nthe allocator and use its internal one.</p>\n</li>\n<li>\n<p>Other arbitrary bufferpool options identified with a string. a\nbufferpool lists the supported options with\n<code>gst_buffer_pool_get_options()</code> and you can ask if an option is\nsupported with <code>gst_buffer_pool_has_option()</code>. The option can be\nenabled by adding it to the configuration structure with\n<code>gst_buffer_pool_config_add_option ()</code>. These options are used to\nenable things like letting the pool set metadata on the buffers or\nto add extra configuration options for padding, for example.</p>\n</li>\n</ul>\n<p>After the configuration is set on the bufferpool, the pool can be\nactivated with <code>gst_buffer_pool_set_active (pool, TRUE)</code>. From that\npoint on you can use <code>gst_buffer_pool_acquire_buffer ()</code> to retrieve a\nbuffer from the pool, like this:</p>\n<pre><code class=\"language-c\">\n  [...]\n\n  GstFlowReturn ret;\n  GstBuffer *buffer;\n\n  ret = gst_buffer_pool_acquire_buffer (pool, &amp;buffer, NULL);\n  if (G_UNLIKELY (ret != GST_FLOW_OK))\n    goto pool_failed;\n\n  [...]\n\n\n</code></pre>\n<p>It is important to check the return value of the acquire function\nbecause it is possible that it fails: When your element shuts down, it\nwill deactivate the bufferpool and then all calls to acquire will return\nGST_FLOW_FLUSHNG.</p>\n<p>All buffers that are acquired from the pool will have their pool member\nset to the original pool. When the last ref is decremented on the\nbuffer, GStreamer will automatically call\n<code>gst_buffer_pool_release_buffer()</code> to release the buffer back to the\npool. You (or any other downstream element) don't need to know if a\nbuffer came from a pool, you can just unref it.</p>\n<h3 id=\"implementing-a-new-gstbufferpool\">Implementing a new GstBufferPool</h3>\n<p>WRITEME</p>\n<h2 id=\"gst_query_allocation\">GST_QUERY_ALLOCATION</h2>\n<p>The ALLOCATION query is used to negotiate <code>GstMeta</code>, <code>GstBufferPool</code> and\n<code>GstAllocator</code> between elements. Negotiation of the allocation strategy\nis always initiated and decided by a srcpad after it has negotiated a\nformat and before it decides to push buffers. A sinkpad can suggest an\nallocation strategy but it is ultimately the source pad that will decide\nbased on the suggestions of the downstream sink pad.</p>\n<p>The source pad will do a GST_QUERY_ALLOCATION with the negotiated caps\nas a parameter. This is needed so that the downstream element knows what\nmedia type is being handled. A downstream sink pad can answer the\nallocation query with the following results:</p>\n<ul>\n<li>\n<p>An array of possible <code>GstBufferPool</code> suggestions with suggested\nsize, minimum and maximum amount of buffers.</p>\n</li>\n<li>\n<p>An array of GstAllocator objects along with suggested allocation\nparameters such as flags, prefix, alignment and padding. These\nallocators can also be configured in a bufferpool when this is\nsupported by the bufferpool.</p>\n</li>\n<li>\n<p>An array of supported <code>GstMeta</code> implementations along with metadata\nspecific parameters. It is important that the upstream element knows\nwhat kind of metadata is supported downstream before it places that\nmetadata on buffers.</p>\n</li>\n</ul>\n<p>When the GST_QUERY_ALLOCATION returns, the source pad will select from\nthe available bufferpools, allocators and metadata how it will allocate\nbuffers.</p>\n<h3 id=\"allocation-query-example\">ALLOCATION query example</h3>\n<p>Below is an example of the ALLOCATION query.</p>\n<pre><code class=\"language-c\">\n#include &lt;gst/video/video.h&gt;\n#include &lt;gst/video/gstvideometa.h&gt;\n#include &lt;gst/video/gstvideopool.h&gt;\n\n  GstCaps *caps;\n  GstQuery *query;\n  GstStructure *structure;\n  GstBufferPool *pool;\n  GstStructure *config;\n  guint size, min, max;\n\n[...]\n\n  /* find a pool for the negotiated caps now */\n  query = gst_query_new_allocation (caps, TRUE);\n\n  if (!gst_pad_peer_query (scope-&gt;srcpad, query)) {\n    /* query failed, not a problem, we use the query defaults */\n  }\n\n  if (gst_query_get_n_allocation_pools (query) &gt; 0) {\n    /* we got configuration from our peer, parse them */\n    gst_query_parse_nth_allocation_pool (query, 0, &amp;pool, &amp;size, &amp;min, &amp;max);\n  } else {\n    pool = NULL;\n    size = 0;\n    min = max = 0;\n  }\n\n  if (pool == NULL) {\n    /* we did not get a pool, make one ourselves then */\n    pool = gst_video_buffer_pool_new ();\n  }\n\n  config = gst_buffer_pool_get_config (pool);\n  gst_buffer_pool_config_add_option (config, GST_BUFFER_POOL_OPTION_VIDEO_META);\n  gst_buffer_pool_config_set_params (config, caps, size, min, max);\n  gst_buffer_pool_set_config (pool, config);\n\n  /* and activate */\n  gst_buffer_pool_set_active (pool, TRUE);\n\n[...]\n\n\n</code></pre>\n<p>This particular implementation will make a custom <code>GstVideoBufferPool</code>\nobject that is specialized in allocating video buffers. You can also\nenable the pool to put <code>GstVideoMeta</code> metadata on the buffers from the\npool doing <code>gst_buffer_pool_config_add_option (config, GST_BUFFER_POOL_OPTION_VIDEO_META)</code>.</p>\n<h3 id=\"the-allocation-query-in-base-classes\">The ALLOCATION query in base classes</h3>\n<p>In many baseclasses you will see the following virtual methods for\ninfluencing the allocation strategy:</p>\n<ul>\n<li>\n<p><code>propose_allocation ()</code> should suggest allocation parameters for the\nupstream element.</p>\n</li>\n<li>\n<p><code>decide_allocation ()</code> should decide the allocation parameters from\nthe suggestions received from downstream.</p>\n</li>\n</ul>\n<p>Implementors of these methods should modify the given <code>GstQuery</code> object\nby updating the pool options and allocation options.</p>\n\n        \n\n    </div>\n\n\n        "});