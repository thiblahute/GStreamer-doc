fragment_downloaded_cb({"url": "plugin-development/advanced/tagging.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"tagging.md\">\n<h1 id=\"tagging-metadata-and-streaminfo\">Tagging (Metadata and Streaminfo)</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>Tags are pieces of information stored in a stream that are not the\ncontent itself, but they rather <em>describe</em> the content. Most media\ncontainer formats support tagging in one way or another. Ogg uses\nVorbisComment for this, MP3 uses ID3, AVI and WAV use RIFF's INFO list\nchunk, etc. GStreamer provides a general way for elements to read tags\nfrom the stream and expose this to the user. The tags (at least the\nmetadata) will be part of the stream inside the pipeline. The\nconsequence of this is that transcoding of files from one format to\nanother will automatically preserve tags, as long as the input and\noutput format elements both support tagging.</p>\n<p>Tags are separated in two categories in GStreamer, even though\napplications won't notice anything of this. The first are called\n<em>metadata</em>, the second are called <em>streaminfo</em>. Metadata are tags that\ndescribe the non-technical parts of stream content. They can be changed\nwithout needing to re-encode the stream completely. Examples are\n\u201cauthor\u201d, \u201ctitle\u201d or \u201calbum\u201d. The container format might still need\nto be re-written for the tags to fit in, though. Streaminfo, on the\nother hand, are tags that describe the stream contents technically. To\nchange them, the stream needs to be re-encoded. Examples are \u201ccodec\u201d or\n\u201cbitrate\u201d. Note that some container formats (like ID3) store various\nstreaminfo tags as metadata in the file container, which means that they\ncan be changed so that they don't match the content in the file any\nmore. Still, they are called metadata because <em>technically</em>, they can be\nchanged without re-encoding the whole stream, even though that makes\nthem invalid. Files with such metadata tags will have the same tag\ntwice: once as metadata, once as streaminfo.</p>\n<p>There is no special name for tag reading elements in GStreamer. There\nare specialised elements (e.g. id3demux) that do nothing besides tag\nreading, but any GStreamer element may extract tags while processing\ndata, and most decoders, demuxers and parsers do.</p>\n<p>A tag writer is called\n<a href=\"../../gstreamer/html/GstTagSetter.html\"><code>TagSetter</code></a>. An element\nsupporting both can be used in a tag editor for quick tag changing\n(note: in-place tag editing is still poorly supported at the time of\nwriting and usually requires tag extraction/stripping and remuxing of\nthe stream with new tags).</p>\n<h2 id=\"reading-tags-from-streams\">Reading Tags from Streams</h2>\n<p>The basic object for tags is a <a href=\"../../gstreamer/html/GstTagList.html\"><code>GstTagList</code></a>. An element that is reading\ntags from a stream should create an empty taglist and fill this with\nindividual tags. Empty tag lists can be created with <code>gst_tag_list_new ()</code>. Then, the element can fill the list using <code>gst_tag_list_add ()</code> or <code>gst_tag_list_add_values ()</code>. Note that elements often read\nmetadata as strings, but the values in the taglist might not necessarily\nbe strings - they need to be of the type the tag was registered as (the\nAPI documentation for each predefined tag should contain the type). Be\nsure to use functions like <code>gst_value_transform ()</code> to make sure that\nyour data is of the right type. After data reading, you can send the\ntags downstream with the TAG event. When the TAG event reaches the sink,\nit will post the TAG message on the pipeline's GstBus for the\napplication to pick up.</p>\n<p>We currently require the core to know the GType of tags before they are\nbeing used, so all tags must be registered first. You can add new tags\nto the list of known tags using <code>gst_tag_register ()</code>. If you think the\ntag will be useful in more cases than just your own element, it might be\na good idea to add it to <code>gsttag.c</code> instead. That's up to you to decide.\nIf you want to do it in your own element, it's easiest to register the\ntag in one of your class init functions, preferably <code>_class_init ()</code>.</p>\n<pre><code class=\"language-c\">\nstatic void\ngst_my_filter_class_init (GstMyFilterClass *klass)\n{\n[..]\n  gst_tag_register (\"my_tag_name\", GST_TAG_FLAG_META,\n            G_TYPE_STRING,\n            _(\"my own tag\"),\n            _(\"a tag that is specific to my own element\"),\n            NULL);\n[..]\n}\n\n\n</code></pre>\n<h2 id=\"writing-tags-to-streams\">Writing Tags to Streams</h2>\n<p>Tag writers are the opposite of tag readers. Tag writers only take\nmetadata tags into account, since that's the only type of tags that have\nto be written into a stream. Tag writers can receive tags in three ways:\ninternal, application and pipeline. Internal tags are tags read by the\nelement itself, which means that the tag writer is - in that case - a\ntag reader, too. Application tags are tags provided to the element via\nthe TagSetter interface (which is just a layer). Pipeline tags are tags\nprovided to the element from within the pipeline. The element receives\nsuch tags via the <code>GST_EVENT_TAG</code> event, which means that tags writers\nshould implement an event handler. The tag writer is responsible for\ncombining all these three into one list and writing them to the output\nstream.</p>\n<p>The example below will receive tags from both application and pipeline,\ncombine them and write them to the output stream. It implements the tag\nsetter so applications can set tags, and retrieves pipeline tags from\nincoming events.</p>\n<p>Warning, this example is outdated and doesn't work with the 1.0 version\nof GStreamer anymore.</p>\n<pre><code class=\"language-c\">\nGType\ngst_my_filter_get_type (void)\n{\n[..]\n    static const GInterfaceInfo tag_setter_info = {\n      NULL,\n      NULL,\n      NULL\n    };\n[..]\n    g_type_add_interface_static (my_filter_type,\n                 GST_TYPE_TAG_SETTER,\n                 &amp;tag_setter_info);\n[..]\n}\n\nstatic void\ngst_my_filter_init (GstMyFilter *filter)\n{\n[..]\n}\n\n/*\n * Write one tag.\n */\n\nstatic void\ngst_my_filter_write_tag (const GstTagList *taglist,\n             const gchar      *tagname,\n             gpointer          data)\n{\n  GstMyFilter *filter = GST_MY_FILTER (data);\n  GstBuffer *buffer;\n  guint num_values = gst_tag_list_get_tag_size (list, tag_name), n;\n  const GValue *from;\n  GValue to = { 0 };\n\n  g_value_init (&amp;to, G_TYPE_STRING);\n\n  for (n = 0; n &lt; num_values; n++) {\n    guint8 * data;\n    gsize size;\n\n    from = gst_tag_list_get_value_index (taglist, tagname, n);\n    g_value_transform (from, &amp;to);\n\n    data = g_strdup_printf (\"%s:%s\", tagname,\n        g_value_get_string (&amp;to));\n    size = strlen (data);\n\n    buf = gst_buffer_new_wrapped (data, size);\n    gst_pad_push (filter-&gt;srcpad, buf);\n  }\n\n  g_value_unset (&amp;to);\n}\n\nstatic void\ngst_my_filter_task_func (GstElement *element)\n{\n  GstMyFilter *filter = GST_MY_FILTER (element);\n  GstTagSetter *tagsetter = GST_TAG_SETTER (element);\n  GstData *data;\n  GstEvent *event;\n  gboolean eos = FALSE;\n  GstTagList *taglist = gst_tag_list_new ();\n\n  while (!eos) {\n    data = gst_pad_pull (filter-&gt;sinkpad);\n\n    /* We're not very much interested in data right now */\n    if (GST_IS_BUFFER (data))\n      gst_buffer_unref (GST_BUFFER (data));\n    event = GST_EVENT (data);\n\n    switch (GST_EVENT_TYPE (event)) {\n      case GST_EVENT_TAG:\n        gst_tag_list_insert (taglist, gst_event_tag_get_list (event),\n                 GST_TAG_MERGE_PREPEND);\n        gst_event_unref (event);\n        break;\n      case GST_EVENT_EOS:\n        eos = TRUE;\n        gst_event_unref (event);\n        break;\n      default:\n        gst_pad_event_default (filter-&gt;sinkpad, event);\n        break;\n    }\n  }\n\n  /* merge tags with the ones retrieved from the application */\n  if ((gst_tag_setter_get_tag_list (tagsetter)) {\n    gst_tag_list_insert (taglist,\n             gst_tag_setter_get_tag_list (tagsetter),\n             gst_tag_setter_get_tag_merge_mode (tagsetter));\n  }\n\n  /* write tags */\n  gst_tag_list_foreach (taglist, gst_my_filter_write_tag, filter);\n\n  /* signal EOS */\n  gst_pad_push (filter-&gt;srcpad, gst_event_new (GST_EVENT_EOS));\n}\n\n\n</code></pre>\n<p>Note that normally, elements would not read the full stream before\nprocessing tags. Rather, they would read from each sinkpad until they've\nreceived data (since tags usually come in before the first data buffer)\nand process that.</p>\n\n</div>\n\n\n\t"});