fragment_downloaded_cb({"url": "libgstnet-doc-1.0/c/gstptpclock.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gstptpclock.h\">\n<h1 id=\"gstptpclock\">GstPtpClock</h1><p>GstPtpClock implements a PTP (IEEE1588:2008) ordinary clock in slave-only\nmode, that allows a GStreamer pipeline to synchronize to a PTP network\nclock in some specific domain.</p>\n<p>The PTP subsystem can be initialized with <a href=\"../../libgstnet-doc-1.0/c/gstptpclock.html#gst_ptp_init\">gst_ptp_init</a>, which then starts\na helper process to do the actual communication via the PTP ports. This is\nrequired as PTP listens on ports &lt; 1024 and thus requires special\nprivileges. Once this helper process is started, the main process will\nsynchronize to all PTP domains that are detected on the selected\ninterfaces.</p>\n<p><a href=\"../../libgstnet-doc-1.0/c/gstptpclock.html#gst_ptp_clock_new\">gst_ptp_clock_new</a> then allows to create a GstClock that provides the PTP\ntime from a master clock inside a specific PTP domain. This clock will only\nreturn valid timestamps once the timestamps in the PTP domain are known. To\ncheck this, you can use <a href=\"../../libgstreamer-doc-1.0/c/gstclock.html#gst_clock_wait_for_sync\">gst_clock_wait_for_sync</a>, the GstClock::synced\nsignal and <a href=\"../../libgstreamer-doc-1.0/c/gstclock.html#gst_clock_is_synced\">gst_clock_is_synced</a>.</p>\n<p>To gather statistics about the PTP clock synchronization,\n<a href=\"../../libgstnet-doc-1.0/c/gstptpclock.html#gst_ptp_statistics_callback_add\">gst_ptp_statistics_callback_add</a> can be used. This gives the application\nthe possibility to collect all kinds of statistics from the clock\nsynchronization.</p>\n\n</div>\n\n\n"});