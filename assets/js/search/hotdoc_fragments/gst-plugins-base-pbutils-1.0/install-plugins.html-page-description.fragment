fragment_downloaded_cb({"url": "gst-plugins-base-pbutils-1.0/install-plugins.html#page-description", "fragment": "Using this API applications can request the installation of missing GStreamer plugins. These may be missing decoders demuxers or encoders muxers for a certain format sources or sinks for a certain URI protocol e.g. http or certain elements known by their element factory name audioresample \nWhether plugin installation is supported or not depends on the operating system and or distribution in question. The vendor of the operating system needs to make sure the necessary hooks and mechanisms are in place for plugin installation to work. See below for more detailed information. \nFrom the application perspective plugin installation is usually triggered either \nThe install functions in this section all take one or more detail strings These detail strings contain information about the type of plugin that needs to be installed decoder encoder source sink or named element and some additional information such GStreamer version used and a human readable description of the component to install for user dialogs. \nApplications should not concern themselves with the composition of the string itself. They should regard the string as if it was a shared secret between GStreamer and the plugin installer application. \nDetail strings can be obtained using the function gst_missing_plugin_message_get_installer_detail on a missing plugin message. Such a message will either have been found by the application on a pipeline s GstBus or the application will have created it itself using gst_missing_element_message_new gst_missing_decoder_message_new gst_missing_encoder_message_new gst_missing_uri_sink_message_new or gst_missing_uri_source_message_new. \nFor each GStreamer element plugin component that should be installed the application needs one of those installer detail string mentioned in the previous section. This string can be obtained as already mentioned above from a missing plugin message using the function gst_missing_plugin_message_get_installer_detail. The missing plugin message is either posted by another element and then found on the bus by the application or the application has created it itself as described above. \nThe application will then call gst_install_plugins_async passing a NULL terminated array of installer detail strings and a function that should be called when the installation of the plugins has finished successfully or not Optionally a GstInstallPluginsContext created with gst_install_plugins_context_new may be passed as well. This way additional optional arguments like the application window s XID can be passed to the external installer application. \ngst_install_plugins_async will return almost immediately with the return code indicating whether plugin installation was started or not. If the necessary hooks for plugin installation are in place and an external installer application has in fact been called the passed in function will be called with a result code as soon as the external installer has finished. If the result code indicates that new plugins have been installed the application will want to call gst_update_registry so the run time plugin registry is updated and the new plugins are made available to the application. \nA Gtk GLib main loop must be running in order for the result function to be called when the external installer has finished. If this is not the case make sure to regularly call in your code \ng_main_context_iteration NULL FALSE \nWhen GStreamer applications initiate plugin installation via gst_install_plugins_async or gst_install_plugins_sync a pre defined helper application will be called. \nThe exact path of the helper application to be called is set at compile time usually by the configure script based on the install prefix. For a normal package build into the usr prefix this will usually default to usr libexec gst install plugins helper or usr lib gst install plugins helper. \nVendors distros who want to support GStreamer plugin installation should either provide such a helper script application or use the configure option with install plugins helper path to installer to make GStreamer call an installer of their own directly. \nIt is strongly recommended that vendors provide a small helper application as interlocutor to the real installer though even more so if command line argument munging is required to transform the command line arguments passed by GStreamer to the helper application into arguments that are understood by the real installer. \nThe helper application path defined at compile time can be overriden at runtime by setting the GST_INSTALL_PLUGINS_HELPER environment variable. This can be useful for testing debugging purposes. \nGStreamer will pass the following arguments to the install helper this is in addition to the path of the executable itself which is by convention argv \nnone to many optional arguments in the form of foo bar val. Example transient for XID where XID is the X Window ID of the main window of the calling application so the installer can make itself transient to that window Unknown optional arguments should be ignored by the installer. \none installer detail string argument for each plugin to be installed these strings will have a gstreamer prefix the exact format of the detail string is explained below \nThe string is in UTF encoding and is made up of several fields separated by characters but neither the first nor the last character is a The fields are \nAn entire ID string might then look like this for example gstreamer totem Vorbis audio decoder decoder audio x vorbis \nPlugin installers parsing this ID string should expect further fields also separated by symbols and either ignore them warn the user or error out when encountering them. \nThose unfamiliar with the GStreamer caps system should note a few things about the caps string used in the above decoder encoder case \nThe installer should return one of the following exit codes when it exits \nIt is up to the vendor to find mechanism to map required components from the detail string to the actual packages plugins to install. This could be a hardcoded list of mappings for example or be part of the packaging system metadata. \nGStreamer plugin files can be introspected for this information. The gst inspect utility has a special command line option that will output information similar to what is required. For example gst inspect print plugin auto install info path to libgstvorbis.so should output something along the lines ofdecoder audio x vorbis element vorbisdecelement vorbisencelement vorbisparse element vorbistag encoder audio x vorbis \nNote that in the encoder and decoder case the introspected caps can be more complex with additional fields e.g. audio mpeg mpegversion int so they will not always exactly match the caps wanted by the application. It is up to the installer to deal with this either by doing proper caps intersection using the GStreamer GstCaps API or by only taking into account the media type \nAnother potential source of problems are plugins such as ladspa or libvisual where the list of elements depends on the installed ladspa libvisual plugins at the time. This is also up to the distribution to handle but usually not relevant for playback applications \n"});