fragment_downloaded_cb({"url": "gst-plugins-base-pbutils-1.0/javascript/install-plugins.html#overview", "fragment": "Overview \nUsing this API applications can request the installation of missing GStreamer plugins. These may be missing decoders demuxers or encoders muxers for a certain format sources or sinks for a certain URI protocol e.g. http or certain elements known by their element factory name audioresample \nWhether plugin installation is supported or not depends on the operating system and or distribution in question. The vendor of the operating system needs to make sure the necessary hooks and mechanisms are in place for plugin installation to work. See below for more detailed information. \nFrom the application perspective plugin installation is usually triggered either \nThe install functions in this section all take one or more detail strings These detail strings contain information about the type of plugin that needs to be installed decoder encoder source sink or named element and some additional information such GStreamer version used and a human readable description of the component to install for user dialogs. \nApplications should not concern themselves with the composition of the string itself. They should regard the string as if it was a shared secret between GStreamer and the plugin installer application. \nDetail strings can be obtained using the function GstPbutils.prototype.missing_plugin_message_get_installer_detail on a missing plugin message. Such a message will either have been found by the application on a pipeline s Gst.Bus or the application will have created it itself using GstPbutils.prototype.missing_element_message_new GstPbutils.prototype.missing_decoder_message_new GstPbutils.prototype.missing_encoder_message_new GstPbutils.prototype.missing_uri_sink_message_new or GstPbutils.prototype.missing_uri_source_message_new. \nFor each GStreamer element plugin component that should be installed the application needs one of those installer detail string mentioned in the previous section. This string can be obtained as already mentioned above from a missing plugin message using the function GstPbutils.prototype.missing_plugin_message_get_installer_detail. The missing plugin message is either posted by another element and then found on the bus by the application or the application has created it itself as described above. \nThe application will then call GstPbutils.prototype.install_plugins_async passing a NULL terminated array of installer detail strings and a function that should be called when the installation of the plugins has finished successfully or not Optionally a GstPbutils.InstallPluginsContext created with GstPbutils.InstallPluginsContext.prototype.new may be passed as well. This way additional optional arguments like the application window s XID can be passed to the external installer application. \nGstPbutils.prototype.install_plugins_async will return almost immediately with the return code indicating whether plugin installation was started or not. If the necessary hooks for plugin installation are in place and an external installer application has in fact been called the passed in function will be called with a result code as soon as the external installer has finished. If the result code indicates that new plugins have been installed the application will want to call Gst.prototype.update_registry so the run time plugin registry is updated and the new plugins are made available to the application. \nA Gtk GLib main loop must be running in order for the result function to be called when the external installer has finished. If this is not the case make sure to regularly call in your code \ng_main_context_iteration NULL FALSE \n"});