fragment_downloaded_cb({"url": "gst-plugins-base-pbutils-1.0/python/install-plugins.html#page-description", "fragment": "Arguments passed to the install helper \nDetail string describing the missing plugin \nExit codes the installer should return \nHow to map the required detail string to packages \nGstInstallPluginsContext \nFunctions \nGStreamer will pass the following arguments to the install helper this is in addition to the path of the executable itself which is by convention argv \nnone to many optional arguments in the form of foo bar val. Example transient for XID where XID is the X Window ID of the main window of the calling application so the installer can make itself transient to that window Unknown optional arguments should be ignored by the installer. \none installer detail string argument for each plugin to be installed these strings will have a gstreamer prefix the exact format of the detail string is explained below \nThe string is in UTF encoding and is made up of several fields separated by characters but neither the first nor the last character is a The fields are \nAn entire ID string might then look like this for example gstreamer totem Vorbis audio decoder decoder audio x vorbis \nPlugin installers parsing this ID string should expect further fields also separated by symbols and either ignore them warn the user or error out when encountering them. \nThose unfamiliar with the GStreamer caps system should note a few things about the caps string used in the above decoder encoder case \nThe installer should return one of the following exit codes when it exits \nIt is up to the vendor to find mechanism to map required components from the detail string to the actual packages plugins to install. This could be a hardcoded list of mappings for example or be part of the packaging system metadata. \nGStreamer plugin files can be introspected for this information. The gst inspect utility has a special command line option that will output information similar to what is required. For example gst inspect print plugin auto install info path to libgstvorbis.so should output something along the lines ofdecoder audio x vorbis element vorbisdecelement vorbisencelement vorbisparse element vorbistag encoder audio x vorbis \nNote that in the encoder and decoder case the introspected caps can be more complex with additional fields e.g. audio mpeg mpegversion int so they will not always exactly match the caps wanted by the application. It is up to the installer to deal with this either by doing proper caps intersection using the GStreamer Gst.Caps API or by only taking into account the media type \nAnother potential source of problems are plugins such as ladspa or libvisual where the list of elements depends on the installed ladspa libvisual plugins at the time. This is also up to the distribution to handle but usually not relevant for playback applications \nCreates a new GstPbutils.InstallPluginsContext. \nFrees a GstPbutils.InstallPluginsContext. \nThis function is used to tell the external installer process whether it should ask for confirmation or not before searching for missing plugins. \nIf set this option will be passed to the installer via a interaction show confirm search hide confirm search command line option. \nThis function is used to pass the calling application s desktop file ID to the external installer process. \nA desktop file ID is the basename of the desktop file including the desktop extension. \nIf set the desktop file ID will be passed to the installer via a desktop id command line option. \nSets the startup notification ID for the launched process. \nThis is typically used to to pass the current X11 event timestamp to the external installer process. \nStartup notification IDs are defined in the FreeDesktop.Org Startup Notifications standard. \nIf set the ID will be passed to the installer via a startup notification id command line option. \nGTK GNOME applications should be able to create a startup notification ID like this \nThis function is for X11 based applications such as most Gtk Qt applications on linux unix only. You can use it to tell the external installer the XID of your main application window. That way the installer can make its own window transient to your application window during the installation. \nIf set the XID will be passed to the installer via a transient for XID command line option. \nGtk Gnome application should be able to obtain the XID of the top level window like this \nRequests plugin installation without blocking. Once the plugins have been installed or installation has failed func will be called with the result of the installation and your provided user_data pointer. \nThis function requires a running GLib Gtk main loop. If you are not running a GLib Gtk main loop make sure to regularly call g_main_context_iteration NULL FALSE \nThe installer strings that make up detail are typically obtained by calling GstPbutils.missing_plugin_message_get_installer_detail on missing plugin messages that have been caught on a pipeline s bus or created by the application via the provided API such as GstPbutils.missing_element_message_new. \nIt is possible to request the installation of multiple missing plugins in one go as might be required if there is a demuxer for a certain format installed but no suitable video decoder and no suitable audio decoder \nChecks whether plugin installation initiated by this application only is currently in progress. \nConvenience function to return the descriptive string associated with a status code. This function returns English strings and should not be used for user messages. It is here only to assist in debugging. \nChecks whether plugin installation is likely to be supported by the current environment. This currently only checks whether the helper script that is to be provided by the distribution or operating system vendor exists. \nRequests plugin installation and block until the plugins have been installed or installation has failed. \nThis function should almost never be used it only exists for cases where a non GLib main loop is running and the user wants to run it in a separate thread and marshal the result back asynchronously into the main thread using the other non GLib main loop. You should almost always use GstPbutils.install_plugins_async instead of this function. \nOpaque context structure for the plugin installation. Use the provided API to set details on it. \nResult codes returned by GstPbutils.install_plugins_async and GstPbutils.install_plugins_sync and also the result code passed to the GstPbutils.InstallPluginsResultFunc specified with GstPbutils.install_plugins_async. \nThese codes indicate success or failure of starting an external installer program and to what extent the requested plugins could be installed. \nsome of the requested plugins could be installed but not all \nGstPbutils.InstallPluginsReturn.user_abort \nthe user has aborted the installation \nGstPbutils.InstallPluginsReturn.crashed \nreturned by GstPbutils.install_plugins_async to indicate that everything went fine so far and the provided callback will be called with the result of the installation later \nGstPbutils.InstallPluginsReturn.internal_failure \nsome internal failure has occured when trying to start the installer \nGstPbutils.InstallPluginsReturn.helper_missing \nthe helper script to call the actual installer is not installed \nGstPbutils.InstallPluginsReturn.install_in_progress \na previously started plugin installation is still in progress try again later \nThe prototype of the callback function that will be called once the external plugin installer program has returned. You only need to provide a callback function if you are using the asynchronous interface. \n"});