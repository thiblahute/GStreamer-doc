fragment_downloaded_cb({"url": "gst-plugins-good-1.0/element-rtpbin.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"element-rtpbin\">\n<h1 id=\"rtpbin1\">rtpbin</h1><p>RTP bin combines the functions of <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpsession.html#GstRtpSession-struct\">GstRtpSession</a>, <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpssrcdemux.html#GstRtpSsrcDemux-struct\">GstRtpSsrcDemux</a>,\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpjitterbuffer.html#GstRtpJitterBuffer-struct\">GstRtpJitterBuffer</a> and <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpptdemux.html#GstRtpPtDemux-struct\">GstRtpPtDemux</a> in one element. It allows for multiple\nRTP sessions that will be synchronized together using RTCP SR packets.</p>\n<p><a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpbin.html#GstRtpBin-struct\">GstRtpBin</a> is configured with a number of request pads that define the\nfunctionality that is activated, similar to the <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpsession.html#GstRtpSession-struct\">GstRtpSession</a> element.</p>\n<p>To use <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpbin.html#GstRtpBin-struct\">GstRtpBin</a> as an RTP receiver, request a recv_rtp_sink_%u pad. The session\nnumber must be specified in the pad name.\nData received on the recv_rtp_sink_%u pad will be processed in the <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpsession.html#GstRtpSession-struct\">GstRtpSession</a>\nmanager and after being validated forwarded on <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpssrcdemux.html#GstRtpSsrcDemux-struct\">GstRtpSsrcDemux</a> element. Each\nRTP stream is demuxed based on the SSRC and send to a <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpjitterbuffer.html#GstRtpJitterBuffer-struct\">GstRtpJitterBuffer</a>. After\nthe packets are released from the jitterbuffer, they will be forwarded to a\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpptdemux.html#GstRtpPtDemux-struct\">GstRtpPtDemux</a> element. The <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpptdemux.html#GstRtpPtDemux-struct\">GstRtpPtDemux</a> element will demux the packets based\non the payload type and will create a unique pad recv_rtp_src_%u_%u_%u on\nrtpbin with the session number, SSRC and payload type respectively as the pad\nname.</p>\n<p>To also use <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpbin.html#GstRtpBin-struct\">GstRtpBin</a> as an RTCP receiver, request a recv_rtcp_sink_%u pad. The\nsession number must be specified in the pad name.</p>\n<p>If you want the session manager to generate and send RTCP packets, request\nthe send_rtcp_src_%u pad with the session number in the pad name. Packet pushed\non this pad contain SR/RR RTCP reports that should be sent to all participants\nin the session.</p>\n<p>To use <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpbin.html#GstRtpBin-struct\">GstRtpBin</a> as a sender, request a send_rtp_sink_%u pad, which will\nautomatically create a send_rtp_src_%u pad. If the session number is not provided,\nthe pad from the lowest available session will be returned. The session manager will modify the\nSSRC in the RTP packets to its own SSRC and wil forward the packets on the\nsend_rtp_src_%u pad after updating its internal state.</p>\n<p><a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpbin.html#GstRtpBin-struct\">GstRtpBin</a> can also demultiplex incoming bundled streams. The first\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpsession.html#GstRtpSession-struct\">GstRtpSession</a> will have a <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpssrcdemux.html#GstRtpSsrcDemux-struct\">GstRtpSsrcDemux</a> element splitting the streams\nbased on their SSRC and potentially dispatched to a different <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpsession.html#GstRtpSession-struct\">GstRtpSession</a>.\nBecause retransmission SSRCs need to be merged with the corresponding media\nstream the GstRtpBin::on-bundled-ssrc signal is emitted so that the\napplication can find out to which session the SSRC belongs.</p>\n<p>The session manager needs the clock-rate of the payload types it is handling\nand will signal the <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpsession.html#GstRtpSession-request-pt-map\">GstRtpSession::request-pt-map</a> signal when it needs such a\nmapping. One can clear the cached values with the <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpsession.html#GstRtpSession-clear-pt-map\">GstRtpSession::clear-pt-map</a>\nsignal.</p>\n<p>Access to the internal statistics of rtpbin is provided with the\nget-internal-session property. This action signal gives access to the\nRTPSession object which further provides action signals to retrieve the\ninternal source and other sources.</p>\n<p><a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpbin.html#GstRtpBin-struct\">GstRtpBin</a> also has signals (#GstRtpBin::request-rtp-encoder,\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpbin.html#GstRtpBin-request-rtp-decoder\">GstRtpBin::request-rtp-decoder</a>, <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpbin.html#GstRtpBin-request-rtcp-encoder\">GstRtpBin::request-rtcp-encoder</a> and\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpbin.html#GstRtpBin-request-rtp-decoder\">GstRtpBin::request-rtp-decoder</a>) to dynamically request for RTP and RTCP encoders\nand decoders in order to support SRTP. The encoders must provide the pads\nrtp_sink_%u and rtp_src_%u for RTP and rtcp_sink_%u and rtcp_src_%u for\nRTCP. The session number will be used in the pad name. The decoders must provide\nrtp_sink and rtp_src for RTP and rtcp_sink and rtcp_src for RTCP. The decoders will\nbe placed before the <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpsession.html#GstRtpSession-struct\">GstRtpSession</a> element, thus they must support SSRC demuxing\ninternally.</p>\n<p><a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpbin.html#GstRtpBin-struct\">GstRtpBin</a> has signals (#GstRtpBin::request-aux-sender and\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpbin.html#GstRtpBin-request-aux-receiver\">GstRtpBin::request-aux-receiver</a> to dynamically request an element that can be\nused to create or merge additional RTP streams. AUX elements are needed to\nimplement FEC or retransmission (such as RFC 4588). An AUX sender must have one\nsink_%u pad that matches the sessionid in the signal and it should have 1 or\nmore src_%u pads. For each src_%\\u pad, a session will be made (if needed)\nand the pad will be linked to the session send_rtp_sink pad. Each session will\nthen expose its source pad as send_rtp_src_%u on <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpbin.html#GstRtpBin-struct\">GstRtpBin</a>.\nAn AUX receiver has 1 src_%u pad that much match the sessionid in the signal\nand 1 or more sink_%u pads. A session will be made for each sink_%u pad\nwhen the corresponding recv_rtp_sink_%u pad is requested on <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpbin.html#GstRtpBin-struct\">GstRtpBin</a>.</p>\n<h2 id=\"example-pipelines\">Example pipelines</h2>\n<pre><code class=\"language-[\"> gst-launch-1.0 udpsrc port=5000 caps=\"application/x-rtp, ...\" ! .recv_rtp_sink_0 \\\n     rtpbin ! rtptheoradepay ! theoradec ! xvimagesink\n ]| Receive RTP data from port 5000 and send to the session 0 in rtpbin.\n |[\n gst-launch-1.0 rtpbin name=rtpbin \\\n         v4l2src ! videoconvert ! ffenc_h263 ! rtph263ppay ! rtpbin.send_rtp_sink_0 \\\n                   rtpbin.send_rtp_src_0 ! udpsink port=5000                            \\\n                   rtpbin.send_rtcp_src_0 ! udpsink port=5001 sync=false async=false    \\\n                   udpsrc port=5005 ! rtpbin.recv_rtcp_sink_0                           \\\n         audiotestsrc ! amrnbenc ! rtpamrpay ! rtpbin.send_rtp_sink_1                   \\\n                   rtpbin.send_rtp_src_1 ! udpsink port=5002                            \\\n                   rtpbin.send_rtcp_src_1 ! udpsink port=5003 sync=false async=false    \\\n                   udpsrc port=5007 ! rtpbin.recv_rtcp_sink_1\n ]| Encode and payload H263 video captured from a v4l2src. Encode and payload AMR\n audio generated from audiotestsrc. The video is sent to session 0 in rtpbin\n and the audio is sent to session 1. Video packets are sent on UDP port 5000\n and audio packets on port 5002. The video RTCP packets for session 0 are sent\n on port 5001 and the audio RTCP packets for session 0 are sent on port 5003.\n RTCP packets for session 0 are received on port 5005 and RTCP for session 1\n is received on port 5007. Since RTCP packets from the sender should be sent\n as soon as possible and do not participate in preroll, sync=false and\n async=false is configured on udpsink\n |[\n gst-launch-1.0 -v rtpbin name=rtpbin                                          \\\n     udpsrc caps=\"application/x-rtp,media=(string)video,clock-rate=(int)90000,encoding-name=(string)H263-1998\" \\\n             port=5000 ! rtpbin.recv_rtp_sink_0                                \\\n         rtpbin. ! rtph263pdepay ! ffdec_h263 ! xvimagesink                    \\\n      udpsrc port=5001 ! rtpbin.recv_rtcp_sink_0                               \\\n      rtpbin.send_rtcp_src_0 ! udpsink port=5005 sync=false async=false        \\\n     udpsrc caps=\"application/x-rtp,media=(string)audio,clock-rate=(int)8000,encoding-name=(string)AMR,encoding-params=(string)1,octet-align=(string)1\" \\\n             port=5002 ! rtpbin.recv_rtp_sink_1                                \\\n         rtpbin. ! rtpamrdepay ! amrnbdec ! alsasink                           \\\n      udpsrc port=5003 ! rtpbin.recv_rtcp_sink_1                               \\\n      rtpbin.send_rtcp_src_1 ! udpsink port=5007 sync=false async=false\n ]| Receive H263 on port 5000, send it through rtpbin in session 0, depayload,\n decode and display the video.\n Receive AMR on port 5002, send it through rtpbin in session 1, depayload,\n decode and play the audio.\n Receive server RTCP packets for session 0 on port 5001 and RTCP packets for\n session 1 on port 5003. These packets will be used for session management and\n synchronisation.\n Send RTCP reports for session 0 on port 5005 and RTCP reports for session 1\n on port 5007.\n</code></pre>\n\n</div>\n\n\n"});