fragment_downloaded_cb({"url": "gst-plugins-base-audio-doc-1.0/python/gstaudioencoder.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gstaudioencoder.h\">\n<h1 id=\"gstaudioencoder\">GstAudioEncoder</h1><p>This base class is for audio encoders turning raw audio samples into\nencoded audio data.</p>\n<p>GstAudioEncoder and subclass should cooperate as follows.</p>\n<h2 id=\"configuration\">Configuration</h2>\n<ul>\n<li>\n<p>Initially, GstAudioEncoder calls <em>start</em> when the encoder element\nis activated, which allows subclass to perform any global setup.</p>\n</li>\n<li>\n<p>GstAudioEncoder calls <em>set_format</em> to inform subclass of the format\nof input audio data that it is about to receive.  Subclass should\nsetup for encoding and configure various base class parameters\nappropriately, notably those directing desired input data handling.\nWhile unlikely, it might be called more than once, if changing input\nparameters require reconfiguration.</p>\n</li>\n<li>\n<p>GstAudioEncoder calls <em>stop</em> at end of all processing.</p>\n</li>\n</ul>\n<p>As of configuration stage, and throughout processing, GstAudioEncoder\nmaintains various parameters that provide required context,\ne.g. describing the format of input audio data.\nConversely, subclass can and should configure these context parameters\nto inform base class of its expectation w.r.t. buffer handling.</p>\n<h2 id=\"data-processing\">Data processing</h2>\n<pre><code> * Base class gathers input sample data (as directed by the context's\n   frame_samples and frame_max) and provides this to subclass' @handle_frame.\n * If codec processing results in encoded data, subclass should call\n   gst_audio_encoder_finish_frame() to have encoded data pushed\n   downstream. Alternatively, it might also call\n   gst_audio_encoder_finish_frame() (with a NULL buffer and some number of\n   dropped samples) to indicate dropped (non-encoded) samples.\n * Just prior to actually pushing a buffer downstream,\n   it is passed to @pre_push.\n * During the parsing process GstAudioEncoderClass will handle both\n   srcpad and sinkpad events. Sink events will be passed to subclass\n   if @event callback has been provided.\n</code></pre>\n<h2 id=\"shutdown-phase\">Shutdown phase</h2>\n<ul>\n<li>GstAudioEncoder class calls <em>stop</em> to inform the subclass that data\nparsing will be stopped.</li>\n</ul>\n<p>Subclass is responsible for providing pad template caps for\nsource and sink pads. The pads need to be named \"sink\" and \"src\". It also\nneeds to set the fixed caps on srcpad, when the format is ensured.  This\nis typically when base class calls subclass' <em>set_format</em> function, though\nit might be delayed until calling <em>gst_audio_encoder_finish_frame</em>.</p>\n<p>In summary, above process should have subclass concentrating on\ncodec data processing while leaving other matters to base class,\nsuch as most notably timestamp handling.  While it may exert more control\nin this area (see e.g. <em>pre_push</em>), it is very much not recommended.</p>\n<p>In particular, base class will either favor tracking upstream timestamps\n(at the possible expense of jitter) or aim to arrange for a perfect stream of\noutput timestamps, depending on <a href=\"gstaudioencoder.html#GstAudioEncoder:perfect-timestamp\">perfect-timestamp</a>.\nHowever, in the latter case, the input may not be so perfect or ideal, which\nis handled as follows.  An input timestamp is compared with the expected\ntimestamp as dictated by input sample stream and if the deviation is less\nthan <a href=\"gstaudioencoder.html#GstAudioEncoder:tolerance\">tolerance</a>, the deviation is discarded.\nOtherwise, it is considered a discontuinity and subsequent output timestamp\nis resynced to the new position after performing configured discontinuity\nprocessing.  In the non-perfect-timestamp case, an upstream variation\nexceeding tolerance only leads to marking DISCONT on subsequent outgoing\n(while timestamps are adjusted to upstream regardless of variation).\nWhile DISCONT is also marked in the perfect-timestamp case, this one\noptionally (see <a href=\"gstaudioencoder.html#GstAudioEncoder:hard-resync\">hard-resync</a>)\nperforms some additional steps, such as clipping of (early) input samples\nor draining all currently remaining input data, depending on the direction\nof the discontuinity.</p>\n<p>If perfect timestamps are arranged, it is also possible to request baseclass\n(usually set by subclass) to provide additional buffer metadata (in OFFSET\nand OFFSET_END) fields according to granule defined semantics currently\nneeded by oggmux.  Specifically, OFFSET is set to granulepos (= sample count\nincluding buffer) and OFFSET_END to corresponding timestamp (as determined\nby same sample count and sample rate).</p>\n<p>Things that subclass need to take care of:</p>\n<ul>\n<li>Provide pad templates</li>\n<li>Set source pad caps when appropriate</li>\n<li>Inform base class of buffer processing needs using context's\nframe_samples and frame_bytes.</li>\n<li>Set user-configurable properties to sane defaults for format and\nimplementing codec at hand, e.g. those controlling timestamp behaviour\nand discontinuity processing.</li>\n<li>Accept data in <em>handle_frame</em> and provide encoded results to\n<a href=\"gstaudioencoder.html#gst_audio_encoder_finish_frame\">GstAudio.AudioEncoder.finish_frame</a>.</li>\n</ul>\n\n</div>\n\n\n"});