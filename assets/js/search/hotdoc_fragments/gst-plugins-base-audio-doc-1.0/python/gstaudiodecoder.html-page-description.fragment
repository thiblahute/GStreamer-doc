fragment_downloaded_cb({"url": "gst-plugins-base-audio-doc-1.0/python/gstaudiodecoder.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gstaudiodecoder.h\">\n<h1 id=\"gstaudiodecoder\">GstAudioDecoder</h1><p>This base class is for audio decoders turning encoded data into\nraw audio samples.</p>\n<p>GstAudioDecoder and subclass should cooperate as follows.</p>\n<h2 id=\"configuration\">Configuration</h2>\n<ul>\n<li>Initially, GstAudioDecoder calls <em>start</em> when the decoder element\nis activated, which allows subclass to perform any global setup.\nBase class (context) parameters can already be set according to subclass\ncapabilities (or possibly upon receive more information in subsequent\n<em>set_format</em>).</li>\n<li>GstAudioDecoder calls <em>set_format</em> to inform subclass of the format\nof input audio data that it is about to receive.\nWhile unlikely, it might be called more than once, if changing input\nparameters require reconfiguration.</li>\n<li>GstAudioDecoder calls <em>stop</em> at end of all processing.</li>\n</ul>\n<p>As of configuration stage, and throughout processing, GstAudioDecoder\nprovides various (context) parameters, e.g. describing the format of\noutput audio data (valid when output caps have been set) or current parsing state.\nConversely, subclass can and should configure context to inform\nbase class of its expectation w.r.t. buffer handling.</p>\n<h2 id=\"data-processing\">Data processing</h2>\n<pre><code> * Base class gathers input data, and optionally allows subclass\n   to parse this into subsequently manageable (as defined by subclass)\n   chunks.  Such chunks are subsequently referred to as 'frames',\n   though they may or may not correspond to 1 (or more) audio format frame.\n * Input frame is provided to subclass' @handle_frame.\n * If codec processing results in decoded data, subclass should call\n   @gst_audio_decoder_finish_frame to have decoded data pushed\n   downstream.\n * Just prior to actually pushing a buffer downstream,\n   it is passed to @pre_push.  Subclass should either use this callback\n   to arrange for additional downstream pushing or otherwise ensure such\n   custom pushing occurs after at least a method call has finished since\n   setting src pad caps.\n * During the parsing process GstAudioDecoderClass will handle both\n   srcpad and sinkpad events. Sink events will be passed to subclass\n   if @event callback has been provided.\n</code></pre>\n<h2 id=\"shutdown-phase\">Shutdown phase</h2>\n<ul>\n<li>GstAudioDecoder class calls <em>stop</em> to inform the subclass that data\nparsing will be stopped.</li>\n</ul>\n<p>Subclass is responsible for providing pad template caps for\nsource and sink pads. The pads need to be named \"sink\" and \"src\". It also\nneeds to set the fixed caps on srcpad, when the format is ensured.  This\nis typically when base class calls subclass' <em>set_format</em> function, though\nit might be delayed until calling <em>gst_audio_decoder_finish_frame</em>.</p>\n<p>In summary, above process should have subclass concentrating on\ncodec data processing while leaving other matters to base class,\nsuch as most notably timestamp handling.  While it may exert more control\nin this area (see e.g. <em>pre_push</em>), it is very much not recommended.</p>\n<p>In particular, base class will try to arrange for perfect output timestamps\nas much as possible while tracking upstream timestamps.\nTo this end, if deviation between the next ideal expected perfect timestamp\nand upstream exceeds <a href=\"gstaudiodecoder.html#GstAudioDecoder:tolerance\">tolerance</a>, then resync to upstream\noccurs (which would happen always if the tolerance mechanism is disabled).</p>\n<p>In non-live pipelines, baseclass can also (configurably) arrange for\noutput buffer aggregation which may help to redue large(r) numbers of\nsmall(er) buffers being pushed and processed downstream.</p>\n<p>On the other hand, it should be noted that baseclass only provides limited\nseeking support (upon explicit subclass request), as full-fledged support\nshould rather be left to upstream demuxer, parser or alike.  This simple\napproach caters for seeking and duration reporting using estimated input\nbitrates.</p>\n<p>Things that subclass need to take care of:</p>\n<ul>\n<li>\n<p>Provide pad templates</p>\n</li>\n<li>\n<p>Set source pad caps when appropriate</p>\n</li>\n<li>\n<p>Set user-configurable properties to sane defaults for format and\nimplementing codec at hand, and convey some subclass capabilities and\nexpectations in context.</p>\n</li>\n<li>\n<p>Accept data in <em>handle_frame</em> and provide encoded results to\n<em>gst_audio_decoder_finish_frame</em>.  If it is prepared to perform\nPLC, it should also accept NULL data in <em>handle_frame</em> and provide for\ndata for indicated duration.</p>\n</li>\n</ul>\n\n</div>\n\n\n"});