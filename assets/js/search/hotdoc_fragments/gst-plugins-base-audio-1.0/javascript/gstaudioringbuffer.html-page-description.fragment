fragment_downloaded_cb({"url": "gst-plugins-base-audio-1.0/javascript/gstaudioringbuffer.html#page-description", "fragment": "Virtual Methods \nThe ringbuffer base class structure. \nguint8 empty_seg \npointer to memory holding one segment of silence samples \ngint channel_reorder_map \ngboolean flushing \ngpointer _gst_reserved \nPrint debug info about the buffer sized in spec to the debug log. \nPrint debug info about the parsed caps in spec to the debug log. \nParse caps into spec. \nAllocate the resources for the ringbuffer. This function fills in the data pointer of the ring buffer with a valid Gst.Buffer to which samples can be written. \nActivate buf to start or stop pulling data. \nMT safe. \nSubclasses should call this function to notify the fact that advance segments are now processed by the device. \nMT safe. \nClear the given segment of the buffer with silence samples. This function is used by subclasses. \nMT safe. \nFill the ringbuffer with silence. \nMT safe. \nClose the audio device associated with the ring buffer. The ring buffer should already have been released via GstAudio.AudioRingBuffer.prototype.release. \nCommit in_samples samples pointed to by data to the ringbuffer buf. \nin_samples and out_samples define the rate conversion to perform on the samples in data. For negative rates out_samples must be negative and in_samples positive. \nWhen out_samples is positive the first sample will be written at position sample in the ringbuffer. When out_samples is negative the last sample will be written to sample in reverse order. \nout_samples does not need to be a multiple of the segment size of the ringbuffer although it is recommended for optimal performance. \naccum will hold a temporary accumulator used in rate conversion and should be set to when this function is first called. In case the commit operation is interrupted one can resume the processing by passing the previously returned accum value back to this function. \nMT safe. \nConvert src_val in src_fmt to the equivalent value in dest_fmt. The result will be put in dest_val. \nGet the number of samples queued in the audio device. This is usually less than the segment size but can be bigger when the implementation uses another internal buffer between the audio device. \nFor playback ringbuffers this is the amount of samples transfered from the ringbuffer to the device but still not played. \nFor capture ringbuffers this is the amount of samples in the device that are not yet transfered to the ringbuffer. \nChecks the status of the device associated with the ring buffer. \nCheck if the ringbuffer is acquired and ready to use. \nCheck if buf is activated. \nMT safe. \nCheck if buf is flushing. \nMT safe. \nTell the ringbuffer that it is allowed to start playback when the ringbuffer is filled with samples. \nMT safe. \nOpen the audio device associated with the ring buffer. Does not perform any setup on the device. You must open the device before acquiring the ring buffer. \nPause processing samples from the ringbuffer. \nReturns a pointer to memory where the data from segment segment can be found. This function is mostly used by subclasses. \nRead len samples from the ringbuffer into the memory pointed to by data. The first sample should be read from position sample in the ringbuffer. \nlen should not be a multiple of the segment size of the ringbuffer although it is recommended. \ntimestamp will return the timestamp associated with the data returned. \nFree the resources of the ringbuffer. \nGet the number of samples that were processed by the ringbuffer since it was last started. This does not include the number of samples not yet processed see GstAudio.AudioRingBuffer.prototype.delay \nSets the given callback function on the buffer. This function will be called every time a segment has been written to a device. \nMT safe. \nTell the ringbuffer about the device s channel positions. This must be called in when the ringbuffer is acquired. \nSet the ringbuffer to flushing mode or normal mode. \nMT safe. \nMake sure that the next sample written to the device is accounted for as being the sample sample written to the device. This value will be used in reporting the current sample position of the ringbuffer. \nThis function will also clear the buffer with silence. \nMT safe. \nStart processing samples from the ringbuffer. \nStop processing samples from the ringbuffer. \ngpointer _gst_reserved \nguint64 buffer_time \nthe total buffer size in microseconds \ngint segsize \nthe size of one segment in bytes \ngint segtotal \nthe total number of segments \ngint seglatency \nnumber of segments queued in the lower level device defaults to segtotal \ngpointer _gst_reserved \nThe format of the samples in the ringbuffer. \nsamples in linear or float \nGstAudio.AudioRingBufferFormatType.prototype.mu_law \nsamples in mulaw \nGstAudio.AudioRingBufferFormatType.prototype.a_law \nsamples in alaw \nGstAudio.AudioRingBufferFormatType.prototype.ima_adpcm \nsamples in ima adpcm \nGstAudio.AudioRingBufferFormatType.prototype.mpeg \nsamples in mpeg audio but not AAC format \nGstAudio.AudioRingBufferFormatType.prototype.gsm \nsamples in gsm format \nGstAudio.AudioRingBufferFormatType.prototype.iec958 \nsamples in IEC958 frames e.g. AC3 \nGstAudio.AudioRingBufferFormatType.prototype.ac3 \nsamples in AC3 format \nGstAudio.AudioRingBufferFormatType.prototype.eac3 \nsamples in EAC3 format \nGstAudio.AudioRingBufferFormatType.prototype.dts \nsamples in DTS format \nGstAudio.AudioRingBufferFormatType.prototype.mpeg2_aac \nsamples in MPEG AAC ADTS format \nGstAudio.AudioRingBufferFormatType.prototype.mpeg4_aac \nsamples in MPEG AAC ADTS format \nGstAudio.AudioRingBufferFormatType.prototype.mpeg2_aac_raw \nsamples in MPEG AAC raw format Since \nGstAudio.AudioRingBufferFormatType.prototype.mpeg4_aac_raw \nsamples in MPEG AAC raw format Since \nGstAudio.AudioRingBufferFormatType.prototype.flac \nsamples in FLAC format Since \nThe state of the ringbuffer. \nThe ringbuffer is stopped \nGstAudio.AudioRingBufferState.prototype.paused \nThe ringbuffer is paused \nGstAudio.AudioRingBufferState.prototype.started \nThe ringbuffer is started \nGstAudio.AudioRingBufferState.prototype.error \nThe ringbuffer has encountered an error after it has been started e.g. because the device was disconnected Since \nThis function is set with gst_audio_ring_buffer_set_callback not introspectable and is called to fill the memory at data with len bytes of samples. \n"});