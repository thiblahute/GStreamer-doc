fragment_downloaded_cb({"url": "gst-plugins-base-video-1.0/python/videooverlay.html#two-basic-usage-scenarios", "fragment": "Two basic usage scenarios \nThere are two basic usage scenarios in the simplest case the application uses playbin not introspectable or plasink or knows exactly what particular element is used for video output which is usually the case when the application creates the videosink to use e.g. xvimagesink not introspectable ximagesink not introspectable etc. itself in this case the application can just create the videosink element create and realize the window to render the video on and then call GstVideo.VideoOverlay.set_window_handle directly with the XID or native window handle before starting up the pipeline. As playbin not introspectable and playsink not introspectable implement the video overlay interface and proxy it transparently to the actual video sink even if it is created later this case also applies when using these elements. \nIn the other and more common case the application does not know in advance what GStreamer video sink element will be used for video output. This is usually the case when an element such as autovideosink not introspectable is used. In this case the video sink element itself is created asynchronously from a GStreamer streaming thread some time after the pipeline has been started up. When that happens however the video sink will need to know right then whether to render onto an already existing application window or whether to create its own window. This is when it posts a prepare window handle message and that is also why this message needs to be handled in a sync bus handler which will be called from the streaming thread directly because the video sink will need an answer right then \nAs response to the prepare window handle element message in the bus sync handler the application may use GstVideo.VideoOverlay.set_window_handle to tell the video sink to render onto an existing window surface. At this point the application should already have obtained the window handle XID so it just needs to set it. It is generally not advisable to call any GUI toolkit functions or window system functions from the streaming thread in which the prepare window handle message is handled because most GUI toolkits and windowing systems are not thread safe at all and a lot of care would be required to co ordinate the toolkit and window system calls of the different threads Gtk users please note prior to Gtk GDK_WINDOW_XID was just a simple structure access so generally fine to do within the bus sync handler this macro was changed to a function call in Gtk and later which is likely to cause problems when called from a sync handler see below for a better approach without GDK_WINDOW_XID used in the callback \n"});