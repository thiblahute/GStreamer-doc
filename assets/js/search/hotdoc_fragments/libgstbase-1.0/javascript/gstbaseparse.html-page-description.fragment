fragment_downloaded_cb({"url": "libgstbase-1.0/javascript/gstbaseparse.html#page-description", "fragment": "Description of the parsing mechanism \nThe opaque GstBase.BaseParse data structure. \nAdds an entry to the index associating offset to ts. It is recommended to only add keyframe entries. force allows to bypass checks such as whether the stream is upstream seekable another entry is already close to the new entry etc. \nDefault implementation of convert vmethod in GstBase.BaseParse class. \nDrains the adapter until it is empty. It decreases the min_frame_size to match the current adapter size and calls chain method until the adapter is emptied or chain returns with error. \nCollects parsed data and pushes this downstream. Source pad caps must be set when this is called. \nIf frame s out_buffer is set that will be used as subsequent frame data. Otherwise size samples will be taken from the input and used for output and the output s metadata timestamps etc will be taken as optionally set by the subclass on frame s input buffer which is otherwise ignored for any but the above purpose information \nNote that the latter buffer is invalidated by this call whereas the caller retains ownership of frame. \nSets the parser subclass s tags and how they should be merged with any upstream stream tags. This will override any tags previously set with GstBase.BaseParse.prototype.merge_tags. \nNote that this is provided for convenience and the subclass is not required to use this and can still do tag handling on its own. \nPushes the frame s buffer downstream sends any pending events and does some timestamp and segment handling. Takes ownership of frame s buffer though caller retains ownership of frame. \nThis must be called with sinkpad STREAM_LOCK held. \nOptionally sets the average bitrate detected in media if non zero e.g. based on metadata as it will be posted to the application. \nBy default announced average bitrate is estimated. The average bitrate is used to estimate the total duration of the stream and to estimate a seek position if there s no index and the format is syncable see GstBase.BaseParse.prototype.set_syncable \nSets the duration of the currently playing media. Subclass can use this when it is able to determine duration and or notices a change in the media duration. Alternatively if interval is non zero default then stream duration is determined based on estimated bitrate and updated every interval frames. \nIf frames per second is configured parser can take care of buffer duration and timestamping. When performing segment clipping or seeking to a specific location a corresponding decoder might need an initial lead_in and a following lead_out number of frames to ensure the desired segment is entirely filled upon decoding. \nSet if frames carry timing information which the subclass can generally parse and provide. In particular intrinsic rather than estimated time can be obtained following a seek. \nBy default the base class might try to infer PTS from DTS and vice versa. While this is generally correct for audio data it may not be otherwise. Sub classes implementing such formats should disable timestamp inferring. \nSets the minimum and maximum which may likely be equal latency introduced by the parsing process. If there is such a latency which depends on the particular parsing of the format it typically corresponds to frame duration. \nSubclass can use this function to tell the base class that it needs to give at least min_size buffers. \nSet if the nature of the format or configuration does not allow much parsing and the parser should operate in passthrough mode which only applies when operating in push mode That is incoming buffers are pushed through unmodified i.e. no check_valid_frame or parse_frame callbacks will be invoked but pre_push_frame will still be invoked so subclass can perform as much or as little is appropriate for passthrough semantics in pre_push_frame. \nBy default the base class will guess PTS timestamps using a simple interpolation previous timestamp duration which is incorrect for data streams with reordering where PTS can go backward. Sub classes implementing such formats should disable PTS interpolation. \nSet if frame starts can be identified. This is set by default and determines whether seeking based on bitrate averages is possible for a format stream. \nThis function should only be called from a handle_frame implementation. \nGstBase.BaseParse creates initial timestamps for frames by using the last timestamp seen in the stream before the frame starts. In certain cases the correct timestamps will occur in the stream after the start of the frame but before the start of the actual picture data. This function can be used to set the timestamps based on the offset into the frame data that the picture starts. \ngpointer _gst_reserved \nAllocates a new GstBase.BaseParseFrame. This function is mainly for bindings elements written in C should usually allocate the frame on the stack and then use GstBase.BaseParseFrame.prototype.init to initialise it. \nSets a GstBase.BaseParseFrame to initial state. Currently this means all public fields are zero ed and a private flag is set to make sure GstBase.BaseParseFrame.prototype.free only frees the contents but not the actual frame. Use this function to initialise a GstBase.BaseParseFrame allocated on the stack. \ngpointer _gst_reserved_p \nguint _private_flags \nFlags to be used in a GstBase.BaseParseFrame. \nno flag \nGstBase.BaseParseFrameFlags.prototype.new_frame \nset by baseclass if current frame is passed for processing to the subclass for the first time and not set on subsequent calls with same data \nGstBase.BaseParseFrameFlags.prototype.no_frame \nset to indicate this buffer should not be counted as frame e.g. if this frame is dependent on a previous one. As it is not counted as a frame bitrate increases but frame to time conversions are maintained. \nGstBase.BaseParseFrameFlags.prototype.clip \npre_push_frame can set this to indicate that regular segment clipping can still be performed as opposed to any custom one having been done \nGstBase.BaseParseFrameFlags.prototype.drop \nindicates to finish_frame that the the frame should be dropped and might be handled internally by subclass \nGstBase.BaseParseFrameFlags.prototype.queue \nindicates to finish_frame that the the frame should be queued for now and processed fully later when the first non queued frame is finished \n"});