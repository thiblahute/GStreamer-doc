fragment_downloaded_cb({"url": "libgstbase-1.0/javascript/gstbasesrc.html#page-description", "fragment": "Controlled shutdown of live sources in applications \nGstBaseSrc \nApplications that record from a live source may want to stop recording in a controlled way so that the recording is stopped but the data already in the pipeline is processed to the end remember that many live sources would go on recording forever otherwise For that to happen the application needs to make the source stop recording and send an EOS event down the pipeline. The application would then wait for an EOS message posted on the pipeline s bus to know when all data has been processed and the pipeline can safely be stopped. \nAn application may send an EOS event to a source element to make it perform the EOS logic send EOS event downstream or post a Gst.MessageType.prototype.segment_done on the bus This can typically be done with the Gst.Element.prototype.send_event function on the element or its parent bin. \nAfter the EOS has been sent to the element the application should wait for an EOS message to be posted on the pipeline s bus. Once this EOS message is received it may safely shut down the entire pipeline. \nThe opaque GstBase.BaseSrc data structure. \nLets GstBase.BaseSrc sub classes to know the memory allocator used by the base class and its params. \nUnref the allocator after usage. \nGet the number of bytes that src will push out with each buffer. \nQuery if src timestamps outgoing buffers based on the current running_time. \nGet the current async behaviour of src. See also GstBase.BaseSrc.prototype.set_async. \nCheck if an element is in live mode. \nPrepare a new seamless segment for emission downstream. This function must only be called by derived sub classes and only from the create function as the stream lock needs to be held. \nThe format for the new segment will be the current format of the source as configured with GstBase.BaseSrc.prototype.set_format \nQuery the source for the latency parameters. live will be true when src is configured as a live source. min_latency and max_latency will be set to the difference between the running time and the timestamp of the first buffer. \nThis function is mostly used by subclasses. \nConfigure async behaviour in src no state change will block. The open close start stop play and pause virtual methods will be executed in a different thread and are thus allowed to perform blocking operations. Any blocking operation should be unblocked with the unlock vmethod. \nIf automatic_eos is true src will automatically go EOS if a buffer after the total size is returned. By default this is true but sources that can t return an authoritative size and only know that they re EOS when trying to read more should set this to false. \nSet the number of bytes that src will push out with each buffer. When blocksize is set to a default length will be used. \nSet new caps on the basesrc source pad. \nConfigure src to automatically timestamp outgoing buffers based on the current running_time of the pipeline. This property is mostly useful for live sources. \nIf not dynamic size is only updated when needed such as when trying to read past current tracked size. Otherwise size is checked for upon each read. \nSets the default format of the source. This will be the format used for sending SEGMENT events and for performing seeks. \nIf a format of GST_FORMAT_BYTES is set the element will be able to operate in pull mode if the GstBaseSrcClass.is_seekable returns true. \nThis function must only be called in states Gst.State.prototype.paused. \nIf the element listens to a live source live should be set to true. \nA live source will not produce data in the PAUSED state and will therefore not be able to participate in the PREROLL phase of a pipeline. To signal this fact to the application and the pipeline the state change return value of the live source will be GST_STATE_CHANGE_NO_PREROLL. \nComplete an asynchronous start operation. When the subclass overrides the start method it should call GstBase.BaseSrc.prototype.start_complete when the start operation completes either from the same thread or from an asynchronous helper thread. \nWait until the start operation completes. \nIf the GstBaseSrcClass.create not introspectable method performs its own synchronisation against the clock it must unblock when going from PLAYING to the PAUSED state and call this method before continuing to produce the remaining data. \nThis function will block until a state change to PLAYING happens in which case this function returns Gst.FlowReturn.prototype.ok or the processing must be stopped due to a state change to READY or a FLUSH event in which case this function returns Gst.FlowReturn.prototype.flushing \n"});