fragment_downloaded_cb({"url": "libgstbase-1.0/javascript/gstbasesink.html#page-description", "fragment": "The opaque GstBase.BaseSink data structure. \nIf the sink spawns its own thread for pulling buffers from upstream it should call this method after it has pulled a buffer. If the element needed to preroll this function will perform the preroll and will then block until the element state is changed. \nThis function should be called with the PREROLL_LOCK held. \nGet the number of bytes that the sink will pull when it is operating in pull mode. \nChecks if sink is currently configured to drop buffers which are outside the current segment \nGet the last sample that arrived in the sink and was used for preroll or for rendering. This property can be used to generate thumbnails. \nThe Gst.Caps on the sample can be used to determine the type of the buffer. \nFree function gst_sample_unref \nGet the currently configured latency. \nGet the maximum amount of bits per second that the sink will render. \nGets the max lateness value. See GstBase.BaseSink.prototype.set_max_lateness for more details. \nGet the render delay of sink. see GstBase.BaseSink.prototype.set_render_delay for more information about the render delay. \nChecks if sink is currently configured to synchronize against the clock. \nGet the time that will be inserted between frames to control the maximum buffers per second. \nGet the synchronisation offset of sink. \nChecks if sink is currently configured to perform asynchronous state changes to PAUSED. \nChecks if sink is currently configured to store the last received sample in the last sample property. \nChecks if sink is currently configured to send Quality of Service events upstream. \nQuery the sink for the latency parameters. The latency will be queried from the upstream elements. live will be true if sink is configured to synchronize against the clock. upstream_live will be true if an upstream element is live. \nIf both live and upstream_live are true the sink will want to compensate for the latency introduced by the upstream elements by setting the min_latency to a strictly positive value. \nThis function is mostly used by subclasses. \nConfigures sink to perform all state changes asynchronously. When async is disabled the sink will immediately go to PAUSED instead of waiting for a preroll buffer. This feature is useful if the sink does not synchronize against the clock or when it is dealing with sparse streams. \nSet the number of bytes that the sink will pull when it is operating in pull mode. \nConfigure sink to drop buffers which are outside the current segment \nConfigures sink to store the last received sample in the last sample property. \nSet the maximum amount of bits per second that the sink will render. \nSets the new max lateness value to max_lateness. This value is used to decide if a buffer should be dropped or not based on the buffer timestamp and the current clock time. A value of means an unlimited time. \nConfigures sink to send Quality of Service events upstream. \nSet the render delay in sink to delay. The render delay is the time between actual rendering of a buffer and its synchronisation time. Some devices might delay media rendering which can be compensated for with this function. \nAfter calling this function this sink will report additional latency and other sinks will adjust their latency to delay the rendering of their media. \nThis function is usually called by subclasses. \nConfigures sink to synchronize on the clock or not. When sync is false incoming samples will be played as fast as possible. If sync is true the timestamps of the incoming buffers will be used to schedule the exact render time of its contents. \nSet the time that will be inserted between rendered buffers. This can be used to control the maximum buffers per second that the sink will render. \nAdjust the synchronisation of sink with offset. A negative value will render buffers earlier than their timestamp. A positive value will delay rendering. This function can be used to fix playback of badly timestamped buffers. \nThis function will block until time is reached. It is usually called by subclasses that use their own internal synchronisation. \nIf time is not valid no synchronisation is done and Gst.ClockReturn.prototype.badtime is returned. Likewise if synchronisation is disabled in the element or there is no clock no synchronisation is done and Gst.ClockReturn.prototype.badtime is returned. \nThis function should only be called with the PREROLL_LOCK held like when receiving an EOS event in the GstBaseSinkClass.event not introspectable vmethod or when receiving a buffer in the GstBaseSinkClass.render not introspectable vmethod. \nThe time argument should be the running_time of when this method should return and is not adjusted with any latency or offset configured in the sink. \nIf the GstBaseSinkClass.render not introspectable method performs its own synchronisation against the clock it must unblock when going from PLAYING to the PAUSED state and call this method before continuing to render the remaining data. \nIf the GstBaseSinkClass.render not introspectable method can block on something else than the clock it must also be ready to unblock immediately on the GstBaseSinkClass.unlock not introspectable method and cause the GstBaseSinkClass.render not introspectable method to immediately call this function. In this case the subclass must be prepared to continue rendering where it left off if this function returns Gst.FlowReturn.prototype.ok. \nThis function will block until a state change to PLAYING happens in which case this function returns Gst.FlowReturn.prototype.ok or the processing must be stopped due to a state change to READY or a FLUSH event in which case this function returns Gst.FlowReturn.prototype.flushing \nThis function should only be called with the PREROLL_LOCK held like in the render function. \n"});