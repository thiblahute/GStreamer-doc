fragment_downloaded_cb({"url": "libgstbase-1.0/c/gstbaseparse.html#page-description", "fragment": "Description of the parsing mechanism \nThe opaque GstBaseParse data structure. \nAdds an entry to the index associating offset to ts. It is recommended to only add keyframe entries. force allows to bypass checks such as whether the stream is upstream seekable another entry is already close to the new entry etc. \nDefault implementation of convert vmethod in GstBaseParse class. \nOptionally sets the average bitrate detected in media if non zero e.g. based on metadata as it will be posted to the application. \nBy default announced average bitrate is estimated. The average bitrate is used to estimate the total duration of the stream and to estimate a seek position if there s no index and the format is syncable see gst_base_parse_set_syncable \nIf frames per second is configured parser can take care of buffer duration and timestamping. When performing segment clipping or seeking to a specific location a corresponding decoder might need an initial lead_in and a following lead_out number of frames to ensure the desired segment is entirely filled upon decoding. \nSet if frames carry timing information which the subclass can generally parse and provide. In particular intrinsic rather than estimated time can be obtained following a seek. \nSubclass can use this function to tell the base class that it needs to give at least min_size buffers. \nSet if the nature of the format or configuration does not allow much parsing and the parser should operate in passthrough mode which only applies when operating in push mode That is incoming buffers are pushed through unmodified i.e. no check_valid_frame or parse_frame callbacks will be invoked but pre_push_frame will still be invoked so subclass can perform as much or as little is appropriate for passthrough semantics in pre_push_frame. \nBy default the base class will guess PTS timestamps using a simple interpolation previous timestamp duration which is incorrect for data streams with reordering where PTS can go backward. Sub classes implementing such formats should disable PTS interpolation. \nThis function should only be called from a handle_frame implementation. \nGstBaseParse creates initial timestamps for frames by using the last timestamp seen in the stream before the frame starts. In certain cases the correct timestamps will occur in the stream after the start of the frame but before the start of the actual picture data. This function can be used to set the timestamps based on the offset into the frame data that the picture starts. \nIf set to TRUE baseparse will unconditionally force parsing of the incoming data. This can be required in the rare cases where the incoming side data caps pts dts is not trusted by the user and wants to force validation and parsing of the incoming data. If set to FALSE decision of whether to parse the data or not is up to the implementation standard behaviour \nFlags Read Write \ngpointer _gst_reserved \ngpointer _gst_reserved_p \nguint _private_flags \nno flag \nGST_BASE_PARSE_FRAME_FLAG_NEW_FRAME \nset by baseclass if current frame is passed for processing to the subclass for the first time and not set on subsequent calls with same data \nGST_BASE_PARSE_FRAME_FLAG_NO_FRAME \nset to indicate this buffer should not be counted as frame e.g. if this frame is dependent on a previous one. As it is not counted as a frame bitrate increases but frame to time conversions are maintained. \nGST_BASE_PARSE_FRAME_FLAG_CLIP \npre_push_frame can set this to indicate that regular segment clipping can still be performed as opposed to any custom one having been done \nGST_BASE_PARSE_FRAME_FLAG_DROP \nindicates to finish_frame that the the frame should be dropped and might be handled internally by subclass \nGST_BASE_PARSE_FRAME_FLAG_QUEUE \nindicates to finish_frame that the the frame should be queued for now and processed fully later when the first non queued frame is finished \n"});