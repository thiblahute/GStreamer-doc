fragment_downloaded_cb({"url": "libgstbase-1.0/gstbasesrc.html#page-description", "fragment": "This is a generic base class for source elements. The following types of sources are supported \nThe source can be configured to operate in any GstFormat with the gst_base_src_set_format method. The currently set format determines the format of the internal GstSegment and any GST_EVENT_SEGMENT events. The default format for GstBaseSrc is GST_FORMAT_BYTES. \nGstBaseSrc always supports push mode scheduling. If the following conditions are met it also supports pull mode scheduling \nIf all the conditions are met for operating in pull mode GstBaseSrc is automatically seekable in push mode as well. The following conditions must be met to make the element seekable in push mode when the format is not GST_FORMAT_BYTES \nWhen the element does not meet the requirements to operate in pull mode the offset and length in the create method should be ignored. It is recommended to subclass GstPushSrc instead in this situation. If the element can operate in pull mode but only with specific offsets and lengths it is allowed to generate an error when the wrong values are passed to the create function. \nGstBaseSrc has support for live sources. Live sources are sources that when paused discard data such as audio or video capture devices. A typical live source also produces data at a fixed rate and thus provides a clock to publish this rate. Use gst_base_src_set_live to activate the live source mode. \nA live source does not produce data in the PAUSED state. This means that the create method will not be called in PAUSED but only in PLAYING. To signal the pipeline that the element will not produce data the return value from the READY to PAUSED state will be GST_STATE_CHANGE_NO_PREROLL. \nA typical live source will timestamp the buffers it creates with the current running time of the pipeline. This is one reason why a live source can only produce data in the PLAYING state when the clock is actually distributed and running. \nLive sources that synchronize and block on the clock an audio source for example can use gst_base_src_wait_playing when the create function was interrupted by a state change to PAUSED. \nThe get_times method can be used to implement pseudo live sources. It only makes sense to implement the get_times function if the source is a live source. The get_times function should return timestamps starting from as if it were a non live source. The base class will make sure that the timestamps are transformed into the current running_time. The base source will then wait for the calculated running_time before pushing out the buffer. \nFor live sources the base class will by default report a latency of For pseudo live sources the base class will by default measure the difference between the first buffer timestamp and the start time of get_times and will report this value as the latency. Subclasses should override the query function when this behaviour is not acceptable. \nThere is only support in GstBaseSrc for exactly one source pad which should be named src A source implementation subclass of GstBaseSrc should install a pad template in its class_init function like so \nApplications that record from a live source may want to stop recording in a controlled way so that the recording is stopped but the data already in the pipeline is processed to the end remember that many live sources would go on recording forever otherwise For that to happen the application needs to make the source stop recording and send an EOS event down the pipeline. The application would then wait for an EOS message posted on the pipeline s bus to know when all data has been processed and the pipeline can safely be stopped. \nAn application may send an EOS event to a source element to make it perform the EOS logic send EOS event downstream or post a GST_MESSAGE_SEGMENT_DONE on the bus This can typically be done with the gst_element_send_event function on the element or its parent bin. \nAfter the EOS has been sent to the element the application should wait for an EOS message to be posted on the pipeline s bus. Once this EOS message is received it may safely shut down the entire pipeline. \n"});