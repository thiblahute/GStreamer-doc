fragment_downloaded_cb({"url": "gst-plugins-base-video-doc-1.0/python/gstvideodecoder.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gstvideodecoder.h\">\n<h1 id=\"gstvideodecoder\">GstVideoDecoder</h1><p>This base class is for video decoders turning encoded data into raw video\nframes.</p>\n<p>The GstVideoDecoder base class and derived subclasses should cooperate as\nfollows:</p>\n<h2 id=\"configuration\">Configuration</h2>\n<ul>\n<li>\n<p>Initially, GstVideoDecoder calls <em>start</em> when the decoder element\nis activated, which allows the subclass to perform any global setup.</p>\n</li>\n<li>\n<p>GstVideoDecoder calls <em>set_format</em> to inform the subclass of caps\ndescribing input video data that it is about to receive, including\npossibly configuration data.\nWhile unlikely, it might be called more than once, if changing input\nparameters require reconfiguration.</p>\n</li>\n<li>\n<p>Incoming data buffers are processed as needed, described in Data\nProcessing below.</p>\n</li>\n<li>\n<p>GstVideoDecoder calls <em>stop</em> at end of all processing.</p>\n</li>\n</ul>\n<h2 id=\"data-processing\">Data processing</h2>\n<pre><code> * The base class gathers input data, and optionally allows subclass\n   to parse this into subsequently manageable chunks, typically\n   corresponding to and referred to as 'frames'.\n\n * Each input frame is provided in turn to the subclass' @handle_frame\n   callback.\n   The ownership of the frame is given to the @handle_frame callback.\n\n * If codec processing results in decoded data, the subclass should call\n   @gst_video_decoder_finish_frame to have decoded data pushed.\n   downstream. Otherwise, the subclass must call\n   @gst_video_decoder_drop_frame, to allow the base class to do timestamp\n   and offset tracking, and possibly to requeue the frame for a later\n   attempt in the case of reverse playback.\n</code></pre>\n<h2 id=\"shutdown-phase\">Shutdown phase</h2>\n<ul>\n<li>The GstVideoDecoder class calls <em>stop</em> to inform the subclass that data\nparsing will be stopped.</li>\n</ul>\n<h2 id=\"additional-notes\">Additional Notes</h2>\n<ul>\n<li>\n<p>Seeking/Flushing</p>\n<ul>\n<li>When the pipeline is seeked or otherwise flushed, the subclass is\ninformed via a call to its <em>reset</em> callback, with the hard parameter\nset to true. This indicates the subclass should drop any internal data\nqueues and timestamps and prepare for a fresh set of buffers to arrive\nfor parsing and decoding.</li>\n</ul>\n</li>\n<li>\n<p>End Of Stream</p>\n<ul>\n<li>At end-of-stream, the subclass <em>parse</em> function may be called some final\ntimes with the at_eos parameter set to true, indicating that the element\nshould not expect any more data to be arriving, and it should parse and\nremaining frames and call <a href=\"gstvideodecoder.html#gst_video_decoder_have_frame\">GstVideo.VideoDecoder.have_frame</a> if possible.</li>\n</ul>\n</li>\n</ul>\n<p>The subclass is responsible for providing pad template caps for\nsource and sink pads. The pads need to be named \"sink\" and \"src\". It also\nneeds to provide information about the ouptput caps, when they are known.\nThis may be when the base class calls the subclass' <em>set_format</em> function,\nthough it might be during decoding, before calling\n<em>gst_video_decoder_finish_frame</em>. This is done via\n<em>gst_video_decoder_set_output_state</em></p>\n<p>The subclass is also responsible for providing (presentation) timestamps\n(likely based on corresponding input ones).  If that is not applicable\nor possible, the base class provides limited framerate based interpolation.</p>\n<p>Similarly, the base class provides some limited (legacy) seeking support\nif specifically requested by the subclass, as full-fledged support\nshould rather be left to upstream demuxer, parser or alike.  This simple\napproach caters for seeking and duration reporting using estimated input\nbitrates. To enable it, a subclass should call\n<em>gst_video_decoder_set_estimate_rate</em> to enable handling of incoming\nbyte-streams.</p>\n<p>The base class provides some support for reverse playback, in particular\nin case incoming data is not packetized or upstream does not provide\nfragments on keyframe boundaries.  However, the subclass should then be\nprepared for the parsing and frame processing stage to occur separately\n(in normal forward processing, the latter immediately follows the former),\nThe subclass also needs to ensure the parsing stage properly marks\nkeyframes, unless it knows the upstream elements will do so properly for\nincoming data.</p>\n<p>The bare minimum that a functional subclass needs to implement is:</p>\n<ul>\n<li>\n<p>Provide pad templates</p>\n</li>\n<li>\n<p>Inform the base class of output caps via\n<em>gst_video_decoder_set_output_state</em></p>\n</li>\n<li>\n<p>Parse input data, if it is not considered packetized from upstream\nData will be provided to <em>parse</em> which should invoke\n<em>gst_video_decoder_add_to_frame</em> and <em>gst_video_decoder_have_frame</em> to\nseparate the data belonging to each video frame.</p>\n</li>\n<li>\n<p>Accept data in <em>handle_frame</em> and provide decoded results to\n<em>gst_video_decoder_finish_frame</em>, or call <em>gst_video_decoder_drop_frame</em>.</p>\n</li>\n</ul>\n\n</div>\n\n\n"});