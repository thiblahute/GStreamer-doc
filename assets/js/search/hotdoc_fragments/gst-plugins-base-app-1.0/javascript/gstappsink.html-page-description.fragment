fragment_downloaded_cb({"url": "gst-plugins-base-app-1.0/javascript/gstappsink.html#page-description", "fragment": "Check if appsink supports buffer lists. \nGet the configured caps on appsink. \nCheck if appsink will drop old buffers when the maximum amount of queued buffers is reached. \nCheck if appsink will emit the new preroll and new sample signals. \nGet the maximum amount of buffers that can be queued in appsink. \nCheck if appsink will wait for all buffers to be consumed when an EOS is received. \nGet the last preroll sample in appsink. This was the sample that caused the appsink to preroll in the PAUSED state. This sample can be pulled many times and remains available to the application even after EOS. \nThis function is typically used when dealing with a pipeline in the PAUSED state. Calling this function after doing a seek will give the sample right after the seek position. \nNote that the preroll sample will also be returned as the first sample when calling GstApp.AppSink.prototype.pull_sample. \nIf an EOS event was received before any buffers this function returns null. Use gst_app_sink_is_eos to check for the EOS condition. \nThis function blocks until a preroll sample or EOS is received or the appsink element is set to the READY NULL state. \nThis function blocks until a sample or EOS becomes available or the appsink element is set to the READY NULL state. \nThis function will only return samples when the appsink is in the PLAYING state. All rendered buffers will be put in a queue so that the application can pull samples at its own rate. Note that when the application does not pull samples fast enough the queued buffers could consume a lot of memory especially when dealing with raw video frames. \nIf an EOS event was received before any buffers this function returns null. Use gst_app_sink_is_eos to check for the EOS condition. \nInstruct appsink to enable or disable buffer list support. \nFor backwards compatibility reasons applications need to opt in to indicate that they will be able to handle buffer lists. \nSet the capabilities on the appsink element. This function takes a copy of the caps structure. After calling this method the sink will only accept caps that match caps. If caps is non fixed or incomplete you must check the caps on the samples to get the actual used caps. \nInstruct appsink to drop old buffers when the maximum amount of queued buffers is reached. \nMake appsink emit the new preroll and new sample signals. This option is by default disabled because signal emission is expensive and unneeded when the application prefers to operate in pull mode. \nSet the maximum amount of buffers that can be queued in appsink. After this amount of buffers are queued in appsink any more buffers will block upstream elements until a sample is pulled from appsink. \nInstruct appsink to wait for all buffers to be consumed when an EOS is received. \nGet the last preroll sample in appsink. This was the sample that caused the appsink to preroll in the PAUSED state. This sample can be pulled many times and remains available to the application even after EOS. \nThis function is typically used when dealing with a pipeline in the PAUSED state. Calling this function after doing a seek will give the sample right after the seek position. \nNote that the preroll sample will also be returned as the first sample when calling GstApp.AppSink.prototype.pull_sample. \nIf an EOS event was received before any buffers or the timeout expires this function returns null. Use gst_app_sink_is_eos to check for the EOS condition. \nThis function blocks until a preroll sample or EOS is received the appsink element is set to the READY NULL state or the timeout expires. \nThis function blocks until a sample or EOS becomes available or the appsink element is set to the READY NULL state or the timeout expires. \nThis function will only return samples when the appsink is in the PLAYING state. All rendered buffers will be put in a queue so that the application can pull samples at its own rate. Note that when the application does not pull samples fast enough the queued buffers could consume a lot of memory especially when dealing with raw video frames. \nIf an EOS event was received before any buffers or the timeout expires this function returns null. Use gst_app_sink_is_eos to check for the EOS condition. \ngpointer _gst_reserved \n"});