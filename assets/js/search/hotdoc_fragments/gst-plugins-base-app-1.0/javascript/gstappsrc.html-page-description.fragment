fragment_downloaded_cb({"url": "gst-plugins-base-app-1.0/javascript/gstappsrc.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gstappsrc.h\">\n<h1 id=\"gstappsrc\">GstAppSrc</h1><p>The appsrc element can be used by applications to insert data into a\nGStreamer pipeline. Unlike most GStreamer elements, appsrc provides\nexternal API functions.</p>\n<p>appsrc can be used by linking with the libgstapp library to access the\nmethods directly or by using the appsrc action signals.</p>\n<p>Before operating appsrc, the caps property must be set to fixed caps\ndescribing the format of the data that will be pushed with appsrc. An\nexception to this is when pushing buffers with unknown caps, in which case no\ncaps should be set. This is typically true of file-like sources that push raw\nbyte buffers. If you don't want to explicitly set the caps, you can use\ngst_app_src_push_sample. This method gets the caps associated with the\nsample and sets them on the appsrc replacing any previously set caps (if\ndifferent from sample's caps).</p>\n<p>The main way of handing data to the appsrc element is by calling the\n<a href=\"gstappsrc.html#gst_app_src_push_buffer\">GstApp.AppSrc.prototype.push_buffer</a> method or by emitting the push-buffer action signal.\nThis will put the buffer onto a queue from which appsrc will read from in its\nstreaming thread. It is important to note that data transport will not happen\nfrom the thread that performed the push-buffer call.</p>\n<p>The \"max-bytes\" property controls how much data can be queued in appsrc\nbefore appsrc considers the queue full. A filled internal queue will always\nsignal the \"enough-data\" signal, which signals the application that it should\nstop pushing data into appsrc. The \"block\" property will cause appsrc to\nblock the push-buffer method until free data becomes available again.</p>\n<p>When the internal queue is running out of data, the \"need-data\" signal is\nemitted, which signals the application that it should start pushing more data\ninto appsrc.</p>\n<p>In addition to the \"need-data\" and \"enough-data\" signals, appsrc can emit the\n\"seek-data\" signal when the \"stream-mode\" property is set to \"seekable\" or\n\"random-access\". The signal argument will contain the new desired position in\nthe stream expressed in the unit set with the \"format\" property. After\nreceiving the seek-data signal, the application should push-buffers from the\nnew position.</p>\n<p>These signals allow the application to operate the appsrc in two different\nways:</p>\n<p>The push mode, in which the application repeatedly calls the push-buffer/push-sample\nmethod with a new buffer/sample. Optionally, the queue size in the appsrc\ncan be controlled with the enough-data and need-data signals by respectively\nstopping/starting the push-buffer/push-sample calls. This is a typical\nmode of operation for the stream-type \"stream\" and \"seekable\". Use this\nmode when implementing various network protocols or hardware devices.</p>\n<p>The pull mode, in which the need-data signal triggers the next push-buffer call.\nThis mode is typically used in the \"random-access\" stream-type. Use this\nmode for file access or other randomly accessable sources. In this mode, a\nbuffer of exactly the amount of bytes given by the need-data signal should be\npushed into appsrc.</p>\n<p>In all modes, the size property on appsrc should contain the total stream\nsize in bytes. Setting this property is mandatory in the random-access mode.\nFor the stream and seekable modes, setting this property is optional but\nrecommended.</p>\n<p>When the application has finished pushing data into appsrc, it should call\n<a href=\"gstappsrc.html#gst_app_src_end_of_stream\">GstApp.AppSrc.prototype.end_of_stream</a> or emit the end-of-stream action signal. After\nthis call, no more buffers can be pushed into appsrc until a flushing seek\noccurs or the state of the appsrc has gone through READY.</p>\n\n</div>\n\n\n\n"});