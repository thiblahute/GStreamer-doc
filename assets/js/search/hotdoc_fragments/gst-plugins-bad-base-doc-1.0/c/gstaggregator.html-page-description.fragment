fragment_downloaded_cb({"url": "gst-plugins-bad-base-doc-1.0/c/gstaggregator.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gstaggregator.h\">\n<h1 id=\"gstaggregatorh\">GstAggregator.h</h1><p>Manages a set of pads with the purpose of aggregating their buffers.\nControl is given to the subclass when all pads have data.</p>\n<ul>\n<li>\n<p>Base class for mixers and muxers. Subclasses should at least implement\nthe <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-bad-libs/html/gst-plugins-bad-libs-GstAggregator.html#GstAggregatorClass.aggregate\">GstAggregatorClass.aggregate</a>() virtual method.</p>\n</li>\n<li>\n<p>When data is queued on all pads, tha aggregate vmethod is called.</p>\n</li>\n<li>\n<p>One can peek at the data on any given GstAggregatorPad with the\ngst_aggregator_pad_get_buffer () method, and take ownership of it\nwith the gst_aggregator_pad_steal_buffer () method. When a buffer\nhas been taken with steal_buffer (), a new buffer can be queued\non that pad.</p>\n</li>\n<li>\n<p>If the subclass wishes to push a buffer downstream in its aggregate\nimplementation, it should do so through the\ngst_aggregator_finish_buffer () method. This method will take care\nof sending and ordering mandatory events such as stream start, caps\nand segment.</p>\n</li>\n<li>\n<p>Same goes for EOS events, which should not be pushed directly by the\nsubclass, it should instead return GST_FLOW_EOS in its aggregate\nimplementation.</p>\n</li>\n<li>\n<p>Note that the aggregator logic regarding gap event handling is to turn\nthese into gap buffers with matching PTS and duration. It will also\nflag these buffers with GST_BUFFER_FLAG_GAP and GST_BUFFER_FLAG_DROPPABLE\nto ease their identification and subsequent processing.</p>\n</li>\n</ul>\n\n</div>\n\n\n"});