fragment_downloaded_cb({"url": "xvimagesink-1.0/index.html#xvimagesink", "fragment": "Scaling \nEvents \nPixel aspect ratio \nExamples \nHierarchy \nFactory details \nXvImageSink renders video frames to a drawable XWindow on a local display using the XVideo extension. Rendering to a remote display is theoretically possible but i doubt that the XVideo extension is actually available when connecting to a remote display. This element can receive a Window ID from the application through the GstVideoOverlay interface and will then render video frames in this drawable. If no Window ID was provided by the application the element will create its own internal window and render into it. \nThe XVideo extension when it s available handles hardware accelerated scaling of video frames. This means that the element will just accept incoming video frames no matter their geometry and will then put them to the drawable scaling them on the fly. Using the force aspect ratio property it is possible to enforce scaling with a constant aspect ratio which means drawing black borders around the video frame. \nXvImageSink creates a thread to handle events coming from the drawable. There are several kind of events that can be grouped in big categories input events and window state related events. Input events will be translated to navigation events and pushed upstream for other elements to react on them. This includes events such as pointer moves key press release clicks etc... Other events are used to handle the drawable appearance even when the data is not flowing GST_STATE_PAUSED That means that even when the element is paused it will receive expose events from the drawable and draw the latest frame with correct borders aspect ratio. \nWhen changing state to GST_STATE_READY XvImageSink will open a connection to the display specified in the display property or the default display if nothing specified. Once this connection is open it will inspect the display configuration including the physical display geometry and then calculate the pixel aspect ratio. When receiving video frames with a different pixel aspect ratio XvImageSink will use hardware scaling to display the video frames correctly on display s pixel aspect ratio. Sometimes the calculated pixel aspect ratio can be wrong it is then possible to enforce a specific pixel aspect ratio using the pixel aspect ratio property. \nA pipeline to test hardware scaling. When the test video signal appears you can resize the window and see that video frames are scaled through hardware no extra CPU cost By default the image will never be distorted when scaled instead black borders will be added if needed. \nSame pipeline with force aspect ratio property set to false. You can observe that no borders are drawn around the scaled image now and it will be distorted to fill the entire frame instead of respecting the aspect ratio. \nA pipeline to test navigation events. While moving the mouse pointer over the test signal you will see a black box following the mouse pointer. If you press the mouse button somewhere on the video and release it somewhere else a green box will appear where you pressed the button and a red one where you released it. The navigationtest element is part of gst plugins good. You can observe here that even if the images are scaled through hardware the pointer coordinates are converted back to the original video frame geometry so that the box can be drawn to the correct position. This also handles borders correctly limiting coordinates to the image area \nThis is faking a pixel aspect ratio caps on video frames produced by videotestsrc in most cases the pixel aspect ratio of the display will be This means that XvImageSink will have to do the scaling to convert incoming frames to a size that will match the display pixel aspect ratio from x240 to x180 in this case \nDemonstrates how to use the colorbalance interface. \n"});