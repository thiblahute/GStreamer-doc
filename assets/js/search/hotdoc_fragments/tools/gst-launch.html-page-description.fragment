fragment_downloaded_cb({"url": "tools/gst-launch.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gst-launch.md\">\n        <h1 id=\"gstlaunch10\">gst-launch-1.0</h1>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"information\" id=\"information\"> This is the Linux man page for\nthe\u00a0<code>gst-inspect-1.0</code>\u00a0tool. As such, it is very Linux-centric\nregarding path specification and plugin names. Please be patient while\nit is rewritten to be more generic.</p>\n</blockquote>\n<h2 id=\"name\">Name</h2>\n<p>gst-launch-1.0 - build and run a GStreamer pipeline</p>\n<h2 id=\"synopsis\">Synopsis</h2>\n<p><strong>gst-launch-1.0</strong>\u00a0<em>[OPTION...]</em>\u00a0PIPELINE-DESCRIPTION</p>\n<h2 id=\"description\">Description</h2>\n<p><em>gst-launch-1.0</em>\u00a0is a tool that builds and runs\nbasic\u00a0<em>GStreamer</em>\u00a0pipelines.</p>\n<p>In simple form, a PIPELINE-DESCRIPTION is a list of elements separated\nby exclamation marks (!). Properties may be appended to elements, in the\nform<em>property=value</em>.</p>\n<p>For a complete description of possible PIPELINE-DESCRIPTIONS see the\nsection<em>pipeline description</em>\u00a0below or consult the GStreamer\ndocumentation.</p>\n<p>Please note that\u00a0<em>gst-launch-1.0</em>\u00a0is primarily a debugging tool for\ndevelopers and users. You should not build applications on top of it.\nFor applications, use the gst_parse_launch() function of the GStreamer\nAPI as an easy way to construct pipelines from pipeline descriptions.</p>\n<h2 id=\"options\">Options</h2>\n<p><em>gst-launch-1.0</em>\u00a0accepts the following options:</p>\n<p><strong>--help</strong></p>\n<p>Print help synopsis and available FLAGS</p>\n<p><strong>-v, --verbose</strong></p>\n<p>Output status information and property notifications</p>\n<p><strong>-q, --quiet</strong></p>\n<p>Do not print any progress information</p>\n<p><strong>-m, --messages</strong></p>\n<p>Output messages posted on the pipeline's bus</p>\n<p><strong>-t, --tags</strong></p>\n<p>Output tags (also known as metadata)</p>\n<p><strong>-o FILE, --output=FILE</strong></p>\n<p>Save XML representation of pipeline to FILE and exit</p>\n<p><strong>-f, --no_fault</strong></p>\n<p>Do not install a fault handler</p>\n<p><strong>-T, --trace</strong></p>\n<p>Print memory allocation traces. The feature must be enabled at compile\ntime to work.</p>\n<p>\u00a0</p>\n<h2 id=\"gstreamer-options\">Gstreamer Options</h2>\n<p><em>gst-launch-1.0</em>\u00a0also accepts the following options that are common to\nall GStreamer applications:</p>\n<h2 id=\"pipeline-description\">Pipeline Description</h2>\n<p>A pipeline consists\u00a0<em>elements</em>\u00a0and\u00a0<em>links</em>.\u00a0<em>Elements</em>\u00a0can be put\ninto\u00a0<em>bins</em>\u00a0of different sorts.\u00a0<em>Elements</em>,\u00a0<em>links</em>\u00a0and\u00a0<em>bins</em>\u00a0can be\nspecified in a pipeline description in any order.</p>\n<p><strong>Elements</strong></p>\n<p>ELEMENTTYPE\u00a0<em>[PROPERTY1 ...]</em></p>\n<p>Creates an element of type ELEMENTTYPE and sets the PROPERTIES.</p>\n<p><strong>Properties</strong></p>\n<p>PROPERTY=VALUE ...</p>\n<p>Sets the property to the specified value. You can\nuse\u00a0<strong>gst-inspect-1.0</strong>(1) to find out about properties and allowed\nvalues of different elements. Enumeration properties can be set by name,\nnick or value.</p>\n<p><strong>Bins</strong></p>\n<p><em>[BINTYPE.]</em>\u00a0(\u00a0<em>[PROPERTY1 ...]</em>\u00a0PIPELINE-DESCRIPTION )</p>\n<p>Specifies that a bin of type BINTYPE is created and the given properties\nare set. Every element between the braces is put into the bin. Please\nnote the dot that has to be used after the BINTYPE. You will almost\nnever need this functionality, it is only really useful for applications\nusing the gst_launch_parse() API with 'bin' as bintype. That way it is\npossible to build partial pipelines instead of a full-fledged top-level\npipeline.</p>\n<p><strong>Links</strong></p>\n<p><em>[[SRCELEMENT].[PAD1,...]]</em>\u00a0!\u00a0<em>[[SINKELEMENT].[PAD1,...]]\n[[SRCELEMENT].[PAD1,...]]</em>\u00a0! CAPS\n!\u00a0<em>[[SINKELEMENT].[PAD1,...]]</em></p>\n<p>Links the element with name SRCELEMENT to the element with name\nSINKELEMENT, using the caps specified in CAPS as a filter. Names can be\nset on elements with the name property. If the name is omitted, the\nelement that was specified directly in front of or after the link is\nused. This works across bins. If a padname is given, the link is done\nwith these pads. If no pad names are given all possibilities are tried\nand a matching pad is used. If multiple padnames are given, both sides\nmust have the same number of pads specified and multiple links are done\nin the given order. So the simplest link is a simple exclamation mark,\nthat links the element to the left of it to the element right of it.</p>\n<p><strong>Caps</strong></p>\n<p>MIMETYPE\u00a0<em>[, PROPERTY[, PROPERTY ...]]] [; CAPS[; CAPS ...]]</em></p>\n<p>Creates a capability with the given mimetype and optionally with given\nproperties. The mimetype can be escaped using \" or '. If you want to\nchain caps, you can add more caps in the same format afterwards.</p>\n<p><strong>Properties</strong></p>\n<p>NAME=*[(TYPE)]*VALUE in lists and ranges:\u00a0*[(TYPE)]*VALUE</p>\n<p>Sets the requested property in capabilities. The name is an alphanumeric\nvalue and the type can have the following case-insensitive values:\n-\u00a0<strong>i</strong>\u00a0or\u00a0<strong>int</strong>\u00a0for integer values or ranges -\u00a0<strong>f</strong>\u00a0or\u00a0<strong>float</strong>\u00a0for\nfloat values or ranges -\u00a0<strong>4</strong>\u00a0or\u00a0<strong>fourcc</strong>\u00a0for FOURCC values\n-\u00a0<strong>b</strong>,\u00a0<strong>bool</strong>\u00a0or\u00a0<strong>boolean</strong>\u00a0for boolean values\n-\u00a0<strong>s</strong>,\u00a0<strong>str</strong>\u00a0or\u00a0<strong>string</strong>\u00a0for strings -\u00a0<strong>fraction</strong>\u00a0for fractions\n(framerate, pixel-aspect-ratio) -\u00a0<strong>l</strong>\u00a0or\u00a0<strong>list</strong>\u00a0for lists If no type\nwas given, the following order is tried: integer, float, boolean,\nstring. Integer values must be parsable by\u00a0<strong>strtol()</strong>, floats\nby\u00a0<strong>strtod()</strong>. FOURCC values may either be integers or strings.\nBoolean values are (case insensitive)\u00a0<em>yes</em>,\u00a0<em>no</em>,\u00a0<em>true</em>\u00a0or\u00a0<em>false</em>\u00a0and\nmay like strings be escaped with \" or '. Ranges are in this format: [\nVALUE, VALUE ] Lists use this format: ( VALUE\u00a0<em>[, VALUE ...]</em>\u00a0)</p>\n<h2 id=\"pipeline-control\">Pipeline Control</h2>\n<p>A pipeline can be controlled by signals. SIGUSR2 will stop the pipeline\n(GST_STATE_NULL); SIGUSR1 will put it back to play\n(GST_STATE_PLAYING). By default, the pipeline will start in the\nplaying state. There are currently no signals defined to go into the\nready or pause (GST_STATE_READY and GST_STATE_PAUSED) state\nexplicitely.</p>\n<h2 id=\"pipeline-examples\">Pipeline Examples</h2>\n<p>The examples below assume that you have the correct plug-ins available.\nIn general, \"osssink\" can be substituted with another audio output\nplug-in such as \"directsoundsink\", \"esdsink\", \"alsasink\",\n\"osxaudiosink\", or \"artsdsink\". Likewise, \"xvimagesink\" can be\nsubstituted with \"d3dvideosink\", \"ximagesink\", \"sdlvideosink\",\n\"osxvideosink\", or \"aasink\". Keep in mind though that different sinks\nmight accept different formats and even the same sink might accept\ndifferent formats on different machines, so you might need to add\nconverter elements like audioconvert and audioresample (for audio) or\nvideoconvert (for video) in front of the sink to make things work.</p>\n<p><strong>Audio playback</strong></p>\n<p><code>gst-launch-1.0 filesrc location=music.mp3 ! mad ! audioconvert ! audioresample ! osssink</code> Play the mp3 music file \"music.mp3\" using a\nlibmad-based plug-in and output to an OSS device</p>\n<p><code>gst-launch-1.0 filesrc location=music.ogg ! oggdemux ! vorbisdec ! audioconvert ! audioresample ! osssink</code> Play an Ogg Vorbis format file</p>\n<p><code>gst-launch-1.0 gnomevfssrc location=music.mp3 ! mad ! osssink gst-launch-1.0 gnomevfssrc location=&lt;http://domain.com/music.mp3&gt; ! mad ! audioconvert ! audioresample ! osssink</code> Play an mp3 file or an http\nstream using GNOME-VFS</p>\n<p><code>gst-launch-1.0 gnomevfssrc location=&lt;smb://computer/music.mp3&gt; ! mad ! audioconvert ! audioresample ! osssink</code> Use GNOME-VFS to play an mp3\nfile located on an SMB server</p>\n<p><strong>Format conversion</strong></p>\n<p><code>gst-launch-1.0 filesrc location=music.mp3 ! mad ! audioconvert ! vorbisenc ! oggmux ! filesink location=music.ogg</code> Convert an mp3 music\nfile to an Ogg Vorbis file</p>\n<p><code>gst-launch-1.0 filesrc location=music.mp3 ! mad ! audioconvert ! flacenc ! filesink location=test.flac</code> Convert to the FLAC format</p>\n<p><strong>Other</strong></p>\n<p><code>gst-launch-1.0 filesrc location=music.wav ! wavparse ! audioconvert ! audioresample ! osssink</code> Plays a .WAV file that contains raw audio data\n(PCM).</p>\n<p><code>gst-launch-1.0 filesrc location=music.wav ! wavparse ! audioconvert ! vorbisenc ! oggmux ! filesink location=music.ogg gst-launch-1.0 filesrc location=music.wav ! wavparse ! audioconvert ! lame ! filesink location=music.mp3</code> Convert a .WAV file containing raw audio data into\nan Ogg Vorbis or mp3 file</p>\n<p><code>gst-launch-1.0 cdparanoiasrc mode=continuous ! audioconvert ! lame ! id3v2mux ! filesink location=cd.mp3</code> rips all tracks from compact disc\nand convert them into a single mp3 file</p>\n<p><code>gst-launch-1.0 cdparanoiasrc track=5 ! audioconvert ! lame ! id3v2mux ! filesink location=track5.mp3</code> rips track 5 from the CD and converts\nit into a single mp3 file</p>\n<p>Using\u00a0<strong>gst-inspect-1.0</strong>(1), it is possible to discover settings like\nthe above for cdparanoiasrc that will tell it to rip the entire cd or\nonly tracks of it. Alternatively, you can use an URI and gst-launch-1.0\nwill find an element (such as cdparanoia) that supports that protocol\nfor you, e.g.:\u00a0<code>gst-launch-1.0 \\[cdda://5\\] ! lame vbr=new vbr-quality=6 ! filesink location=track5.mp3</code></p>\n<p><code>gst-launch-1.0 osssrc ! audioconvert ! vorbisenc ! oggmux ! filesink location=input.ogg</code> records sound from your audio input and encodes it\ninto an ogg file</p>\n<p><strong>Video</strong></p>\n<p><code>gst-launch-1.0 filesrc location=JB\\_FF9\\_TheGravityOfLove.mpg ! dvddemux ! mpeg2dec ! xvimagesink</code> Display only the video portion of an\nMPEG-1 video file, outputting to an X display window</p>\n<p><code>gst-launch-1.0 filesrc location=/flflfj.vob ! dvddemux ! mpeg2dec ! sdlvideosink</code> Display the video portion of a .vob file (used on DVDs),\noutputting to an SDL window</p>\n<p><code>gst-launch-1.0 filesrc location=movie.mpg ! dvddemux name=demuxer demuxer. ! queue ! mpeg2dec ! sdlvideosink demuxer. ! queue ! mad ! audioconvert ! audioresample ! osssink</code> Play both video and audio\nportions of an MPEG movie</p>\n<p><code>gst-launch-1.0 filesrc location=movie.mpg ! mpegdemux name=demuxer demuxer. ! queue ! mpeg2dec ! videoconvert ! sdlvideosink demuxer. ! queue ! mad ! audioconvert ! audioresample ! osssink</code> Play an AVI movie\nwith an external text subtitle stream</p>\n<p>This example also shows how to refer to specific pads by name if an\nelement (here: textoverlay) has multiple sink or source pads.</p>\n<p><code>gst-launch-1.0 textoverlay name=overlay ! videoconvert ! videoscale ! autovideosink filesrc location=movie.avi ! decodebin2 ! videoconvert ! overlay.video\\_sink filesrc location=movie.srt ! subparse ! overlay.text\\_sink</code></p>\n<p>Play an AVI movie with an external text subtitle stream using playbin</p>\n<p><code>gst-launch-1.0 playbin uri=&lt;file:///path/to/movie.avi&gt; suburi=&lt;file:///path/to/movie.srt&gt;</code></p>\n<p><strong>Network streaming</strong></p>\n<p>Stream video using RTP and network elements.</p>\n<p><code>gst-launch-1.0 v4l2src ! video/x-raw-yuv,width=128,height=96,format='(fourcc)'UYVY ! videoconvert ! ffenc\\_h263 ! video/x-h263 ! rtph263ppay pt=96 ! udpsink host=192.168.1.1 port=5000 sync=false</code> Use this command on the\nreceiver</p>\n<p><code>gst-launch-1.0 udpsrc port=5000 ! application/x-rtp, clock-rate=90000,payload=96 ! rtph263pdepay queue-delay=0 ! ffdec\\_h263 ! xvimagesink</code> This command would be run on the transmitter</p>\n<p><strong>Diagnostic</strong></p>\n<p><code>gst-launch-1.0 -v fakesrc num-buffers=16 ! fakesink</code> Generate a null\nstream and ignore it (and print out details).</p>\n<p><code>gst-launch-1.0 audiotestsrc ! audioconvert ! audioresample ! osssink</code>\nGenerate a pure sine tone to test the audio output</p>\n<p><code>gst-launch-1.0 videotestsrc ! xvimagesink gst-launch-1.0 videotestsrc ! ximagesink</code> Generate a familiar test pattern to test the video output</p>\n<p><strong>Automatic linking</strong></p>\n<p>You can use the decodebin element to automatically select the right\nelements to get a working pipeline.</p>\n<p><code>gst-launch-1.0 filesrc location=musicfile ! decodebin ! audioconvert ! audioresample ! osssink</code> Play any supported audio format</p>\n<p><code>gst-launch-1.0 filesrc location=videofile ! decodebin name=decoder decoder. ! queue ! audioconvert ! audioresample ! osssink decoder. ! videoconvert ! xvimagesink</code> Play any supported video format with\nvideo and audio output. Threads are used automatically. To make this\neven easier, you can use the playbin element:</p>\n<p><code>gst-launch-1.0 playbin uri=&lt;file:///home/joe/foo.avi&gt;</code></p>\n<p><strong>Filtered connections</strong></p>\n<p>These examples show you how to use filtered caps.</p>\n<p><code>gst-launch-1.0 videotestsrc ! 'video/x-raw-yuv,format=(fourcc)YUY2;video/x-raw-yuv,format=(fourcc)YV12' ! xvimagesink</code> Show a test image and use the YUY2 or YV12 video format\nfor this.</p>\n<p><code>gst-launch-1.0 osssrc ! 'audio/x-raw-int,rate=\\[32000,64000\\],width=\\[16,32\\],depth={16,24,32},signed=(boolean)true' ! wavenc ! filesink location=recording.wav</code> record audio and write it\nto a .wav file. Force usage of signed 16 to 32 bit samples and a sample\nrate between 32kHz and 64KHz.</p>\n<h2 id=\"environment-variables\">Environment Variables</h2>\n<p><code>GST\\_DEBUG</code>: Comma-separated list of debug categories and levels,\ne.g. GST_DEBUG= totem:4,typefind:5</p>\n<p><code>GST\\_DEBUG\\_NO\\_COLOR</code>: When this environment variable is set,\ncoloured debug output is disabled.</p>\n<p><code>GST\\_DEBUG\\_DUMP\\_DOT\\_DIR</code>: When set to a filesystem path, store dot\nfiles of pipeline graphs there.</p>\n<p><code>GST\\_REGISTRY</code>: Path of the plugin registry file. Default is\n~/.gstreamer-1.0/registry-CPU.xml where CPU is the machine/cpu type\nGStreamer was compiled for, e.g. 'i486', 'i686', 'x86-64', 'ppc', etc.\n(check the output of \"uname -i\" and \"uname -m\" for details).</p>\n<p><code>GST\\_REGISTRY\\_UPDATE</code>: Set to \"no\" to force GStreamer to assume that\nno plugins have changed, been added or been removed. This will make\nGStreamer skip the initial check whether a rebuild of the registry cache\nis required or not. This may be useful in embedded environments where\nthe installed plugins never change. Do not use this option in any other\nsetup.</p>\n<p><code>GST\\_PLUGIN\\_PATH</code>: Specifies a list of directories to scan for\nadditional plugins. These take precedence over the system plugins.</p>\n<p><code>GST\\_PLUGIN\\_SYSTEM\\_PATH</code>: Specifies a list of plugins that are\nalways loaded by default. If not set, this defaults to the\nsystem-installed path, and the plugins installed in the user's home\ndirectory</p>\n<p><code>OIL\\_CPU\\_FLAGS</code>: Useful liboil environment variable. Set\nOIL_CPU_FLAGS=0 when valgrind or other debugging tools trip over\nliboil's CPU detection (quite a few important GStreamer plugins like\nvideotestsrc, audioconvert or audioresample use liboil).</p>\n<p><code>G\\_DEBUG</code>: Useful GLib environment variable. Set\nG_DEBUG=fatal_warnings to make GStreamer programs abort when a\ncritical warning such as an assertion failure occurs. This is useful if\nyou want to find out which part of the code caused that warning to be\ntriggered and under what circumstances. Simply set G_DEBUG as mentioned\nabove and run the program in gdb (or let it core dump). Then get a stack\ntrace in the usual way</p>\n\n        \n\n    </div>\n\n\n        "});