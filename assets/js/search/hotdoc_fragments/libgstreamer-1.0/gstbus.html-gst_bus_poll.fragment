fragment_downloaded_cb({"url": "libgstreamer-1.0/gstbus.html#gst_bus_poll", "fragment": "Gst.prototype.poll \nGst.Bus.poll \nGst.Bus.Poll \ngst_bus_poll \nPoll the bus for messages. Will block while waiting for messages to come. You can specify a maximum time to poll with the timeout parameter. If timeout is negative this function will block indefinitely. \nAll messages not in events will be popped off the bus and will be ignored. It is not possible to use message enums beyond Gst.MessageType.EXTENDED in the events mask \nBecause poll is implemented using the message signal enabled by Gst.prototype.add_signal_watch calling Gst.prototype.poll will cause the message signal to be emitted for every message that poll sees. Thus a message signal handler will see the same messages that this function sees neither will steal messages from the other. \nThis function will run a main loop from the default main context when polling. \nYou should never use this function since it is pure evil. This is especially true for GUI applications based on Gtk or Qt but also for any other non trivial application that uses the GLib main loop. As this function runs a GLib main loop any callback attached to the default GLib main context may be invoked. This could be timeouts GUI events I O events etc. even if Gst.prototype.poll is called with a timeout. Any of these callbacks may do things you do not expect e.g. destroy the main application window or some other resource change other application state display a dialog and run another main loop until the user clicks it away. In short using this function may add a lot of complexity to your code through unexpected re entrancy and unexpected changes to your application s state. \nFor timeouts use Gst.prototype.pop_filtered instead of this function for other short timeouts use Gst.prototype.timed_pop_filtered everything else is better handled by setting up an asynchronous bus watch and doing things from there. \nParameters \na Gst.Bus \na mask of Gst.MessageType representing the set of message types to poll for note special handling of extended message types below \nthe poll timeout as a Number or Gst.CLOCK_TIME_NONE to poll indefinitely. \nthe message that was received or null if the poll timed out. The message is taken from the bus and needs to be unreffed with gst_message_unref not introspectable after usage. \nPoll the bus for messages. Will block while waiting for messages to come. You can specify a maximum time to poll with the timeout parameter. If timeout is negative this function will block indefinitely. \nAll messages not in events will be popped off the bus and will be ignored. It is not possible to use message enums beyond Gst.MessageType.EXTENDED in the events mask \nBecause poll is implemented using the message signal enabled by Gst.Bus.add_signal_watch calling Gst.Bus.poll will cause the message signal to be emitted for every message that poll sees. Thus a message signal handler will see the same messages that this function sees neither will steal messages from the other. \nThis function will run a main loop from the default main context when polling. \nYou should never use this function since it is pure evil. This is especially true for GUI applications based on Gtk or Qt but also for any other non trivial application that uses the GLib main loop. As this function runs a GLib main loop any callback attached to the default GLib main context may be invoked. This could be timeouts GUI events I O events etc. even if Gst.Bus.poll is called with a timeout. Any of these callbacks may do things you do not expect e.g. destroy the main application window or some other resource change other application state display a dialog and run another main loop until the user clicks it away. In short using this function may add a lot of complexity to your code through unexpected re entrancy and unexpected changes to your application s state. \nFor timeouts use Gst.Bus.pop_filtered instead of this function for other short timeouts use Gst.Bus.timed_pop_filtered everything else is better handled by setting up an asynchronous bus watch and doing things from there. \nParameters \na Gst.Bus \na mask of Gst.MessageType representing the set of message types to poll for note special handling of extended message types below \nthe poll timeout as a int or Gst.CLOCK_TIME_NONE to poll indefinitely. \nthe message that was received or None if the poll timed out. The message is taken from the bus and needs to be unreffed with gst_message_unref not introspectable after usage. \nPoll the bus for messages. Will block while waiting for messages to come. You can specify a maximum time to poll with the timeout parameter. If timeout is negative this function will block indefinitely. \nAll messages not in events will be popped off the bus and will be ignored. It is not possible to use message enums beyond Gst.MessageType.Extended in the events mask \nBecause poll is implemented using the message signal enabled by Gst.Bus.AddSignalWatch calling Gst.Bus.Poll will cause the message signal to be emitted for every message that poll sees. Thus a message signal handler will see the same messages that this function sees neither will steal messages from the other. \nThis function will run a main loop from the default main context when polling. \nYou should never use this function since it is pure evil. This is especially true for GUI applications based on Gtk or Qt but also for any other non trivial application that uses the GLib main loop. As this function runs a GLib main loop any callback attached to the default GLib main context may be invoked. This could be timeouts GUI events I O events etc. even if Gst.Bus.Poll is called with a timeout. Any of these callbacks may do things you do not expect e.g. destroy the main application window or some other resource change other application state display a dialog and run another main loop until the user clicks it away. In short using this function may add a lot of complexity to your code through unexpected re entrancy and unexpected changes to your application s state. \nFor timeouts use Gst.Bus.PopFiltered instead of this function for other short timeouts use Gst.Bus.TimedPopFiltered everything else is better handled by setting up an asynchronous bus watch and doing things from there. \nParameters \na mask of Gst.MessageType representing the set of message types to poll for note special handling of extended message types below \nthe poll timeout as a Gst.ClockTime or Gst.Constants.CLOCK_TIME_NONE to poll indefinitely. \nthe message that was received or null if the poll timed out. The message is taken from the bus and needs to be unreffed with gst_message_unref not introspectable after usage. \nPoll the bus for messages. Will block while waiting for messages to come. You can specify a maximum time to poll with the timeout parameter. If timeout is negative this function will block indefinitely. \nAll messages not in events will be popped off the bus and will be ignored. It is not possible to use message enums beyond GST_MESSAGE_EXTENDED in the events mask \nBecause poll is implemented using the message signal enabled by gst_bus_add_signal_watch calling gst_bus_poll will cause the message signal to be emitted for every message that poll sees. Thus a message signal handler will see the same messages that this function sees neither will steal messages from the other. \nThis function will run a main loop from the default main context when polling. \nYou should never use this function since it is pure evil. This is especially true for GUI applications based on Gtk or Qt but also for any other non trivial application that uses the GLib main loop. As this function runs a GLib main loop any callback attached to the default GLib main context may be invoked. This could be timeouts GUI events I O events etc. even if gst_bus_poll is called with a timeout. Any of these callbacks may do things you do not expect e.g. destroy the main application window or some other resource change other application state display a dialog and run another main loop until the user clicks it away. In short using this function may add a lot of complexity to your code through unexpected re entrancy and unexpected changes to your application s state. \nFor timeouts use gst_bus_pop_filtered instead of this function for other short timeouts use gst_bus_timed_pop_filtered everything else is better handled by setting up an asynchronous bus watch and doing things from there. \nParameters \na GstBus \na mask of GstMessageType representing the set of message types to poll for note special handling of extended message types below \nthe poll timeout as a GstClockTime or GST_CLOCK_TIME_NONE to poll indefinitely. \nthe message that was received or NULL if the poll timed out. The message is taken from the bus and needs to be unreffed with gst_message_unref after usage. \n"});