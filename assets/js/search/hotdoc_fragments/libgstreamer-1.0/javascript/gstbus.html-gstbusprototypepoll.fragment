fragment_downloaded_cb({"url": "libgstreamer-1.0/javascript/gstbus.html#gstbusprototypepoll", "fragment": "Gst.Bus.prototype.poll \nPoll the bus for messages. Will block while waiting for messages to come. You can specify a maximum time to poll with the timeout parameter. If timeout is negative this function will block indefinitely. \nAll messages not in events will be popped off the bus and will be ignored. It is not possible to use message enums beyond Gst.MessageType.prototype.extended in the events mask \nBecause poll is implemented using the message signal enabled by Gst.Bus.prototype.add_signal_watch calling Gst.Bus.prototype.poll will cause the message signal to be emitted for every message that poll sees. Thus a message signal handler will see the same messages that this function sees neither will steal messages from the other. \nThis function will run a main loop from the default main context when polling. \nYou should never use this function since it is pure evil. This is especially true for GUI applications based on Gtk or Qt but also for any other non trivial application that uses the GLib main loop. As this function runs a GLib main loop any callback attached to the default GLib main context may be invoked. This could be timeouts GUI events I O events etc. even if Gst.Bus.prototype.poll is called with a timeout. Any of these callbacks may do things you do not expect e.g. destroy the main application window or some other resource change other application state display a dialog and run another main loop until the user clicks it away. In short using this function may add a lot of complexity to your code through unexpected re entrancy and unexpected changes to your application s state. \nFor timeouts use Gst.Bus.prototype.pop_filtered instead of this function for other short timeouts use Gst.Bus.prototype.timed_pop_filtered everything else is better handled by setting up an asynchronous bus watch and doing things from there. \n"});