fragment_downloaded_cb({"url": "libgstreamer-1.0/javascript/gstbus.html#gstbus-page", "fragment": "GstBus \nThe Gst.Bus is an object responsible for delivering Gst.Message packets in a first in first out way from the streaming threads see Gst.Task to the application. \nSince the application typically only wants to deal with delivery of these messages from one thread the GstBus will marshall the messages between different threads. This is important since the actual streaming of media is done in another thread than the application. \nThe GstBus provides support for GLib.Source based notifications. This makes it possible to handle the delivery in the glib mainloop. \nThe GLib.Source callback function Gst.Bus.prototype.async_signal_func can be used to convert all bus messages into signal emissions. \nA message is posted on the bus with the Gst.Bus.prototype.post method. With the Gst.Bus.prototype.peek and Gst.Bus.prototype.pop methods one can look at or retrieve a previously posted message. \nThe bus can be polled with the Gst.Bus.prototype.poll method. This methods blocks up to the specified timeout value until one of the specified messages types is posted on the bus. The application can then Gst.Bus.prototype.pop the messages from the bus to handle them. Alternatively the application can register an asynchronous bus function using Gst.Bus.prototype.add_watch_full or gst_bus_add_watch not introspectable This function will install a GLib.Source in the default glib main loop and will deliver messages a short while after they have been posted. Note that the main loop should be running for the asynchronous callbacks. \nIt is also possible to get messages from the bus without any thread marshalling with the Gst.Bus.prototype.set_sync_handler method. This makes it possible to react to a message in the same thread that posted the message on the bus. This should only be used if the application is able to deal with messages from different threads. \nEvery Gst.Pipeline has one bus. \nNote that a Gst.Pipeline will set its bus into flushing state when changing from READY to NULL state. \n"});