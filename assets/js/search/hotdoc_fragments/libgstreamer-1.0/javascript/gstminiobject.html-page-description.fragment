fragment_downloaded_cb({"url": "libgstreamer-1.0/javascript/gstminiobject.html#page-description", "fragment": "This function gets back user data pointers stored via Gst.MiniObject.prototype.set_qdata. \nIf mini_object has the LOCKABLE flag set check if the current EXCLUSIVE lock on object is the only one this means that changes to the object will not be visible to any other object. \nIf the LOCKABLE flag is not set check if the refcount of mini_object is exactly meaning that no other reference exists to the object and that the object is therefore writable. \nModification of a mini object should only be done after verifying that it is writable. \nThis sets an opaque named pointer on a miniobject. The name is specified through a GLib.Quark retrieved e.g. via GLib.prototype.quark_from_static_string and the pointer can be gotten back from the object with Gst.MiniObject.prototype.get_qdata until the object is disposed. Setting a previously set user data pointer overrides frees the old pointer set using null as pointer essentially removes the data stored. \ndestroy may be specified which is called with data as argument when the object is disposed or the data is being overwritten by a call to Gst.MiniObject.prototype.set_qdata with the same quark. \nThis function gets back user data pointers stored via Gst.MiniObject.prototype.set_qdata and removes the data from object without invoking its destroy function if any was set \nAtomically modifies a pointer to point to a new mini object. The reference count of olddata is decreased and the reference count of newdata is increased. \nEither newdata and the value pointed to by olddata may be null. \nthe object is permanently locked in READONLY mode. Only read locks can be performed on the object. \nGst.MiniObjectFlags.prototype.may_be_leaked \nthe object is expected to stay alive even after Gst.prototype.deinit has been called and so should be ignored by leak detection tools. Since \nGst.MiniObjectFlags.prototype.last \n"});