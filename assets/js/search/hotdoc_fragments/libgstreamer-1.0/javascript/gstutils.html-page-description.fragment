fragment_downloaded_cb({"url": "libgstreamer-1.0/javascript/gstutils.html#page-description", "fragment": "Calculates the linear regression of the values xy and places the result in m_num m_denom b and xbase representing the function y x m_num m_denom x xbase b that has the least square distance from all points x and y. \nr_squared will contain the remaining error. \nIf temp is not null it will be used as temporary space for the function in which case the function works without any allocation at all. If temp is null an allocation will take place. temp should have at least the same amount of memory allocated as xy i.e. nsizeof GstClockTime \nThis function assumes x y values with reasonable large differences between them. It will not calculate the exact results if the differences between neighbouring values are too small due to not being able to represent sub integer values during the calculations. \nThis is a convenience wrapper around Gst.prototype.parse_launch to create a Gst.Bin from a gst launch style pipeline description. See Gst.prototype.parse_launch and the gst launch man page for details about the syntax. Ghost pads on the bin for unlinked source or sink pads within the bin can automatically be created but only a maximum of one ghost pad for each direction will be created if you expect multiple unlinked source pads or multiple unlinked sink pads and want them all ghosted you will have to create the ghost pads yourself \nThis is a convenience wrapper around Gst.prototype.parse_launch to create a Gst.Bin from a gst launch style pipeline description. See Gst.prototype.parse_launch and the gst launch man page for details about the syntax. Ghost pads on the bin for unlinked source or sink pads within the bin can automatically be created but only a maximum of one ghost pad for each direction will be created if you expect multiple unlinked source pads or multiple unlinked sink pads and want them all ghosted you will have to create the ghost pads yourself \nSearches inside array for search_data by using the comparison function search_func. array must be sorted ascending. \nAs search_data is always passed as second argument to search_func it s not required that search_data has the same type as the array elements. \nThe complexity of this search function is O log num_elements \nTransforms a Number to a fraction and simplifies the result. \nCompares the fractions a_n a_d and b_n b_d and returns if a b if a b and if a b. \nMultiplies the fractions a_n a_d and b_n b_d and stores the result in res_n and res_d. \nTransforms a fraction to a Number. \nGet a property of type GST_TYPE_ARRAY not introspectable and transform it into a GObject.ValueArray. This allow language bindings to get GST_TYPE_ARRAY properties which are otherwise not an accessible type. \nGet a timestamp as GstClockTime to be used for interval measurements. The timestamp should not be interpreted in any other way. \nCalculates the greatest common divisor of a and b. \nCalculates the greatest common divisor of a and b. \nReturn a constantly incrementing group id. \nThis function is used to generate a new group id for the stream start event. \nCompare two sequence numbers handling wraparound. \nThe current implementation just returns gint32 s1 s2 \nConverts the string value to the type of the objects argument and sets the argument with it. \nNote that this function silently returns if object has no property named name or when value cannot be converted to the type of the property. \nTransfer a GObject.ValueArray to GST_TYPE_ARRAY not introspectable and set this value on the specified property name. This allow language bindings to set GST_TYPE_ARRAY properties which are otherwise not an accessible type. \nConverts the string to the type of the value and sets the value with it. \nNote that this function is dangerous as it does not return any indication if the conversion worked or not. \nScale val by the rational number num denom avoiding overflows and underflows and without loss of precision. \nThis function can potentially be very slow if val and num are both greater than G_MAXUINT32. \nScale val by the rational number num denom avoiding overflows and underflows and without loss of precision. num must be non negative and denom must be positive. \nScale val by the rational number num denom avoiding overflows and underflows and without loss of precision. num must be non negative and denom must be positive. \nScale val by the rational number num denom avoiding overflows and underflows and without loss of precision. num must be non negative and denom must be positive. \nScale val by the rational number num denom avoiding overflows and underflows and without loss of precision. \nThis function can potentially be very slow if val and num are both greater than G_MAXUINT32. \n"});