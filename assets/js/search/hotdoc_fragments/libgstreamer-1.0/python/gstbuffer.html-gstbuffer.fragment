fragment_downloaded_cb({"url": "libgstreamer-1.0/python/gstbuffer.html#gstbuffer", "fragment": "GstBuffer \nGstBuffer \nBuffers are the basic unit of data transfer in GStreamer. They contain the timing and offset along with other arbitrary metadata that is associated with the Gst.Memory blocks that the buffer contains. \nBuffers are usually created with Gst.Buffer.new. After a buffer has been created one will typically allocate memory for it and add it to the buffer. The following example creates a buffer that can hold a given video frame with a given width height and bits per plane. \nAlternatively use Gst.Buffer.new_allocate to create a buffer with preallocated data of a given size. \nBuffers can contain a list of Gst.Memory objects. You can retrieve how many memory objects with Gst.Buffer.n_memory and you can get a pointer to memory with Gst.Buffer.peek_memory \nA buffer will usually have timestamps and a duration but neither of these are guaranteed they may be set to Gst.CLOCK_TIME_NONE Whenever a meaningful value can be given for these they should be set. The timestamps and duration are measured in nanoseconds they are Gst.ClockTime values \nThe buffer DTS refers to the timestamp when the buffer should be decoded and is usually monotonically increasing. The buffer PTS refers to the timestamp when the buffer content should be presented to the user and is not always monotonically increasing. \nA buffer can also have one or both of a start and an end offset. These are media type specific. For video buffers the start offset will generally be the frame number. For audio buffers it will be the number of samples produced so far. For compressed data it could be the byte offset in a source or destination file. Likewise the end offset will be the offset of the end of the buffer. These can only be meaningfully interpreted if you know the media type of the buffer the preceding CAPS event Either or both can be set to Gst.BUFFER_OFFSET_NONE. \ngst_buffer_ref not introspectable is used to increase the refcount of a buffer. This must be done when you want to keep a handle to the buffer after pushing it to the next element. The buffer refcount determines the writability of the buffer a buffer is only writable when the refcount is exactly i.e. when the caller has the only reference to the buffer. \nTo efficiently create a smaller buffer out of an existing one you can use Gst.Buffer.copy_region. This method tries to share the memory objects between the two buffers. \nIf a plug in wants to modify the buffer data or metadata in place it should first obtain a buffer that is safe to modify by using gst_buffer_make_writable not introspectable This function is optimized so that a copy will only be made when it is necessary. \nSeveral flags of the buffer can be set and unset with the GST_BUFFER_FLAG_SET not introspectable and GST_BUFFER_FLAG_UNSET not introspectable macros. Use GST_BUFFER_FLAG_IS_SET not introspectable to test if a certain Gst.BufferFlags flag is set. \nBuffers can be efficiently merged into a larger buffer with Gst.Buffer.append. Copying of memory will only be done when absolutely needed. \nArbitrary extra metadata can be set on a buffer with Gst.Buffer.add_meta. Metadata can be retrieved with Gst.Buffer.get_meta. See also Gst.Meta \nAn element should either unref the buffer or push it out on a src pad using Gst.Pad.push see Gst.Pad \nBuffers are usually freed by unreffing them with gst_buffer_unref not introspectable When the refcount drops to any memory and metadata pointed to by the buffer is unreffed as well. Buffers allocated from a Gst.BufferPool will be returned to the pool when the refcount drops to \nThe Gst.ParentBufferMeta is a meta which can be attached to a Gst.Buffer to hold a reference to another buffer that is only released when the child Gst.Buffer is released. \nTypically Gst.ParentBufferMeta is used when the child buffer is directly using the Gst.Memory of the parent buffer and wants to prevent the parent buffer from being returned to a buffer pool until the Gst.Memory is available for re use. Since \n"});