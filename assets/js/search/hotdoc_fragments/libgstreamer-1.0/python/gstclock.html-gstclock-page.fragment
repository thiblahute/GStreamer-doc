fragment_downloaded_cb({"url": "libgstreamer-1.0/python/gstclock.html#gstclock-page", "fragment": "GstClock \nGStreamer uses a global clock to synchronize the plugins in a pipeline. Different clock implementations are possible by implementing this abstract base class or more conveniently by subclassing Gst.SystemClock. \nThe Gst.Clock returns a monotonically increasing time with the method Gst.Clock.get_time. Its accuracy and base time depend on the specific clock implementation but time is always expressed in nanoseconds. Since the baseline of the clock is undefined the clock time returned is not meaningful in itself what matters are the deltas between two clock times. The time returned by a clock is called the absolute time. \nThe pipeline uses the clock to calculate the running time. Usually all renderers synchronize to the global clock using the buffer timestamps the newsegment events and the element s base time see Gst.Pipeline. \nA clock implementation can support periodic and single shot clock notifications both synchronous and asynchronous. \nOne first needs to create a object for the periodic or single shot notification using Gst.Clock.new_single_shot_id or Gst.Clock.new_periodic_id. \nTo perform a blocking wait for the specific time of the object use the Gst.Clock.id_wait. To receive a callback when the specific time is reached in the clock use Gst.Clock.id_wait_async. Both these calls can be interrupted with the Gst.Clock.id_unschedule call. If the blocking wait is unscheduled a return value of Gst.ClockReturn.unscheduled is returned. \nPeriodic callbacks scheduled async will be repeatedly called automatically until it is unscheduled. To schedule a sync periodic callback Gst.Clock.id_wait should be called repeatedly. \nThe async callbacks can happen from any thread either provided by the core or from a streaming thread. The application should be prepared for this. \nA object that has been unscheduled cannot be used again for any wait operation a new object should be created and the old unscheduled one should be destroyed with Gst.Clock.id_unref. \nIt is possible to perform a blocking wait on the same object from multiple threads. However registering the same object for multiple async notifications is not possible the callback will only be called for the thread registering the entry last. \nNone of the wait operations unref the object the owner is responsible for unreffing the ids itself. This holds for both periodic and single shot notifications. The reason being that the owner of the object has to keep a handle to the object to unblock the wait on FLUSHING events or state changes and if the entry would be unreffed automatically the handle might become invalid without any notification. \nThese clock operations do not operate on the running time so the callbacks will also occur when not in PLAYING state as if the clock just keeps on running. Some clocks however do not progress when the element that provided the clock is not PLAYING. \nWhen a clock has the Gst.ClockFlags.can_set_master flag set it can be slaved to another Gst.Clock with the Gst.Clock.set_master. The clock will then automatically be synchronized to this master clock by repeatedly sampling the master clock and the slave clock and recalibrating the slave clock with Gst.Clock.set_calibration. This feature is mostly useful for plugins that have an internal clock but must operate with another clock selected by the Gst.Pipeline. They can track the offset and rate difference of their internal clock relative to the master clock by using the Gst.Clock.get_calibration function. \nThe master slave synchronisation can be tuned with the timeout window size and window threshold properties. The timeout property defines the interval to sample the master clock and run the calibration functions. window size defines the number of samples to use when calibrating and window threshold defines the minimum number of samples before the calibration is performed. \n"});