fragment_downloaded_cb({"url": "libgstcheck-doc-1.0/javascript/gsttestclock.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gsttestclock.h\">\n<h1 id=\"gsttestclock\">GstTestClock</h1><p>GstTestClock is an implementation of <a href=\"../../libgstreamer-doc-1.0/c/gstclock.html#GstClock\">Gst.Clock</a> which has different\nbehaviour compared to <a href=\"../../libgstreamer-doc-1.0/c/gstsystemclock.html#GstSystemClock\">Gst.SystemClock</a>. Time for <a href=\"../../libgstreamer-doc-1.0/c/gstsystemclock.html#GstSystemClock\">Gst.SystemClock</a> advances\naccording to the system time, while time for <a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#GstTestClock\">GstCheck.TestClock</a> changes only\nwhen <a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#gst_test_clock_set_time\">GstCheck.TestClock.prototype.set_time</a> or <a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#gst_test_clock_advance_time\">GstCheck.TestClock.prototype.advance_time</a> are\ncalled. <a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#GstTestClock\">GstCheck.TestClock</a> provides unit tests with the possibility to\nprecisely advance the time in a deterministic manner, independent of the\nsystem time or any other external factors.</p>\n<h2 id=\"advancing-the-time-of-a-gstchecktestclock\">Advancing the time of a <a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#GstTestClock\">GstCheck.TestClock</a></h2>\n<pre><code class=\"language-[&lt;!--\">   #include &lt;gst/gst.h&gt;\n   #include &lt;gst/check/gsttestclock.h&gt;\n\n   GstClock *clock;\n   GstTestClock *test_clock;\n\n   clock = gst_test_clock_new ();\n   test_clock = GST_TEST_CLOCK (clock);\n   GST_INFO (\"Time: %\" GST_TIME_FORMAT, GST_TIME_ARGS (gst_clock_get_time (clock)));\n   gst_test_clock_advance_time ( test_clock, 1 * GST_SECOND);\n   GST_INFO (\"Time: %\" GST_TIME_FORMAT, GST_TIME_ARGS (gst_clock_get_time (clock)));\n   g_usleep (10 * G_USEC_PER_SEC);\n   GST_INFO (\"Time: %\" GST_TIME_FORMAT, GST_TIME_ARGS (gst_clock_get_time (clock)));\n   gst_test_clock_set_time (test_clock, 42 * GST_SECOND);\n   GST_INFO (\"Time: %\" GST_TIME_FORMAT, GST_TIME_ARGS (gst_clock_get_time (clock)));\n   ...\n</code></pre>\n<p><a href=\"../../libgstreamer-doc-1.0/c/gstclock.html#GstClock\">Gst.Clock</a> allows for setting up single shot or periodic clock notifications\nas well as waiting for these notifications synchronously (using\n<a href=\"../../libgstreamer-doc-1.0/c/gstclock.html#gst_clock_id_wait\">Gst.Clock.prototype.id_wait</a>) or asynchronously (using <a href=\"../../libgstreamer-doc-1.0/c/gstclock.html#gst_clock_id_wait_async\">Gst.Clock.prototype.id_wait_async</a> or\n<a href=\"../../libgstreamer-doc-1.0/c/gstclock.html#gst_clock_id_wait_async\">Gst.Clock.prototype.id_wait_async</a>). This is used by many GStreamer elements,\namong them <a href=\"../../libgstbase-doc-1.0/c/gstbasesrc.html#GstBaseSrc\">GstBaseSrc (not introspectable)</a> and <a href=\"../../libgstbase-doc-1.0/c/gstbasesink.html#GstBaseSink\">GstBaseSink (not introspectable)</a>.</p>\n<p><a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#GstTestClock\">GstCheck.TestClock</a> keeps track of these clock notifications. By calling\n<a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#gst_test_clock_wait_for_next_pending_id\">GstCheck.TestClock.prototype.wait_for_next_pending_id</a> or\n<a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#gst_test_clock_wait_for_multiple_pending_ids\">GstCheck.TestClock.prototype.wait_for_multiple_pending_ids</a> a unit tests may wait for the\nnext one or several clock notifications to be requested. Additionally unit\ntests may release blocked waits in a controlled fashion by calling\n<a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#gst_test_clock_process_next_clock_id\">GstCheck.TestClock.prototype.process_next_clock_id</a>. This way a unit test can control the\ninaccuracy (jitter) of clock notifications, since the test can decide to\nrelease blocked waits when the clock time has advanced exactly to, or past,\nthe requested clock notification time.</p>\n<p>There are also interfaces for determining if a notification belongs to a\n<a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#GstTestClock\">GstCheck.TestClock</a> or not, as well as getting the number of requested clock\nnotifications so far.</p>\n<p>N.B.: When a unit test waits for a certain amount of clock notifications to\nbe requested in <a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#gst_test_clock_wait_for_next_pending_id\">GstCheck.TestClock.prototype.wait_for_next_pending_id</a> or\n<a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#gst_test_clock_wait_for_multiple_pending_ids\">GstCheck.TestClock.prototype.wait_for_multiple_pending_ids</a> then these functions may block\nfor a long time. If they block forever then the expected clock notifications\nwere never requested from <a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#GstTestClock\">GstCheck.TestClock</a>, and so the assumptions in the code\nof the unit test are wrong. The unit test case runner in gstcheck is\nexpected to catch these cases either by the default test case timeout or the\none set for the unit test by calling tcase_set_timeout().</p>\n<p>The sample code below assumes that the element under test will delay a\nbuffer pushed on the source pad by some latency until it arrives on the sink\npad. Moreover it is assumed that the element will at some point call\n<a href=\"../../libgstreamer-doc-1.0/c/gstclock.html#gst_clock_id_wait\">Gst.Clock.prototype.id_wait</a> to synchronously wait for a specific time. The first\nbuffer sent will arrive exactly on time only delayed by the latency. The\nsecond buffer will arrive a little late (7ms) due to simulated jitter in the\nclock notification.</p>\n<h2 id=\"demonstration-of-how-to-work-with-clock-notifications-and-gstchecktestclock\">Demonstration of how to work with clock notifications and <a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#GstTestClock\">GstCheck.TestClock</a></h2>\n<pre><code class=\"language-[&lt;!--\">   #include &lt;gst/gst.h&gt;\n   #include &lt;gst/check/gstcheck.h&gt;\n   #include &lt;gst/check/gsttestclock.h&gt;\n\n   GstClockTime latency;\n   GstElement *element;\n   GstPad *srcpad;\n   GstClock *clock;\n   GstTestClock *test_clock;\n   GstBuffer buf;\n   GstClockID pending_id;\n   GstClockID processed_id;\n\n   latency = 42 * GST_MSECOND;\n   element = create_element (latency, ...);\n   srcpad = get_source_pad (element);\n\n   clock = gst_test_clock_new ();\n   test_clock = GST_TEST_CLOCK (clock);\n   gst_element_set_clock (element, clock);\n\n   GST_INFO (\"Set time, create and push the first buffer\\n\");\n   gst_test_clock_set_time (test_clock, 0);\n   buf = create_test_buffer (gst_clock_get_time (clock), ...);\n   gst_assert_cmpint (gst_pad_push (srcpad, buf), ==, GST_FLOW_OK);\n\n   GST_INFO (\"Block until element is waiting for a clock notification\\n\");\n   gst_test_clock_wait_for_next_pending_id (test_clock, &amp;pending_id);\n   GST_INFO (\"Advance to the requested time of the clock notification\\n\");\n   gst_test_clock_advance_time (test_clock, latency);\n   GST_INFO (\"Release the next blocking wait and make sure it is the one from element\\n\");\n   processed_id = gst_test_clock_process_next_clock_id (test_clock);\n   g_assert (processed_id == pending_id);\n   g_assert_cmpint (GST_CLOCK_ENTRY_STATUS (processed_id), ==, GST_CLOCK_OK);\n   gst_clock_id_unref (pending_id);\n   gst_clock_id_unref (processed_id);\n\n   GST_INFO (\"Validate that element produced an output buffer and check its timestamp\\n\");\n   g_assert_cmpint (get_number_of_output_buffer (...), ==, 1);\n   buf = get_buffer_pushed_by_element (element, ...);\n   g_assert_cmpint (GST_BUFFER_TIMESTAMP (buf), ==, latency);\n   gst_buffer_unref (buf);\n   GST_INFO (\"Check that element does not wait for any clock notification\\n\");\n   g_assert (!gst_test_clock_peek_next_pending_id (test_clock, NULL));\n\n   GST_INFO (\"Set time, create and push the second buffer\\n\");\n   gst_test_clock_advance_time (test_clock, 10 * GST_SECOND);\n   buf = create_test_buffer (gst_clock_get_time (clock), ...);\n   gst_assert_cmpint (gst_pad_push (srcpad, buf), ==, GST_FLOW_OK);\n\n   GST_INFO (\"Block until element is waiting for a new clock notification\\n\");\n   (gst_test_clock_wait_for_next_pending_id (test_clock, &amp;pending_id);\n   GST_INFO (\"Advance past 7ms beyond the requested time of the clock notification\\n\");\n   gst_test_clock_advance_time (test_clock, latency + 7 * GST_MSECOND);\n   GST_INFO (\"Release the next blocking wait and make sure it is the one from element\\n\");\n   processed_id = gst_test_clock_process_next_clock_id (test_clock);\n   g_assert (processed_id == pending_id);\n   g_assert_cmpint (GST_CLOCK_ENTRY_STATUS (processed_id), ==, GST_CLOCK_OK);\n   gst_clock_id_unref (pending_id);\n   gst_clock_id_unref (processed_id);\n\n   GST_INFO (\"Validate that element produced an output buffer and check its timestamp\\n\");\n   g_assert_cmpint (get_number_of_output_buffer (...), ==, 1);\n   buf = get_buffer_pushed_by_element (element, ...);\n   g_assert_cmpint (GST_BUFFER_TIMESTAMP (buf), ==,\n       10 * GST_SECOND + latency + 7 * GST_MSECOND);\n   gst_buffer_unref (buf);\n   GST_INFO (\"Check that element does not wait for any clock notification\\n\");\n   g_assert (!gst_test_clock_peek_next_pending_id (test_clock, NULL));\n   ...\n</code></pre>\n<p>Since <a href=\"../../libgstcheck-doc-1.0/javascript/gsttestclock.html#GstTestClock\">GstCheck.TestClock</a> is only supposed to be used in unit tests it calls\n<a href=\"https://developer.gnome.org/glib/unstable/glib-Testing.html#g-assert\">g_assert (not introspectable)</a>, <a href=\"https://developer.gnome.org/glib/unstable/glib-Testing.html#g-assert-cmpint\">g_assert_cmpint (not introspectable)</a> or <a href=\"https://developer.gnome.org/glib/unstable/glib-Testing.html#g-assert-cmpuint\">g_assert_cmpuint (not introspectable)</a> to validate all function\narguments. This will highlight any issues with the unit test code itself.</p>\n\n</div>\n\n\n"});