fragment_downloaded_cb({"url": "gst-plugins-base-pbutils-doc-1.0/python/install-plugins.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"install-plugins.h\">\n<h1 id=\"gstinstallpluginscontext\">GstInstallPluginsContext</h1><h2 id=\"overview\">Overview</h2>\n<p>Using this API, applications can request the installation of missing\nGStreamer plugins. These may be missing decoders/demuxers or encoders/muxers\nfor a certain format, sources or sinks for a certain URI protocol\n(e.g. 'http'), or certain elements known by their element factory name\n('audioresample').</p>\n<p>Whether plugin installation is supported or not depends on the operating\nsystem and/or distribution in question. The vendor of the operating system\nneeds to make sure the necessary hooks and mechanisms are in place for\nplugin installation to work. See below for more detailed information.</p>\n<p>From the application perspective, plugin installation is usually triggered\neither</p>\n<ul>\n<li>\n<p>when the application itself has found that it wants or needs to install a\ncertain element</p>\n</li>\n<li>\n<p>when the application has been notified by an element (such as playbin or\ndecodebin) that one or more plugins are missing <emphasis>and</emphasis>\nthe application has decided that it wants to install one or more of those\nmissing plugins</p>\n</li>\n</ul>\n<h2 id=\"detail-strings\">Detail Strings</h2>\n<p>The install functions in this section all take one or more 'detail strings'.\nThese detail strings contain information about the type of plugin that\nneeds to be installed (decoder, encoder, source, sink, or named element),\nand some additional information such GStreamer version used and a\nhuman-readable description of the component to install for user dialogs.</p>\n<p>Applications should not concern themselves with the composition of the\nstring itself. They should regard the string as if it was a shared secret\nbetween GStreamer and the plugin installer application.</p>\n<p>Detail strings can be obtained using the function\n<a href=\"../../gst-plugins-base-pbutils-doc-1.0/python/missing-plugins.html#gst_missing_plugin_message_get_installer_detail\">GstPbutils.missing_plugin_message_get_installer_detail</a> on a missing-plugin\nmessage. Such a message will either have been found by the application on\na pipeline's <a href=\"../../libgstreamer-doc-1.0/c/gstbus.html#GstBus\">Gst.Bus</a>, or the application will have created it itself using\n<a href=\"../../gst-plugins-base-pbutils-doc-1.0/python/missing-plugins.html#gst_missing_element_message_new\">GstPbutils.missing_element_message_new</a>, <a href=\"../../gst-plugins-base-pbutils-doc-1.0/python/missing-plugins.html#gst_missing_decoder_message_new\">GstPbutils.missing_decoder_message_new</a>,\n<a href=\"../../gst-plugins-base-pbutils-doc-1.0/python/missing-plugins.html#gst_missing_encoder_message_new\">GstPbutils.missing_encoder_message_new</a>, <a href=\"../../gst-plugins-base-pbutils-doc-1.0/python/missing-plugins.html#gst_missing_uri_sink_message_new\">GstPbutils.missing_uri_sink_message_new</a>, or\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-base-libs/html/gst-plugins-base-libs-gstpbutilsmissingplugins.html#gst-missing-uri-source-message-new\">GstPbutils.missing_uri_source_message_new</a>.</p>\n<h2 id=\"plugin-installation-from-the-application-perspective\">Plugin Installation from the Application Perspective</h2>\n<p>For each GStreamer element/plugin/component that should be installed, the\napplication needs one of those 'installer detail' string mentioned in the\nprevious section. This string can be obtained, as already mentioned above,\nfrom a missing-plugin message using the function\n<a href=\"../../gst-plugins-base-pbutils-doc-1.0/python/missing-plugins.html#gst_missing_plugin_message_get_installer_detail\">GstPbutils.missing_plugin_message_get_installer_detail</a>. The missing-plugin\nmessage is either posted by another element and then found on the bus\nby the application, or the application has created it itself as described\nabove.</p>\n<p>The application will then call <a href=\"../../gst-plugins-base-pbutils-doc-1.0/python/install-plugins.html#gst_install_plugins_async\">GstPbutils.install_plugins_async</a>, passing a\nNULL-terminated array of installer detail strings, and a function that\nshould be called when the installation of the plugins has finished\n(successfully or not). Optionally, a <a href=\"../../gst-plugins-base-pbutils-doc-1.0/python/install-plugins.html#GstInstallPluginsContext\">GstPbutils.InstallPluginsContext</a> created\nwith <a href=\"../../gst-plugins-base-pbutils-doc-1.0/python/install-plugins.html#gst_install_plugins_context_new\">GstPbutils.InstallPluginsContext.new</a> may be passed as well. This way\nadditional optional arguments like the application window's XID can be\npassed to the external installer application.</p>\n<p><a href=\"../../gst-plugins-base-pbutils-doc-1.0/python/install-plugins.html#gst_install_plugins_async\">GstPbutils.install_plugins_async</a> will return almost immediately, with the\nreturn code indicating whether plugin installation was started or not.\nIf the necessary hooks for plugin installation are in place and an\nexternal installer application has in fact been called, the passed in\nfunction will be called with a result code as soon as the external installer\nhas finished. If the result code indicates that new plugins have been\ninstalled, the application will want to call <a href=\"../../libgstreamer-doc-1.0/c/gst.html#gst_update_registry\">Gst.update_registry</a> so the\nrun-time plugin registry is updated and the new plugins are made available\nto the application.</p>\n<blockquote>\n<p>A Gtk/GLib main loop must be running in order for the result function to\nbe called when the external installer has finished. If this is not the case,\nmake sure to regularly call</p>\n</blockquote>\n<blockquote>\n<pre><code>g_main_context_iteration (NULL,FALSE);\n</code></pre>\n</blockquote>\n<blockquote>\n<p>from your code.</p>\n</blockquote>\n<h2 id=\"plugin-installation-from-the-vendordistribution-perspective\">Plugin Installation from the Vendor/Distribution Perspective</h2>\n<p><emphasis>1. Installer hook</emphasis></p>\n<p>When GStreamer applications initiate plugin installation via\n<a href=\"../../gst-plugins-base-pbutils-doc-1.0/python/install-plugins.html#gst_install_plugins_async\">GstPbutils.install_plugins_async</a> or <a href=\"../../gst-plugins-base-pbutils-doc-1.0/python/install-plugins.html#gst_install_plugins_sync\">GstPbutils.install_plugins_sync</a>, a pre-defined\nhelper application will be called.</p>\n<p>The exact path of the helper application to be called is set at compile\ntime, usually by the <code>./configure</code> script based on the\ninstall prefix. For a normal package build into the <code>/usr</code>\nprefix, this will usually default to\n<filename>/usr/libexec/gst-install-plugins-helper<code>or &lt;filename&gt;/usr/lib/gst-install-plugins-helper</code>.</filename></p>\n<p>Vendors/distros who want to support GStreamer plugin installation should\neither provide such a helper script/application or use the\n<code>./configure</code> option\n<code>--with-install-plugins-helper=/path/to/installer</code> to\nmake GStreamer call an installer of their own directly.</p>\n<p>It is strongly recommended that vendors provide a small helper application\nas interlocutor to the real installer though, even more so if command line\nargument munging is required to transform the command line arguments\npassed by GStreamer to the helper application into arguments that are\nunderstood by the real installer.</p>\n<p>The helper application path defined at compile time can be overriden at\nruntime by setting the <envar>GST_INSTALL_PLUGINS_HELPER</envar>\nenvironment variable. This can be useful for testing/debugging purposes.</p>\n<p><emphasis>2. Arguments passed to the install helper</emphasis></p>\n<p>GStreamer will pass the following arguments to the install helper (this is\nin addition to the path of the executable itself, which is by convention\nargv[0]):</p>\n<ul>\n<li>\n<p>none to many optional arguments in the form of\n<code>--foo-bar=val</code>. Example:\n<code>--transient-for=XID</code> where XID is the X Window ID of\nthe main window of the calling application (so the installer can make\nitself transient to that window). Unknown optional arguments should\nbe ignored by the installer.</p>\n</li>\n<li>\n<p>one 'installer detail string' argument for each plugin to be installed;\nthese strings will have a <code>gstreamer</code> prefix; the\nexact format of the detail string is explained below</p>\n</li>\n</ul>\n<p><emphasis>3. Detail string describing the missing plugin</emphasis></p>\n<p>The string is in UTF-8 encoding and is made up of several fields, separated\nby '|' characters (but neither the first nor the last character is a '|').\nThe fields are:</p>\n<ul>\n<li>plugin system identifier, ie. \"gstreamer\"</li>\n</ul>\n<pre><code>This identifier determines the format of the rest of the detail string.\nAutomatic plugin installers should not process detail strings with\nunknown identifiers. This allows other plugin-based libraries to use\nthe same mechanism for their automatic plugin installation needs, or\nfor the format to be changed should it turn out to be insufficient.\n</code></pre>\n<ul>\n<li>plugin system version, e.g. \"0.10\"</li>\n</ul>\n<pre><code>This is required so that when there is a GStreamer-0.12 or GStreamer-1.0\nat some point in future, the different major versions can still co-exist\nand use the same plugin install mechanism in the same way.\n</code></pre>\n<ul>\n<li>application identifier, e.g. \"totem\"</li>\n</ul>\n<pre><code>This may also be in the form of \"pid/12345\" if the program name can't\nbe obtained for some reason.\n</code></pre>\n<ul>\n<li>\n<p>human-readable localised description of the required component,\ne.g. \"Vorbis audio decoder\"</p>\n</li>\n<li>\n<p>identifier string for the required component (see below for details about\nhow to map this to the package/plugin that needs installing), e.g.</p>\n<ul>\n<li>\n<p>urisource-$(PROTOCOL_REQUIRED), e.g. urisource-http or urisource-mms</p>\n</li>\n<li>\n<p>element-$(ELEMENT_REQUIRED), e.g. element-videoconvert</p>\n</li>\n<li>\n<p>decoder-$(CAPS_REQUIRED), e.g. (do read below for more details!):</p>\n<ul>\n<li>decoder-audio/x-vorbis</li>\n<li>decoder-application/ogg</li>\n<li>decoder-audio/mpeg, mpegversion=(int)4</li>\n<li>decoder-video/mpeg, systemstream=(boolean)true, mpegversion=(int)2</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code> * encoder-$(CAPS_REQUIRED), e.g. encoder-audio/x-vorbis\n</code></pre>\n<ul>\n<li>optional further fields not yet specified</li>\n</ul>\n<p>An entire ID string might then look like this, for example:\n<code>gstreamer|0.10|totem|Vorbis audio decoder|decoder-audio/x-vorbis</code></p>\n<p>Plugin installers parsing this ID string should expect further fields also\nseparated by '|' symbols and either ignore them, warn the user, or error\nout when encountering them.</p>\n<p>Those unfamiliar with the GStreamer 'caps' system should note a few things\nabout the caps string used in the above decoder/encoder case:</p>\n<pre><code> * the first part (\"video/mpeg\") of the caps string is a GStreamer media\n   type and &lt;emphasis&gt;not&lt;/emphasis&gt; a MIME type. Wherever possible, the\n   GStreamer media type will be the same as the corresponding MIME type,\n   but often it is not.\n\n * a caps string may or may not have additional comma-separated fields\n   of various types (as seen in the examples above)\n\n * the caps string of a 'required' component (as above) will always have\n   fields with fixed values, whereas an introspected string (see below)\n   may have fields with non-fixed values. Compare for example:\n\n     * `audio/mpeg, mpegversion=(int)4` vs.\n       `audio/mpeg, mpegversion=(int){2, 4}`\n\n     * `video/mpeg, mpegversion=(int)2` vs.\n       `video/mpeg, systemstream=(boolean){ true, false}, mpegversion=(int)[1, 2]`\n</code></pre>\n<p><emphasis>4. Exit codes the installer should return</emphasis></p>\n<p>The installer should return one of the following exit codes when it exits:</p>\n<ul>\n<li>\n<p>0 if all of the requested plugins could be installed\n(#GST_INSTALL_PLUGINS_SUCCESS)</p>\n</li>\n<li>\n<p>1 if no appropriate installation candidate for any of the requested\nplugins could be found. Only return this if nothing has been installed\n(#GST_INSTALL_PLUGINS_NOT_FOUND)</p>\n</li>\n<li>\n<p>2 if an error occured during the installation. The application will\nassume that the user will already have seen an error message by the\ninstaller in this case and will usually not show another one\n(#GST_INSTALL_PLUGINS_ERROR)</p>\n</li>\n<li>\n<p>3 if some of the requested plugins could be installed, but not all\n(#GST_INSTALL_PLUGINS_PARTIAL_SUCCESS)</p>\n</li>\n<li>\n<p>4 if the user aborted the installation (#GST_INSTALL_PLUGINS_USER_ABORT)</p>\n</li>\n</ul>\n<p><emphasis>5. How to map the required detail string to packages</emphasis></p>\n<p>It is up to the vendor to find mechanism to map required components from\nthe detail string to the actual packages/plugins to install. This could\nbe a hardcoded list of mappings, for example, or be part of the packaging\nsystem metadata.</p>\n<p>GStreamer plugin files can be introspected for this information. The\n<code>gst-inspect</code> utility has a special command line option\nthat will output information similar to what is required. For example\n<command>\n$ gst-inspect-1.0 --print-plugin-auto-install-info /path/to/libgstvorbis.so\n</command>\nshould output something along the lines of\n<computeroutput>\ndecoder-audio/x-vorbis\nelement-vorbisdec\nelement-vorbisenc\nelement-vorbisparse\nelement-vorbistag\nencoder-audio/x-vorbis\n</computeroutput>\nNote that in the encoder and decoder case the introspected caps can be more\ncomplex with additional fields, e.g.\n<code>audio/mpeg,mpegversion=(int){2,4}</code>, so they will not\nalways exactly match the caps wanted by the application. It is up to the\ninstaller to deal with this (either by doing proper caps intersection using\nthe GStreamer <a href=\"../../libgstbase-doc-1.0/c/gsttypefindhelper.html#GstCaps\">Gst.Caps</a> API, or by only taking into account the media type).</p>\n<p>Another potential source of problems are plugins such as ladspa or\nlibvisual where the list of elements depends on the installed\nladspa/libvisual plugins at the time. This is also up to the distribution\nto handle (but usually not relevant for playback applications).</p>\n\n</div>\n\n\n"});