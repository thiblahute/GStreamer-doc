fragment_downloaded_cb({"url": "GStreamer-doc-1.0/design/gstobject.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gstobject.md\">\n<h1 id=\"gstobject\">GstObject</h1>\n<p>The base class for the entire GStreamer hierarchy is the <code>GstObject</code>.</p>\n<h2 id=\"parentage\">Parentage</h2>\n<p>A pointer is available to store the current parent of the object. This\nis one of the two fundamental requirements for a hierarchical system\nsuch as GStreamer (for the other, read up on <code>GstBin</code>). Three functions\nare provided: <code>_set_parent()</code>, <code>_get_parent()</code>, and <code>_unparent()</code>. The\nthird is required because there is an explicit check in <code>_set_parent()</code>:\nan object must not already have a parent if you wish to set one. You\nmust unparent the object first. This allows for new additions later.</p>\n<ul>\n<li><code>GstObject</code>\u2019s that can be parented: <code>GstElement</code> (inside a bin) <code>GstPad</code> (inside an element)</li>\n</ul>\n<h2 id=\"naming\">Naming</h2>\n<ul>\n<li>names of objects cannot be changed when they are parented</li>\n<li>names of objects should be unique across parent\n<ul>\n<li><code>set_name()</code> can fail because of this</li>\n<li>as can <code>gst_element_add_pad()</code>/<code>gst_bin_add_element()</code></li>\n</ul>\n</li>\n<li><code>gst_object_set_name()</code> only changes the object\u2019s name</li>\n<li>objects also have a name_prefix that is used to prefix the object\nname during debugging and identification</li>\n<li>there are object-specific <code>set_name()</code> which also set the\nname_prefix on the object. This is useful for debugging purposes to\ngive the object a more identifiable name. Typically a parent will\ncall <code>_set_name_prefix()</code> on children, taking a lock on them to do\nso.</li>\n</ul>\n<h2 id=\"locking\">Locking</h2>\n<p>The <code>GstObject</code> contains the necessary primitives to lock the object in a\nthread-safe manner. This will be used to provide general thread-safety\nas needed. However, this lock is generic, i.e. it covers the whole\nobject.</p>\n<p>The object LOCK is a very lowlevel lock that should only be held to\naccess the object properties for short periods of code.</p>\n<p>All members of the <code>GstObject</code> structure marked as <code>/**&lt; public &gt;**/ /* with LOCK */</code> are protected by this lock. These members can only be\naccessed for reading or writing while the lock is held. All members\nshould be copied or reffed if they are used after releasing the LOCK.</p>\n<p>Note that this does <strong>not</strong> mean that no other thread can modify the\nobject at the same time that the lock is held. It only means that any\ntwo sections of code that obey the lock are guaranteed to not be running\nsimultaneously. \"The lock is voluntary and cooperative\".</p>\n<p>This lock will ideally be used for parentage, flags and naming, which is\nreasonable, since they are the only possible things to protect in the\n<code>GstObject</code>.</p>\n<h2 id=\"locking-order\">Locking order</h2>\n<p>In parent-child situations the lock of the parent must always be taken\nfirst before taking the lock of the child. It is NOT allowed to hold the\nchild lock before taking the parent lock.</p>\n<p>This policy allows for parents to iterate their children and setting\nproperties on them.</p>\n<p>Whenever a nested lock needs to be taken on objects not involved in a\nparent-child relation (eg. pads), an explictic locking order has to be\ndefined.</p>\n<h2 id=\"path-generation\">Path Generation</h2>\n<p>Due to the base nature of the <code>GstObject</code>, it becomes the only reasonable\nplace to put this particular function (<code>_get_path_string()</code>). It will\ngenerate a string describing the parent hierarchy of a given <code>GstObject</code>.</p>\n<h2 id=\"flags\">Flags</h2>\n<p>Each object in the GStreamer object hierarchy can have flags associated\nwith it, which are used to describe its state or a features.</p>\n\n</div>\n\n\n\t"});