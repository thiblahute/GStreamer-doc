fragment_downloaded_cb({"url": "GStreamer-doc-1.0/design/relations.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"relations.md\">\n<h1 id=\"object-relation-types\">Object relation types</h1>\n<p>This document describes the relations between objects that exist in\nGStreamer. It will also describe the way of handling the relation wrt\nlocking and refcounting.</p>\n<h2 id=\"parentchild-relation\">parent-child relation</h2>\n<pre><code>     +---------+    +-------+\n     | parent  |    | child |\n*---&gt;|       *-----&gt;|       |\n     |       F1|&lt;-----*    1|\n     +---------+    +-------+\n</code></pre>\n<h3 id=\"properties\">properties</h3>\n<pre><code>- parent has references to multiple children\n- child has reference to parent\n- reference fields protected with LOCK\n- the reference held by each child to the parent is NOT reflected in\nthe refcount of the parent.\n- the parent removes the floating flag of the child when taking\nownership.\n- the application has valid reference to parent\n- creation/destruction requires two unnested locks and 1 refcount.\n</code></pre>\n<h3 id=\"usage-in-gstreamer\">usage in GStreamer</h3>\n<pre><code>* `GstBin` -&gt; `GstElement`\n* `GstElement` -&gt; `GstRealPad`\n</code></pre>\n<h3 id=\"lifecycle\">lifecycle</h3>\n<h4 id=\"object-creation\">object creation</h4>\n<p>The application creates two objects and holds a pointer\nto them. The objects are initially FLOATING with a refcount of 1.</p>\n<pre><code>     +---------+              +-------+\n*---&gt;| parent  |         *---&gt;| child |\n     |       * |              |       |\n     |       F1|              | *   F1|\n     +---------+              +-------+\n</code></pre>\n<h4 id=\"establishing-the-parentchild-relationship\">establishing the parent-child relationship</h4>\n<p>The application then calls a method on the parent object to take ownership of\nthe child object. The parent performs the following actions:</p>\n<pre><code>result = _set_parent (child, parent);\nif (result) {\n  lock (parent);\n  ref_pointer = child;\n\n  1.  update other data structures .. unlock (parent);\n} else {\n\n  2.  child had parent ..\n}\n</code></pre>\n<p>the <code>_set_parent()</code> method performs the following actions:</p>\n<pre><code>lock (child);\nif (child-&gt;parent != null) {\n  unlock (child);\n  return false;\n}\nif (is_floating (child)) {\n  unset (child, floating);\n}\nelse {\n  _ref (child);\n}\nchild-&gt;parent = parent;\nunlock (child);\n_signal (parent_set, child, parent);\nreturn true;\n</code></pre>\n<p>The function atomically checks if the child has no parent yet\nand will set the parent if not. It will also sink the child, meaning\nall floating references to the child are invalid now as it takes\nover the refcount of the object.</p>\n<p>Visually:</p>\n<p>after <code>_set_parent()</code> returns TRUE:</p>\n<pre><code>      +---------+            +-------+\n*----&gt;| parent  |      *-//-&gt;| child |\n      |       * |            |       |\n      |       F1|&lt;-------------*    1|\n      +---------+            +-------+\n</code></pre>\n<p>after parent updates <code>ref_pointer</code> to child.</p>\n<pre><code>      +---------+        +-------+\n*----&gt;| parent  |  *-//-&gt;| child |\n      |       *---------&gt;|       |\n      |       F1|&lt;---------*    1|\n      +---------+        +-------+\n</code></pre>\n<ul>\n<li>\n<p>only one parent is able to <code>_sink</code> the same object because the\n<code>_set_parent()</code> method is atomic.</p>\n</li>\n<li>\n<p>since only one parent is able to <code>_set_parent()</code> the object, only\none will add a reference to the object.</p>\n</li>\n<li>\n<p>since the parent can hold multiple references to children, we don\u2019t\nneed to lock the parent when locking the child. Many threads can\ncall <code>_set_parent()</code> on the children with the same parent, the\nparent can then add all those to its lists.</p>\n</li>\n</ul>\n<blockquote>\n<p>Note: that the signal is emitted before the parent has added the\nelement to its internal data structures. This is not a problem\nsince the parent usually has his own signal to inform the app that\nthe child was reffed. One possible solution would be to update the\ninternal structure first and then perform a rollback if the <code>_set_parent()</code>\nfailed. This is not a good solution as iterators might grab the\n'half-added' child too soon.</p>\n</blockquote>\n<h4 id=\"using-the-parentchild-relationship\">using the parent-child relationship</h4>\n<ul>\n<li>\n<p>since the initial floating reference to the child object became\ninvalid after giving it to the parent, any reference to a child has\nat least a refcount &gt; 1.</p>\n</li>\n<li>\n<p>this means that unreffing a child object cannot decrease the\nrefcount to 0. In fact, only the parent can destroy and dispose the\nchild object.</p>\n</li>\n<li>\n<p>given a reference to the child object, the parent pointer is only\nvalid when holding the child LOCK. Indeed, after unlocking the child\nLOCK, the parent can unparent the child or the parent could even\nbecome disposed. To avoid the parent dispose problem, when obtaining\nthe parent pointer, if should be reffed before releasing the child\nLOCK.</p>\n</li>\n</ul>\n<ul>\n<li>getting a reference to the parent.\n<ul>\n<li>a referece is held to the child, so it cannot be disposed.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-c\">    LOCK (child);\n    parent = _ref (child-&gt;parent);\n    UNLOCK (child);\n\n   .. use parent ..\n\n   _unref (parent);\n</code></pre>\n<ul>\n<li>\n<p>getting a reference to a child</p>\n<ul>\n<li>\n<p>a reference to a child can be obtained by reffing it before adding\nit to the parent or by querying the parent.</p>\n</li>\n<li>\n<p>when requesting a child from the parent, a reference is held to the\nparent so it cannot be disposed. The parent will use its internal\ndata structures to locate the child element and will return a\nreference to it with an incremented refcount. The requester should\n<code>_unref()</code> the child after usage.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>destroying the parent-child relationship</p>\n<ul>\n<li>\n<p>only the parent can actively destroy the parent-child relationship\nthis typically happens when a method is called on the parent to\nrelease ownership of the child.</p>\n</li>\n<li>\n<p>a child shall never remove itself from the parent.</p>\n</li>\n<li>\n<p>since calling a method on the parent with the child as an argument\nrequires the caller to obtain a valid reference to the child, the\nchild refcount is at least &gt; 1.</p>\n</li>\n<li>\n<p>the parent will perform the folowing actions:</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-c\">    LOCK (parent);\n    if (ref_pointer == child) {\n      ref_pointer = NULL;\n\n      ..update other data structures ..\n      UNLOCK (parent);\n\n      _unparent (child);\n    } else {\n      UNLOCK (parent);\n      .. not our child ..\n    }\n</code></pre>\n<p>The <code>_unparent()</code> method performs the following actions:</p>\n<pre><code class=\"language-c\">LOCK (child);\nif (child-&gt;parent != NULL) {\n  child-&gt;parent = NULL;\n  UNLOCK (child);\n  _signal (PARENT_UNSET, child, parent);\n\n  _unref (child);\n} else {\n  UNLOCK (child);\n}\n</code></pre>\n<p>Since the <code>_unparent()</code> method unrefs the child object, it is possible that\nthe child pointer is invalid after this function. If the parent wants to\nperform other actions on the child (such as signal emission) it should\n<code>_ref()</code> the child first.</p>\n<h2 id=\"singlereffed-relation\">single-reffed relation</h2>\n<pre><code>     +---------+        +---------+\n*---&gt;| object1 |   *---&gt;| object2 |\n     |       *---------&gt;|         |\n     |        1|        |        2|\n     +---------+        +---------+\n</code></pre>\n<h3 id=\"properties1\">properties</h3>\n<pre><code>  - one object has a reference to another\n  - reference field protected with LOCK\n  - the reference held by the object is reflected in the refcount of the\n    other object.\n  - typically the other object can be shared among multiple other\n    objects where each ref is counted for in the refcount.\n  - no object has ownership of the other.\n  - either shared state or copy-on-write.\n  - creation/destruction requires one lock and one refcount.\n</code></pre>\n<h3 id=\"usage\">usage</h3>\n<pre><code>        GstRealPad -&gt; GstCaps\n        GstBuffer -&gt; GstCaps\n        GstEvent -&gt; GstCaps\n        GstEvent -&gt; GstObject\n        GstMessage -&gt; GstCaps\n        GstMessage -&gt; GstObject\n</code></pre>\n<h3 id=\"lifecycle1\">lifecycle</h3>\n<h4 id=\"two-objects-exist-unlinked\">Two objects exist unlinked.</h4>\n<pre><code>     +---------+        +---------+\n*---&gt;| object1 |   *---&gt;| object2 |\n     |      *  |        |         |\n     |        1|        |        1|\n     +---------+        +---------+\n</code></pre>\n<h4 id=\"establishing-the-singlereffed-relationship\">establishing the single-reffed relationship</h4>\n<p>The second object is attached to the first one using a method\non the first object. The second object is reffed and a pointer\nis updated in the first object using the following algorithm:</p>\n<pre><code class=\"language-c\">LOCK (object1);\nif (object1-&gt;pointer)\n  _unref (object1-&gt;pointer);\nobject1-&gt;pointer = _ref (object2);\nUNLOCK (object1);\n</code></pre>\n<p>After releasing the lock on the first object is is not sure that\nobject2 is still reffed from object1.</p>\n<pre><code>     +---------+        +---------+\n*---&gt;| object1 |   *---&gt;| object2 |\n     |       *---------&gt;|         |\n     |        1|        |        2|\n     +---------+        +---------+\n</code></pre>\n<h4 id=\"using-the-singlereffed-relationship\">using the single-reffed relationship</h4>\n<p>The only way to access object2 is by holding a ref to it or by\ngetting the reference from object1.\nReading the object pointed to by object1 can be done like this:</p>\n<pre><code class=\"language-c\">LOCK (object1);\nobject2 = object1-&gt;pointer;\n_ref (object2);\nUNLOCK (object1);\n\n\u2026 use object2 \u2026\n_unref (object2);\n</code></pre>\n<p>Depending on the type of the object, modifications can be done either with\ncopy-on-write or directly into the object.</p>\n<p>Copy on write can practically only be done like this:</p>\n<pre><code class=\"language-c\">LOCK (object1);\nobject2 = object1-&gt;pointer;\nobject2 = _copy_on_write (object2);\n... make modifications to object2 ...\nUNLOCK (object1);\n\nReleasing the lock has only a very small window where the copy_on_write\nactually does not perform a copy:\n\nLOCK (object1);\nobject2 = object1-&gt;pointer;\n_ref (object2);\nUNLOCK (object1);\n\n/* object2 now has at least 2 refcounts making the next\ncopy-on-write make a real copy, unless some other thread writes\nanother object2 to object1 here \u2026 */\n\nobject2 = _copy_on_write (object2);\n\n/* make modifications to object2 \u2026 */\n\nLOCK (object1);\nif (object1-&gt;pointer != object2) {\n  if (object1-&gt;pointer)\n    _unref (object1-&gt;pointer);\n  object1-&gt;pointer = gst_object_ref (object2);\n}\nUNLOCK (object1);\n</code></pre>\n<h4 id=\"destroying-the-singlereffed-relationship\">destroying the single-reffed relationship</h4>\n<p>The folowing algorithm removes the single-reffed link between\nobject1 and object2.</p>\n<pre><code class=\"language-c\">LOCK (object1);\n_unref (object1-&gt;pointer);\nobject1-&gt;pointer = NULL;\nUNLOCK (object1);\n</code></pre>\n<p>Which yields the following initial state again:</p>\n<pre><code>     +---------+        +---------+\n*---&gt;| object1 |   *---&gt;| object2 |\n     |      *  |        |         |\n     |        1|        |        1|\n     +---------+        +---------+\n</code></pre>\n<h2 id=\"unreffed-relation\">unreffed relation</h2>\n<pre><code>     +---------+        +---------+\n*---&gt;| object1 |   *---&gt;| object2 |\n     |       *---------&gt;|         |\n     |        1|&lt;---------*      1|\n     +---------+        +---------+\n</code></pre>\n<h3 id=\"properties2\">properties</h3>\n<ul>\n<li>two objects have references to each other</li>\n<li>both objects can only have 1 reference to another object.</li>\n<li>reference fields protected with LOCK</li>\n<li>the references held by each object are NOT reflected in the refcount\nof the other object.</li>\n<li>no object has ownership of the other.</li>\n<li>typically each object is owned by a different parent.</li>\n<li>creation/destruction requires two nested locks and no refcounts.</li>\n</ul>\n<h3 id=\"usage1\">usage</h3>\n<ul>\n<li>\n<p>This type of link is used when the link is less important than the\nexistance of the objects, If one of the objects is disposed, so is\nthe link.</p>\n<p><code>GstRealPad</code> &lt;-&gt; <code>GstRealPad</code> (srcpad lock taken first)</p>\n</li>\n</ul>\n<h3 id=\"lifecycle2\">lifecycle</h3>\n<h4 id=\"two-objects-exist-unlinked1\">Two objects exist unlinked.</h4>\n<pre><code>     +---------+        +---------+\n*---&gt;| object1 |   *---&gt;| object2 |\n     |       * |        |         |\n     |        1|        | *      1|\n     +---------+        +---------+\n</code></pre>\n<h4 id=\"establishing-the-unreffed-relationship\">establishing the unreffed relationship</h4>\n<p>Since we need to take two locks, the order in which these locks are\ntaken is very important or we might cause deadlocks. This lock order\nmust be defined for all unreffed relations. In these examples we always\nlock object1 first and then object2.</p>\n<pre><code class=\"language-c\">LOCK (object1);\nLOCK (object2);\nobject2-&gt;refpointer = object1;\nobject1-&gt;refpointer = object2;\nUNLOCK (object2);\nUNLOCK (object1);\n</code></pre>\n<h4 id=\"using-the-unreffed-relationship\">using the unreffed relationship</h4>\n<p>Reading requires taking one of the locks and reading the corresponing\nobject. Again we need to ref the object before releasing the lock.</p>\n<pre><code class=\"language-c\">LOCK (object1);\nobject2 = _ref (object1-&gt;refpointer);\nUNLOCK (object1);\n\n.. use object2 ..\n_unref (object2);\n</code></pre>\n<h4 id=\"destroying-the-unreffed-relationship\">destroying the unreffed relationship</h4>\n<p>Because of the lock order we need to be careful when destroying this\nrelation.</p>\n<p>When only a reference to object1 is held:</p>\n<pre><code class=\"language-c\">LOCK (object1);\nLOCK (object2);\nobject1-&gt;refpointer-&gt;refpointer = NULL;\nobject1-&gt;refpointer = NULL;\nUNLOCK (object2);\nUNLOCK (object1);\n</code></pre>\n<p>When only a reference to object2 is held, we need to get a handle to the\nother object fist so that we can lock it first. There is a window where\nwe need to release all locks and the relation could be invalid. To solve\nthis we check the relation after grabbing both locks and retry if the\nrelation changed.</p>\n<pre><code class=\"language-c\">retry:\n  LOCK (object2);\n  object1 = _ref (object2-&gt;refpointer);\n  UNLOCK (object2);\n  .. things can change here ..\n  LOCK (object1);\n  LOCK (object2);\n  if (object1 == object2-&gt;refpointer) {\n    /* relation unchanged */\n    object1-&gt;refpointer-&gt;refpointer = NULL;\n    object1-&gt;refpointer = NULL;\n  }\n  else {\n    /* relation changed.. retry */\n    UNLOCK (object2);\n    UNLOCK (object1);\n    _unref (object1);\n    goto retry;\n  }\n  UNLOCK (object2);\n  UNLOCK (object1);\n  _unref (object1);\n\n/* When references are held to both objects. Note that it is not possible to\nget references to both objects with the locks released since when the\nreferences are taken and the locks are released, a concurrent update might\nhave changed the link, making the references not point to linked objects. */\n\nLOCK (object1);\nLOCK (object2);\nif (object1-&gt;refpointer == object2) {\n  object2-&gt;refpointer = NULL;\n  object1-&gt;refpointer = NULL;\n}\nelse {\n  .. objects are not linked ..\n}\nUNLOCK (object2);\nUNLOCK (object1);\n</code></pre>\n<h2 id=\"doublereffed-relation\">double-reffed relation</h2>\n<pre><code>     +---------+        +---------+\n*---&gt;| object1 |   *---&gt;| object2 |\n     |       *---------&gt;|         |\n     |        2|&lt;---------*      2|\n     +---------+        +---------+\n</code></pre>\n<h3 id=\"properties3\">properties</h3>\n<ul>\n<li>two objects have references to each other</li>\n<li>reference fields protected with LOCK</li>\n<li>the references held by each object are reflected in the refcount of\nthe other object.</li>\n<li>no object has ownership of the other.</li>\n<li>typically each object is owned by a different parent.</li>\n<li>creation/destruction requires two locks and two refcounts.</li>\n</ul>\n<h4 id=\"usage2\">usage</h4>\n<p>Not used in GStreamer.</p>\n<h3 id=\"lifecycle3\">lifecycle</h3>\n\n</div>\n\n\n\t"});