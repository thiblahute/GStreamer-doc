fragment_downloaded_cb({"url": "GStreamer-doc-1.0/design/stream-selection.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"stream-selection.md\">\n<h1 id=\"stream-selection\">Stream selection</h1>\n<p>History</p>\n<pre><code>v0.1: Jun 11th 2015\n   Initial Draft\nv0.2: Sep 18th 2015\n   Update to reflect design changes\nv1.0: Jun 28th 2016\n   Pre-commit revision\n</code></pre>\n<p>This document describes the events and objects involved in stream\nselection in GStreamer pipelines, elements and applications</p>\n<h2 id=\"background\">Background</h2>\n<p>This new API is intended to address the use cases described in\nthis section:</p>\n<ol>\n<li>\n<p>As a user/app I want an overview and control of the media streams\nthat can be configured within a pipeline for processing, even\nwhen some streams are mutually exclusive or logical constructs only.</p>\n</li>\n<li>\n<p>The user/app can disable entirely streams it's not interested\nin so they don't occupy memory or processing power - discarded\nas early as possible in the pipeline. The user/app can also\n(re-)enable them at a later time.</p>\n</li>\n<li>\n<p>If the set of possible stream configurations is changing,\nthe user/app should be aware of the pending change and\nbe able to make configuration choices for the new set of streams,\nas well as possibly still reconfiguring the old set</p>\n</li>\n<li>\n<p>Elements that have some other internal mechanism for triggering\nstream selections (DVD, or maybe some scripted playback\nplaylist) should be able to trigger 'selection' of some particular\nstream.</p>\n</li>\n<li>\n<p>Indicate known relationships between streams - for example that\n2 separate video feeds represent the 2 views of a stereoscopic\nview, or that certain streams are mutually exclusive.</p>\n</li>\n</ol>\n<blockquote>\n<p>Note: the streams that are \"available\" are not automatically\nthe ones active, or present in the pipeline as pads. Think HLS/DASH\nalternate streams.</p>\n</blockquote>\n<h2 id=\"example-use-cases\">Example use cases</h2>\n<ol>\n<li>\n<p>Playing an MPEG-TS multi-program stream, we want to tell the\napp that there are multiple programs that could be extracted\nfrom the incoming feed. Further, we want to provide a mechanism\nfor the app to select which program(s) to decode, and once\nthat is known to further tell the app which elementary streams\nare then available within those program(s) so the app/user can\nchoose which audio track(s) to decode and/or use.</p>\n</li>\n<li>\n<p>A new PMT arrives for an MPEG-TS stream, due to a codec or\nchannel change. The pipeline will need to reconfigure to\nplay the desired streams from new program. Equally, there\nmay be multiple seconds of content buffered from the old\nprogram and it should still be possible to switch (for example)\nsubtitle tracks responsively in the draining out data, as\nwell as selecting which subs track to play from the new feed.\nThis same scenario applies when doing gapless transition to a\nnew source file/URL, except that likely the element providing\nthe list of streams also changes as a new demuxer is installed.</p>\n</li>\n<li>\n<p>When playing a multi-angle DVD, the DVD Virtual Machine needs to\nextract 1 angle from the data for presentation. It can publish\nthe available angles as logical streams, even though only one\nstream can be chosen.</p>\n</li>\n<li>\n<p>When playing a DVD, the user can make stream selections from the\nDVD menu to choose audio or sub-picture tracks, or the DVD VM\ncan trigger automatic selections. In addition, the player UI\nshould be able to show which audio/subtitle tracks are available\nand allow direct selection in a GUI the same as for normal\nfiles with subtitle tracks in them.</p>\n</li>\n<li>\n<p>Playing a SCHC (3DTV) feed, where one view is MPEG-2 and the other\nis H.264 and they should be combined for 3D presentation, or\nnot bother decoding 1 stream if displaying 2D.\n(bug https://bugzilla.gnome.org/show_bug.cgi?id=719333)</p>\n</li>\n</ol>\n<p>FIXME - need some use cases indicating what alternate streams in\nHLS might require - what are the possibilities?</p>\n<h2 id=\"design-overview\">Design Overview</h2>\n<p>Stream selection in GStreamer is implemented in several parts:</p>\n<ol>\n<li>Objects describing streams : <code>GstStream</code></li>\n<li>Objects describing a collection of streams : <code>GstStreamCollection</code></li>\n<li>Events from the app allowing selection and activation of some streams:\n<code>GST_EVENT_SELECT_STREAMS</code></li>\n<li>Messages informing the user/application about the available\nstreams and current status: <code>GST_MESSAGE_STREAM_COLLECTION</code> and\n<code>GST_MESSAGE_STREAMS_SELECTED</code></li>\n</ol>\n<h2 id=\"gststream-objects\">GstStream objects</h2>\n<pre><code>API:\n\nGstStream\ngst_stream_new(..)\ngst_stream_get_\\*(...)\ngst_stream_set_\\*()\ngst_event_set_stream(...)\ngst_event_parse_stream(...)\n</code></pre>\n<p><code>GstStream</code> objects are a high-level convenience object containing\ninformation regarding a possible data stream that can be exposed by\nGStreamer elements.</p>\n<p>They are mostly the aggregation of information present in other\nGStreamer components (<code>STREAM_START</code>, <code>CAPS</code>, <code>TAGS</code> events) but are not\ntied to the presence of a <code>GstPad</code>, and for some use-cases provide\ninformation that the existing components don't provide.</p>\n<p>The various properties of a <code>GstStream</code> object are:</p>\n<ul>\n<li>stream_id (from the <code>STREAM_START</code> event)</li>\n<li>flags (from the <code>STREAM_START</code> event)</li>\n<li>caps</li>\n<li>tags</li>\n<li>type (high-level type of stream: Audio, Video, Container,...)</li>\n</ul>\n<p><code>GstStream</code> objects can be subclassed so that they can be re-used by\nelements already using the notion of stream (which is common for\nexample in demuxers).</p>\n<p>Elements that create GstStream should also set it on the\n<code>GST_EVENT_STREAM_START</code> event of the relevant pad. This helps\ndownstream elements to have all information in one location.</p>\n<h2 id=\"exposing-collections-of-streams\">Exposing collections of streams</h2>\n<pre><code>API:\n\nGstStreamCollection\ngst_stream_collection_new(...)\ngst_stream_collection_add_stream(...)\ngst_stream_collection_get_size(...)\ngst_stream_collection_get_stream(...)\nGST_MESSAGE_STREAM_COLLECTION\ngst_message_new_stream_collection(...)\ngst_message_parse_stream_collection(...)\nGST_EVENT_STREAM_COLLECTION\ngst_event_new_stream_collection(...)\ngst_event_parse_stream_collection(...)\n</code></pre>\n<p>Elements that create new streams (such as demuxers) or can create\nnew streams (like the HLS/DASH alternative streams) can list the\nstreams they can make available with the GstStreamCollection object.</p>\n<p>Other elements that might generate <code>GstStreamCollections</code> are the\nDVD-VM, which handles internal switching of tracks, or parsebin and\ndecodebin3 when it aggregates and presents multiple internal stream\nsources as a single configurable collection.</p>\n<p>The <code>GstStreamCollection</code> object is a flat listing of <code>GstStream</code> objects.</p>\n<p>The various properties of a <code>GstStreamCollection</code> are:</p>\n<ul>\n<li>'identifier'\n<ul>\n<li>the identifier of the collection (unique name)</li>\n<li>Generated from the 'upstream stream id' (or stream ids, plural)</li>\n</ul>\n</li>\n<li>the list of <code>GstStreams</code> in the collection.</li>\n<li>(Not implemented) : Flags -\nFor now, the only flag is <code>INFORMATIONAL</code> - used by container parsers to\npublish information about detected streams without allowing selection of\nthe streams.</li>\n<li>(Not implemented yet) : The relationship between the various streams\nThis specifies which streams are exclusive (can not be selected at the\nsame time), are related (such as <code>LINKED_VIEW</code> or <code>ENHANCEMENT</code>), or need to\nbe selected together.</li>\n</ul>\n<p>An element will inform outside components about that collection via:</p>\n<ul>\n<li>a <code>GST_MESSAGE_STREAM_COLLECTION</code> message on the bus.</li>\n<li>a <code>GST_EVENT_STREAM_COLLECTION</code> on each source pads.</li>\n</ul>\n<p>Applications and container bin elements can listen and collect the\nvarious stream collections to know the full range of streams\navailable within a bin/pipeline.</p>\n<p>Once posted on the bus, a <code>GstStreamCollection</code> is immutable. It is\nupdated by subsequent messages with a matching identifier.</p>\n<p>If the element that provided the collection goes away, there is no way\nto know that the streams are no longer valid (without having the\nuser/app track that element). The exception to that is if the bin\ncontaining that element (such as parsebin or decodebin3) informs that\nthe next collection is a replacement of the former one.</p>\n<p>The mutual exclusion and relationship lists use stream-ids\nrather than <code>GstStream</code> references in order to avoid circular\nreferencing problems.</p>\n<h3 id=\"usage-from-elements\">Usage from elements</h3>\n<p>When a demuxer knows the list of streams it can expose, it\ncreates a new GstStream for each stream it can provide with the\nappropriate information (stream id, flag, tags, caps, ...).</p>\n<p>The demuxer then creates a GstStreamCollection object in which it\nwill put the list of GstStream it can expose.  That collection is\nthen both posted on the bus (via a <code>GST_MESSAGE_COLLECTION</code>) and on\neach pad (via a <code>GST_EVENT_STREAM_COLLECTION</code>).</p>\n<p>That new collection must be posted on the bus <em>before</em> the changes\nare made available. i.e. before pads corresponding to that selection\nare added/removed.</p>\n<p>In order to be backwards-compatible and support elements that don't\ncreate streams/collection yet, the new 'parsebin' element used by\ndecodebin3 will automatically create those if not provided.</p>\n<h3 id=\"usage-from-application\">Usage from application</h3>\n<p>Applications can know what streams are available by listening to the\n<code>GST_MESSAGE_STREAM_COLLECTION</code> messages posted on the bus.</p>\n<p>The application can list the available streams per-type (such as all\nthe audio streams, or all the video streams) by iterating the\nstreams available in the collection by <code>GST_STREAM_TYPE</code>.</p>\n<p>The application will also be able to use these stream information to\ndecide which streams should be activated or not (see the stream\nselection event below).</p>\n<h3 id=\"backwards-compatibility\">Backwards compatibility</h3>\n<p>Not all demuxers will create the various <code>GstStream</code> and\n<code>GstStreamCollection</code> objects. In order to remain backwards\ncompatible, a parent bin (parsebin in decodebin3) will create the\n<code>GstStream</code> and <code>GstStreamCollection</code> based on the pads being\nadded/removed from an element.</p>\n<p>This allows providing stream listing/selection for any demuxer-like\nelement even if it doesn't implement the <code>GstStreamCollection</code> usage.</p>\n<h2 id=\"stream-selection-event\">Stream selection event</h2>\n<pre><code>API:\n\nGST_EVENT_SELECT_STREAMS\ngst_event_new_select_streams(...)\ngst_event_parse_select_streams(...)\n</code></pre>\n<p>Stream selection events are generated by the application and sent into the\npipeline to configure the streams.</p>\n<p>The event carries:</p>\n<ul>\n<li>List of <code>GstStreams</code> to activate - a subset of the <code>GstStreamCollection</code></li>\n<li>(Not implemented) - List of <code>GstStreams</code> to be kept discarded - a\nsubset of streams for which hot-swapping will not be desired,\nallowing elements (such as decodebin3, demuxers, ...) to not parse or\nbuffer those streams at all.</li>\n</ul>\n<h3 id=\"usage-from-application1\">Usage from application</h3>\n<p>There are two use-cases where an application needs to specify in a\ngeneric fashion which streams it wants in output:</p>\n<ol>\n<li>When there are several present streams of which it only wants a\nsubset (such as one audio, one video and one subtitle\nstream). Those streams are demuxed and present in the pipeline.</li>\n<li>When the stream the user wants require some element to undertake\nsome action to expose that stream in the pipeline (such as\nDASH/HLS alternative streams).</li>\n</ol>\n<p>From the point of view of the application, those two use-cases are\ntreated identically.  The streams are all available through the\n<code>GstStreamCollection</code> posted on the bus, and it will select a subset.</p>\n<p>The application can select the streams it wants by creating a\n<code>GST_EVENT_SELECT_STREAMS</code> event with the list of stream-id of the\nstreams it wants. That event is then sent on the pipeline,\neventually traveling all the way upstream from each sink.</p>\n<p>In some cases, selecting one stream may trigger the availability of\nother dependent streams, resulting in new <code>GstStreamCollection</code>\nmessages. This can happen in the case where choosing a different DVB\nchannel would create a new single-program collection.</p>\n<h3 id=\"usage-in-elements\">Usage in elements</h3>\n<p>Elements that receive the <code>GST_EVENT_SELECT_STREAMS</code> event and that\ncan activate/deactivate streams need to look at the list of\nstream-id contained in the event and decide if they need to do some\naction.</p>\n<p>In the standard demuxer case (demuxing and exposing all streams),\nthere is nothing to do by default.</p>\n<p>In decodebin3, activating or deactivating streams is taken care of by\nlinking only the streams present in the event to decoders and output\nghostpad.</p>\n<p>In the case of elements that can expose alternate streams that are\nnot present in the pipeline as pads, they will take the appropriate\naction to add/remove those streams.</p>\n<p>Containers that receive the event should pass it to any elements\nwith no downstream peers, so that streams can be configured during\npre-roll before a pipeline is completely linked down to sinks.</p>\n<h2 id=\"decodebin3-usage-and-example\">decodebin3 usage and example</h2>\n<p>This is an example of how decodebin3 works by using the\nabove-mentioned objects/events/messages.</p>\n<p>For clarity/completeness, we will consider a mpeg-ts stream that has\nmultiple audio streams. Furthermore that stream might have changes\nat some point (switching video codec, or adding/removing audio\nstreams).</p>\n<h3 id=\"initial-differences\">Initial differences</h3>\n<p>decodebin3 is different, compared to decodebin2, in the sense that, by\ndefault:</p>\n<ul>\n<li>it will only expose as output ghost source pads one stream of each\ntype (one audio, one video, ..).</li>\n<li>It will only decode the exposed streams</li>\n</ul>\n<p>The multiqueue element is still used and takes in all elementary\n(non-decoded) streams. If parsers are needed/present they are placed\nbefore the multiqueue. This is needed in order for multiqueue to\nwork only with packetized and properly timestamped streams.</p>\n<p>Note that the whole typefinding of streams, and optional depayloading,\ndemuxing and parsing are done in a new 'parsebin' element.</p>\n<p>Just like the current implementation, demuxers will expose all\nstreams present within a program as source pads. They will connect\nto parsers and multiqueue.</p>\n<p>Initial setup. 1 video stream, 2 audio streams.</p>\n<pre><code>  +---------------------+\n  | parsebin            |\n  | ---------           | +-------------+\n  | | demux |--[parser]-+-| multiqueue  |--[videodec]---[\n]-+-|       |--[parser]-+-|             |\n  | |       |--[parser]-+-|             |--[audiodec]---[\n  | ---------           | +-------------+\n  +---------------------+\n</code></pre>\n<h3 id=\"gststreamcollection\">GstStreamCollection</h3>\n<p>When parsing the initial PAT/PMT, the demuxer will:</p>\n<ol>\n<li>create the various GstStream objects for each stream.</li>\n<li>create the GstStreamCollection for that initial PMT</li>\n<li>post the <code>GST_MESSAGE_STREAM_COLLECTION</code> Decodebin will intercept that\nmessage and know what the demuxer will be exposing.</li>\n<li>The demuxer creates the various pads and sends the corresponding\n<code>STREAM_START</code> event (with the same stream-id as the corresponding\n<code>GstStream</code> objects), <code>CAPS</code> event, and <code>TAGS</code> event.</li>\n</ol>\n<ul>\n<li>\n<p>parsebin will add all relevant parsers and expose those streams.</p>\n</li>\n<li>\n<p>Decodebin will be able to correlate, based on <code>STREAM_START</code> event\nstream-id, what pad corresponds to which stream. It links each stream\nfrom parsebin to multiqueue.</p>\n</li>\n<li>\n<p>Decodebin knows all the streams that will be available. Since by\ndefault it is configured to only expose a stream of each type, it\nwill pick a stream of each for which it will complete the\nauto-plugging (finding a decoder and then exposing that stream as a\nsource ghostpad.</p>\n</li>\n</ul>\n<blockquote>\n<p>Note: If the demuxer doesn't create/post the <code>GstStreamCollection</code>,\nparsebin will create it on itself, as explained in section 2.3\nabove.</p>\n</blockquote>\n<h3 id=\"changing-the-active-selection-from-the-application\">Changing the active selection from the application</h3>\n<p>The user wants to change the audio track. The application received\nthe <code>GST_MESSAGE_STREAM_COLLECTION</code> containing the list of available\nstreams. For clarity, we will assume those stream-ids are\n\"video-main\", \"audio-english\" and \"audio-french\".</p>\n<p>The user prefers to use the french soundtrack (which it knows based\non the language tag contained in the <code>GstStream</code> objects).</p>\n<p>The application will create and send a <code>GST_EVENT_SELECT_STREAM</code> event\ncontaining the list of streams: \"video-main\", \"audio-french\".</p>\n<p>That event gets sent on the pipeline, the sinks send it upstream and\neventually reach decodebin.</p>\n<p>Decodebin compares:</p>\n<ul>\n<li>The currently active selection (\"video-main\", \"audio-english\")</li>\n<li>The available stream collection (\"video-main\", \"audio-english\",\n\"audio-french\")</li>\n<li>The list of streams in the event (\"video-main\", \"audio-french\")</li>\n</ul>\n<p>Decodebin determines that no change is required for \"video-main\",\nbut sees that it needs to deactivate \"audio-english\" and activate\n\"audio-french\".</p>\n<p>It unlinks the multiqueue source pad connected to the audiodec. Then\nit queries audiodec, using the <code>GST_QUERY_ACCEPT_CAPS</code>, whether it can\naccept as-is the caps from the \"audio-french\" stream.</p>\n<ol>\n<li>If it does, the multiqueue source pad corresponding to\n\"audio-french\" is linked to the decoder.</li>\n<li>If it does not, the existing audio decoder is removed,\na new decoder is selected (like during initial\nauto-plugging), and replaces the old audio decoder element.</li>\n</ol>\n<p>The newly selected stream gets decoded and output through the same\npad as the previous audio stream.</p>\n<p>Note:\nThe default behaviour would be to only expose one stream of each\ntype. But nothing prevents decodebin from outputting more/less of\neach type if the <code>GST_EVENT_SELECT_STREAM</code> event specifies that. This\nallows covering more use-case than the simple playback one.\nSuch examples could be :</p>\n<ul>\n<li>Wanting just a video stream or just an audio stream</li>\n<li>Wanting all decoded streams</li>\n<li>Wanting all audio streams\n...</li>\n</ul>\n<h3 id=\"changes-coming-from-upstream\">Changes coming from upstream</h3>\n<p>At some point in time, a PMT change happens. Let's assume a change\nin video-codec and/or PID.</p>\n<p>The demuxer creates a new <code>GstStream</code> for the changed/new stream,\ncreates a new GstStreamCollection for the updated PMT and posts it.</p>\n<p>Decodebin sees the new <code>GstStreamCollection</code> message.</p>\n<p>The demuxer (and parsebin) then adds and removes pads.</p>\n<ol>\n<li>decodebin will match the new pads to <code>GstStream</code> in the \"new\"\n<code>GstStreamCollection</code> the same way it did for the initial pads in\nsection 4.2 above.</li>\n<li>decodebin will see whether the new stream can re-use a multiqueue\nslot used by a stream of the same type no longer present (it\ncompares the old collection to the new collection).\nIn this case, decodebin sees that the new video stream can re-use\nthe same slot as the previous video stream.</li>\n<li>If the new stream is going to be active by default (in this case\nit does because we are replacing the only video stream, which was\nactive), it will check whether the caps are compatible with the\nexisting videodec (in the same way it was done for the audio\ndecoder switch in section 4.3).</li>\n</ol>\n<p>Eventually, the stream that switched will be decoded and output\nthrough the same pad as the previous video stream in a gapless fashion.</p>\n<h3 id=\"further-examples\">Further examples</h3>\n<h5 id=\"hls-alternates\">HLS alternates</h5>\n<p>There is a main (multi-bitrate or not) stream with audio and\nvideo interleaved in mpeg-ts. The manifest also indicates the\npresence of alternate language audio-only streams.\nHLS would expose one collection containing:</p>\n<ol>\n<li>The main A+V CONTAINER stream (mpeg-ts), initially active,\ndownloaded and exposed as a pad</li>\n<li>The alternate A-only streams, initially inactive and not exposed as pads\nthe tsdemux element connected to the first stream will also expose\na collection containing\n1.1) A video stream\n1.2) An audio stream</li>\n</ol>\n<pre><code>    [ Collection 1 ]         [ Collection 2 ]\n    [  (hlsdemux)  ]         [   (tsdemux)  ]\n    [ upstream:nil ]    /----[ upstream:main]\n    [              ]   /     [              ]\n    [ \"main\" (A+V) ]&lt;-/      [ \"video\"  (V) ]  viddec1 : \"video\"\n    [ \"fre\"  (A)   ]         [ \"eng\"    (A) ]  auddec1 : \"eng\"\n    [ \"kor\"  (A)   ]         [              ]\n</code></pre>\n<p>The user might want to use the korean audio track instead of the\ndefault english one.</p>\n<pre><code>  =&gt; SELECT_STREAMS (\"video\", \"kor\")\n</code></pre>\n<ol>\n<li>decodebin3 receives and sends the event further upstream</li>\n<li>tsdemux sees that \"video\" is part of its current upstream,\nso adds the corresponding stream-id (\"main\") to the event\nand sends it upstream (\"main\", \"video\", \"kor\")</li>\n<li>hlsdemux receives the event\n=&gt; It activates \"kor\" in addition to \"main\"</li>\n<li>The event travels back to decodebin3 which will remember the\nrequested selection. If \"kor\" is already present it will switch\nthe \"eng\" stream from the audio decoder to the \"kor\" stream.\nIf it appears a bit later, it will wait until that \"kor\" stream\nis available before switching</li>\n</ol>\n<h4 id=\"multiprogram-mpegts\">multi-program MPEG-TS</h4>\n<p>Assuming the case of a mpeg-ts stream which contains multiple\nprograms.\nThere would be three \"levels\" of collection:</p>\n<ol>\n<li>The collection of programs presents in the stream</li>\n<li>The collection of elementary streams presents in a stream</li>\n<li>The collection of streams decodebin can expose</li>\n</ol>\n<p>Initially tsdemux exposes the first program present (default)</p>\n<pre><code>    [ Collection 1 ]         [ Collection 2     ]        [ Collection 3    ]\n    [  (tsdemux)   ]         [   (tsdemux)      ]        [ (decodebin)     ]\n    [ id:Programs  ]&lt;-\\      [ id:BBC1          ]&lt;-\\     [ id:BBC1-decoded ]\n    [ upstream:nil ]   \\-----[ upstream:Programs]   \\----[ upstream:BBC1   ]\n    [              ]         [                  ]        [                 ]\n    [ \"BBC1\" (C)   ]         [ id:\"bbcvideo\"(V) ]        [ id:\"bbcvideo\"(V)]\n    [ \"ITV\"  (C)   ]         [ id:\"bbcaudio\"(A) ]        [ id:\"bbcaudio\"(A)]\n    [ \"NBC\"  (C)   ]         [                  ]        [                 ]\n</code></pre>\n<p>At some point the user wants to switch to ITV (of which we do not\nknow the topology at this point in time. A <code>SELECT_STREAMS</code> event\nis sent with \"ITV\" in it and the pointer to the Collection1.</p>\n<ol>\n<li>The event travels up the pipeline until tsdemux receives it\nand begins the switch.</li>\n<li>tsdemux publishes a new 'Collection 2a/ITV' and marks 'Collection 2/BBC'\nas replaced.\n2a) App may send a <code>SELECT_STREAMS</code> event configuring which demuxer output\nstreams should be selected (parsed)</li>\n<li>tsdemux adds/removes pads as needed (flushing pads as it removes them?)</li>\n<li>Decodebin feeds new pad streams through existing parsers/decoders as\nneeded. As data from the new collection arrives out each decoder,\ndecodebin sends new <code>GstStreamCollection</code> messages to the app so it\ncan know that the new streams are now switchable at that level.\n4a) As new <code>GstStreamCollections</code> are published, the app may override\nthe default decodebin stream selection to expose more/fewer streams.\nThe default is to decode and output 1 stream of each type.</li>\n</ol>\n<p>Final state:</p>\n<pre><code>    [ Collection 1 ]         [ Collection 4     ]        [ Collection 5    ]\n    [  (tsdemux)   ]         [   (tsdemux)      ]        [ (decodebin)     ]\n    [ id:Programs  ]&lt;-\\      [ id:ITV           ]&lt;-\\     [ id:ITV-decoded  ]\n    [ upstream:nil ]   \\-----[ upstream:Programs]   \\----[ upstream:ITV    ]\n    [              ]         [                  ]        [                 ]\n    [ \"BBC1\" (C)   ]         [ id:\"itvvideo\"(V) ]        [ id:\"itvvideo\"(V)]\n    [ \"ITV\"  (C)   ]         [ id:\"itvaudio\"(A) ]        [ id:\"itvaudio\"(A)]\n    [ \"NBC\"  (C)   ]         [                  ]        [                 ]\n</code></pre>\n<h3 id=\"todo\">TODO</h3>\n<ul>\n<li>\n<p>Add missing implementation</p>\n<ul>\n<li>\n<p>Add flags to <code>GstStreamCollection</code></p>\n</li>\n<li>\n<p>Add mutual-exclusion and relationship API to <code>GstStreamCollection</code></p>\n</li>\n</ul>\n</li>\n<li>\n<p>Add helper API to figure out whether a collection is a replacement\nof another or a completely new one. This will require a more generic\nsystem to know whether a certain stream-id is a replacement of\nanother or not.</p>\n</li>\n</ul>\n<h3 id=\"open-questions\">OPEN QUESTIONS</h3>\n<ul>\n<li>\n<p>Is a <code>FLUSHING</code> flag for stream-selection required or not ? This would\nmake the handler of the <code>SELECT_STREAMS</code> event send <code>FLUSH START/STOP</code>\nbefore switching to the other streams. This is tricky when dealing\nwhere situations where we keep some streams and only switch some\nothers. Do we flush all streams ? Do we only flush the new streams,\npotentially resulting in delay to fully switch ? Furthermore, due to\nefficient buffering in decodebin3, the switching time has been\nminimized extensively, to the point where flushing might not bring a\nnoticeable improvement.</p>\n</li>\n<li>\n<p>Store the stream collection in bins/pipelines ? A Bin/Pipeline could\nstore all active collection internally, so that it could be queried\nlater on. This could be useful to then get, on any pipeline, at any\npoint in time, the full list of collections available without having\nto listen to all COLLECTION messages on the bus. This would require\nfixing the \"is a collection a replacement or not\" issue first.</p>\n</li>\n<li>\n<p>When switching to new collections, should decodebin3 make any effort\nto <em>map</em> corresponding streams from the old to new PMT - that is,\ntry and stick to the <em>english</em> language audio track, for example?\nAlternatively, rely on the app to do such smarts with stream-select\nmessages ?</p>\n</li>\n</ul>\n\n</div>\n\n\n\t"});