fragment_downloaded_cb({"url": "GStreamer-doc-1.0/design/probes.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"probes.md\">\n<h1 id=\"probes\">Probes</h1>\n<p>Probes are callbacks that can be installed by the application and will notify\nthe application about the states of the dataflow.</p>\n<h2 id=\"requirements\">Requirements</h2>\n<p>Applications should be able to monitor and control the dataflow on pads.\nWe identify the following types:</p>\n<ul>\n<li>\n<p>be notified when the pad is/becomes idle and make sure the pad stays\nidle. This is essential to be able to implement dynamic relinking of\nelements without breaking the dataflow.</p>\n</li>\n<li>\n<p>be notified when data, events or queries are pushed or sent on a\npad. It should also be possible to inspect and modify the data.</p>\n</li>\n<li>\n<p>be able to drop, pass and block on data based on the result of the\ncallback.</p>\n</li>\n<li>\n<p>be able to drop, pass data on blocking pads based on methods\nperformed by the application\nthread.</p>\n</li>\n</ul>\n<h2 id=\"overview\">Overview</h2>\n<p>The function <code>gst_pad_add_probe()</code> is used to add a probe to a pad. It accepts a\nprobe type mask and a callback.</p>\n<pre><code class=\"language-c\">    gulong  gst_pad_add_probe    (GstPad *pad,\n                                  GstPadProbeType mask,\n                                  GstPadProbeCallback callback,\n                                  gpointer user_data,\n                                  GDestroyNotify destroy_data);\n</code></pre>\n<p>The function returns a gulong that uniquely identifies the probe and that can\nbe used to remove the probe with <code>gst_pad_remove_probe()</code>:</p>\n<pre><code class=\"language-c\">    void    gst_pad_remove_probe (GstPad *pad, gulong id);\n</code></pre>\n<p>The mask parameter is a bitwise or of the following flags:</p>\n<pre><code class=\"language-c\">typedef enum\n{\n  GST_PAD_PROBE_TYPE_INVALID          = 0,\n\n  /* flags to control blocking */\n  GST_PAD_PROBE_TYPE_IDLE             = (1 &lt;&lt; 0),\n  GST_PAD_PROBE_TYPE_BLOCK            = (1 &lt;&lt; 1),\n\n  /* flags to select datatypes */\n  GST_PAD_PROBE_TYPE_BUFFER           = (1 &lt;&lt; 4),\n  GST_PAD_PROBE_TYPE_BUFFER_LIST      = (1 &lt;&lt; 5),\n  GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM = (1 &lt;&lt; 6),\n  GST_PAD_PROBE_TYPE_EVENT_UPSTREAM   = (1 &lt;&lt; 7),\n  GST_PAD_PROBE_TYPE_EVENT_FLUSH      = (1 &lt;&lt; 8),\n  GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM = (1 &lt;&lt; 9),\n  GST_PAD_PROBE_TYPE_QUERY_UPSTREAM   = (1 &lt;&lt; 10),\n\n  /* flags to select scheduling mode */\n  GST_PAD_PROBE_TYPE_PUSH             = (1 &lt;&lt; 12),\n  GST_PAD_PROBE_TYPE_PULL             = (1 &lt;&lt; 13),\n} GstPadProbeType;\n</code></pre>\n<p>When adding a probe with the IDLE or BLOCK flag, the probe will become a\nblocking probe (see below). Otherwise the probe will be a DATA probe.</p>\n<p>The datatype and scheduling selector flags are used to select what kind of\ndatatypes and scheduling modes should be allowed in the callback.</p>\n<p>The blocking flags must match the triggered probe exactly.</p>\n<p>The probe callback is defined as:</p>\n<pre><code class=\"language-c\">    GstPadProbeReturn (*GstPadProbeCallback) (GstPad *pad, GstPadProbeInfo *info,\n                                           gpointer user_data);\n</code></pre>\n<p>A probe info structure is passed as an argument and its type is guaranteed\nto match the mask that was used to register the callback. The data item in the\ninfo contains type specific data, which is usually the data item that is blocked\nor NULL when no data item is present.</p>\n<p>The probe can return any of the following return values:</p>\n<pre><code class=\"language-c\">typedef enum\n{\n  GST_PAD_PROBE_DROP,\n  GST_PAD_PROBE_OK,\n  GST_PAD_PROBE_REMOVE,\n  GST_PAD_PROBE_PASS,\n} GstPadProbeReturn;\n</code></pre>\n<p><code>GST_PAD_PROBE_OK</code> is the normal return value. DROP will drop the item that is\ncurrently being probed. <code>GST_PAD_PROBE_REMOVE</code> the currently executing probe from the\nlist of probes.</p>\n<p><code>GST_PAD_PROBE_PASS</code> is relevant for blocking probes and will temporarily unblock the\npad and let the item trough, it will then block again on the next item.</p>\n<h2 id=\"blocking-probes\">Blocking probes</h2>\n<p>Blocking probes are probes with BLOCK or IDLE flags set. They will always\nblock the dataflow and trigger the callback according to the following rules:</p>\n<p>When the IDLE flag is set, the probe callback is called as soon as no data is\nflowing over the pad. If at the time of probe registration, the pad is idle,\nthe callback will be called immediately from the current thread. Otherwise,\nthe callback will be called as soon as the pad becomes idle in the streaming\nthread.</p>\n<p>The IDLE probe is useful to perform dynamic linking, it allows to wait for for\na safe moment when an unlink/link operation can be done. Since the probe is a\nblocking probe, it will also make sure that the pad stays idle until the probe\nis removed.</p>\n<p>When the BLOCK flag is set, the probe callback will be called when new data\narrives on the pad and right before the pad goes into the blocking state. This\ncallback is thus only called when there is new data on the pad.</p>\n<p>The blocking probe is removed with <code>gst_pad_remove_probe()</code> or when the probe\ncallback return <code>GST_PAD_PROBE_REMOVE</code>. In both cases, and if this was the last\nblocking probe on the pad, the pad is unblocked and dataflow can continue.</p>\n<h2 id=\"nonblocking-probes\">Non-Blocking probes</h2>\n<p>Non-blocking probes or DATA probes are probes triggered when data is flowing\nover the pad. The are called after the blocking probes are run and always with\ndata.</p>\n<h2 id=\"push-dataflow\">Push dataflow</h2>\n<p>Push probes have the <code>GST_PAD_PROBE_TYPE_PUSH</code> flag set in the\ncallbacks.</p>\n<p>In push based scheduling, the blocking probe is called first with the\ndata item. Then the data probes are called before the peer pad chain or\nevent function is called.</p>\n<p>The data probes are called before the peer pad is checked. This allows\nfor linking the pad in either the BLOCK or DATA probes on the pad.</p>\n<p>Before the peerpad chain or event function is called, the peer pad block\nand data probes are called.</p>\n<p>Finally, the IDLE probe is called on the pad after the data was sent to\nthe peer pad.</p>\n<p>The push dataflow probe behavior is the same for buffers and\nbidirectional events.</p>\n<pre><code>                    pad                           peerpad\n                     |                               |\ngst_pad_push() /     |                               |\ngst_pad_push_event() |                               |\n--------------------&gt;O                               |\n                     O                               |\n       flushing?     O                               |\n       FLUSHING      O                               |\n       &lt; - - - - - - O                               |\n                     O-&gt; do BLOCK probes             |\n                     O                               |\n                     O-&gt; do DATA probes              |\n        no peer?     O                               |\n       NOT_LINKED    O                               |\n       &lt; - - - - - - O                               |\n                     O   gst_pad_chain() /           |\n                     O   gst_pad_send_event()        |\n                     O------------------------------&gt;O\n                     O                   flushing?   O\n                     O                   FLUSHING    O\n                     O&lt; - - - - - - - - - - - - - - -O\n                     O                               O-&gt; do BLOCK probes\n                     O                               O\n                     O                               O-&gt; do DATA probes\n                     O                               O\n                     O                               O---&gt; chainfunc /\n                     O                               O     eventfunc\n                     O&lt; - - - - - - - - - - - - - - -O\n                     O                               |\n                     O-&gt; do IDLE probes              |\n                     O                               |\n       &lt; - - - - - - O                               |\n                     |                               |\n</code></pre>\n<h2 id=\"pull-dataflow\">Pull dataflow</h2>\n<p>Pull probes have the <code>GST_PAD_PROBE_TYPE_PULL</code> flag set in the\ncallbacks.</p>\n<p>The <code>gst_pad_pull_range()</code> call will first trigger the BLOCK probes\nwithout a DATA item. This allows the pad to be linked before the peer\npad is resolved. It also allows the callback to set a data item in the\nprobe info.</p>\n<p>After the blocking probe and the getrange function is called on the peer\npad and there is a data item, the DATA probes are called.</p>\n<p>When control returns to the sinkpad, the IDLE callbacks are called. The\nIDLE callback is called without a data item so that it will also be\ncalled when there was an error.</p>\n<p>If there is a valid DATA item, the DATA probes are called for the item.</p>\n<pre><code>                srcpad                          sinkpad\n                  |                               |\n                  |                               | gst_pad_pull_range()\n                  |                               O&lt;---------------------\n                  |                               O\n                  |                               O  flushing?\n                  |                               O  FLUSHING\n                  |                               O - - - - - - - - - - &gt;\n                  |             do BLOCK probes &lt;-O\n                  |                               O   no peer?\n                  |                               O  NOT_LINKED\n                  |                               O - - - - - - - - - - &gt;\n                  |          gst_pad_get_range()  O\n                  O&lt;------------------------------O\n                  O                               O\n                  O flushing?                     O\n                  O FLUSHING                      O\n                  O- - - - - - - - - - - - - - - &gt;O\ndo BLOCK probes &lt;-O                               O\n                  O                               O\n getrangefunc &lt;---O                               O\n                  O  flow error?                  O\n                  O- - - - - - - - - - - - - - - &gt;O\n                  O                               O\n do DATA probes &lt;-O                               O\n                  O- - - - - - - - - - - - - - - &gt;O\n                  |                               O\n                  |              do IDLE probes &lt;-O\n                  |                               O   flow error?\n                  |                               O - - - - - - - - - - &gt;\n                  |                               O\n                  |              do DATA probes &lt;-O\n                  |                               O - - - - - - - - - - &gt;\n                  |                               |\n</code></pre>\n<h2 id=\"queries\">Queries</h2>\n<p>Query probes have the <code>GST_PAD_PROBE_TYPE_QUERY_*</code> flag set in the\ncallbacks.</p>\n<pre><code>                    pad                           peerpad\n                     |                               |\ngst_pad_peer_query() |                               |\n--------------------&gt;O                               |\n                     O                               |\n                     O-&gt; do BLOCK probes             |\n                     O                               |\n                     O-&gt; do QUERY | PUSH probes      |\n        no peer?     O                               |\n          FALSE      O                               |\n       &lt; - - - - - - O                               |\n                     O   gst_pad_query()             |\n                     O------------------------------&gt;O\n                     O                               O-&gt; do BLOCK probes\n                     O                               O\n                     O                               O-&gt; do QUERY | PUSH probes\n                     O                               O\n                     O                               O---&gt; queryfunc\n                     O                    error      O\n       &lt;- - - - - - - - - - - - - - - - - - - - - - -O\n                     O                               O\n                     O                               O-&gt; do QUERY | PULL probes\n                     O&lt; - - - - - - - - - - - - - - -O\n                     O                               |\n                     O-&gt; do QUERY | PULL probes      |\n                     O                               |\n       &lt; - - - - - - O                               |\n                     |                               |\n</code></pre>\n<p>For queries, the PUSH ProbeType is set when the query is traveling to\nthe object that will answer the query and the PULL type is set when the\nquery contains the answer.</p>\n<h2 id=\"usecases\">Use-cases</h2>\n<h3 id=\"prerolling-a-partial-pipeline\">Prerolling a partial pipeline</h3>\n<pre><code>    .---------.      .---------.                .----------.\n    | filesrc |      | demuxer |     .-----.    | decoder1 |\n    |        src -&gt; sink      src1 -&gt;|queue|-&gt; sink       src\n    '---------'      |         |     '-----'    '----------' X\n                     |         |                .----------.\n                     |         |     .-----.    | decoder2 |\n                     |        src2 -&gt;|queue|-&gt; sink       src\n                     '---------'     '-----'    '----------' X\n</code></pre>\n<p>The purpose is to create the pipeline dynamically up to the decoders but\nnot yet connect them to a sink and without losing any data.</p>\n<p>To do this, the source pads of the decoders is blocked so that no events\nor buffers can escape and we don\u2019t interrupt the stream.</p>\n<p>When all of the dynamic pad are created (no-more-pads emitted by the\nbranching point, ie, the demuxer or the queues filled) and the pads are\nblocked (blocked callback received) the pipeline is completely\nprerolled.</p>\n<p>It should then be possible to perform the following actions on the\nprerolled pipeline:</p>\n<ul>\n<li>\n<p>query duration/position</p>\n</li>\n<li>\n<p>perform a flushing seek to preroll a new position</p>\n</li>\n<li>\n<p>connect other elements and unblock the blocked pads.</p>\n</li>\n</ul>\n<h3 id=\"dynamically-switching-an-element-in-a-playing-pipeline\">dynamically switching an element in a PLAYING pipeline</h3>\n<pre><code> .----------.      .----------.      .----------.\n | element1 |      | element2 |      | element3 |\n...        src -&gt; sink       src -&gt; sink       ...\n '----------'      '----------'      '----------'\n                   .----------.\n                   | element4 |\n                  sink       src\n                   '----------'\n</code></pre>\n<p>The purpose is to replace element2 with element4 in the PLAYING\npipeline.</p>\n<ol>\n<li>block element1 src pad.</li>\n<li>inside the block callback nothing is flowing between\nelement1 and element2 and nothing will flow until unblocked.</li>\n<li>unlink element1 and element2</li>\n<li>optional step: make sure data is flushed out of element2:\n4a) pad event probe on element2 src\n4b) send EOS to element2, this makes sure that element2 flushes out the last bits of data it holds.\n4c) wait for EOS to appear in the probe, drop the EOS.\n4d) remove the EOS pad event probe.</li>\n<li>unlink element2 and element3\n5a) optionally element2 can now be set to NULL and/or removed from the pipeline.</li>\n<li>link element4 and element3</li>\n<li>link element1 and element4</li>\n<li>make sure element4 is in the same state as the rest of the elements. The\nelement should at least be PAUSED.</li>\n<li>unblock element1 src</li>\n</ol>\n<p>The same flow can be used to replace an element in a PAUSED pipeline. Of\ncourse in a PAUSED pipeline there might not be dataflow so the block\nmight not immediately happen.</p>\n\n</div>\n\n\n\t"});