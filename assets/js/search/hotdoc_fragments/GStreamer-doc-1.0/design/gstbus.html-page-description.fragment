fragment_downloaded_cb({"url": "GStreamer-doc-1.0/design/gstbus.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gstbus.md\">\n<h1 id=\"gstbus\">GstBus</h1>\n<p>The <code>GstBus</code> is an object responsible for delivering <code>GstMessages</code> in a\nfirst-in first-out way from the streaming threads to the application.</p>\n<p>Since the application typically only wants to deal with delivery of\nthese messages from one thread, the <code>GstBus</code> will marshall the messages\nbetween different threads. This is important since the actual streaming\nof media is done in other threads (streaming threads) than the\napplication. It is also important to not block the streaming threads\nwhile the application deals with the message.</p>\n<p>The <code>GstBus</code> provides support for <code>GSource</code> based notifications. This makes\nit possible to handle the delivery in the glib mainloop. Different\n<code>GSources</code> can be added to the same bin provided they listen to different\nmessage types.</p>\n<p>A message is posted on the bus with the <code>gst_bus_post()</code> method. With\nthe <code>gst_bus_peek()</code> and <code>_pop()</code> methods one can look at or retrieve a\npreviously posted message.</p>\n<p>The bus can be polled with the <code>gst_bus_poll()</code> method. This method\nblocks up to the specified timeout value until one of the specified\nmessage types are posted on the bus. The application can then <code>_pop()</code>\nthese messages from the bus to handle them.</p>\n<p>It is also possible to get messages from the bus without any thread\nmarshalling with the <code>gst_bus_set_sync_handler()</code> method. This makes\nit possible to react to a message in the same thread that posted it\non the bus. This should only be used if the application is able\nto deal with messages from different threads.</p>\n<p>If no messages are popped from the bus with either a <code>GSource</code> or\n<code>gst_bus_pop()</code>, they remain on the bus.</p>\n<p>When a pipeline or bin goes from READY into NULL state, it will set its\nbus to flushing, ie. the bus will drop all existing and new messages on\nthe bus. This is necessary because bus messages hold references to the\nbin/pipeline or its elements, so there are circular references that need\nto be broken if one ever wants to be able to destroy a bin or pipeline\nproperly.</p>\n\n</div>\n\n\n\t"});