fragment_downloaded_cb({"url": "GStreamer-doc-1.0/design/buffer.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"buffer.md\">\n<h1 id=\"gstbuffer\">GstBuffer</h1>\n<p>This document describes the design for buffers.</p>\n<p>A <code>GstBuffer</code> is the object that is passed from an upstream element to a\ndownstream element and contains memory and metadata information.</p>\n<h2 id=\"requirements\">Requirements</h2>\n<ul>\n<li>It must be fast\n<ul>\n<li>allocation, free, low fragmentation</li>\n</ul>\n</li>\n<li>Must be able to attach multiple memory blocks to the buffer</li>\n<li>Must be able to attach arbitrary metadata to buffers</li>\n<li>efficient handling of subbuffer, copy, span, trim</li>\n</ul>\n<h2 id=\"lifecycle\">Lifecycle</h2>\n<p><code>GstMemory</code> extends from <code>GstMiniObject</code> and therefore uses its lifecycle\nmanagement (See <a href=\"miniobject.html\">miniobject</a>).</p>\n<h2 id=\"writability\">Writability</h2>\n<p>When a <code>GstBuffer</code> is writable as returned by <code>gst_buffer_is_writable()</code>:</p>\n<ul>\n<li>\n<p>metadata can be added/removed and the metadata can be changed</p>\n</li>\n<li>\n<p><code>GstMemory</code> blocks can be added/removed</p>\n</li>\n</ul>\n<p>The individual memory blocks have their own locking and READONLY flags\nthat might influence their writability.</p>\n<p>Buffers can be made writable with <code>gst_buffer_make_writable()</code>. This\nwill copy the buffer with the metadata and will ref the memory in the\nbuffer. This means that the memory is not automatically copied when\ncopying buffers.</p>\n<h1 id=\"managing-gstmemory\">Managing GstMemory</h1>\n<p>A <code>GstBuffer</code> contains an array of pointers to <code>GstMemory</code> objects.</p>\n<p>When the buffer is writable, <code>gst_buffer_insert_memory()</code> can be used\nto add a new <code>GstMemory</code> object to the buffer. When the array of memory is\nfull, memory will be merged to make room for the new memory object.</p>\n<p><code>gst_buffer_n_memory()</code> is used to get the amount of memory blocks on\nthe <code>GstBuffer</code>.</p>\n<p>With <code>gst_buffer_peek_memory()</code>, memory can be retrieved from the\nmemory array. The desired access pattern for the memory block should be\nspecified so that appropriate checks can be made and, in case of\n<code>GST_MAP_WRITE</code>, a writable copy can be constructed when needed.</p>\n<p><code>gst_buffer_remove_memory_range()</code> and <code>gst_buffer_remove_memory()</code>\ncan be used to remove memory from the <code>GstBuffer</code>.</p>\n<h1 id=\"subbuffers\">Subbuffers</h1>\n<p>Subbuffers are made by copying only a region of the memory blocks and\ncopying all of the metadata.</p>\n<h1 id=\"span\">Span</h1>\n<p>Spanning will merge together the data of 2 buffers into a new buffer</p>\n<h1 id=\"data-access\">Data access</h1>\n<p>Accessing the data of the buffer can happen by retrieving the individual\n<code>GstMemory</code> objects in the <code>GstBuffer</code> or by using the <code>gst_buffer_map()</code> and\n<code>gst_buffer_unmap()</code> functions.</p>\n<p>The <code>_map()</code> and <code>_unmap()</code> functions will always return the memory of all\nblocks as one large contiguous region. Using these functions might be more\nconvenient than accessing the individual memory blocks at the expense of\nbeing more expensive because it might perform memcpy operations.</p>\n<p>For buffers with only one <code>GstMemory</code> object (the most common case), <code>_map()</code>\nand <code>_unmap()</code> have no performance penalty at all.</p>\n<ul>\n<li>\n<p><strong>Read access with 1 memory block</strong>: The memory block is accessed and mapped\nfor read access. The memory block is unmapped after usage</p>\n</li>\n<li>\n<p><strong>write access with 1 memory block</strong>: The buffer should be writable or this\noperation will fail. The memory block is accessed. If the memory block is\nreadonly, a copy is made and the original memory block is replaced with this\ncopy. Then the memory block is mapped in write mode and unmapped after usage.</p>\n</li>\n<li>\n<p><strong>Read access with multiple memory blocks</strong>: The memory blocks are combined\ninto one large memory block. If the buffer is writable, the memory blocks are\nreplaced with this new combined block. If the buffer is not writable, the\nmemory is returned as is. The memory block is then mapped in read mode.\nWhen the memory is unmapped after usage and the buffer has multiple memory\nblocks, this means that the map operation was not able to store the combined\nbuffer and it thus returned memory that should be freed. Otherwise, the memory\nis unmapped.</p>\n</li>\n<li>\n<p><strong>Write access with multiple memory blocks</strong>: The buffer should be writable\nor the operation fails. The memory blocks are combined into one large memory\nblock and the existing blocks are replaced with this new block. The memory is\nthen mapped in write mode and unmapped after usage.</p>\n</li>\n</ul>\n<h1 id=\"use-cases\">Use cases</h1>\n<h2 id=\"generating-rtp-packets-from-h264-video\">Generating RTP packets from h264 video</h2>\n<p>We receive as input a <code>GstBuffer</code> with an encoded h264 image and we need\nto create RTP packets containing this h264 data as the payload. We\ntypically need to fragment the h264 data into multiple packets, each\nwith their own RTP and payload specific header.</p>\n<pre><code>                     +-------+-------+---------------------------+--------+\ninput H264 buffer:   | NALU1 | NALU2 |  .....                    | NALUx  |\n                     +-------+-------+---------------------------+--------+\n                           |\n                           V\narray of             +-+ +-------+  +-+ +-------+            +-+ +-------+\noutput buffers:      | | | NALU1 |  | | | NALU2 |   ....     | | | NALUx |\n                     +-+ +-------+  +-+ +-------+            +-+ +-------+\n                     :           :  :           :\n                     \\-----------/  \\-----------/\n                       buffer 1        buffer 2\n</code></pre>\n<p>The output buffer array consists of x buffers consisting of an RTP\npayload header and a subbuffer of the original input H264 buffer. Since\nthe rtp headers and the h264 data don\u2019t need to be contiguous in memory,\nthey are added to the buffer as separate <code>GstMemory</code> blocks and we can\navoid to memcpy the h264 data into contiguous memory.</p>\n<p>A typical udpsink will then use something like sendmsg to send the\nmemory regions on the network inside one UDP packet. This will further\navoid having to memcpy data into contiguous memory.</p>\n<p>Using bufferlists, the complete array of output buffers can be pushed in\none operation to the peer element.</p>\n\n</div>\n\n\n\t"});