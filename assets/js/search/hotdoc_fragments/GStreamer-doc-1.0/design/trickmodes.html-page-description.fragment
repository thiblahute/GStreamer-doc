fragment_downloaded_cb({"url": "GStreamer-doc-1.0/design/trickmodes.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"trickmodes.md\">\n<h1 id=\"trickmodes\">Trickmodes</h1>\n<p>GStreamer provides API for performing various trickmode playback. This\nincludes:</p>\n<ul>\n<li>\n<p>server side trickmodes</p>\n</li>\n<li>\n<p>client side fast/slow forward playback</p>\n</li>\n<li>\n<p>client side fast/slow backwards playback</p>\n</li>\n</ul>\n<p>Server side trickmodes mean that a source (network source) can provide a\nstream with different playback speed and direction. The client does not\nhave to perform any special algorithms to decode this stream.</p>\n<p>Client side trickmodes mean that the decoding client (GStreamer)\nperforms the needed algorithms to change the direction and speed of the\nmedia file.</p>\n<p>Seeking can both be done in a playback pipeline and a transcoding\npipeline.</p>\n<h2 id=\"general-seeking-overview\">General seeking overview</h2>\n<p>Consider a typical playback pipeline:</p>\n<pre><code>                        .---------.  .------.\n            .-------.   | decoder |-&gt;| sink |\n.--------.  |       |--&gt;'---------'  '------'\n| source |-&gt;| demux |\n'--------'  |       |--&gt;.---------.  .------.\n            '-------'   | decoder |-&gt;| sink |\n                        '---------'  '------'\n</code></pre>\n<p>The pipeline is initially configured to play back at speed 1.0 starting\nfrom position 0 and stopping at the total duration of the file.</p>\n<p>When performing a seek, the following steps have to be taken by the\napplication:</p>\n<h3 id=\"create-a-seek-event\">Create a seek event</h3>\n<p>The seek event contains:</p>\n<ul>\n<li>\n<p>various flags describing:</p>\n</li>\n<li>\n<p>where to seek to (KEY_UNIT)</p>\n</li>\n<li>\n<p>how accurate the seek should be (ACCURATE)</p>\n</li>\n<li>\n<p>how to perform the seek (FLUSH)</p>\n</li>\n<li>\n<p>what to do when the stop position is reached (SEGMENT).</p>\n</li>\n<li>\n<p>extra playback options (SKIP)</p>\n</li>\n<li>\n<p>a format to seek in, this can be time, bytes, units (frames,\nsamples), \u2026</p>\n</li>\n<li>\n<p>a playback rate, 1.0 is normal playback speed, positive values\nbigger than 1.0 mean fast playback. negative values mean reverse\nplayback. A playback speed of 0.0 is not allowed (but is equivalent\nto PAUSING the pipeline).</p>\n</li>\n<li>\n<p>a start position, this value has to be between 0 and the total\nduration of the file. It can also be relative to the previously\nconfigured start value.</p>\n</li>\n<li>\n<p>a stop position, this value has to be between 0 and the total\nduration. It can also be relative to the previously configured stop\nvalue.</p>\n</li>\n</ul>\n<p>See also <code>gst_event_new_seek()</code>.</p>\n<h3 id=\"send-the-seek-event\">Send the seek event</h3>\n<p>Send the new seek event to the pipeline with\n<code>gst_element_send_event()</code>.</p>\n<p>By default the pipeline will send the event to all sink elements. By\ndefault an element will forward the event upstream on all sinkpads.\nElements can modify the format of the seek event. The most common format\nis GST_FORMAT_TIME.</p>\n<p>One element will actually perform the seek, this is usually the demuxer\nor source element. For more information on how to perform the different\nseek types see <a href=\"seeking.html\">seeking</a>.</p>\n<p>For client side trickmode a SEGMENT event will be sent downstream with\nthe new rate and start/stop positions. All elements prepare themselves\nto handle the rate (see below). The applied rate of the SEGMENT event\nwill be set to 1.0 to indicate that no rate adjustment has been done.</p>\n<p>for server side trick mode a SEGMENT event is sent downstream with a\nrate of 1.0 and the start/stop positions. The elements will configure\nthemselves for normal playback speed since the server will perform the\nrate conversions. The applied rate will be set to the rate that will be\napplied by the server. This is done to insure that the position\nreporting performed in the sink is aware of the trick mode.</p>\n<p>When the seek succeeds, the <code>_send_event()</code> function will return TRUE.</p>\n<h2 id=\"server-side-trickmode\">Server side trickmode</h2>\n<p>The source element operates in push mode. It can reopen a server\nconnection requesting a new byte or time position and a new playback\nspeed. The capabilities can be queried from the server when the\nconnection is opened.</p>\n<p>We assume the source element is derived from the GstPushSrc base class.\nThe base source should be configured with gst_base_src_set_format\n(src, GST_FORMAT_TIME).</p>\n<p>The do_seek method will be called on the push src subclass with the\nseek information passed in the GstSegment argument.</p>\n<p>The rate value in the segment should be used to reopen the connection to\nthe server requesting data at the new speed and possibly a new playback\nposition.</p>\n<p>When the server connection was successfully reopened, set the rate of\nthe segment to 1.0 so that the client side trickmode is not enabled. The\napplied rate in the segment is set to the rate transformation done by\nthe server.</p>\n<p>Alternatively a combination of client side and serverside trickmode can\nbe used, for example if the server does not support certain rates, the\nclient can perform rate conversion for the remainder.</p>\n<pre><code>            source               server\ndo_seek       |                     |\n  -----------&gt;|                     |\n              |  reopen connection  |\n              |--------------------&gt;|\n              |                     .\n              |   success           .\n              |&lt;--------------------|\n    modify    |                     |\n  rate to 1.0 |                     |\n              |                     |\n   return     |                     |\n    TRUE      |                     |\n              |                     |\n</code></pre>\n<p>After performing the seek, the source will inform the downstream\nelements of the new segment that is to be played back. Since the segment\nwill have a rate of 1.0, no client side trick modes are enabled. The\nsegment will have an applied rate different from 1.0 to indicate that\nthe media contains data with non-standard playback speed or direction.</p>\n<h2 id=\"client-side-forward-trickmodes\">client side forward trickmodes</h2>\n<p>The seek happens as stated above. a SEGMENT event is sent downstream\nwith a rate different from 1.0. Plugins receiving the SEGMENT can decide\nto perform the rate conversion of the media data (retimestamp video\nframes, resample audio, \u2026).</p>\n<p>If a plugin decides to resample or retimestamp, it should modify the\nSEGMENT with a rate of 1.0 and update the applied rate so that\ndownstream elements don\u2019t resample again but are aware that the media\nhas been modified.</p>\n<p>The GStreamer base audio and video sinks will resample automatically if\nthey receive a SEGMENT event with a rate different from 1.0. The\nposition reporting in the base audio and video sinks will also depend on\nthe applied rate of the segment information.</p>\n<p>When the SKIP flag is set, frames can be dropped in the elements. If S\nis the speedup factor, a good algorithm for implementing frame skipping\nis to send audio in chunks of Nms (usually 300ms is good) and then skip\n((S-1) * Nns) of audio data. For the video we send only the keyframes\nin the (S * Nns) interval. In this case, the demuxer would scale the\ntimestamps and would set an applied rate of S.</p>\n<h2 id=\"client-side-backwards-trickmode\">client side backwards trickmode</h2>\n<p>For backwards playback the following rules apply:</p>\n<ul>\n<li>\n<p>the rate in the SEGMENT is less than 0.0.</p>\n</li>\n<li>\n<p>the SEGMENT start position is less than the stop position, playback\nwill however happen from stop to start in reverse.</p>\n</li>\n<li>\n<p>the time member in the SEGMENT is set to the stream time of the\nstart position.</p>\n</li>\n</ul>\n<p>For plugins the following rules apply:</p>\n<ul>\n<li>\n<p>A source plugin sends data in chunks starting from the last chunk of\nthe file. The actual bytes are not reversed. Each chunk that is not\nforward continuous with the previous chunk is marked with a DISCONT\nflag.</p>\n</li>\n<li>\n<p>A demuxer accumulates the chunks. As soon as a keyframe is found,\neverything starting from the keyframe up to the accumulated data is\nsent downstream. Timestamps on the buffers are set starting from the\nstop position to start, effectively going backwards. Chunks are\nmarked with DISCONT when they are not forward continuous with the\nprevious buffer.</p>\n</li>\n<li>\n<p>A video decoder decodes and accumulates all decoded frames. If a\nbuffer with a DISCONT, SEGMENT or EOS is received, all accumulated\nframes are sent downsteam in reverse.</p>\n</li>\n<li>\n<p>An audio decoder decodes and accumulates all decoded audio. If a\nbuffer with a DISCONT, SEGMENT or EOS is received, all accumulated\naudio is sent downstream in reverse order. Some audio codecs need\nthe previous data buffer to decode the current one, in that case,\nthe previous DISCONT buffer needs to be combined with the last\nnon-DISCONT buffer to generate the last bit of output.</p>\n</li>\n<li>\n<p>A sink reverses (for audio) and retimestamps (audio, video) the\nbuffers before playing them back. Retimestamping occurs relative to\nthe stop position, making the timestamps increase again and suitable\nfor synchronizing against the clock. Audio sinks also have to\nperform simple resampling before playing the samples.</p>\n</li>\n<li>\n<p>for transcoding, audio and video resamplers can be used to reverse,\nresample and retimestamp the buffers. Any rate adjustments performed\non the media must be added to the applied_rate and subtracted from\nthe rate members in the SEGMENT\nevent.</p>\n</li>\n</ul>\n<p>In SKIP mode, the same algorithm as for forward SKIP mode can be used.</p>\n<h2 id=\"notes\">Notes</h2>\n<ul>\n<li>\n<p>The clock/running_time keeps running forward.</p>\n</li>\n<li>\n<p>backwards playback potentially uses a lot of memory as frames and\nundecoded data gets buffered.</p>\n</li>\n</ul>\n\n</div>\n\n\n\t"});