fragment_downloaded_cb({"url": "GStreamer-doc-1.0/design/scheduling.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"scheduling.md\">\n<h1 id=\"scheduling\">Scheduling</h1>\n<p>The scheduling in GStreamer is based on pads actively pushing\n(producing) data or pulling (consuming) data from other pads.</p>\n<h2 id=\"pushing\">Pushing</h2>\n<p>A pad can produce data and push it to the next pad. A pad that behaves\nthis way exposes a loop function that will be repeatedly called until it\nreturns false. This loop function is allowed to block whenever it wants.\nWhen the pad is deactivated the loop function should unblock though.</p>\n<p>A pad operating in the push mode can only produce data to a pad that\nexposes a chain function. This chain function will be called with the\nbuffer produced by the pushing pad.</p>\n<p>This method of producing data is called the streaming mode since the\nproducer produces a constant stream of data.</p>\n<h2 id=\"pulling\">Pulling</h2>\n<p>Pads that operate in pulling mode can only pull data from a pad that\nexposes the <code>pull_range()</code> function. In this case, the sink pad exposes a\nloop function that will be called repeatedly until the task is stopped.</p>\n<p>After pulling data from the peer pad, the loop function will typically\ncall the push function to push the result to the peer sinkpad.</p>\n<h2 id=\"deciding-the-scheduling-mode\">Deciding the scheduling mode</h2>\n<p>When a pad is activated, the <code>_activate()</code> function is called. The pad\ncan then choose to activate itself in push or pull mode depending on\nupstream capabilities.</p>\n<p>The GStreamer core will by default activate pads in push mode when there\nis no activate function for the pad.</p>\n<h2 id=\"the-chain-function\">The chain function</h2>\n<p>The chain function will be called when a upstream element performs a\n<code>_push()</code> on the pad. The upstream element can be another chain based\nelement or a pushing source.</p>\n<h2 id=\"the-getrange-function\">The getrange function</h2>\n<p>The getrange function is called when a peer pad performs a\n<code>_pull_range()</code> on the pad. This downstream pad can be a pulling element\nor another <code>_pull_range()</code> based element.</p>\n<h2 id=\"scheduling-query\">Scheduling Query</h2>\n<p>A sinkpad can ask the upstream srcpad for its scheduling attributes. It\ndoes this with the <code>SCHEDULING</code> query.</p>\n<ul>\n<li>\n<p>(out) <strong><code>modes</code></strong>: <code>G_TYPE_ARRAY</code> (default NULL): an array of <code>GST_TYPE_PAD_MODE</code> enums. Contains all the supported scheduling modes.</p>\n</li>\n<li>\n<p>(out) <strong><code>flags</code></strong>, <code>GST_TYPE_SCHEDULING_FLAGS</code> (default 0):</p>\n</li>\n</ul>\n<pre><code class=\"language-c\">typedef enum {\n  GST_SCHEDULING_FLAG_SEEKABLE           = (1 &lt;&lt; 0),\n  GST_SCHEDULING_FLAG_SEQUENTIAL         = (1 &lt;&lt; 1),\n  GST_SCHEDULING_FLAG_BANDWIDTH_LIMITED  = (1 &lt;&lt; 2)\n} GstSchedulingFlags;\n</code></pre>\n<ul>\n<li>\n<ul>\n<li>\n<p><strong><code>_SEEKABLE</code></strong>: the offset of a pull operation can be specified, if this\nflag is false, the offset should be -1.</p>\n</li>\n<li>\n<p><strong><code>_SEQUENTIAL</code></strong>: suggest sequential access to the data. If <code>_SEEKABLE</code>\nis specified, seeks are allowed but should be avoided. This is common for\nnetwork streams.</p>\n</li>\n<li>\n<p><strong><code>_BANDWIDTH_LIMITED</code></strong>: suggest the element supports buffering data for\ndownstream to cope with bandwidth limitations. If this flag is on, the\ndownstream element might ask for more data than necessary for normal\nplayback. This use-case is interesting for on-disk buffering scenarios for\ninstance. Seek operations might be slow as well so downstream elements\nshould take this into consideration.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>(out) <strong><code>minsize</code></strong>: <code>G_TYPE_INT</code> (default 1): the suggested minimum size of pull requests</p>\n</li>\n<li>\n<p>(out) <strong><code>maxsize</code></strong>: <code>G_TYPE_INT</code> (default -1, unlimited): the suggested maximum size of pull requests</p>\n</li>\n<li>\n<p>(out) <strong><code>align</code></strong>: <code>G_TYPE_INT</code> (default 0): the suggested alignment for the pull requests.</p>\n</li>\n</ul>\n<h2 id=\"plugin-techniques\">Plug-in techniques</h2>\n<h3 id=\"multisink-elements\">Multi-sink elements</h3>\n<p>Elements with multiple sinks can either expose a loop function on each\nof the pads to actively <code>pull_range</code> data or they can expose a chain\nfunction on each pad.</p>\n<p>Implementing a chain function is usually easy and allows for all\npossible scheduling methods.</p>\n<h1 id=\"pad-select\">Pad select</h1>\n<p>If the chain based sink wants to wait for one of the pads to receive a buffer, just\nimplement the action to perform in the chain function. Be aware that the action could\nbe performed in different threads and possibly simultaneously so grab the <code>STREAM_LOCK</code>.</p>\n<h1 id=\"collect-pads\">Collect pads</h1>\n<p>If the chain based sink pads all require one buffer before the element can operate on\nthe data, collect all the buffers in the chain function and perform the action when\nall chainpads received the buffer.</p>\n<p>In this case you probably also don't want to accept more data on a pad that has a buffer\nqueued. This can easily be done with the following code snippet:</p>\n<pre><code class=\"language-c\">static GstFlowReturn _chain (GstPad *pad, GstBuffer *buffer)\n{\n  LOCK (mylock);\n  while (pad-&gt;store != NULL) {\n    WAIT (mycond, mylock);\n  }\n  pad-&gt;store = buffer;\n  SIGNAL (mycond);\n  UNLOCK (mylock);\n\n  return GST_FLOW_OK;\n}\n\nstatic void _pull (GstPad *pad, GstBuffer **buffer)\n{\n  LOCK (mylock);\n  while (pad-&gt;store == NULL) {\n    WAIT (mycond, mylock);\n  }\n  **buffer = pad-&gt;store;\n  pad-&gt;store = NULL;\n  SIGNAL (mycond);\n  UNLOCK (mylock);\n}\n</code></pre>\n<h2 id=\"cases\">Cases</h2>\n<p>Inside the braces below the pads is stated what function the pad\nsupport:</p>\n<ul>\n<li>l: exposes a loop function, so it can act as a pushing source.</li>\n<li>g: exposes a getrange function</li>\n<li>c: exposes a chain function</li>\n</ul>\n<p>Following scheduling decisions are made based on the scheduling methods exposed\nby the pads:</p>\n<ul>\n<li>\n<p>(g) - (l): sinkpad will pull data from src</p>\n</li>\n<li>\n<p>(l) - (c): srcpad actively pushes data to sinkpad</p>\n</li>\n<li>\n<p>()  - (c): srcpad will push data to sinkpad.</p>\n</li>\n<li>\n<p>()  - () : not schedulable.</p>\n</li>\n<li>\n<p>()  - (l): not schedulable.</p>\n</li>\n<li>\n<p>(g) - () : not schedulable.</p>\n</li>\n<li>\n<p>(g) - (c): not schedulable.</p>\n</li>\n<li>\n<p>(l) - () : not schedulable.</p>\n</li>\n<li>\n<p>(l) - (l): not schedulable</p>\n</li>\n<li>\n<p>()  - (g): impossible</p>\n</li>\n<li>\n<p>(g) - (g): impossible.</p>\n</li>\n<li>\n<p>(l) - (g): impossible</p>\n</li>\n<li>\n<p>(c) - () : impossible</p>\n</li>\n<li>\n<p>(c) - (g): impossible</p>\n</li>\n<li>\n<p>(c) - (l): impossible</p>\n</li>\n<li>\n<p>(c) - (c): impossible</p>\n</li>\n</ul>\n<pre><code>+---------+    +------------+    +-----------+\n| filesrc |    | mp3decoder |    | audiosink |\n|        src--sink         src--sink         |\n+---------+    +------------+    +-----------+\n        (l-g) (c)           ()   (c)\n</code></pre>\n<p>When activating the pads:</p>\n<ul>\n<li>\n<p>audiosink has a chain function and the peer pad has no loop\nfunction, no scheduling is done.</p>\n</li>\n<li>\n<p>mp3decoder and filesrc expose an (l) - (c) connection, a thread is\ncreated to call the srcpad loop function.</p>\n</li>\n</ul>\n<pre><code>+---------+    +------------+    +----------+\n| filesrc |    | avidemuxer |    | fakesink |\n|        src--sink         src--sink        |\n+---------+    +------------+    +----------+\n        (l-g) (l)          ()   (c)\n</code></pre>\n<ul>\n<li>\n<p>fakesink has a chain function and the peer pad has no loop function,\nno scheduling is done.</p>\n</li>\n<li>\n<p>avidemuxer and filesrc expose an (g) - (l) connection, a thread is\ncreated to call the sinkpad loop function.</p>\n</li>\n</ul>\n<pre><code>+---------+    +----------+    +------------+    +----------+\n| filesrc |    | identity |    | avidemuxer |    | fakesink |\n|        src--sink       src--sink         src--sink        |\n+---------+    +----------+    +------------+    +----------+\n        (l-g) (c)        ()   (l)          ()   (c)\n</code></pre>\n<ul>\n<li>\n<p>fakesink has a chain function and the peer pad has no loop function,\nno scheduling is done.</p>\n</li>\n<li>\n<p>avidemuxer and identity expose no schedulable connection so this\npipeline is not schedulable.</p>\n</li>\n</ul>\n<pre><code>+---------+    +----------+    +------------+    +----------+\n| filesrc |    | identity |    | avidemuxer |    | fakesink |\n|        src--sink       src--sink         src--sink        |\n+---------+    +----------+    +------------+    +----------+\n        (l-g) (c-l)      (g)  (l)          ()   (c)\n</code></pre>\n<ul>\n<li>\n<p>fakesink has a chain function and the peer pad has no loop function,\nno scheduling is done.</p>\n</li>\n<li>\n<p>avidemuxer and identity expose an (g) - (l) connection, a thread is\ncreated to call the sinkpad loop function.</p>\n</li>\n<li>\n<p>identity knows the srcpad is getrange based and uses the thread from\navidemux to getrange data from filesrc.</p>\n</li>\n</ul>\n<pre><code>+---------+    +----------+    +------------+    +----------+\n| filesrc |    | identity |    | oggdemuxer |    | fakesink |\n|        src--sink       src--sink         src--sink        |\n+---------+    +----------+    +------------+    +----------+\n        (l-g) (c)        ()   (l-c)        ()   (c)\n</code></pre>\n<ul>\n<li>\n<p>fakesink has a chain function and the peer pad has no loop function,\nno scheduling is done.</p>\n</li>\n<li>\n<p>oggdemuxer and identity expose an () - (l-c) connection, oggdemux\nhas to operate in chain mode.</p>\n</li>\n<li>\n<p>identity chan only work chain based and so filesrc creates a thread\nto push data to it.</p>\n</li>\n</ul>\n\n</div>\n\n\n\t"});