fragment_downloaded_cb({"url": "GStreamer-doc-1.0/design/sparsestreams.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"sparsestreams.md\">\n<h1 id=\"draft-sparse-streams\">DRAFT Sparse Streams</h1>\n<h2 id=\"introduction\">Introduction</h2>\n<p>In 0.8, there was some support for sparse streams through the use of\n<code>FILLER</code> events. These were used to mark gaps between buffers so that\ndownstream elements could know not to expect any more data for that gap.</p>\n<p>In 0.10, segment information conveyed through <code>SEGMENT</code> events can be used\nfor the same purpose.</p>\n<p>In 1.0, there is a <code>GAP</code> event that works in a similar fashion as the\n<code>FILLER</code> event in 0.8.</p>\n<h2 id=\"use-cases\">Use cases</h2>\n<h3 id=\"subtitle-streams\">Sub-title streams</h3>\n<p>Sub-title information from muxed formats such as\nMatroska or MPEG consist of irregular buffers spaced far apart compared\nto the other streams (audio and video). Since these usually only appear\nwhen someone speaks or some other action in the video/audio needs\ndescribing, they can be anywhere from 1-2 seconds to several minutes\napart. Downstream elements that want to mix sub-titles and video (and muxers)\nhave no way of knowing whether to process a video packet or wait a moment\nfor a corresponding sub-title to be delivered on another pad.</p>\n<h3 id=\"still-framedvd-menues\">Still frame/DVD menues</h3>\n<p>In DVDs and other formats, there are still-frame regions where the current\nvideo frame should be retained and no audio played for a period. In DVD,\nthese are described either as a fixed duration, or infinite duration still\nframe.</p>\n<h3 id=\"avoiding-processing-silence-from-audio-generators\">Avoiding processing silence from audio generators</h3>\n<p>Imagine a source that, from time to time, produces empty buffers (silence or\nblank images). If the pipeline has many elements next, it is better to\noptimise the absolute data processing in this case. Examples for such sources\nare sound-generators (simsyn in gst-buzztard) or a source in a voip\napplication that uses noise-gating (to save bandwith).</p>\n<h2 id=\"details\">Details</h2>\n<h3 id=\"subtitle-streams1\">Sub-title streams</h3>\n<p>The main requirement here is to avoid stalling the\npipeline between sub-title packets, and is effectively updating the\nminimum-timestamp for that\nstream.</p>\n<p>A demuxer can do this by sending an 'update' SEGMENT with a new start time\nto the subtitle pad. For example, every time the SCR in MPEG data\nadvances more than 0.5 seconds, the MPEG demuxer can issue a SEGMENT with\n(update=TRUE, start=SCR ). Downstream elements can then be aware not to\nexpect any data older than the new start time.</p>\n<p>The same holds true for any element that knows the current position in the\nstream - once the element knows that there is no more data to be presented\nuntil time 'n' it can advance the start time of the current segment to 'n'.</p>\n<p>This technique can also be used, for example, to represent a stream of\nMIDI events spaced to a clock period. When there is no event present for\na clock time, a SEGMENT update can be sent in its place.</p>\n<h3 id=\"still-framemenu-support\">Still frame/menu support</h3>\n<p>Still frames in DVD menus are different because they do not introduce a gap\nin the data timestamps. Instead, they represent a pause in the presentation\nof a stream. Correctly performing the wait requires some synchronisation with\ndownstream elements.</p>\n<p>In this scenario, an upstream element that wants to execute a still frame\nperforms the following steps:</p>\n<ul>\n<li>\n<p>Send all data before the still frame wait</p>\n</li>\n<li>\n<p>Send a <code>DRAIN</code> event to ensure that all data has been played\ndownstream.</p>\n</li>\n<li>\n<p>wait on the clock for the required duration, possibly interrupting\nif necessary due to an intervening activity (such as a user\nnavigation)</p>\n</li>\n<li>\n<p>FLUSH the pipeline using a normal flush sequence (<code>FLUSH_START</code>,\nchain-lock, <code>FLUSH_STOP</code>)</p>\n</li>\n<li>\n<p>Send a SEGMENT to restart playback with the next timestamp in the\nstream.</p>\n</li>\n</ul>\n<p>The upstream element performing the wait must only do so when in the <code>PLAYING</code>\nstate. During <code>PAUSED</code>, the clock will not be running, and may not even have\nbeen distributed to the element yet.</p>\n<p><code>DRAIN</code> is a new event that will block on a src pad until all data downstream\nhas been played out.</p>\n<p>Flushing after completing the still wait is to ensure that data after the wait\nis played correctly. Without it, sinks will consider the first buffers\n(x seconds, where x is the duration of the wait that occurred) to be\narriving late at the sink, and they will be discarded instead of played.</p>\n<h3 id=\"for-audio\">For audio</h3>\n<p>It is the same case as the first one - there is a <em>gap</em> in the audio\ndata that needs to be presented, and this can be done by sending a\nSEGMENT update that moves the start time of the segment to the next\ntimestamp when data will be sent.</p>\n<p>For video, however, it is slightly different. Video frames are typically\ntreated at the moment as continuing to be displayed after their indicated\nduration if no new frame arrives. Here, it is desired to display a blank\nframe instead, in which case at least one blank frame should be sent before\nupdating the start time of the segment.</p>\n\n</div>\n\n\n\t"});