fragment_downloaded_cb({"url": "GStreamer-doc-1.0/design/draft-tagreading.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"draft-tagreading.md\">\n<h1 id=\"tagreading\">Tagreading</h1>\n<p>The tagreading (metadata reading) use case for mediacenter applications\nis not too well supported by the current GStreamer architecture. It uses\ndemuxers on the files, which generally said takes too long (building\nseek-index, prerolling). What we want is specialized elements / parsing\nmodes that just do the tag-reading.</p>\n<p>The idea is to define a TagReadIFace. Tag-demuxers, classic demuxers and\ndecoder plugins can just implement the interface or provide a separate\nelement that implements the interface.</p>\n<p>In addition we need a tagreadbin, that similar to decodebin does a\ntypefind and then plugs the right tagread element(s). If will only look\nat elements that implement the interface. It can plug serval if\npossible.</p>\n<p>For optimal performance typefind and tagread could share the list of\nalready peeked buffers (a queue element after sink, but that would\nchange pull to push).</p>\n<h2 id=\"design\">Design</h2>\n<p>The plan is that applications can do the following: pipeline = \"filesrc\n! tagbin\" for (file_path in list_of_files) {\nfilesrc.location=file_path pipeline.set_state(PAUSED) // wait for TAGS\n&amp; EOS pipeline.set_state(READY) }</p>\n<ul>\n<li>\n<p>it should have one sinkpad of type ANY</p>\n</li>\n<li>\n<p>it should send EOS when all metadata has been read \"done\"-signal\nfrom all tagread-elements</p>\n</li>\n<li>\n<p>special tagread-elements should have RANK_NONE to be not\nautoplugged by decodebin</p>\n</li>\n</ul>\n<h2 id=\"interface\">Interface</h2>\n<ul>\n<li>\n<p>gboolean iface property \"tag-reading\" Switches the element to\ntagreading mode. Needed if normal element implement that behaviour.\nElements will skip parsing unneeded data, don\u2019t build a seeking\nindex, etc.</p>\n</li>\n<li>\n<p>signal \"done\" Equivalent of EOS.</p>\n</li>\n</ul>\n<h2 id=\"use-cases\">Use Cases</h2>\n<ul>\n<li>\n<p>mp3 with id3- and apetags</p>\n</li>\n<li>\n<p>plug id3demux ! apedemux</p>\n</li>\n<li>\n<p>avi with vorbis audio</p>\n</li>\n<li>\n<p>plug avidemux</p>\n</li>\n<li>\n<p>new pad \u2192 audio/vorbis</p>\n</li>\n<li>\n<p>plug vorbisdec or special vorbiscomment reader</p>\n</li>\n</ul>\n<h2 id=\"additional-thoughts\">Additional Thoughts</h2>\n<ul>\n<li>\n<p>would it make sense to have 2-phase tag-reading (property on tagbin\nand/or tagread elements)</p>\n</li>\n<li>\n<p>1st phase: get tag-data that are directly embedded in the data</p>\n</li>\n<li>\n<p>2nd phase: get tag-data that has to be generated</p>\n</li>\n<li>\n<p>e.g. album-art via web, video-thumbnails</p>\n</li>\n<li>\n<p>what about caching backends</p>\n</li>\n<li>\n<p>it would be good to allow applications to supply tagbin with a\ntagcache- object instance. Whenever tagbin gets a <em>location</em> to\ntagread, it consults the cache first. whenever there is a cache-miss\nit will tag-read and then store in the\ncache</p>\n</li>\n</ul>\n<pre><code class=\"language-c\">    GstTagList *gst_tag_cache_load_tag_data (GstTagCache *self, const gchar *uri);\n    gst_tag_cache_store_tag_data (GstTagCache *self, const gchar *uri, GstTagList *tags);\n</code></pre>\n<h2 id=\"tests\">Tests</h2>\n<ul>\n<li>write a generic test for parsers/demuxers to ensure they send tags\nuntil they reached PAUSED (elements need to parse file for\nprerolling anyway): set pipeline to paused, check for tags, set to\nplaying, error out if tags come after paused</li>\n</ul>\n<h2 id=\"code-locations\">Code Locations</h2>\n<ul>\n<li>\n<p>tagreadbin \u2192 gst-plugins-base/gst/tagread</p>\n</li>\n<li>\n<p>tagreaderiface \u2192 gst-plugins-base/gst-libs/gst/tag</p>\n</li>\n</ul>\n<h2 id=\"reuse\">Reuse</h2>\n<ul>\n<li>\n<p>ogg : gst-plugins-base/ext/ogg</p>\n</li>\n<li>\n<p>avi : gst-plugins-good/gst/avi</p>\n</li>\n<li>\n<p>mp3 : gst-plugins-good/gst/id3demux</p>\n</li>\n<li>\n<p>wav : gst-plugins-good/gst/wavparse</p>\n</li>\n<li>\n<p>qt : gst-plugins-bad/gst/qtdemux</p>\n</li>\n</ul>\n\n</div>\n\n\n\t"});