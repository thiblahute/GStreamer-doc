fragment_downloaded_cb({"url": "GStreamer-doc-1.0/design/bufferpool.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"bufferpool.md\">\n<h1 id=\"bufferpool\">Bufferpool</h1>\n<p>This document details the design of how buffers are allocated and\nmanaged in pools.</p>\n<p>Bufferpools increase performance by reducing allocation overhead and\nimproving possibilities to implement zero-copy memory transfer.</p>\n<p>Together with the ALLOCATION query, elements can negotiate allocation\nproperties and bufferpools between themselves. This also allows elements\nto negotiate buffer metadata between themselves.</p>\n<h2 id=\"requirements\">Requirements</h2>\n<ul>\n<li>\n<p>Provide a <code>GstBufferPool</code> base class to help the efficient\nimplementation of a list of reusable <code>GstBuffer</code> objects.</p>\n</li>\n<li>\n<p>Let upstream elements initiate the negotiation of a bufferpool and\nits configuration. Allow downstream elements provide bufferpool\nproperties and/or a bufferpool. This includes the following\nproperties:</p>\n<ul>\n<li>\n<p>have minimum and maximum amount of buffers with the option of\npreallocating buffers.</p>\n</li>\n<li>\n<p>allocator, alignment and padding support</p>\n</li>\n<li>\n<p>buffer metadata</p>\n</li>\n<li>\n<p>arbitrary extra options</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Integrate with dynamic caps renegotiation.</p>\n</li>\n<li>\n<p>Notify upstream element of new bufferpool availability. This is\nimportant when a new element, that can provide a bufferpool, is\ndynamically linked downstream.</p>\n</li>\n</ul>\n<h2 id=\"gstbufferpool\">GstBufferPool</h2>\n<p>The bufferpool object manages a list of buffers with the same properties such\nas size, padding and alignment.</p>\n<p>The bufferpool has two states: active and inactive. In the inactive\nstate, the bufferpool can be configured with the required allocation\npreferences. In the active state, buffers can be retrieved from and\nreturned to the pool.</p>\n<p>The default implementation of the bufferpool is able to allocate buffers\nfrom any allocator with arbitrary alignment and padding/prefix.</p>\n<p>Custom implementations of the bufferpool can override the allocation and\nfree algorithms of the buffers from the pool. This should allow for\ndifferent allocation strategies such as using shared memory or hardware\nmapped memory.</p>\n<h2 id=\"negotiation\">Negotiation</h2>\n<p>After a particular media format has been negotiated between two pads (using the\nCAPS event), they must agree on how to allocate buffers.</p>\n<p>The srcpad will always take the initiative to negotiate the allocation\nproperties. It starts with creating a <code>GST_QUERY_ALLOCATION</code> with the negotiated\ncaps.</p>\n<p>The srcpad can set the need-pool flag to TRUE in the query to optionally make\nthe peer pad allocate a bufferpool. It should only do this if it is able to use\nthe peer provided bufferpool.</p>\n<p>It will then inspect the returned results and configure the returned pool or\ncreate a new pool with the returned properties when needed.</p>\n<p>Buffers are then allocated by the srcpad from the negotiated pool and pushed to\nthe peer pad as usual.</p>\n<p>The allocation query can also return an allocator object when the buffers are\nof different sizes and can't be allocated from a pool.</p>\n<h2 id=\"allocation-query\">Allocation query</h2>\n<p>The allocation query has the following fields:</p>\n<ul>\n<li>\n<p>(in) <strong><code>caps</code></strong>, <code>GST_TYPE_CAPS</code>: the caps that was negotiated</p>\n</li>\n<li>\n<p>(in) <strong><code>need-pool</code></strong>, <code>G_TYPE_BOOLEAN</code>: if a <code>GstBufferPool</code> is requested</p>\n</li>\n<li>\n<p>(out) <strong><code>pool</code></strong>, <code>G_TYPE_ARRAY</code> of structure: an array of pool configurations:</p>\n</li>\n</ul>\n<pre><code class=\"language-c\">    struct {\n      GstBufferPool *pool;\n      guint          size;\n      guint          min_buffers;\n      guint          max_buffers;\n    }\n</code></pre>\n<p>Use <code>gst_query_parse_nth_allocation_pool()</code> to get the values.</p>\n<p>The allocator can contain multiple pool configurations. If need-pool\nwas TRUE, the pool member might contain a <code>GstBufferPool</code> when the\ndownstream element can provide one.</p>\n<p>Size contains the size of the bufferpool's buffers and is never 0.</p>\n<p><code>min_buffers</code> and <code>max_buffers</code> contain the suggested min and max amount of\nbuffers that should be managed by the pool.</p>\n<p>The upstream element can choose to use the provided pool or make its own\npool when none was provided or when the suggested pool was not\nacceptable.</p>\n<p>The pool can then be configured with the suggested min and max amount of\nbuffers or a downstream element might choose different values.</p>\n<ul>\n<li>(out) <strong><code>allocator</code></strong>, <code>G_TYPE_ARRAY</code> of structure: an array of allocator\nparameters that can be used.</li>\n</ul>\n<pre><code class=\"language-c\">    struct {\n      GstAllocator *allocator;\n      GstAllocationParams params;\n    }\n</code></pre>\n<p>Use <code>gst_query_parse_nth_allocation_param()</code> to get the values.</p>\n<p>The element performing the query can use the allocators and its\nparameters to allocate memory for the downstream element.</p>\n<p>It is also possible to configure the allocator in a provided pool.</p>\n<ul>\n<li>(out) <strong><code>metadata</code></strong>, <code>G_TYPE_ARRAY</code> of structure: an array of metadata\nparams that can be accepted.</li>\n</ul>\n<pre><code class=\"language-c\">    struct {\n      GType api;\n      GstStructure *params;\n    }\n</code></pre>\n<p>Use <code>gst_query_parse_nth_allocation_meta()</code> to get the values.</p>\n<p>These metadata items can be accepted by the downstream element when\nplaced on buffers. There is also an arbitrary <code>GstStructure</code> associated\nwith the metadata that contains metadata-specific options.</p>\n<p>Some bufferpools have options to enable metadata on the buffers\nallocated by the pool.</p>\n<h2 id=\"allocating-from-pool\">Allocating from pool</h2>\n<p>Buffers are allocated from the pool of a pad:</p>\n<pre><code class=\"language-c\">res = gst_buffer_pool_acquire_buffer (pool, &amp;buffer, &amp;params);\n</code></pre>\n<p>A <code>GstBuffer</code> that is allocated from the pool will always be writable (have a\nrefcount of 1) and it will also have its pool member point to the\n<code>GstBufferPool</code> that created the buffer.</p>\n<p>Buffers are refcounted in the usual way. When the refcount of the buffer\nreaches 0, the buffer is automatically returned to the pool.</p>\n<p>Since all the buffers allocated from the pool keep a reference to the pool,\nwhen nothing else is holding a refcount to the pool, it will be finalized\nwhen all the buffers from the pool are unreffed. By setting the pool to\nthe inactive state we can drain all buffers from the pool.</p>\n<p>When the pool is in the inactive state, <code>gst_buffer_pool_acquire_buffer()</code> will\nreturn <code>GST_FLOW_FLUSHING</code> immediately.</p>\n<p>Extra parameters can be given to the <code>gst_buffer_pool_acquire_buffer()</code> method\nto influence the allocation decision. <code>GST_BUFFER_POOL_ACQUIRE_FLAG_KEY_UNIT</code>\nand <code>GST_BUFFER_POOL_ACQUIRE_FLAG_DISCONT</code> serve as hints.</p>\n<p>When the bufferpool is configured with a maximum number of buffers, allocation\nwill block when all buffers are outstanding until a buffer is returned to the\npool. This behaviour can be changed by specifying the\n<code>GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT</code> flag in the parameters. With this flag\nset, allocation will return <code>GST_FLOW_EOS</code> when the pool is empty.</p>\n<h2 id=\"renegotiation\">Renegotiation</h2>\n<p>Renegotiation of the bufferpool might need to be performed when the\nconfiguration of the pool changes. Changes can be in the buffer size\n(because of a caps change), alignment or number of buffers.</p>\n<h3 id=\"downstream\">Downstream</h3>\n<p>When the upstream element wants to negotiate a new format, it might need\nto renegotiate a new bufferpool configuration with the downstream element.\nThis can, for example, happen when the buffer size changes.</p>\n<p>We can not just reconfigure the existing bufferpool because there might\nstill be outstanding buffers from the pool in the pipeline. Therefore we\nneed to create a new bufferpool for the new configuration while we let the\nold pool drain.</p>\n<p>Implementations can choose to reuse the same bufferpool object and wait for\nthe drain to finish before reconfiguring the pool.</p>\n<p>The element that wants to renegotiate a new bufferpool uses exactly the same\nalgorithm as when it first started. It will negotiate caps first then use the\nALLOCATION query to get and configure the new pool.</p>\n<h3 id=\"upstream\">Upstream</h3>\n<p>When a downstream element wants to negotiate a new format, it will send a\nRECONFIGURE event upstream. This instructs upstream to renegotiate both\nthe format and the bufferpool when needed.</p>\n<p>A pipeline reconfiguration happens when new elements are added or removed from\nthe pipeline or when the topology of the pipeline changes. Pipeline\nreconfiguration also triggers possible renegotiation of the bufferpool and\ncaps.</p>\n<p>A RECONFIGURE event tags each pad it travels on as needing reconfiguration.\nThe next buffer allocation will then require the renegotiation or\nreconfiguration of a pool.</p>\n<h2 id=\"shutting-down\">Shutting down</h2>\n<p>In push mode, a source pad is responsible for setting the pool to the\ninactive state when streaming stops. The inactive state will unblock any pending\nallocations so that the element can shut down.</p>\n<p>In pull mode, the sink element should set the pool to the inactive state when\nshutting down so that the peer <code>_get_range()</code> function can unblock.</p>\n<p>In the inactive state, all the buffers that are returned to the pool will\nautomatically be freed by the pool and new allocations will fail.</p>\n<h2 id=\"use-cases\">Use cases</h2>\n<h3 id=\"videotestsrc-xvimagesink\"><code>videotestsrc ! xvimagesink</code></h3>\n<ul>\n<li>\n<p>Before videotestsrc can output a buffer, it needs to negotiate caps and\na bufferpool with the downstream peer pad.</p>\n</li>\n<li>\n<p>First it will negotiate a suitable format with downstream according to the\nnormal rules. It will send a <code>CAPS</code> event downstream with the negotiated\nconfiguration.</p>\n</li>\n<li>\n<p>Then it does an <code>ALLOCATION</code> query. It will use the returned bufferpool or\nconfigures its own bufferpool with the returned parameters. The bufferpool is\ninitially in the inactive state.</p>\n</li>\n<li>\n<p>The <code>ALLOCATION</code> query lists the desired configuration of the downstream\nxvimagesink, which can have specific alignment and/or min/max amount of\nbuffers.</p>\n</li>\n<li>\n<p>videotestsrc updates the configuration of the bufferpool, it will likely set\nthe min buffers to 1 and the size of the desired buffers. It then updates the\nbufferpool configuration with the new properties.</p>\n</li>\n<li>\n<p>When the configuration is successfully updated, videotestsrc sets the\nbufferpool to the active state. This preallocates the buffers in the pool (if\nneeded). This operation can fail when there is not enough memory available.\nSince the bufferpool is provided by xvimagesink, it will allocate buffers\nbacked by an XvImage and pointing to shared memory with the X server.</p>\n</li>\n<li>\n<p>If the bufferpool is successfully activated, videotestsrc can acquire\na buffer from the pool, fill in the data and push it out to xvimagesink.</p>\n</li>\n<li>\n<p>xvimagesink can know that the buffer originated from its pool by following\nthe pool member.</p>\n</li>\n<li>\n<p>when shutting down, videotestsrc will set the pool to the inactive state,\nthis will cause further allocations to fail and currently allocated buffers to\nbe freed. videotestsrc will then free the pool and stop streaming.</p>\n</li>\n</ul>\n<h3 id=\"videotestsrc-queue-myvideosink\"><code>videotestsrc ! queue ! myvideosink</code></h3>\n<ul>\n<li>\n<p>In this second use case we have a videosink that can at most allocate 3 video\nbuffers.</p>\n</li>\n<li>\n<p>Again videotestsrc will have to negotiate a bufferpool with the peer element.\nFor this it will perform the <code>ALLOCATION</code> query which queue will proxy to its\ndownstream peer element.</p>\n</li>\n<li>\n<p>The bufferpool returned from myvideosink will have a <code>max_buffers</code> set to 3.\nqueue and videotestsrc can operate with this upper limit because none of those\nelements require more than that amount of buffers for temporary storage.</p>\n</li>\n<li>\n<p>Myvideosink's bufferpool will then be configured with the size of the buffers\nfor the negotiated format and according to the padding and alignment rules.\nWhen videotestsrc sets the pool to active, the 3 video buffers will be\npreallocated in the pool.</p>\n</li>\n<li>\n<p>videotestsrc acquires a buffer from the configured pool on its srcpad and\npushes this into the queue. When videotestsrc has acquired and pushed 3 frames,\nthe next call to <code>gst_buffer_pool_acquire_buffer()</code> will block (assuming the\n<code>GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT</code> is not specified).</p>\n</li>\n<li>\n<p>When the queue has pushed out a buffer and the sink has rendered it, the\nrefcount of the buffer reaches 0 and the buffer is recycled in the pool. This\nwill wake up the videotestsrc that was blocked, waiting for more buffers and\nwill make it produce the next buffer.</p>\n</li>\n<li>\n<p>In this setup, there are at most 3 buffers active in the pipeline and the\nvideotestsrc is rate limited by the rate at which buffers are recycled in the\nbufferpool.</p>\n</li>\n<li>\n<p>When shutting down, videotestsrc will first set the bufferpool on the srcpad\nto inactive. This causes any pending (blocked) acquire to return with\na FLUSHING result and causes the streaming thread to pause.</p>\n</li>\n</ul>\n<h3 id=\"-myvideodecoder-queue-fakesink\"><code>.. ! myvideodecoder ! queue ! fakesink</code></h3>\n<ul>\n<li>\n<p>In this case, the myvideodecoder requires buffers to be aligned to 128 bytes\nand padded with 4096 bytes. The pipeline starts out with the decoder linked to\na fakesink but we will then dynamically change the sink to one that can provide\na bufferpool.</p>\n</li>\n<li>\n<p>When myvideodecoder negotiates the size with the downstream fakesink element,\nit will receive a NULL bufferpool because fakesink does not provide\na bufferpool. It will then select its own custom bufferpool to start the data\ntransfer.</p>\n</li>\n<li>\n<p>At some point we block the queue srcpad, unlink the queue from the fakesink,\nlink a new sink and set the new sink to the PLAYING state. Linking the new sink\nwould automatically send a RECONFIGURE event upstream and, through queue,\ninform myvideodecoder that it should renegotiate its bufferpool because\ndownstream has been reconfigured.</p>\n</li>\n<li>\n<p>Before pushing the next buffer, myvideodecoder has to renegotiate a new\nbufferpool. To do this, it performs the usual bufferpool negotiation algorithm.\nIf it can obtain and configure a new bufferpool from downstream, it sets its\nown (old) pool to inactive and unrefs it. This will eventually drain and unref\nthe old bufferpool.</p>\n</li>\n<li>\n<p>The new bufferpool is set as the new bufferpool for the srcpad and sinkpad of\nthe queue and set to the active state.</p>\n</li>\n</ul>\n<h3 id=\"-myvideodecoder-queue-myvideosink\"><code>.. ! myvideodecoder ! queue ! myvideosink</code></h3>\n<ul>\n<li>\n<p>myvideodecoder has negotiated a bufferpool with the downstream myvideosink to\nhandle buffers of size 320x240. It has now detected a change in the video\nformat and needs to renegotiate to a resolution of 640x480. This requires it to\nnegotiate a new bufferpool with a larger buffer size.</p>\n</li>\n<li>\n<p>When myvideodecoder needs to get the bigger buffer, it starts the negotiation\nof a new bufferpool. It queries a bufferpool from downstream, reconfigures it\nwith the new configuration (which includes the bigger buffer size) and sets the\nbufferpool to active. The old pool is inactivated and unreffed, which causes\nthe old format to drain.</p>\n</li>\n<li>\n<p>It then uses the new bufferpool for allocating new buffers of the new\ndimension.</p>\n</li>\n<li>\n<p>If at some point, the decoder wants to switch to a lower resolution again, it\ncan choose to use the current pool (which has buffers that are larger than the\nrequired size) or it can choose to renegotiate a new bufferpool.</p>\n</li>\n</ul>\n<h3 id=\"-myvideodecoder-videoscale-myvideosink\"><code>.. ! myvideodecoder ! videoscale ! myvideosink</code></h3>\n<ul>\n<li>\n<p>myvideosink is providing a bufferpool for upstream elements and wants to\nchange the resolution.</p>\n</li>\n<li>\n<p>myvideosink sends a <code>RECONFIGURE</code> event upstream to notify upstream that a new\nformat is desirable. Upstream elements try to negotiate a new format and\nbufferpool before pushing out a new buffer. The old bufferpools are drained in\nthe regular way.</p>\n</li>\n</ul>\n\n</div>\n\n\n\t"});