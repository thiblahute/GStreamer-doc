fragment_downloaded_cb({"url": "GStreamer-doc-1.0/design/states.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"states.md\">\n<h1 id=\"states\">States</h1>\n<p>Both elements and pads can be in different states. The states of the\npads are linked to the state of the element so the design of the states\nis mainly focused around the element states.</p>\n<p>An element can be in 4 states. <code>NULL</code>, <code>READY</code>, <code>PAUSED</code> and <code>PLAYING</code>. When an\nelement is initially instantiated, it is in the NULL state.</p>\n<h2 id=\"state-definitions\">State definitions</h2>\n<ul>\n<li>\n<p><code>NULL</code>: This is the initial state of an element.</p>\n</li>\n<li>\n<p><code>READY</code>: The element should be prepared to go to <code>PAUSED</code>.</p>\n</li>\n<li>\n<p><code>PAUSED</code>: The element should be ready to accept and process data. Sink\nelements, however, only accept one buffer and then block.</p>\n</li>\n<li>\n<p><code>PLAYING</code>: The same as <code>PAUSED</code> except for live sources and sinks. Sinks\naccept and render data. Live sources produce data.</p>\n</li>\n</ul>\n<p>We call the sequence <code>NULL\u2192PLAYING</code> an upwards state change and\n<code>PLAYING\u2192NULL</code> a downwards state change.</p>\n<h2 id=\"state-transitions\">State transitions</h2>\n<p>the following state changes are possible:</p>\n<ul>\n<li>\n<p><code>NULL -&gt; READY</code>:</p>\n<ul>\n<li>The element must check if the resources it needs are available.\nDevice sinks and sources typically try to probe the device to constrain\ntheir caps.</li>\n<li>The element opens the device, this is needed if the previous step requires\nthe device to be opened.</li>\n</ul>\n</li>\n<li>\n<p><code>READY -&gt; PAUSED</code>:</p>\n<ul>\n<li>The element pads are activated in order to receive data in <code>PAUSED</code>.\nStreaming threads are started.</li>\n<li>Some elements might need to return <code>ASYNC</code> and complete the state change\nwhen they have enough information. It is a requirement for sinks to\nreturn <code>ASYNC</code> and complete the state change when they receive the first\nbuffer or EOS event (preroll). Sinks also block the dataflow when in <code>PAUSED</code>.</li>\n<li>A pipeline resets the <code>running_time</code> to 0.</li>\n<li>Live sources return <code>NO_PREROLL</code> and don't generate data.</li>\n</ul>\n</li>\n<li>\n<p><code>PAUSED -&gt; PLAYING</code>:</p>\n<ul>\n<li>Most elements ignore this state change.</li>\n<li>The pipeline selects a clock and distributes this to all the children\nbefore setting them to <code>PLAYING</code>. This means that it is only allowed to\nsynchronize on the clock in the <code>PLAYING</code> state.</li>\n<li>The pipeline uses the clock and the <code>running_time</code> to calculate the\n<code>base_time</code>. This <code>base_time</code> is distributed to all children when\nperforming the state change.</li>\n<li>Sink elements stop blocking on the preroll buffer or event and start\nrendering the data.</li>\n<li>Sinks can post the EOS message in the <code>PLAYING</code> state. It is not allowed to\npost EOS when not in the <code>PLAYING</code> state.</li>\n<li>While streaming in <code>PAUSED</code> or <code>PLAYING</code> elements can create and remove\nsometimes pads.</li>\n<li>Live sources start generating data and return <code>SUCCESS</code>.</li>\n</ul>\n</li>\n<li>\n<p><code>PLAYING -&gt; PAUSED</code>:</p>\n<ul>\n<li>Most elements ignore this state change.</li>\n<li>The pipeline calculates the <code>running_time</code> based on the last selected clock\nand the <code>base_time</code>. It stores this information to continue playback when\ngoing back to the <code>PLAYING</code> state.</li>\n<li>Sinks unblock any clock wait calls.</li>\n<li>When a sink does not have a pending buffer to play, it returns <code>ASYNC</code> from\nthis state change and completes the state change when it receives a new\nbuffer or an EOS event.</li>\n<li>Any queued EOS messages are removed since they will be reposted when going\nback to the <code>PLAYING</code> state. The EOS messages are queued in <code>GstBins</code>.</li>\n<li>Live sources stop generating data and return <code>NO_PREROLL</code>.</li>\n</ul>\n</li>\n<li>\n<p><code>PAUSED -&gt; READY</code>:</p>\n<ul>\n<li>Sinks unblock any waits in the preroll.</li>\n<li>Elements unblock any waits on devices</li>\n<li>Chain or <code>get_range()</code> functions return <code>FLUSHING</code>.</li>\n<li>The element pads are deactivated so that streaming becomes impossible and\nall streaming threads are stopped.</li>\n<li>The sink forgets all negotiated formats</li>\n<li>Elements remove all sometimes pads</li>\n</ul>\n</li>\n<li>\n<p><code>READY -&gt; NULL</code>:</p>\n<ul>\n<li>Elements close devices</li>\n<li>Elements reset any internal state.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"state-variables\">State variables</h2>\n<p>An element has 4 state variables that are protected with the object LOCK:</p>\n<ul>\n<li><code>STATE</code></li>\n<li><code>STATE_NEXT</code></li>\n<li><code>STATE_PENDING</code></li>\n<li><code>STATE_RETURN</code></li>\n</ul>\n<p>The <code>STATE</code> always reflects the current state of the element. The\n<code>STATE_NEXT</code> reflects the next state the element will go to. The\n<code>STATE_PENDING</code> always reflects the required state of the element. The\n<code>STATE_RETURN</code> reflects the last return value of a state change.</p>\n<p>The <code>STATE_NEXT</code> and <code>STATE_PENDING</code> can be <code>VOID_PENDING</code> if the element\nis in the right state.</p>\n<p>An element has a special lock to protect against concurrent invocations\nof <code>set_state()</code>, called the <code>STATE_LOCK</code>.</p>\n<h2 id=\"setting-state-on-elements\">Setting state on elements</h2>\n<p>The state of an element can be changed with <code>_element_set_state()</code>.\nWhen changing the state of an element all intermediate states will also\nbe set on the element until the final desired state is set.</p>\n<p>The <code>set_state()</code> function can return 3 possible values:</p>\n<ul>\n<li>\n<p><code>GST_STATE_FAILURE</code>: The state change failed for some reason. The plugin should have posted an error message on the bus with information.</p>\n</li>\n<li>\n<p><code>GST_STATE_SUCCESS</code>: The state change is completed successfully.</p>\n</li>\n<li>\n<p><code>GST_STATE_ASYNC</code>: The state change will complete later on. This can happen\nwhen the element needs a long time to perform the state change or for sinks\nthat need to receive the first buffer before they can complete the state change\n(preroll).</p>\n</li>\n<li>\n<p><code>GST_STATE_NO_PREROLL</code>: The state change is completed successfully but the\nelement will not be able to produce data in the <code>PAUSED</code> state.</p>\n</li>\n</ul>\n<p>In the case of an <code>ASYNC</code> state change, it is possible to proceed to the\nnext state before the current state change completes, however, the\nelement will only get to this next state before completing the previous\n<code>ASYNC</code> state change. After receiving an <code>ASYNC</code> return value, you can use\n<code>element_get_state()</code> to poll the status of the element. If the\npolling returns <code>SUCCESS</code>, the element completed the state change to the\nlast requested state with <code>set_state()</code>.</p>\n<p>When setting the state of an element, the <code>STATE_PENDING</code> is set to the\nrequired state. Then the state change function of the element is called\nand the result of that function is used to update the <code>STATE</code> and\n<code>STATE_RETURN</code> fields, <code>STATE_NEXT</code>, <code>STATE_PENDING</code> and <code>STATE_RETURN</code>\nfields. If the function returned <code>ASYNC</code>, this result is immediately\nreturned to the caller.</p>\n<h2 id=\"getting-the-state-of-elements\">Getting the state of elements</h2>\n<p>The <code>get_state()</code> function takes 3 arguments, two pointers that will\nhold the current and pending state and one <code>GstClockTime</code> that holds a\ntimeout value. The function returns a <code>GstElementStateReturn</code>.</p>\n<ul>\n<li>\n<p>If the element returned <code>SUCCESS</code> to the previous <code>_set_state()</code>\nfunction, this function will return the last state set on the\nelement and <code>VOID_PENDING</code> in the pending state value. The function\nreturns <code>GST_STATE_SUCCESS</code>.</p>\n</li>\n<li>\n<p>If the element returned <code>NO_PREROLL</code> to the previous <code>_set_state()</code>\nfunction, this function will return the last state set on the\nelement and <code>VOID_PENDING</code> in the pending state value. The function\nreturns <code>GST_STATE_NO_PREROLL</code>.</p>\n</li>\n<li>\n<p>If the element returned <code>FAILURE</code> to the previous <code>_set_state()</code> call,\nthis function will return <code>FAILURE</code> with the state set to the current\nstate of the element and the pending state set to the value used in\nthe last call of <code>_set_state()</code>.</p>\n</li>\n<li>\n<p>If the element returned <code>ASYNC</code> to the previous <code>_set_state()</code> call,\nthis function will wait for the element to complete its state change\nup to the amount of time specified in the <code>GstClockTime</code>.</p>\n<ul>\n<li>\n<p>If the element does not complete the state change in the\nspecified amount of time, this function will return <code>ASYNC</code> with\nthe state set to the current state and the pending state set to\nthe pending state.</p>\n</li>\n<li>\n<p>If the element completes the state change within the specified\ntimeout, this function returns the updated state and\n<code>VOID_PENDING</code> as the pending state.</p>\n</li>\n<li>\n<p>If the element aborts the <code>ASYNC</code> state change due to an error\nwithin the specified timeout, this function returns <code>FAILURE</code> with\nthe state set to last successful state and pending set to the\nlast attempt. The element should also post an error message on\nthe bus with more information about the problem.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"states-in-gstbin\">States in GstBin</h2>\n<p>A <code>GstBin</code> manages the state of its children. It does this by propagating\nthe state changes performed on it to all of its children. The\n<code>_set_state()</code> function on a bin will call the <code>_set_state()</code> function\non all of its children, that are not already in the target state or in a\nchange state to the target state.</p>\n<p>The children are iterated from the sink elements to the source elements.\nThis makes sure that when changing the state of an element, the\ndownstream elements are in the correct state to process the eventual\nbuffers. In the case of a downwards state change, the sink elements will\nshut down first which makes the upstream elements shut down as well\nsince the <code>_push()</code> function returns a <code>GST_FLOW_FLUSHING</code> error.</p>\n<p>If all the children return <code>SUCCESS</code>, the function returns <code>SUCCESS</code> as\nwell.</p>\n<p>If one of the children returns <code>FAILURE</code>, the function returns <code>FAILURE</code> as\nwell. In this state it is possible that some elements successfully\nchanged state. The application can check which elements have a changed\nstate, which were in error and which were not affected by iterating the\nelements and calling <code>_get_state()</code> on the elements.</p>\n<p>If after calling the state function on all children, one of the children\nreturned <code>ASYNC</code>, the function returns <code>ASYNC</code> as well.</p>\n<p>If after calling the state function on all children, one of the children\nreturned <code>NO_PREROLL</code>, the function returns <code>NO_PREROLL</code> as well.</p>\n<p>If both <code>NO_PREROLL</code> and <code>ASYNC</code> children are present, <code>NO_PREROLL</code> is\nreturned.</p>\n<p>The current state of the bin can be retrieved with <code>_get_state()</code>.</p>\n<p>If the bin is performing an <code>ASYNC</code> state change, it will automatically\nupdate its current state fields when it receives state messages from the\nchildren.</p>\n<h2 id=\"implementing-states-in-elements\">Implementing states in elements</h2>\n<h3 id=\"upward-state-change\">Upward state change</h3>\n<p>Upward state changes always return <code>ASYNC</code> either if the <code>STATE_PENDING</code> is\nreached or not.</p>\n<p>Element:</p>\n<ul>\n<li>\n<p>A -&gt; B =&gt; <code>SUCCESS</code></p>\n<ul>\n<li>commit state</li>\n</ul>\n</li>\n<li>\n<p>A -&gt; B =&gt; <code>ASYNC</code></p>\n<ul>\n<li>no commit state</li>\n<li>element commits state <code>ASYNC</code></li>\n</ul>\n</li>\n<li>\n<p>A -&gt; B while <code>ASYNC</code></p>\n<ul>\n<li>update <code>STATE_PENDING</code> state</li>\n<li>no commit state</li>\n<li>no <code>change_state()</code> called on element</li>\n</ul>\n</li>\n</ul>\n<p>Bin:</p>\n<ul>\n<li>\n<p>A-&gt;B: all elements <code>SUCCESS</code></p>\n<ul>\n<li>commit state</li>\n</ul>\n</li>\n<li>\n<p>A-&gt;B: some elements <code>ASYNC</code></p>\n<ul>\n<li>no commit state</li>\n<li>listen for commit messages on bus</li>\n<li>for each commit message, poll elements, this happens in another\nthread.</li>\n<li>if no <code>ASYNC</code> elements, commit state, continue state change\nto <code>STATE_PENDING</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"downward-state-change\">Downward state change</h3>\n<p>Downward state changes only return <code>ASYNC</code> if the final state is <code>ASYNC</code>.\nThis is to make sure that it\u2019s not needed to wait for an element to\ncomplete the preroll or other <code>ASYNC</code> state changes when one only wants to\nshut down an element.</p>\n<p>Element:</p>\n<p>A -&gt; B =&gt; <code>SUCCESS</code></p>\n<ul>\n<li>commit state</li>\n</ul>\n<p>A -&gt; B =&gt; <code>ASYNC</code> not final state</p>\n<ul>\n<li>commit state on behalf of element</li>\n</ul>\n<p>A -&gt; B =&gt; <code>ASYNC</code> final state</p>\n<ul>\n<li>element will commit <code>ASYNC</code></li>\n</ul>\n<p>Bin:</p>\n<p>A -&gt; B -&gt; <code>SUCCESS</code></p>\n<ul>\n<li>commit state</li>\n</ul>\n<p>A -&gt; B -&gt; <code>ASYNC</code> not final state</p>\n<ul>\n<li>commit state on behalf of element, continue state change</li>\n</ul>\n<p>A -&gt; B =&gt; <code>ASYNC</code> final state</p>\n<ul>\n<li>no commit state</li>\n<li>listen for commit messages on bus</li>\n<li>for each commit message, poll elements</li>\n<li>if no <code>ASYNC</code> elements, commit state</li>\n</ul>\n<h2 id=\"locking-overview-element\">Locking overview (element)</h2>\n<ul>\n<li>\n<p>Element committing <code>SUCCESS</code></p>\n<ul>\n<li>\n<p><code>STATE_LOCK</code> is taken in <code>set_state()</code></p>\n</li>\n<li>\n<p>change state is called if <code>SUCCESS</code>, commit state is called</p>\n</li>\n<li>\n<p>commit state calls <code>change_state()</code> to next state change.</p>\n</li>\n<li>\n<p>if final state is reached, stack unwinds and result is returned\nto <code>set_state()</code> and caller.</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>set_state(element)       change_state (element)   commit_state\n\n    |                         |                       |\n    |                         |                       |\nSTATE_LOCK                    |                       |\n    |                         |                       |\n    |------------------------&gt;|                       |\n    |                         |                       |\n    |                         |                       |\n    |                         | (do state change)     |\n    |                         |                       |\n    |                         |                       |\n    |                         | if `SUCCESS`            |\n    |                         |----------------------&gt;|\n    |                         |                       | post message\n    |                         |                       |\n    |                         |&lt;----------------------| if (!final) change_state (next)\n    |                         |                       | else SIGNAL\n    |                         |                       |\n    |                         |                       |\n    |                         |                       |\n    |&lt;------------------------|                       |\n    |     `SUCCESS`\n    |\nSTATE_UNLOCK\n    |\n  `SUCCESS`\n</code></pre>\n<ul>\n<li>\n<p>Element committing <code>ASYNC</code></p>\n<ul>\n<li>\n<p><code>STATE_LOCK</code> is taken in <code>set_state()</code></p>\n</li>\n<li>\n<p>change state is called and returns <code>ASYNC</code></p>\n</li>\n<li>\n<p><code>ASYNC</code> returned to the caller.</p>\n</li>\n<li>\n<p>element takes LOCK in streaming thread.</p>\n</li>\n<li>\n<p>element calls <code>commit_state</code> in streaming thread.</p>\n</li>\n<li>\n<p>commit state calls <code>change_state()</code> to next state\nchange.</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>set_state(element)       change_state (element)     stream_thread      commit_state (element)\n\n    |                         |                          |                  |\n    |                         |                          |                  |\nSTATE_LOCK                    |                          |                  |\n    |                         |                          |                  |\n    |------------------------&gt;|                          |                  |\n    |                         |                          |                  |\n    |                         |                          |                  |\n    |                         | (start_task)             |                  |\n    |                         |                          |                  |\n    |                         |                     STREAM_LOCK             |\n    |                         |                          |...               |\n    |&lt;------------------------|                          |                  |\n    |     ASYNC                                     STREAM_UNLOCK           |\nSTATE_UNLOCK                                             |                  |\n    |                .....sync........               STATE_LOCK             |\n  ASYNC                                                  |-----------------&gt;|\n                                                         |                  |\n                                                         |                  |---&gt; post_message()\n                                                         |                  |---&gt; if (!final) change_state (next)\n                                                         |                  |     else SIGNAL\n                                                         |&lt;-----------------|\n                                                     STATE_UNLOCK\n                                                         |\n                                                    STREAM_LOCK\n                                                         | ...\n                                                    STREAM_UNLOCK\n</code></pre>\n<h2 id=\"remarks\">Remarks</h2>\n<p><code>set_state()</code> cannot be called from multiple threads at the same time. The\n<code>STATE_LOCK</code> prevents this.</p>\n<p>State variables are protected with the LOCK.</p>\n<p>Calling <code>set_state()</code> while <code>get_state()</code> is called should unlock the\n<code>get_state()</code> with an error. The cookie will do that.</p>\n<pre><code class=\"language-c\">set_state(element)\n\nSTATE_LOCK\n\nLOCK\nupdate current, next, pending state\ncookie++\nUNLOCK\n\nchange_state\n\nSTATE_UNLOCK\n</code></pre>\n\n</div>\n\n\n\t"});