fragment_downloaded_cb({"url": "GStreamer-doc-1.0/application-development/basics/elements.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"elements.md\">\n<h1 id=\"elements\">Elements</h1>\n<p>The most important object in GStreamer for the application programmer is\nthe\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElement.html\"><code>GstElement</code></a>\nobject. An element is the basic building block for a media pipeline. All\nthe different high-level components you will use are derived from\n<code>GstElement</code>. Every decoder, encoder, demuxer, video or audio output is\nin fact a <code>GstElement</code></p>\n<h2 id=\"what-are-elements\">What are elements?</h2>\n<p>For the application programmer, elements are best visualized as black\nboxes. On the one end, you might put something in, the element does\nsomething with it and something else comes out at the other side. For a\ndecoder element, for example, you'd put in encoded data, and the element\nwould output decoded data. In the next chapter (see <a href=\"pads.html\">Pads and\ncapabilities</a>), you will learn more about data input\nand output in elements, and how you can set that up in your application.</p>\n<h3 id=\"source-elements\">Source elements</h3>\n<p>Source elements generate data for use by a pipeline, for example reading\nfrom disk or from a sound card. <a href=\"../../../#visualisation-of-a-source-element\">Visualisation of a source\nelement</a> shows how we will visualise\na source element. We always draw a source pad to the right of the\nelement.</p>\n<p><img src=\"images/src-element.png\" alt=\"Visualisation of a source element\" title=\"fig:\" id=\"visualisation-of-a-source-element\"></p>\n<p>Source elements do not accept data, they only generate data. You can see\nthis in the figure because it only has a source pad (on the right). A\nsource pad can only generate data.</p>\n<h3 id=\"filters-convertors-demuxers-muxers-and-codecs\">Filters, convertors, demuxers, muxers and codecs</h3>\n<p>Filters and filter-like elements have both input and outputs pads. They\noperate on data that they receive on their input (sink) pads, and will\nprovide data on their output (source) pads. Examples of such elements\nare a volume element (filter), a video scaler (convertor), an Ogg\ndemuxer or a Vorbis decoder.</p>\n<p>Filter-like elements can have any number of source or sink pads. A video\ndemuxer, for example, would have one sink pad and several (1-N) source\npads, one for each elementary stream contained in the container format.\nDecoders, on the other hand, will only have one source and sink pads.</p>\n<p><img src=\"images/filter-element.png\" alt=\"Visualisation of a filter element\" title=\"fig:\" id=\"visualisation-of-a-filter-element\"></p>\n<p><a href=\"../../../#visualisation-of-a-filter-element\">Visualisation of a filter element</a>\nshows how we will visualise a filter-like element. This specific element\nhas one source and one sink element. Sink pads, receiving input data,\nare depicted at the left of the element; source pads are still on the\nright.</p>\n<p><img src=\"images/filter-element-multi.png\" alt=\"Visualisation of a filter element with more than one output pad\" title=\"fig:\" id=\"visualisation-of-a-filter-element-with-more-than-one-output-pad\"></p>\n<p><a href=\"../../../#visualisation-of-a-filter-element-with----more-than-one-output-pad\">Visualisation of a filter element with more than one output\npad</a>\nshows another filter-like element, this one having more than one output\n(source) pad. An example of one such element could, for example, be an\nOgg demuxer for an Ogg stream containing both audio and video. One\nsource pad will contain the elementary video stream, another will\ncontain the elementary audio stream. Demuxers will generally fire\nsignals when a new pad is created. The application programmer can then\nhandle the new elementary stream in the signal handler.</p>\n<h3 id=\"sink-elements\">Sink elements</h3>\n<p>Sink elements are end points in a media pipeline. They accept data but\ndo not produce anything. Disk writing, soundcard playback, and video\noutput would all be implemented by sink elements. <a href=\"../../../#visualisation-of-a-sink-element\">Visualisation of a\nsink element</a> shows a sink element.</p>\n<p><img src=\"images/sink-element.png\" alt=\"Visualisation of a sink element\" title=\"fig:\" id=\"visualisation-of-a-sink-element\"></p>\n<h2 id=\"creating-a-gstelement\">Creating a <code>GstElement</code></h2>\n<p>The simplest way to create an element is to use\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElementFactory.html#gst-element-factory-make\"><code>gst_element_factory_make ()</code></a>.\nThis function takes a factory name and an element name for the newly\ncreated element. The name of the element is something you can use later\non to look up the element in a bin, for example. The name will also be\nused in debug output. You can pass <code>NULL</code> as the name argument to get a\nunique, default name.</p>\n<p>When you don't need the element anymore, you need to unref it using\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstObject.html#gst-object-unref\"><code>gst_object_unref ()</code></a>.\nThis decreases the reference count for the element by 1. An element has\na refcount of 1 when it gets created. An element gets destroyed\ncompletely when the refcount is decreased to 0.</p>\n<p>The following example [1] shows how to create an element named\n<em>source</em> from the element factory named <em>fakesrc</em>. It checks if the\ncreation succeeded. After checking, it unrefs the element.</p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\nint\nmain (int   argc,\n      char *argv[])\n{\n  GstElement *element;\n\n  /* init GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* create element */\n  element = gst_element_factory_make (\"fakesrc\", \"source\");\n  if (!element) {\n    g_print (\"Failed to create element of type 'fakesrc'\\n\");\n    return -1;\n  }\n\n  gst_object_unref (GST_OBJECT (element));\n\n  return 0;\n}\n\n</code></pre>\n<p><code>gst_element_factory_make</code> is actually a shorthand for a combination of\ntwo functions. A\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElement.html\"><code>GstElement</code></a>\nobject is created from a factory. To create the element, you have to get\naccess to a\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElementFactory.html\"><code>GstElementFactory</code></a>\nobject using a unique factory name. This is done with\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElementFactory.html#gst-element-factory-find\"><code>gst_element_factory_find ()</code></a>.</p>\n<p>The following code fragment is used to get a factory that can be used to\ncreate the <em>fakesrc</em> element, a fake data source. The function\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElementFactory.html#gst-element-factory-create\"><code>gst_element_factory_create ()</code></a>\nwill use the element factory to create an element with the given name.</p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\nint\nmain (int   argc,\n      char *argv[])\n{\n  GstElementFactory *factory;\n  GstElement * element;\n\n  /* init GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* create element, method #2 */\n  factory = gst_element_factory_find (\"fakesrc\");\n  if (!factory) {\n    g_print (\"Failed to find factory of type 'fakesrc'\\n\");\n    return -1;\n  }\n  element = gst_element_factory_create (factory, \"source\");\n  if (!element) {\n    g_print (\"Failed to create element, even though its factory exists!\\n\");\n    return -1;\n  }\n\n  gst_object_unref (GST_OBJECT (element));\n\n  return 0;\n}\n\n</code></pre>\n<h2 id=\"using-an-element-as-a-gobject\">Using an element as a <code>GObject</code></h2>\n<p>A\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElement.html\"><code>GstElement</code></a>\ncan have several properties which are implemented using standard\n<code>GObject</code> properties. The usual <code>GObject</code> methods to query, set and get\nproperty values and <code>GParamSpecs</code> are therefore supported.</p>\n<p>Every <code>GstElement</code> inherits at least one property from its parent\n<code>GstObject</code>: the \"name\" property. This is the name you provide to the\nfunctions <code>gst_element_factory_make ()</code> or <code>gst_element_factory_create ()</code>. You can get and set this property using the functions\n<code>gst_object_set_name</code> and <code>gst_object_get_name</code> or use the <code>GObject</code>\nproperty mechanism as shown below.</p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\nint\nmain (int   argc,\n      char *argv[])\n{\n  GstElement *element;\n  gchar *name;\n\n  /* init GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* create element */\n  element = gst_element_factory_make (\"fakesrc\", \"source\");\n\n  /* get name */\n  g_object_get (G_OBJECT (element), \"name\", &amp;name, NULL);\n  g_print (\"The name of the element is '%s'.\\n\", name);\n  g_free (name);\n\n  gst_object_unref (GST_OBJECT (element));\n\n  return 0;\n}\n\n</code></pre>\n<p>Most plugins provide additional properties to provide more information\nabout their configuration or to configure the element. <code>gst-inspect</code> is\na useful tool to query the properties of a particular element, it will\nalso use property introspection to give a short explanation about the\nfunction of the property and about the parameter types and ranges it\nsupports. See <a href=\"../appendix/checklist-element.html#gst-inspect\">gst-inspect</a> in\nthe appendix for details about <code>gst-inspect</code>.</p>\n<p>For more information about <code>GObject</code> properties we recommend you read\nthe <a href=\"http://developer.gnome.org/gobject/stable/rn01.html\">GObject\nmanual</a> and an\nintroduction to <a href=\"http://developer.gnome.org/gobject/stable/pt01.html\">The Glib Object\nsystem</a>.</p>\n<p>A\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElement.html\"><code>GstElement</code></a>\nalso provides various <code>GObject</code> signals that can be used as a flexible\ncallback mechanism. Here, too, you can use <code>gst-inspect</code> to see which\nsignals a specific element supports. Together, signals and properties\nare the most basic way in which elements and applications interact.</p>\n<h2 id=\"more-about-element-factories\">More about element factories</h2>\n<p>In the previous section, we briefly introduced the\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElementFactory.html\"><code>GstElementFactory</code></a>\nobject already as a way to create instances of an element. Element\nfactories, however, are much more than just that. Element factories are\nthe basic types retrieved from the GStreamer registry, they describe all\nplugins and elements that GStreamer can create. This means that element\nfactories are useful for automated element instancing, such as what\nautopluggers do, and for creating lists of available elements.</p>\n<h3 id=\"getting-information-about-an-element-using-a-factory\">Getting information about an element using a factory</h3>\n<p>Tools like <code>gst-inspect</code> will provide some generic information about an\nelement, such as the person that wrote the plugin, a descriptive name\n(and a shortname), a rank and a category. The category can be used to\nget the type of the element that can be created using this element\nfactory. Examples of categories include <code>Codec/Decoder/Video</code> (video\ndecoder), <code>Codec/Encoder/Video</code> (video encoder), <code>Source/Video</code> (a video\ngenerator), <code>Sink/Video</code> (a video output), and all these exist for audio\nas well, of course. Then, there's also <code>Codec/Demuxer</code> and <code>Codec/Muxer</code>\nand a whole lot more. <code>gst-inspect</code> will give a list of all factories,\nand <code>gst-inspect &lt;factory-name&gt;</code> will list all of the above information,\nand a lot more.</p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\nint\nmain (int   argc,\n      char *argv[])\n{\n  GstElementFactory *factory;\n\n  /* init GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* get factory */\n  factory = gst_element_factory_find (\"fakesrc\");\n  if (!factory) {\n    g_print (\"You don't have the 'fakesrc' element installed!\\n\");\n    return -1;\n  }\n\n  /* display information */\n  g_print (\"The '%s' element is a member of the category %s.\\n\"\n           \"Description: %s\\n\",\n           gst_plugin_feature_get_name (GST_PLUGIN_FEATURE (factory)),\n           gst_element_factory_get_metadata (factory, GST_ELEMENT_METADATA_KLASS),\n           gst_element_factory_get_metadata (factory, GST_ELEMENT_METADATA_DESCRIPTION));\n\n  return 0;\n}\n\n</code></pre>\n<p>You can use <code>gst_registry_pool_feature_list (GST_TYPE_ELEMENT_FACTORY)</code>\nto get a list of all the element factories that GStreamer knows about.</p>\n<h3 id=\"finding-out-what-pads-an-element-can-contain\">Finding out what pads an element can contain</h3>\n<p>Perhaps the most powerful feature of element factories is that they\ncontain a full description of the pads that the element can generate,\nand the capabilities of those pads (in layman words: what types of media\ncan stream over those pads), without actually having to load those\nplugins into memory. This can be used to provide a codec selection list\nfor encoders, or it can be used for autoplugging purposes for media\nplayers. All current GStreamer-based media players and autopluggers work\nthis way. We'll look closer at these features as we learn about <code>GstPad</code>\nand <code>GstCaps</code> in the next chapter: <a href=\"pads.html\">Pads and capabilities</a></p>\n<h2 id=\"linking-elements\">Linking elements</h2>\n<p>By linking a source element with zero or more filter-like elements and\nfinally a sink element, you set up a media pipeline. Data will flow\nthrough the elements. This is the basic concept of media handling in\nGStreamer.</p>\n<p><img src=\"images/linked-elements.png\" alt=\"Visualisation of three linked elements\" title=\"fig:\" id=\"visualisation-of-three-linked-elements\"></p>\n<p>By linking these three elements, we have created a very simple chain of\nelements. The effect of this will be that the output of the source\nelement (\u201celement1\u201d) will be used as input for the filter-like element\n(\u201celement2\u201d). The filter-like element will do something with the data\nand send the result to the final sink element (\u201celement3\u201d).</p>\n<p>Imagine the above graph as a simple Ogg/Vorbis audio decoder. The source\nis a disk source which reads the file from disc. The second element is a\nOgg/Vorbis audio decoder. The sink element is your soundcard, playing\nback the decoded audio data. We will use this simple graph to construct\nan Ogg/Vorbis player later in this manual.</p>\n<p>In code, the above graph is written like this:</p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\nint\nmain (int   argc,\n      char *argv[])\n{\n  GstElement *pipeline;\n  GstElement *source, *filter, *sink;\n\n  /* init */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* create pipeline */\n  pipeline = gst_pipeline_new (\"my-pipeline\");\n\n  /* create elements */\n  source = gst_element_factory_make (\"fakesrc\", \"source\");\n  filter = gst_element_factory_make (\"identity\", \"filter\");\n  sink = gst_element_factory_make (\"fakesink\", \"sink\");\n\n  /* must add elements to pipeline before linking them */\n  gst_bin_add_many (GST_BIN (pipeline), source, filter, sink, NULL);\n\n  /* link */\n  if (!gst_element_link_many (source, filter, sink, NULL)) {\n    g_warning (\"Failed to link elements!\");\n  }\n\n[..]\n\n}\n\n</code></pre>\n<p>For more specific behaviour, there are also the functions\n<code>gst_element_link ()</code> and <code>gst_element_link_pads ()</code>. You can also\nobtain references to individual pads and link those using various\n<code>gst_pad_link_* ()</code> functions. See the API references for more details.</p>\n<p>Important: you must add elements to a bin or pipeline <em>before</em> linking\nthem, since adding an element to a bin will disconnect any already\nexisting links. Also, you cannot directly link elements that are not in\nthe same bin or pipeline; if you want to link elements or pads at\ndifferent hierarchy levels, you will need to use ghost pads (more about\nghost pads later, see <a href=\"pads.html#ghost-pads\">Ghost pads</a></p>\n<h2 id=\"element-states\">Element States</h2>\n<p>After being created, an element will not actually perform any actions\nyet. You need to change elements state to make it do something.\nGStreamer knows four element states, each with a very specific meaning.\nThose four states are:</p>\n<ul>\n<li>\n<p><code>GST_STATE_NULL</code>: this is the default state. No resources are\nallocated in this state, so, transitioning to it will free all\nresources. The element must be in this state when its refcount\nreaches 0 and it is freed.</p>\n</li>\n<li>\n<p><code>GST_STATE_READY</code>: in the ready state, an element has allocated all\nof its global resources, that is, resources that can be kept within\nstreams. You can think about opening devices, allocating buffers and\nso on. However, the stream is not opened in this state, so the\nstream positions is automatically zero. If a stream was previously\nopened, it should be closed in this state, and position, properties\nand such should be reset.</p>\n</li>\n<li>\n<p><code>GST_STATE_PAUSED</code>: in this state, an element has opened the stream,\nbut is not actively processing it. An element is allowed to modify a\nstream's position, read and process data and such to prepare for\nplayback as soon as state is changed to PLAYING, but it is <em>not</em>\nallowed to play the data which would make the clock run. In summary,\nPAUSED is the same as PLAYING but without a running clock.</p>\n<p>Elements going into the PAUSED state should prepare themselves for\nmoving over to the PLAYING state as soon as possible. Video or audio\noutputs would, for example, wait for data to arrive and queue it so\nthey can play it right after the state change. Also, video sinks can\nalready play the first frame (since this does not affect the clock\nyet). Autopluggers could use this same state transition to already\nplug together a pipeline. Most other elements, such as codecs or\nfilters, do not need to explicitly do anything in this state,\nhowever.</p>\n</li>\n<li>\n<p><code>GST_STATE_PLAYING</code>: in the PLAYING state, an element does exactly\nthe same as in the PAUSED state, except that the clock now runs.</p>\n</li>\n</ul>\n<p>You can change the state of an element using the function\n<code>gst_element_set_state ()</code>. If you set an element to another state,\nGStreamer will internally traverse all intermediate states. So if you\nset an element from NULL to PLAYING, GStreamer will internally set the\nelement to READY and PAUSED in between.</p>\n<p>When moved to <code>GST_STATE_PLAYING</code>, pipelines will process data\nautomatically. They do not need to be iterated in any form. Internally,\nGStreamer will start threads that take this task on to them. GStreamer\nwill also take care of switching messages from the pipeline's thread\ninto the application's own thread, by using a\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstBus.html\"><code>GstBus</code></a>.\nSee <a href=\"bus.html\">Bus</a> for details.</p>\n<p>When you set a bin or pipeline to a certain target state, it will\nusually propagate the state change to all elements within the bin or\npipeline automatically, so it's usually only necessary to set the state\nof the top-level pipeline to start up the pipeline or shut it down.\nHowever, when adding elements dynamically to an already-running\npipeline, e.g. from within a \"pad-added\" signal callback, you need to\nset it to the desired target state yourself using <code>gst_element_set_state ()</code> or <code>gst_element_sync_state_with_parent ()</code>.</p>\n<ol>\n<li>The code for this example is automatically extracted from the\ndocumentation and built under <code>tests/examples/manual</code> in the\nGStreamer tarball.</li>\n</ol>\n\n</div>\n\n\n\t"});