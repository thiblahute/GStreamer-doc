fragment_downloaded_cb({"url": "GStreamer-doc-1.0/application-development/basics/data.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"data.md\">\n<h1 id=\"buffers-and-events\">Buffers and Events</h1>\n<p>The data flowing through a pipeline consists of a combination of buffers\nand events. Buffers contain the actual media data. Events contain\ncontrol information, such as seeking information and end-of-stream\nnotifiers. All this will flow through the pipeline automatically when\nit's running. This chapter is mostly meant to explain the concept to\nyou; you don't need to do anything for this.</p>\n<h2 id=\"buffers\">Buffers</h2>\n<p>Buffers contain the data that will flow through the pipeline you have\ncreated. A source element will typically create a new buffer and pass it\nthrough a pad to the next element in the chain. When using the GStreamer\ninfrastructure to create a media pipeline you will not have to deal with\nbuffers yourself; the elements will do that for you.</p>\n<p>A buffer consists, amongst others, of:</p>\n<ul>\n<li>\n<p>Pointers to memory objects. Memory objects encapsulate a region in\nthe memory.</p>\n</li>\n<li>\n<p>A timestamp for the buffer.</p>\n</li>\n<li>\n<p>A refcount that indicates how many elements are using this buffer.\nThis refcount will be used to destroy the buffer when no element has\na reference to it.</p>\n</li>\n<li>\n<p>Buffer flags.</p>\n</li>\n</ul>\n<p>The simple case is that a buffer is created, memory allocated, data put\nin it, and passed to the next element. That element reads the data, does\nsomething (like creating a new buffer and decoding into it), and\nunreferences the buffer. This causes the data to be free'ed and the\nbuffer to be destroyed. A typical video or audio decoder works like\nthis.</p>\n<p>There are more complex scenarios, though. Elements can modify buffers\nin-place, i.e. without allocating a new one. Elements can also write to\nhardware memory (such as from video-capture sources) or memory allocated\nfrom the X-server (using XShm). Buffers can be read-only, and so on.</p>\n<h2 id=\"events\">Events</h2>\n<p>Events are control particles that are sent both up- and downstream in a\npipeline along with buffers. Downstream events notify fellow elements of\nstream states. Possible events include seeking, flushes, end-of-stream\nnotifications and so on. Upstream events are used both in\napplication-element interaction as well as element-element interaction\nto request changes in stream state, such as seeks. For applications,\nonly upstream events are important. Downstream events are just explained\nto get a more complete picture of the data concept.</p>\n<p>Since most applications seek in time units, our example below does so\ntoo:</p>\n<pre><code class=\"language-c\">static void\nseek_to_time (GstElement *element,\n          guint64     time_ns)\n{\n  GstEvent *event;\n\n  event = gst_event_new_seek (1.0, GST_FORMAT_TIME,\n                  GST_SEEK_FLAG_NONE,\n                  GST_SEEK_METHOD_SET, time_ns,\n                  GST_SEEK_TYPE_NONE, G_GUINT64_CONSTANT (0));\n  gst_element_send_event (element, event);\n}\n\n</code></pre>\n<p>The function <code>gst_element_seek ()</code> is a shortcut for this. This is\nmostly just to show how it all works.</p>\n\n</div>\n\n\n\t"});