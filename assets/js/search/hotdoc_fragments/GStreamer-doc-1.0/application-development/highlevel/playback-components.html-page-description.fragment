fragment_downloaded_cb({"url": "GStreamer-doc-1.0/application-development/highlevel/playback-components.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"playback-components.md\">\n<h1 id=\"playback-components\">Playback Components</h1>\n<p>GStreamer includes several higher-level components to simplify an\napplication developer's life. All of the components discussed here (for\nnow) are targetted at media playback. The idea of each of these\ncomponents is to integrate as closely as possible with a GStreamer\npipeline, but to hide the complexity of media type detection and several\nother rather complex topics that have been discussed in <a href=\"../advanced/index.html\">Advanced\nGStreamer concepts</a>.</p>\n<p>We currently recommend people to use either playbin (see\n<a href=\"../../#playbin\">Playbin</a>) or decodebin (see <a href=\"../../#decodebin\">Decodebin</a>),\ndepending on their needs. Playbin is the recommended solution for\neverything related to simple playback of media that should just work.\nDecodebin is a more flexible autoplugger that could be used to add more\nadvanced features, such as playlist support, crossfading of audio tracks\nand so on. Its programming interface is more low-level than that of\nplaybin, though.</p>\n<h2 id=\"playbin\">Playbin</h2>\n<p>Playbin is an element that can be created using the standard GStreamer\nAPI (e.g. <code>gst_element_factory_make ()</code>). The factory is conveniently\ncalled \u201cplaybin\u201d. By being a <code>GstPipeline</code> (and thus a <code>GstElement</code>),\nplaybin automatically supports all of the features of this class,\nincluding error handling, tag support, state handling, getting stream\npositions, seeking, and so on.</p>\n<p>Setting up a playbin pipeline is as simple as creating an instance of\nthe playbin element, setting a file location using the \u201curi\u201d property on\nplaybin, and then setting the element to the <code>GST_STATE_PLAYING</code> state\n(the location has to be a valid URI, so \u201c&lt;protocol&gt;://&lt;location&gt;\u201d,\ne.g. file:///tmp/my.ogg or http://www.example.org/stream.ogg).\nInternally, playbin will set up a pipeline to playback the media\nlocation.</p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\n[.. my_bus_callback goes here ..]\n\ngint\nmain (gint   argc,\n      gchar *argv[])\n{\n  GMainLoop *loop;\n  GstElement *play;\n  GstBus *bus;\n\n  /* init GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n  loop = g_main_loop_new (NULL, FALSE);\n\n  /* make sure we have a URI */\n  if (argc != 2) {\n    g_print (\"Usage: %s &lt;URI&gt;\\n\", argv[0]);\n    return -1;\n  }\n\n  /* set up */\n  play = gst_element_factory_make (\"playbin\", \"play\");\n  g_object_set (G_OBJECT (play), \"uri\", argv[1], NULL);\n\n  bus = gst_pipeline_get_bus (GST_PIPELINE (play));\n  gst_bus_add_watch (bus, my_bus_callback, loop);\n  gst_object_unref (bus);\n\n  gst_element_set_state (play, GST_STATE_PLAYING);\n\n  /* now run */\n  g_main_loop_run (loop);\n\n  /* also clean up */\n  gst_element_set_state (play, GST_STATE_NULL);\n  gst_object_unref (GST_OBJECT (play));\n\n  return 0;\n}\n\n</code></pre>\n<p>Playbin has several features that have been discussed previously:</p>\n<ul>\n<li>\n<p>Settable video and audio output (using the \u201cvideo-sink\u201d and\n\u201caudio-sink\u201d properties).</p>\n</li>\n<li>\n<p>Mostly controllable and trackable as a <code>GstElement</code>, including error\nhandling, eos handling, tag handling, state handling (through the\n<code>GstBus</code>), media position handling and seeking.</p>\n</li>\n<li>\n<p>Buffers network-sources, with buffer fullness notifications being\npassed through the <code>GstBus</code>.</p>\n</li>\n<li>\n<p>Supports visualizations for audio-only media.</p>\n</li>\n<li>\n<p>Supports subtitles, both in the media as well as from separate\nfiles. For separate subtitle files, use the \u201csuburi\u201d property.</p>\n</li>\n<li>\n<p>Supports stream selection and disabling. If your media has multiple\naudio or subtitle tracks, you can dynamically choose which one to\nplay back, or decide to turn it off altogether (which is especially\nuseful to turn off subtitles). For each of those, use the\n\u201ccurrent-text\u201d and other related properties.</p>\n</li>\n</ul>\n<p>For convenience, it is possible to test \u201cplaybin\u201d on the commandline,\nusing the command \u201cgst-launch-1.0 playbin uri=file:///path/to/file\u201d.</p>\n<h2 id=\"decodebin\">Decodebin</h2>\n<p>Decodebin is the actual autoplugger backend of playbin, which was\ndiscussed in the previous section. Decodebin will, in short, accept\ninput from a source that is linked to its sinkpad and will try to detect\nthe media type contained in the stream, and set up decoder routines for\neach of those. It will automatically select decoders. For each decoded\nstream, it will emit the \u201cpad-added\u201d signal, to let the client know\nabout the newly found decoded stream. For unknown streams (which might\nbe the whole stream), it will emit the \u201cunknown-type\u201d signal. The\napplication is then responsible for reporting the error to the user.</p>\n<pre><code class=\"language-c\">\n#include &lt;gst/gst.h&gt;\n\n\n[.. my_bus_callback goes here ..]\n\n\n\nGstElement *pipeline, *audio;\n\nstatic void\ncb_newpad (GstElement *decodebin,\n       GstPad     *pad,\n       gpointer    data)\n{\n  GstCaps *caps;\n  GstStructure *str;\n  GstPad *audiopad;\n\n  /* only link once */\n  audiopad = gst_element_get_static_pad (audio, \"sink\");\n  if (GST_PAD_IS_LINKED (audiopad)) {\n    g_object_unref (audiopad);\n    return;\n  }\n\n  /* check media type */\n  caps = gst_pad_query_caps (pad, NULL);\n  str = gst_caps_get_structure (caps, 0);\n  if (!g_strrstr (gst_structure_get_name (str), \"audio\")) {\n    gst_caps_unref (caps);\n    gst_object_unref (audiopad);\n    return;\n  }\n  gst_caps_unref (caps);\n\n  /* link'n'play */\n  gst_pad_link (pad, audiopad);\n\n  g_object_unref (audiopad);\n}\n\ngint\nmain (gint   argc,\n      gchar *argv[])\n{\n  GMainLoop *loop;\n  GstElement *src, *dec, *conv, *sink;\n  GstPad *audiopad;\n  GstBus *bus;\n\n  /* init GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n  loop = g_main_loop_new (NULL, FALSE);\n\n  /* make sure we have input */\n  if (argc != 2) {\n    g_print (\"Usage: %s &lt;filename&gt;\\n\", argv[0]);\n    return -1;\n  }\n\n  /* setup */\n  pipeline = gst_pipeline_new (\"pipeline\");\n\n  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));\n  gst_bus_add_watch (bus, my_bus_callback, loop);\n  gst_object_unref (bus);\n\n  src = gst_element_factory_make (\"filesrc\", \"source\");\n  g_object_set (G_OBJECT (src), \"location\", argv[1], NULL);\n  dec = gst_element_factory_make (\"decodebin\", \"decoder\");\n  g_signal_connect (dec, \"pad-added\", G_CALLBACK (cb_newpad), NULL);\n  gst_bin_add_many (GST_BIN (pipeline), src, dec, NULL);\n  gst_element_link (src, dec);\n\n  /* create audio output */\n  audio = gst_bin_new (\"audiobin\");\n  conv = gst_element_factory_make (\"audioconvert\", \"aconv\");\n  audiopad = gst_element_get_static_pad (conv, \"sink\");\n  sink = gst_element_factory_make (\"alsasink\", \"sink\");\n  gst_bin_add_many (GST_BIN (audio), conv, sink, NULL);\n  gst_element_link (conv, sink);\n  gst_element_add_pad (audio,\n      gst_ghost_pad_new (\"sink\", audiopad));\n  gst_object_unref (audiopad);\n  gst_bin_add (GST_BIN (pipeline), audio);\n\n  /* run */\n  gst_element_set_state (pipeline, GST_STATE_PLAYING);\n  g_main_loop_run (loop);\n\n  /* cleanup */\n  gst_element_set_state (pipeline, GST_STATE_NULL);\n  gst_object_unref (GST_OBJECT (pipeline));\n\n  return 0;\n}\n\n\n</code></pre>\n<p>Decodebin, similar to playbin, supports the following features:</p>\n<ul>\n<li>\n<p>Can decode an unlimited number of contained streams to decoded\noutput pads.</p>\n</li>\n<li>\n<p>Is handled as a <code>GstElement</code> in all ways, including tag or error\nforwarding and state handling.</p>\n</li>\n</ul>\n<p>Although decodebin is a good autoplugger, there's a whole lot of things\nthat it does not do and is not intended to do:</p>\n<ul>\n<li>\n<p>Taking care of input streams with a known media type (e.g. a DVD, an\naudio-CD or such).</p>\n</li>\n<li>\n<p>Selection of streams (e.g. which audio track to play in case of\nmulti-language media streams).</p>\n</li>\n<li>\n<p>Overlaying subtitles over a decoded video stream.</p>\n</li>\n</ul>\n<p>Decodebin can be easily tested on the commandline, e.g. by using the\ncommand <code>gst-launch-1.0 filesrc location=file.ogg ! decodebin ! audioconvert ! audioresample ! autoaudiosink</code>.</p>\n<h2 id=\"uridecodebin\">URIDecodebin</h2>\n<p>The uridecodebin element is very similar to decodebin, only that it\nautomatically plugs a source plugin based on the protocol of the URI\ngiven.</p>\n<p>Uridecodebin will also automatically insert buffering elements when the\nuri is a slow network source. The buffering element will post BUFFERING\nmessages that the application needs to handle as explained in\n<a href=\"../advanced/buffering.html\">Buffering</a>. The following properties can be used\nto configure the buffering method:</p>\n<ul>\n<li>\n<p>The buffer-size property allows you to configure a maximum size in\nbytes for the buffer element.</p>\n</li>\n<li>\n<p>The buffer-duration property allows you to configure a maximum size\nin time for the buffer element. The time will be estimated based on\nthe bitrate of the network.</p>\n</li>\n<li>\n<p>With the download property you can enable the download buffering method\nas described in <a href=\"../advanced/buffering.html#download-buffering\">Download buffering</a>. Setting this\noption to TRUE will only enable download buffering for selected\nformats such as quicktime, flash video, avi and webm.</p>\n</li>\n<li>\n<p>You can also enable buffering on the parsed/demuxed data with the\nuse-buffering property. This is interesting to enable buffering on\nslower random access media such as a network file server.</p>\n</li>\n</ul>\n<p>URIDecodebin can be easily tested on the commandline, e.g. by using the\ncommand <code>gst-launch-1.0 uridecodebin uri=file:///file.ogg ! ! audioconvert ! audioresample ! autoaudiosink</code>.</p>\n<h2 id=\"playsink\">Playsink</h2>\n<p>The playsink element is a powerful sink element. It has request pads for\nraw decoded audio, video and text and it will configure itself to play\nthe media streams. It has the following features:</p>\n<ul>\n<li>\n<p>It exposes GstStreamVolume, GstVideoOverlay, GstNavigation and\nGstColorBalance interfaces and automatically plugs software elements\nto implement the interfaces when needed.</p>\n</li>\n<li>\n<p>It will automatically plug conversion elements.</p>\n</li>\n<li>\n<p>Can optionally render visualizations when there is no video input.</p>\n</li>\n<li>\n<p>Configurable sink elements.</p>\n</li>\n<li>\n<p>Configurable audio/video sync offset to fine-tune synchronization in\nbadly muxed files.</p>\n</li>\n<li>\n<p>Support for taking a snapshot of the last video frame.</p>\n</li>\n</ul>\n<p>Below is an example of how you can use playsink. We use a uridecodebin\nelement to decode into raw audio and video streams which we then link to\nthe playsink request pads. We only link the first audio and video pads,\nyou could use an input-selector to link all pads.</p>\n<pre><code class=\"language-c\">\n\n#include &lt;gst/gst.h&gt;\n\n\n[.. my_bus_callback goes here ..]\n\n\n\n\n\nGstElement *pipeline, *sink;\n\nstatic void\ncb_pad_added (GstElement *dec,\n          GstPad     *pad,\n          gpointer    data)\n{\n  GstCaps *caps;\n  GstStructure *str;\n  const gchar *name;\n  GstPadTemplate *templ;\n  GstElementClass *klass;\n\n  /* check media type */\n  caps = gst_pad_query_caps (pad, NULL);\n  str = gst_caps_get_structure (caps, 0);\n  name = gst_structure_get_name (str);\n\n  klass = GST_ELEMENT_GET_CLASS (sink);\n\n  if (g_str_has_prefix (name, \"audio\")) {\n    templ = gst_element_class_get_pad_template (klass, \"audio_sink\");\n  } else if (g_str_has_prefix (name, \"video\")) {\n    templ = gst_element_class_get_pad_template (klass, \"video_sink\");\n  } else if (g_str_has_prefix (name, \"text\")) {\n    templ = gst_element_class_get_pad_template (klass, \"text_sink\");\n  } else {\n    templ = NULL;\n  }\n\n  if (templ) {\n    GstPad *sinkpad;\n\n    sinkpad = gst_element_request_pad (sink, templ, NULL, NULL);\n\n    if (!gst_pad_is_linked (sinkpad))\n      gst_pad_link (pad, sinkpad);\n\n    gst_object_unref (sinkpad);\n  }\n}\n\ngint\nmain (gint   argc,\n      gchar *argv[])\n{\n  GMainLoop *loop;\n  GstElement *dec;\n  GstBus *bus;\n\n  /* init GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n  loop = g_main_loop_new (NULL, FALSE);\n\n  /* make sure we have input */\n  if (argc != 2) {\n    g_print (\"Usage: %s &lt;uri&gt;\\n\", argv[0]);\n    return -1;\n  }\n\n  /* setup */\n  pipeline = gst_pipeline_new (\"pipeline\");\n\n  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));\n  gst_bus_add_watch (bus, my_bus_callback, loop);\n  gst_object_unref (bus);\n\n  dec = gst_element_factory_make (\"uridecodebin\", \"source\");\n  g_object_set (G_OBJECT (dec), \"uri\", argv[1], NULL);\n  g_signal_connect (dec, \"pad-added\", G_CALLBACK (cb_pad_added), NULL);\n\n  /* create audio output */\n  sink = gst_element_factory_make (\"playsink\", \"sink\");\n  gst_util_set_object_arg (G_OBJECT (sink), \"flags\",\n      \"soft-colorbalance+soft-volume+vis+text+audio+video\");\n  gst_bin_add_many (GST_BIN (pipeline), dec, sink, NULL);\n\n  /* run */\n  gst_element_set_state (pipeline, GST_STATE_PLAYING);\n  g_main_loop_run (loop);\n\n  /* cleanup */\n  gst_element_set_state (pipeline, GST_STATE_NULL);\n  gst_object_unref (GST_OBJECT (pipeline));\n\n  return 0;\n}\n\n\n\n</code></pre>\n<p>This example will show audio and video depending on what you give it.\nTry this example on an audio file and you will see that it shows\nvisualizations. You can change the visualization at runtime by changing\nthe vis-plugin property.</p>\n\n</div>\n\n\n\t"});