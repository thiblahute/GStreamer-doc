fragment_downloaded_cb({"url": "GStreamer-doc-1.0/plugin-development/element-types/base-classes.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"base-classes.md\">\n<h1 id=\"premade-base-classes\">Pre-made base classes</h1>\n<p>So far, we've been looking at low-level concepts of creating any type of\nGStreamer element. Now, let's assume that all you want is to create an\nsimple audiosink that works exactly the same as, say, \u201cesdsink\u201d, or a\nfilter that simply normalizes audio volume. Such elements are very\ngeneral in concept and since they do nothing special, they should be\neasier to code than to provide your own scheduler activation functions\nand doing complex caps negotiation. For this purpose, GStreamer provides\nbase classes that simplify some types of elements. Those base classes\nwill be discussed in this chapter.</p>\n<h2 id=\"writing-a-sink\">Writing a sink</h2>\n<p>Sinks are special elements in GStreamer. This is because sink elements\nhave to take care of <em>preroll</em>, which is the process that takes care\nthat elements going into the <code>GST_STATE_PAUSED</code> state will have buffers\nready after the state change. The result of this is that such elements\ncan start processing data immediately after going into the\n<code>GST_STATE_PLAYING</code> state, without requiring to take some time to\ninitialize outputs or set up decoders; all that is done already before\nthe state-change to <code>GST_STATE_PAUSED</code> successfully completes.</p>\n<p>Preroll, however, is a complex process that would require the same code\nin many elements. Therefore, sink elements can derive from the\n<code>GstBaseSink</code> base-class, which does preroll and a few other utility\nfunctions automatically. The derived class only needs to implement a\nbunch of virtual functions and will work automatically.</p>\n<p>The base class implement much of the synchronization logic that a sink\nhas to perform.</p>\n<p>The <code>GstBaseSink</code> base-class specifies some limitations on elements,\nthough:</p>\n<ul>\n<li>It requires that the sink only has one sinkpad. Sink elements that\nneed more than one sinkpad, must make a manager element with\nmultiple GstBaseSink elements inside.</li>\n</ul>\n<p>Sink elements can derive from <code>GstBaseSink</code> using the usual <code>GObject</code>\nconvenience macro <code>G_DEFINE_TYPE ()</code>:</p>\n<pre><code class=\"language-c\">G_DEFINE_TYPE (GstMySink, gst_my_sink, GST_TYPE_BASE_SINK);\n\n[..]\n\nstatic void\ngst_my_sink_class_init (GstMySinkClass * klass)\n{\n  klass-&gt;set_caps = [..];\n  klass-&gt;render = [..];\n[..]\n}\n\n</code></pre>\n<p>The advantages of deriving from <code>GstBaseSink</code> are numerous:</p>\n<ul>\n<li>\n<p>Derived implementations barely need to be aware of preroll, and do\nnot need to know anything about the technical implementation\nrequirements of preroll. The base-class does all the hard work.</p>\n<p>Less code to write in the derived class, shared code (and thus\nshared bugfixes).</p>\n</li>\n</ul>\n<p>There are also specialized base classes for audio and video, let's look\nat those a bit.</p>\n<h3 id=\"writing-an-audio-sink\">Writing an audio sink</h3>\n<p>Essentially, audio sink implementations are just a special case of a\ngeneral sink. An audio sink has the added complexity that it needs to\nschedule playback of samples. It must match the clock selected in the\npipeline against the clock of the audio device and calculate and\ncompensate for drift and jitter.</p>\n<p>There are two audio base classes that you can choose to derive from,\ndepending on your needs: <code>GstAudioBasesink</code> and <code>GstAudioSink</code>. The\naudiobasesink provides full control over how synchronization and\nscheduling is handled, by using a ringbuffer that the derived class\ncontrols and provides. The audiosink base-class is a derived class of\nthe audiobasesink, implementing a standard ringbuffer implementing\ndefault synchronization and providing a standard audio-sample clock.\nDerived classes of this base class merely need to provide a <code>_open ()</code>, <code>_close ()</code> and a <code>_write ()</code> function implementation, and some optional functions. This should\nsuffice for many sound-server output elements and even most interfaces.\nMore demanding audio systems, such as Jack, would want to implement the\n<code>GstAudioBaseSink</code> base-class.</p>\n<p>The <code>GstAudioBaseSink</code> has little to no limitations and should fit\nvirtually every implementation, but is hard to implement. The\n<code>GstAudioSink</code>, on the other hand, only fits those systems with a simple\n<code>open ()</code> / <code>close ()</code> / <code>write ()</code> API (which practically means pretty much all of them), but has the\nadvantage that it is a lot easier to implement. The benefits of this\nsecond base class are large:</p>\n<ul>\n<li>\n<p>Automatic synchronization, without any code in the derived class.</p>\n</li>\n<li>\n<p>Also automatically provides a clock, so that other sinks (e.g. in\ncase of audio/video playback) are synchronized.</p>\n</li>\n<li>\n<p>Features can be added to all audiosinks by making a change in the\nbase class, which makes maintenance easy.</p>\n</li>\n<li>\n<p>Derived classes require only three small functions, plus some\n<code>GObject</code> boilerplate code.</p>\n</li>\n</ul>\n<p>In addition to implementing the audio base-class virtual functions,\nderived classes can (should) also implement the <code>GstBaseSink</code> <code>set_caps ()</code> and <code>get_caps ()</code> virtual functions for negotiation.</p>\n<h3 id=\"writing-a-video-sink\">Writing a video sink</h3>\n<p>Writing a videosink can be done using the <code>GstVideoSink</code> base-class,\nwhich derives from <code>GstBaseSink</code> internally. Currently, it does nothing\nyet but add another compile dependency, so derived classes will need to\nimplement all base-sink virtual functions. When they do this correctly,\nthis will have some positive effects on the end user experience with the\nvideosink:</p>\n<ul>\n<li>\n<p>Because of preroll (and the <code>preroll ()</code> virtual function), it is\npossible to display a video frame already when going into the\n<code>GST_STATE_PAUSED</code> state.</p>\n</li>\n<li>\n<p>By adding new features to <code>GstVideoSink</code>, it will be possible to add\nextensions to videosinks that affect all of them, but only need to\nbe coded once, which is a huge maintenance benefit.</p>\n</li>\n</ul>\n<h2 id=\"writing-a-source\">Writing a source</h2>\n<p>In the previous part, particularly <a href=\"../advanced/scheduling.html#providing-random-access\">Providing random access</a>,\nwe have learned that some types of elements can provide random access. This\napplies most definitely to source elements reading from a randomly seekable\nlocation, such as file sources. However, other source elements may be better\ndescribed as a live source element, such as a camera source, an audio\ncard source and such; those are not seekable and do not provide\nbyte-exact access. For all such use cases, GStreamer provides two base\nclasses: <code>GstBaseSrc</code> for the basic source functionality, and\n<code>GstPushSrc</code>, which is a non-byte exact source base-class. The\npushsource base class itself derives from basesource as well, and thus\nall statements about the basesource apply to the pushsource, too.</p>\n<p>The basesrc class does several things automatically for derived classes,\nso they no longer have to worry about it:</p>\n<ul>\n<li>\n<p>Fixes to <code>GstBaseSrc</code> apply to all derived classes automatically.</p>\n</li>\n<li>\n<p>Automatic pad activation handling, and task-wrapping in case we get\nassigned to start a task ourselves.</p>\n</li>\n</ul>\n<p>The <code>GstBaseSrc</code> may not be suitable for all cases, though; it has\nlimitations:</p>\n<ul>\n<li>There is one and only one sourcepad. Source elements requiring\nmultiple sourcepads must implement a manager bin and use multiple\nsource elements internally or make a manager element that uses a\nsource element and a demuxer inside.</li>\n</ul>\n<p>It is possible to use special memory, such as X server memory pointers\nor <code>mmap ()</code>'ed memory areas, as data pointers in buffers returned from\nthe <code>create()</code> virtual function.</p>\n<h3 id=\"writing-an-audio-source\">Writing an audio source</h3>\n<p>An audio source is nothing more but a special case of a pushsource.\nAudio sources would be anything that reads audio, such as a source\nreading from a soundserver, a kernel interface (such as ALSA) or a test\nsound / signal generator. GStreamer provides two base classes, similar\nto the two audiosinks described in <a href=\"../../#writing-an-audio-sink\">Writing an audio\nsink</a>; one is ringbuffer-based, and requires the\nderived class to take care of its own scheduling, synchronization and\nsuch. The other is based on this <code>GstAudioBaseSrc</code> and is called\n<code>GstAudioSrc</code>, and provides a simple <code>open ()</code>, <code>close ()</code> and <code>read ()</code>\ninterface, which is rather simple to implement and will suffice for most\nsoundserver sources and audio interfaces (e.g. ALSA or OSS) out there.</p>\n<p>The <code>GstAudioSrc</code> base-class has several benefits for derived classes,\non top of the benefits of the <code>GstPushSrc</code> base-class that it is based\non:</p>\n<ul>\n<li>\n<p>Does syncronization and provides a clock.</p>\n</li>\n<li>\n<p>New features can be added to it and will apply to all derived\nclasses automatically.</p>\n</li>\n</ul>\n<h2 id=\"writing-a-transformation-element\">Writing a transformation element</h2>\n<p>A third base-class that GStreamer provides is the <code>GstBaseTransform</code>.\nThis is a base class for elements with one sourcepad and one sinkpad\nwhich act as a filter of some sort, such as volume changing, audio\nresampling, audio format conversion, and so on and so on. There is quite\na lot of bookkeeping that such elements need to do in order for things\nsuch as buffer allocation forwarding, passthrough, in-place processing\nand such to all work correctly. This base class does all that for you,\nso that you just need to do the actual processing.</p>\n<p>Since the <code>GstBaseTransform</code> is based on the 1-to-1 model for filters,\nit may not apply well to elements such as decoders, which may have to\nparse properties from the stream. Also, it will not work for elements\nrequiring more than one sourcepad or sinkpad.</p>\n\n</div>\n\n\n\t"});