fragment_downloaded_cb({"url": "GStreamer-doc-1.0/plugin-development/advanced/interfaces.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"interfaces.md\">\n<h1 id=\"interfaces\">Interfaces</h1>\n<p>Previously, in the chapter <a href=\"../basics/args.html\">Adding Properties</a>, we have\nintroduced the concept of GObject properties of controlling an element's\nbehaviour. This is very powerful, but it has two big disadvantages: first of\nall, it is too generic, and second, it isn't dynamic.</p>\n<p>The first disadvantage is related to the customizability of the end-user\ninterface that will be built to control the element. Some properties are\nmore important than others. Some integer properties are better shown in\na spin-button widget, whereas others would be better represented by a\nslider widget. Such things are not possible because the UI has no actual\nmeaning in the application. A UI widget that represents a bitrate\nproperty is the same as a UI widget that represents the size of a video,\nas long as both are of the same <code>GParamSpec</code> type. Another problem, is\nthat things like parameter grouping, function grouping, or parameter\ncoupling are not really possible.</p>\n<p>The second problem with parameters are that they are not dynamic. In\nmany cases, the allowed values for a property are not fixed, but depend\non things that can only be detected at runtime. The names of inputs for\na TV card in a video4linux source element, for example, can only be\nretrieved from the kernel driver when we've opened the device; this only\nhappens when the element goes into the READY state. This means that we\ncannot create an enum property type to show this to the user.</p>\n<p>The solution to those problems is to create very specialized types of\ncontrols for certain often-used controls. We use the concept of\ninterfaces to achieve this. The basis of this all is the glib\n<code>GTypeInterface</code> type. For each case where we think it's useful, we've\ncreated interfaces which can be implemented by elements at their own\nwill.</p>\n<p>One important note: interfaces do <em>not</em> replace properties. Rather,\ninterfaces should be built <em>next to</em> properties. There are two important\nreasons for this. First of all, properties can be more easily\nintrospected. Second, properties can be specified on the commandline\n(<code>gst-launch-1.0</code>).</p>\n<h2 id=\"how-to-implement-interfaces\">How to Implement Interfaces</h2>\n<p>Implementing interfaces is initiated in the <code>_get_type ()</code> of your\nelement. You can register one or more interfaces after having registered\nthe type itself. Some interfaces have dependencies on other interfaces\nor can only be registered by certain types of elements. You will be\nnotified of doing that wrongly when using the element: it will quit with\nfailed assertions, which will explain what went wrong. If it does, you\nneed to register support for <em>that</em> interface before registering support\nfor the interface that you're wanting to support. The example below\nexplains how to add support for a simple interface with no further\ndependencies.</p>\n<pre><code class=\"language-c\">static void gst_my_filter_some_interface_init   (GstSomeInterface *iface);\n\nGType\ngst_my_filter_get_type (void)\n{\n  static GType my_filter_type = 0;\n\n  if (!my_filter_type) {\n    static const GTypeInfo my_filter_info = {\n      sizeof (GstMyFilterClass),\n      NULL,\n      NULL,\n      (GClassInitFunc) gst_my_filter_class_init,\n      NULL,\n      NULL,\n      sizeof (GstMyFilter),\n      0,\n      (GInstanceInitFunc) gst_my_filter_init\n    };\n    static const GInterfaceInfo some_interface_info = {\n      (GInterfaceInitFunc) gst_my_filter_some_interface_init,\n      NULL,\n      NULL\n    };\n\n    my_filter_type =\n    g_type_register_static (GST_TYPE_ELEMENT,\n                \"GstMyFilter\",\n                &amp;my_filter_info, 0);\n    g_type_add_interface_static (my_filter_type,\n                 GST_TYPE_SOME_INTERFACE,\n                                 &amp;some_interface_info);\n  }\n\n  return my_filter_type;\n}\n\nstatic void\ngst_my_filter_some_interface_init (GstSomeInterface *iface)\n{\n  /* here, you would set virtual function pointers in the interface */\n}\n\n</code></pre>\n<p>Or more\nconveniently:</p>\n<pre><code class=\"language-c\">static void gst_my_filter_some_interface_init   (GstSomeInterface *iface);\n\nG_DEFINE_TYPE_WITH_CODE (GstMyFilter, gst_my_filter,GST_TYPE_ELEMENT,\n     G_IMPLEMENT_INTERFACE (GST_TYPE_SOME_INTERFACE,\n            gst_my_filter_some_interface_init));\n\n\n</code></pre>\n<h2 id=\"uri-interface\">URI interface</h2>\n<p>WRITEME</p>\n<h2 id=\"color-balance-interface\">Color Balance Interface</h2>\n<p>WRITEME</p>\n<h2 id=\"video-overlay-interface\">Video Overlay Interface</h2>\n<p>The <code>GstVideoOverlay</code> interface is used for 2 main purposes :</p>\n<ul>\n<li>\n<p>To get a grab on the Window where the video sink element is going to\nrender. This is achieved by either being informed about the Window\nidentifier that the video sink element generated, or by forcing the\nvideo sink element to use a specific Window identifier for\nrendering.</p>\n</li>\n<li>\n<p>To force a redrawing of the latest video frame the video sink\nelement displayed on the Window. Indeed if the <code>GstPipeline</code> is in\n<code>GST\\_STATE\\_PAUSED</code> state, moving the Window around will damage its\ncontent. Application developers will want to handle the Expose\nevents themselves and force the video sink element to refresh the\nWindow's content.</p>\n</li>\n</ul>\n<p>A plugin drawing video output in a video window will need to have that\nwindow at one stage or another. Passive mode simply means that no window\nhas been given to the plugin before that stage, so the plugin created\nthe window by itself. In that case the plugin is responsible of\ndestroying that window when it's not needed any more and it has to tell\nthe applications that a window has been created so that the application\ncan use it. This is done using the <code>have-window-handle</code> message that can\nbe posted from the plugin with the <code>gst_video_overlay_got_window_handle</code>\nmethod.</p>\n<p>As you probably guessed already active mode just means sending a video\nwindow to the plugin so that video output goes there. This is done using\nthe <code>gst_video_overlay_set_window_handle</code> method.</p>\n<p>It is possible to switch from one mode to another at any moment, so the\nplugin implementing this interface has to handle all cases. There are\nonly 2 methods that plugins writers have to implement and they most\nprobably look like that :</p>\n<pre><code class=\"language-c\">static void\ngst_my_filter_set_window_handle (GstVideoOverlay *overlay, guintptr handle)\n{\n  GstMyFilter *my_filter = GST_MY_FILTER (overlay);\n\n  if (my_filter-&gt;window)\n    gst_my_filter_destroy_window (my_filter-&gt;window);\n\n  my_filter-&gt;window = handle;\n}\n\nstatic void\ngst_my_filter_xoverlay_init (GstVideoOverlayClass *iface)\n{\n  iface-&gt;set_window_handle = gst_my_filter_set_window_handle;\n}\n\n</code></pre>\n<p>You will also need to use the interface methods to post messages when\nneeded such as when receiving a CAPS event where you will know the video\ngeometry and maybe create the window.</p>\n<pre><code class=\"language-c\">static MyFilterWindow *\ngst_my_filter_window_create (GstMyFilter *my_filter, gint width, gint height)\n{\n  MyFilterWindow *window = g_new (MyFilterWindow, 1);\n  ...\n  gst_video_overlay_got_window_handle (GST_VIDEO_OVERLAY (my_filter), window-&gt;win);\n}\n\n/* called from the event handler for CAPS events */\nstatic gboolean\ngst_my_filter_sink_set_caps (GstMyFilter *my_filter, GstCaps *caps)\n{\n  gint width, height;\n  gboolean ret;\n  ...\n  ret = gst_structure_get_int (structure, \"width\", &amp;width);\n  ret &amp;= gst_structure_get_int (structure, \"height\", &amp;height);\n  if (!ret) return FALSE;\n\n  gst_video_overlay_prepare_window_handle (GST_VIDEO_OVERLAY (my_filter));\n\n  if (!my_filter-&gt;window)\n    my_filter-&gt;window = gst_my_filter_create_window (my_filter, width, height);\n\n  ...\n}\n\n</code></pre>\n<h2 id=\"navigation-interface\">Navigation Interface</h2>\n<p>WRITEME</p>\n\n</div>\n\n\n\t"});