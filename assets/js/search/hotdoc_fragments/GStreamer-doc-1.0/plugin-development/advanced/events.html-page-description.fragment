fragment_downloaded_cb({"url": "GStreamer-doc-1.0/plugin-development/advanced/events.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"events.md\">\n<h1 id=\"events-seeking-navigation-and-more\">Events: Seeking, Navigation and More</h1>\n<p>There are many different event types but only two ways they can travel\nin the pipeline: downstream or upstream. It is very important to\nunderstand how both of these methods work because if one element in the\npipeline is not handling them correctly the whole event system of the\npipeline is broken. We will try to explain here how these methods work\nand how elements are supposed to implement them.</p>\n<h2 id=\"downstream-events\">Downstream events</h2>\n<p>Downstream events are received through the sink pad's event handler, as\nset using <code>gst_pad_set_event_function ()</code> when the pad was created.</p>\n<p>Downstream events can travel in two ways: they can be in-band\n(serialised with the buffer flow) or out-of-band (travelling through the\npipeline instantly, possibly not in the same thread as the streaming\nthread that is processing the buffers, skipping ahead of buffers being\nprocessed or queued in the pipeline). The most common downstream events\n(SEGMENT, CAPS, TAG, EOS) are all serialised with the buffer flow.</p>\n<p>Here is a typical event function:</p>\n<pre><code class=\"language-c\">static gboolean\ngst_my_filter_sink_event (GstPad  *pad, GstObject * parent, GstEvent * event)\n{\n  GstMyFilter *filter;\n  gboolean ret;\n\n  filter = GST_MY_FILTER (parent);\n  ...\n\n  switch (GST_EVENT_TYPE (event)) {\n    case GST_EVENT_SEGMENT:\n      /* maybe save and/or update the current segment (e.g. for output\n       * clipping) or convert the event into one in a different format\n       * (e.g. BYTES to TIME) or drop it and set a flag to send a segment\n       * event in a different format later */\n      ret = gst_pad_push_event (filter-&gt;src_pad, event);\n      break;\n    case GST_EVENT_EOS:\n      /* end-of-stream, we should close down all stream leftovers here */\n      gst_my_filter_stop_processing (filter);\n      ret = gst_pad_push_event (filter-&gt;src_pad, event);\n      break;\n    case GST_EVENT_FLUSH_STOP:\n      gst_my_filter_clear_temporary_buffers (filter);\n      ret = gst_pad_push_event (filter-&gt;src_pad, event);\n      break;\n    default:\n      ret = gst_pad_event_default (pad, parent, event);\n      break;\n  }\n\n  ...\n  return ret;\n}\n\n</code></pre>\n<p>If your element is chain-based, you will almost always have to implement\na sink event function, since that is how you are notified about\nsegments, caps and the end of the stream.</p>\n<p>If your element is exclusively loop-based, you may or may not want a\nsink event function (since the element is driving the pipeline it will\nknow the length of the stream in advance or be notified by the flow\nreturn value of <code>gst_pad_pull_range()</code>. In some cases even loop-based\nelement may receive events from upstream though (for example audio\ndecoders with an id3demux or apedemux element in front of them, or\ndemuxers that are being fed input from sources that send additional\ninformation about the stream in custom events, as DVD sources do).</p>\n<h2 id=\"upstream-events\">Upstream events</h2>\n<p>Upstream events are generated by an element somewhere downstream in the\npipeline (example: a video sink may generate navigation events that\ninforms upstream elements about the current position of the mouse\npointer). This may also happen indirectly on request of the application,\nfor example when the application executes a seek on a pipeline this seek\nrequest will be passed on to a sink element which will then in turn\ngenerate an upstream seek event.</p>\n<p>The most common upstream events are seek events, Quality-of-Service\n(QoS) and reconfigure events.</p>\n<p>An upstream event can be sent using the <code>gst_pad_send_event</code> function.\nThis function simply call the default event handler of that pad. The\ndefault event handler of pads is <code>gst_pad_event_default</code>, and it\nbasically sends the event to the peer of the internally linked pad. So\nupstream events always arrive on the src pad of your element and are\nhandled by the default event handler except if you override that handler\nto handle it yourself. There are some specific cases where you have to\ndo that :</p>\n<ul>\n<li>\n<p>If you have multiple sink pads in your element. In that case you\nwill have to decide which one of the sink pads you will send the\nevent to (if not all of them).</p>\n</li>\n<li>\n<p>If you need to handle that event locally. For example a navigation\nevent that you will want to convert before sending it upstream, or a\nQoS event that you want to handle.</p>\n</li>\n</ul>\n<p>The processing you will do in that event handler does not really matter\nbut there are important rules you have to absolutely respect because one\nbroken element event handler is breaking the whole pipeline event\nhandling. Here they are :</p>\n<ul>\n<li>\n<p>Always handle events you won't handle using the default\n<code>gst_pad_event_default</code> method. This method will depending on the\nevent, forward the event or drop it.</p>\n</li>\n<li>\n<p>If you are generating some new event based on the one you received\ndon't forget to gst_event_unref the event you received.</p>\n</li>\n<li>\n<p>Event handler function are supposed to return TRUE or FALSE\nindicating if the event has been handled or not. Never simply return\nTRUE/FALSE in that handler except if you really know that you have\nhandled that event.</p>\n</li>\n<li>\n<p>Remember that the event handler might be called from a different\nthread than the streaming thread, so make sure you use appropriate\nlocking everywhere.</p>\n</li>\n</ul>\n<h2 id=\"all-events-together\">All Events Together</h2>\n<p>In this chapter follows a list of all defined events that are currently\nbeing used, plus how they should be used/interpreted. You can check the\nwhat type a certain event is using the GST_EVENT_TYPE macro (or if you\nneed a string for debugging purposes you can use\nGST_EVENT_TYPE_NAME).</p>\n<p>In this chapter, we will discuss the following events:</p>\n<ul>\n<li>\n<p><a href=\"../../../#stream-start\">Stream Start</a></p>\n</li>\n<li>\n<p><a href=\"../../../#caps\">Caps</a></p>\n</li>\n<li>\n<p><a href=\"../../../#segment\">Segment</a></p>\n</li>\n<li>\n<p><a href=\"../../../#tag-metadata\">Tag (metadata)</a></p>\n</li>\n<li>\n<p><a href=\"../../../#end-of-stream-eos\">End of Stream (EOS)</a></p>\n</li>\n<li>\n<p><a href=\"../../../#table-of-contents\">Table Of Contents</a></p>\n</li>\n<li>\n<p><a href=\"../../../#gap\">Gap</a></p>\n</li>\n<li>\n<p><a href=\"../../../#flush-start\">Flush Start</a></p>\n</li>\n<li>\n<p><a href=\"../../../#flush-stop\">Flush Stop</a></p>\n</li>\n<li>\n<p><a href=\"../../../#quality-of-service-qos\">Quality Of Service (QOS)</a></p>\n</li>\n<li>\n<p><a href=\"../../../#seek-request\">Seek Request</a></p>\n</li>\n<li>\n<p><a href=\"../../../#navigation\">Navigation</a></p>\n</li>\n</ul>\n<p>For more comprehensive information about events and how they should be\nused correctly in various circumstances please consult the GStreamer\ndesign documentation. This section only gives a general overview.</p>\n<h3 id=\"stream-start\">Stream Start</h3>\n<p>WRITEME</p>\n<h3 id=\"caps\">Caps</h3>\n<p>The CAPS event contains the format description of the following buffers.\nSee <a href=\"negotiation.html\">Caps negotiation</a> for more information\nabout negotiation.</p>\n<h3 id=\"segment\">Segment</h3>\n<p>A segment event is sent downstream to announce the range of valid\ntimestamps in the stream and how they should be transformed into\nrunning-time and stream-time. A segment event must always be sent before\nthe first buffer of data and after a flush (see above).</p>\n<p>The first segment event is created by the element driving the pipeline,\nlike a source operating in push-mode or a demuxer/decoder operating\npull-based. This segment event then travels down the pipeline and may be\ntransformed on the way (a decoder, for example, might receive a segment\nevent in BYTES format and might transform this into a segment event in\nTIMES format based on the average bitrate).</p>\n<p>Depending on the element type, the event can simply be forwarded using\n<code>gst_pad_event_default ()</code>, or it should be parsed and a modified event\nshould be sent on. The last is true for demuxers, which generally have a\nbyte-to-time conversion concept. Their input is usually byte-based, so\nthe incoming event will have an offset in byte units\n(<code>GST_FORMAT_BYTES</code>), too. Elements downstream, however, expect segment\nevents in time units, so that it can be used to synchronize against the\npipeline clock. Therefore, demuxers and similar elements should not\nforward the event, but parse it, free it and send a segment event (in\ntime units, <code>GST_FORMAT_TIME</code>) further downstream.</p>\n<p>The segment event is created using the function <code>gst_event_new_segment ()</code>. See the API reference and design document for details about its\nparameters.</p>\n<p>Elements parsing this event can use gst_event_parse_segment() to\nextract the event details. Elements may find the GstSegment API useful\nto keep track of the current segment (if they want to use it for output\nclipping, for example).</p>\n<h3 id=\"tag-metadata\">Tag (metadata)</h3>\n<p>Tagging events are being sent downstream to indicate the tags as parsed\nfrom the stream data. This is currently used to preserve tags during\nstream transcoding from one format to the other. Tags are discussed\nextensively in <a href=\"tagging.html\">Tagging (Metadata and Streaminfo)</a>. Most elements\nwill simply forward the event by calling <code>gst_pad_event_default ()</code>.</p>\n<p>The tag event is created using the function <code>gst_event_new_tag ()</code>, but\nmore often elements will send a tag event downstream that will be\nconverted into a message on the bus by sink elements. All of these\nfunctions require a filled-in taglist as argument, which they will take\nownership of.</p>\n<p>Elements parsing this event can use the function <code>gst_event_parse_tag ()</code> to\nacquire the taglist that the event contains.</p>\n<h3 id=\"end-of-stream-eos\">End of Stream (EOS)</h3>\n<p>End-of-stream events are sent if the stream that an element sends out is\nfinished. An element receiving this event (from upstream, so it receives\nit on its sinkpad) will generally just process any buffered data (if\nthere is any) and then forward the event further downstream. The\n<code>gst_pad_event_default ()</code> takes care of all this, so most elements do\nnot need to support this event. Exceptions are elements that explicitly\nneed to close a resource down on EOS, and N-to-1 elements. Note that the\nstream itself is <em>not</em> a resource that should be closed down on EOS!\nApplications might seek back to a point before EOS and continue playing\nagain.</p>\n<p>The EOS event has no properties, which makes it one of the simplest\nevents in GStreamer. It is created using the <code>gst_event_new_eos()</code>\nfunction.</p>\n<p>It is important to note that <em>only elements driving the pipeline should\never send an EOS event</em>. If your element is chain-based, it is not\ndriving the pipeline. Chain-based elements should just return\nGST_FLOW_EOS from their chain function at the end of the stream (or\nthe configured segment), the upstream element that is driving the\npipeline will then take care of sending the EOS event (or alternatively\npost a SEGMENT_DONE message on the bus depending on the mode of\noperation). If you are implementing your own source element, you also do\nnot need to ever manually send an EOS event, you should also just return\nGST_FLOW_EOS in your create or fill function (assuming your element\nderives from GstBaseSrc or GstPushSrc).</p>\n<h3 id=\"table-of-contents\">Table Of Contents</h3>\n<p>WRITEME</p>\n<h3 id=\"gap\">Gap</h3>\n<p>WRITEME</p>\n<h3 id=\"flush-start\">Flush Start</h3>\n<p>The flush start event is sent downstream (in push mode) or upstream (in\npull mode) if all buffers and caches in the pipeline should be emptied.\n\u201cQueue\u201d elements will empty their internal list of buffers when they\nreceive this event, for example. File sink elements (e.g. \u201cfilesink\u201d)\nwill flush the kernel-to-disk cache (<code>fdatasync ()</code> or <code>fflush ()</code>) when\nthey receive this event. Normally, elements receiving this event will\nsimply just forward it, since most filter or filter-like elements don't\nhave an internal cache of data. <code>gst_pad_event_default ()</code> does just\nthat, so for most elements, it is enough to forward the event using the\ndefault event handler.</p>\n<p>As a side-effect of flushing all data from the pipeline, this event\nunblocks the streaming thread by making all pads reject data until they\nreceive a <a href=\"../../../#flush-stop\">Flush Stop</a> signal (elements trying to push data\nwill get a FLUSHING flow return and stop processing data).</p>\n<p>The flush-start event is created with the <code>gst_event_new_flush_start ()</code>. Like the EOS event, it has no properties. This event is usually\nonly created by elements driving the pipeline, like source elements\noperating in push-mode or pull-range based demuxers/decoders.</p>\n<h3 id=\"flush-stop\">Flush Stop</h3>\n<p>The flush-stop event is sent by an element driving the pipeline after a\nflush-start and tells pads and elements downstream that they should\naccept events and buffers again (there will be at least a SEGMENT event\nbefore any buffers first though).</p>\n<p>If your element keeps temporary caches of stream data, it should clear\nthem when it receives a FLUSH-STOP event (and also whenever its chain\nfunction receives a buffer with the DISCONT flag set).</p>\n<p>The flush-stop event is created with <code>gst_event_new_flush_stop ()</code>. It\nhas one parameter that controls if the running-time of the pipeline\nshould be reset to 0 or not. Normally after a flushing seek, the\nrunning_time is set back to 0.</p>\n<h3 id=\"quality-of-service-qos\">Quality Of Service (QOS)</h3>\n<p>The QOS event contains a report about the current real-time performance\nof the stream. See more info in <a href=\"qos.html\">Quality Of Service (QoS)</a>.</p>\n<h3 id=\"seek-request\">Seek Request</h3>\n<p>Seek events are meant to request a new stream position to elements. This\nnew position can be set in several formats (time, bytes or \u201cdefault\nunits\u201d [a term indicating frames for video, channel-independent samples\nfor audio, etc.]). Seeking can be done with respect to the end-of-file\nor start-of-file, and usually happens in upstream direction (downstream\nseeking is done by sending a SEGMENT event with the appropriate offsets\nfor elements that support that, like filesink).</p>\n<p>Elements receiving seek events should, depending on the element type,\neither just forward it upstream (filters, decoders), change the format\nin which the event is given and then forward it (demuxers), or handle\nthe event by changing the file pointer in their internal stream resource\n(file sources, demuxers/decoders driving the pipeline in pull-mode) or\nsomething else.</p>\n<p>Seek events are built up using positions in specified formats (time,\nbytes, units). They are created using the function <code>gst_event_new_seek ()</code>. Note that many plugins do not support seeking from the end of the\nstream. An element not driving the pipeline and forwarding a seek\nrequest should not assume that the seek succeeded or actually happened,\nit should operate based on the SEGMENT events it receives.</p>\n<p>Elements parsing this event can do this using <code>gst_event_parse_seek()</code>.</p>\n<h3 id=\"navigation\">Navigation</h3>\n<p>Navigation events are sent upstream by video sinks to inform upstream\nelements of where the mouse pointer is, if and where mouse pointer\nclicks have happened, or if keys have been pressed or released.</p>\n<p>All this information is contained in the event structure which can be\nobtained with <code>gst_event_get_structure ()</code>.</p>\n<p>Check out the navigationtest element in gst-plugins-good for an idea how\nto extract navigation information from this event.</p>\n\n</div>\n\n\n\t"});