fragment_downloaded_cb({"url": "GStreamer-doc-1.0/tutorials/android/a-running-pipeline.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"a-running-pipeline.md\">\n<h1 id=\"android-tutorial-2-a-running-pipeline\">Android tutorial 2: A running pipeline</h1>\n<h3 id=\"goal\">Goal</h3>\n<p><img src=\"images/tutorials/android-a-running-pipeline-screenshot.png\" alt=\"screenshot\" id=\"screenshot\"></p>\n<p>The tutorials seen in the <a href=\"../basic/index.html\">Basic</a> and\n<a href=\"../playback/index.html\">Playback</a> sections are intended for Desktop\nplatforms and, therefore, their main thread is allowed to block (using\n<code>gst_bus_pop_filtered()</code>) or relinquish control to a GLib main loop. On\nAndroid this would lead to the application being tagged as\nnon-responsive and probably closed.</p>\n<p>This tutorial shows how to overcome this problem. In particular, we will\nlearn:</p>\n<ul>\n<li>How to move the native code to its own thread</li>\n<li>How to allow threads created from C code to communicate with Java</li>\n<li>How to access Java code from C</li>\n<li>How to allocate a <code>CustomData</code> structure from C and have Java host\nit</li>\n</ul>\n<h3 id=\"introduction\">Introduction</h3>\n<p>When using a Graphical User Interface (UI), if the application waits for\nGStreamer calls to complete the user experience will suffer. The usual\napproach, with the <a href=\"http://www.gtk.org\">GTK+ toolkit</a> for example, is to\nrelinquish control to a GLib <code>GMainLoop</code> and let it control the events\ncoming from the UI or GStreamer.</p>\n<p>This approach can be very cumbersome when GStreamer and the Android UI\ncommunicate through the JNI interface, so we take a cleaner route: We\nuse a GLib main loop, and move it to its own thread, so it does not\nblock the application. This simplifies the GStreamer-Android\nintegration, and we only need to worry about a few inter-process\nsynchronization bits, which are detailed in this tutorial.</p>\n<p>Additionally, this tutorial shows how to obtain, from any thread, the\n<a href=\"http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/design.html#wp16696\">JNI Environment\npointer</a>\nrequired to make JNI calls. This is necessary, for example, to call Java\ncode from callbacks in threads spawned deep within GStreamer, which\nnever received this pointer directly.</p>\n<p>Finally, this tutorial explains how to call Java methods from native C\ncode, which involves locating the desired method\u2019s ID in the class.\nThese IDs never change, so they are cached as global variables in the C\ncode and obtained in the static initializer of the class.</p>\n<p>The code below builds a pipeline with an <code>audiotestsrc</code> and an\n<code>autoaudiosink</code> (it plays an audible tone). Two buttons in the UI allow\nsetting the pipeline to PLAYING or PAUSED. A TextView in the UI shows\nmessages sent from the C code (for errors and state changes).</p>\n<h3 id=\"a-pipeline-on-android-java-code\">A pipeline on Android [Java code]</h3>\n<p><strong>src/org/freedesktop/gstreamer/tutorials/tutorial_2/Tutorial2.java</strong></p>\n<pre><code class=\"language-java\">package org.freedesktop.gstreamer.tutorials.tutorial_2;\n\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.ImageButton;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport org.freedesktop.gstreamer.GStreamer;\n\npublic class Tutorial2 extends Activity {\n    private native void nativeInit();     // Initialize native code, build pipeline, etc\n    private native void nativeFinalize(); // Destroy pipeline and shutdown native code\n    private native void nativePlay();     // Set pipeline to PLAYING\n    private native void nativePause();    // Set pipeline to PAUSED\n    private static native boolean nativeClassInit(); // Initialize native class: cache Method IDs for callbacks\n    private long native_custom_data;      // Native code will use this to keep private data\n\n    private boolean is_playing_desired;   // Whether the user asked to go to PLAYING\n\n    // Called when the activity is first created.\n    @Override\n    public void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n\n        // Initialize GStreamer and warn if it fails\n        try {\n            GStreamer.init(this);\n        } catch (Exception e) {\n            Toast.makeText(this, e.getMessage(), Toast.LENGTH_LONG).show();\n            finish();\n            return;\n        }\n\n        setContentView(R.layout.main);\n\n        ImageButton play = (ImageButton) this.findViewById(R.id.button_play);\n        play.setOnClickListener(new OnClickListener() {\n            public void onClick(View v) {\n                is_playing_desired = true;\n                nativePlay();\n            }\n        });\n\n        ImageButton pause = (ImageButton) this.findViewById(R.id.button_stop);\n        pause.setOnClickListener(new OnClickListener() {\n            public void onClick(View v) {\n                is_playing_desired = false;\n                nativePause();\n            }\n        });\n\n        if (savedInstanceState != null) {\n            is_playing_desired = savedInstanceState.getBoolean(\"playing\");\n            Log.i (\"GStreamer\", \"Activity created. Saved state is playing:\" + is_playing_desired);\n        } else {\n            is_playing_desired = false;\n            Log.i (\"GStreamer\", \"Activity created. There is no saved state, playing: false\");\n        }\n\n        // Start with disabled buttons, until native code is initialized\n        this.findViewById(R.id.button_play).setEnabled(false);\n        this.findViewById(R.id.button_stop).setEnabled(false);\n\n        nativeInit();\n    }\n\n    protected void onSaveInstanceState (Bundle outState) {\n        Log.d (\"GStreamer\", \"Saving state, playing:\" + is_playing_desired);\n        outState.putBoolean(\"playing\", is_playing_desired);\n    }\n\n    protected void onDestroy() {\n        nativeFinalize();\n        super.onDestroy();\n    }\n\n    // Called from native code. This sets the content of the TextView from the UI thread.\n    private void setMessage(final String message) {\n        final TextView tv = (TextView) this.findViewById(R.id.textview_message);\n        runOnUiThread (new Runnable() {\n          public void run() {\n            tv.setText(message);\n          }\n        });\n    }\n\n    // Called from native code. Native code calls this once it has created its pipeline and\n    // the main loop is running, so it is ready to accept commands.\n    private void onGStreamerInitialized () {\n        Log.i (\"GStreamer\", \"Gst initialized. Restoring state, playing:\" + is_playing_desired);\n        // Restore previous playing state\n        if (is_playing_desired) {\n            nativePlay();\n        } else {\n            nativePause();\n        }\n\n        // Re-enable buttons, now that GStreamer is initialized\n        final Activity activity = this;\n        runOnUiThread(new Runnable() {\n            public void run() {\n                activity.findViewById(R.id.button_play).setEnabled(true);\n                activity.findViewById(R.id.button_stop).setEnabled(true);\n            }\n        });\n    }\n\n    static {\n        System.loadLibrary(\"gstreamer_android\");\n        System.loadLibrary(\"tutorial-2\");\n        nativeClassInit();\n    }\n\n}\n</code></pre>\n<p>As usual, the first bit that gets executed is the static initializer of\nthe class:</p>\n<pre><code class=\"language-java\">static {\n    System.loadLibrary(\"gstreamer_android\");\n    System.loadLibrary(\"tutorial-2\");\n    nativeClassInit();\n}\n</code></pre>\n<p>As explained in the previous tutorial, the two native libraries are\nloaded and their <code>JNI_OnLoad()</code> methods are executed. Here, we also call\nthe native method <code>nativeClassInit()</code>, previously declared with the\n<code>native</code> keyword in line 19. We will later see what its purpose is</p>\n<p>In the <code>onCreate()</code> method GStreamer is initialized as in the previous\ntutorial with <code>GStreamer.init(this)</code>, and then the layout is inflated\nand listeners are setup for the two UI buttons:</p>\n<pre><code class=\"language-java\">ImageButton play = (ImageButton) this.findViewById(R.id.button_play);\nplay.setOnClickListener(new OnClickListener() {\n    public void onClick(View v) {\n        is_playing_desired = true;\n        nativePlay();\n    }\n});\nImageButton pause = (ImageButton) this.findViewById(R.id.button_stop);\npause.setOnClickListener(new OnClickListener() {\n    public void onClick(View v) {\n        is_playing_desired = false;\n        nativePause();\n    }\n});\n</code></pre>\n<p>Each button instructs the native code to set the pipeline to the desired\nstate, and also remembers this state in the\n<code>is_playing_desired</code> variable.  This is required so, when the\napplication is restarted (for example, due to an orientation change), it\ncan set the pipeline again to the desired state. This approach is easier\nand safer than tracking the actual pipeline state, because orientation\nchanges can happen before the pipeline has moved to the desired state,\nfor example.</p>\n<pre><code class=\"language-java\">if (savedInstanceState != null) {\n    is_playing_desired = savedInstanceState.getBoolean(\"playing\");\n    Log.i (\"GStreamer\", \"Activity created. Saved state is playing:\" + is_playing_desired);\n} else {\n    is_playing_desired = false;\n    Log.i (\"GStreamer\", \"Activity created. There is no saved state, playing: false\");\n}\n</code></pre>\n<p>Restore the previous playing state (if any) from <code>savedInstanceState</code>.\nWe will first build the GStreamer pipeline (below) and only when the\nnative code reports itself as initialized we will use\n<code>is_playing_desired</code>.</p>\n<pre><code class=\"language-java\">nativeInit();\n</code></pre>\n<p>As will be shown in the C code, <code>nativeInit()</code> creates a dedicated\nthread, a GStreamer pipeline, a GLib main loop, and, right before\ncalling <code>g_main_loop_run()</code> and going to sleep, it warns the Java code\nthat the native code is initialized and ready to accept commands.</p>\n<p>This finishes the <code>onCreate()</code> method and the Java initialization. The\nUI buttons are disabled, so nothing will happen until native code is\nready and <code>onGStreamerInitialized()</code> is called:</p>\n<pre><code class=\"language-java\">private void onGStreamerInitialized () {\n    Log.i (\"GStreamer\", \"Gst initialized. Restoring state, playing:\" + is_playing_desired);\n</code></pre>\n<p>This is called by the native code when its main loop is finally running.\nWe first retrieve the desired playing state from <code>is_playing_desired</code>,\nand then set that state:</p>\n<pre><code class=\"language-java\">// Restore previous playing state\nif (is_playing_desired) {\n    nativePlay();\n} else {\n    nativePause();\n}\n</code></pre>\n<p>Here comes the first caveat, when re-enabling the UI buttons:</p>\n<pre><code class=\"language-java\">// Re-enable buttons, now that GStreamer is initialized\nfinal Activity activity = this;\nrunOnUiThread(new Runnable() {\n    public void run() {\n        activity.findViewById(R.id.button_play).setEnabled(true);\n        activity.findViewById(R.id.button_stop).setEnabled(true);\n    }\n});\n</code></pre>\n<p>This method is being called from the thread that the native code created\nto run its main loop, and is not allowed to issue UI-altering commands:\nOnly the UI thread can do that. The solution is easy though: Android\nActivities have a handy\n<a href=\"http://developer.android.com/reference/android/app/Activity.html#runOnUiThread(java.lang.Runnable)\">runOnUiThread()</a>\nmethod which lets bits of code to be executed from the correct thread. A\n<a href=\"http://developer.android.com/reference/java/lang/Runnable.html\">Runnable</a>\ninstance has to be constructed and any parameter can be passed either by\nsub-classing\n<a href=\"http://developer.android.com/reference/java/lang/Runnable.html\">Runnable</a>\nand adding a dedicated constructor, or by using the <code>final</code> modifier, as\nshown in the above snippet.</p>\n<p>The same problem exists when the native code wants to output a string in\nour TextView using the <code>setMessage()</code> method: it has to be done from the\nUI thread. The solution is the same:</p>\n<pre><code class=\"language-java\">private void setMessage(final String message) {\n    final TextView tv = (TextView) this.findViewById(R.id.textview_message);\n    runOnUiThread (new Runnable() {\n      public void run() {\n      tv.setText(message);\n    }\n  });\n}\n</code></pre>\n<p>Finally, a few remaining bits:</p>\n<pre><code class=\"language-java\">protected void onSaveInstanceState (Bundle outState) {\n    Log.d (\"GStreamer\", \"Saving state, playing:\" + is_playing_desired);\n    outState.putBoolean(\"playing\", is_playing_desired);\n}\n</code></pre>\n<p>This method stores the currently desired playing state when Android is\nabout to shut us down, so next time it restarts (after an orientation\nchange, for example), it can restore the same state.</p>\n<pre><code class=\"language-java\">protected void onDestroy() {\n    nativeFinalize();\n    super.onDestroy();\n}\n</code></pre>\n<p>And this is called before Android destroys our application. We call the\n<code>nativeFinalize()</code>method to exit the main loop, destroy its thread and\nall allocated resources.</p>\n<p>This concludes the UI part of the tutorial.</p>\n<h3 id=\"a-pipeline-on-android-c-code\">A pipeline on Android [C code]</h3>\n<p><strong>jni/tutorial-2.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;string.h&gt;\n#include &lt;jni.h&gt;\n#include &lt;android/log.h&gt;\n#include &lt;gst/gst.h&gt;\n#include &lt;pthread.h&gt;\n\nGST_DEBUG_CATEGORY_STATIC (debug_category);\n#define GST_CAT_DEFAULT debug_category\n\n/*\n * These macros provide a way to store the native pointer to CustomData, which might be 32 or 64 bits, into\n * a jlong, which is always 64 bits, without warnings.\n */\n#if GLIB_SIZEOF_VOID_P == 8\n## define GET_CUSTOM_DATA(env, thiz, fieldID) (CustomData *)(*env)-&gt;GetLongField (env, thiz, fieldID)\n## define SET_CUSTOM_DATA(env, thiz, fieldID, data) (*env)-&gt;SetLongField (env, thiz, fieldID, (jlong)data)\n#else\n## define GET_CUSTOM_DATA(env, thiz, fieldID) (CustomData *)(jint)(*env)-&gt;GetLongField (env, thiz, fieldID)\n## define SET_CUSTOM_DATA(env, thiz, fieldID, data) (*env)-&gt;SetLongField (env, thiz, fieldID, (jlong)(jint)data)\n#endif\n\n/* Structure to contain all our information, so we can pass it to callbacks */\ntypedef struct _CustomData {\n  jobject app;           /* Application instance, used to call its methods. A global reference is kept. */\n  GstElement *pipeline;  /* The running pipeline */\n  GMainContext *context; /* GLib context used to run the main loop */\n  GMainLoop *main_loop;  /* GLib main loop */\n  gboolean initialized;  /* To avoid informing the UI multiple times about the initialization */\n} CustomData;\n\n/* These global variables cache values which are not changing during execution */\nstatic pthread_t gst_app_thread;\nstatic pthread_key_t current_jni_env;\nstatic JavaVM *java_vm;\nstatic jfieldID custom_data_field_id;\nstatic jmethodID set_message_method_id;\nstatic jmethodID on_gstreamer_initialized_method_id;\n\n/*\n * Private methods\n */\n\n/* Register this thread with the VM */\nstatic JNIEnv *attach_current_thread (void) {\n  JNIEnv *env;\n  JavaVMAttachArgs args;\n\n  GST_DEBUG (\"Attaching thread %p\", g_thread_self ());\n  args.version = JNI_VERSION_1_4;\n  args.name = NULL;\n  args.group = NULL;\n\n  if ((*java_vm)-&gt;AttachCurrentThread (java_vm, &amp;env, &amp;args) &lt; 0) {\n    GST_ERROR (\"Failed to attach current thread\");\n    return NULL;\n  }\n\n  return env;\n}\n\n/* Unregister this thread from the VM */\nstatic void detach_current_thread (void *env) {\n  GST_DEBUG (\"Detaching thread %p\", g_thread_self ());\n  (*java_vm)-&gt;DetachCurrentThread (java_vm);\n}\n\n/* Retrieve the JNI environment for this thread */\nstatic JNIEnv *get_jni_env (void) {\n  JNIEnv *env;\n\n  if ((env = pthread_getspecific (current_jni_env)) == NULL) {\n    env = attach_current_thread ();\n    pthread_setspecific (current_jni_env, env);\n  }\n\n  return env;\n}\n\n/* Change the content of the UI's TextView */\nstatic void set_ui_message (const gchar *message, CustomData *data) {\n  JNIEnv *env = get_jni_env ();\n  GST_DEBUG (\"Setting message to: %s\", message);\n  jstring jmessage = (*env)-&gt;NewStringUTF(env, message);\n  (*env)-&gt;CallVoidMethod (env, data-&gt;app, set_message_method_id, jmessage);\n  if ((*env)-&gt;ExceptionCheck (env)) {\n    GST_ERROR (\"Failed to call Java method\");\n    (*env)-&gt;ExceptionClear (env);\n  }\n  (*env)-&gt;DeleteLocalRef (env, jmessage);\n}\n\n/* Retrieve errors from the bus and show them on the UI */\nstatic void error_cb (GstBus *bus, GstMessage *msg, CustomData *data) {\n  GError *err;\n  gchar *debug_info;\n  gchar *message_string;\n\n  gst_message_parse_error (msg, &amp;err, &amp;debug_info);\n  message_string = g_strdup_printf (\"Error received from element %s: %s\", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);\n  g_clear_error (&amp;err);\n  g_free (debug_info);\n  set_ui_message (message_string, data);\n  g_free (message_string);\n  gst_element_set_state (data-&gt;pipeline, GST_STATE_NULL);\n}\n\n/* Notify UI about pipeline state changes */\nstatic void state_changed_cb (GstBus *bus, GstMessage *msg, CustomData *data) {\n  GstState old_state, new_state, pending_state;\n  gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);\n  /* Only pay attention to messages coming from the pipeline, not its children */\n  if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data-&gt;pipeline)) {\n    gchar *message = g_strdup_printf(\"State changed to %s\", gst_element_state_get_name(new_state));\n    set_ui_message(message, data);\n    g_free (message);\n  }\n}\n\n/* Check if all conditions are met to report GStreamer as initialized.\n * These conditions will change depending on the application */\nstatic void check_initialization_complete (CustomData *data) {\n  JNIEnv *env = get_jni_env ();\n  if (!data-&gt;initialized &amp;&amp; data-&gt;main_loop) {\n    GST_DEBUG (\"Initialization complete, notifying application. main_loop:%p\", data-&gt;main_loop);\n    (*env)-&gt;CallVoidMethod (env, data-&gt;app, on_gstreamer_initialized_method_id);\n    if ((*env)-&gt;ExceptionCheck (env)) {\n      GST_ERROR (\"Failed to call Java method\");\n      (*env)-&gt;ExceptionClear (env);\n    }\n    data-&gt;initialized = TRUE;\n  }\n}\n\n/* Main method for the native code. This is executed on its own thread. */\nstatic void *app_function (void *userdata) {\n  JavaVMAttachArgs args;\n  GstBus *bus;\n  CustomData *data = (CustomData *)userdata;\n  GSource *bus_source;\n  GError *error = NULL;\n\n  GST_DEBUG (\"Creating pipeline in CustomData at %p\", data);\n\n  /* Create our own GLib Main Context and make it the default one */\n  data-&gt;context = g_main_context_new ();\n  g_main_context_push_thread_default(data-&gt;context);\n\n  /* Build pipeline */\n  data-&gt;pipeline = gst_parse_launch(\"audiotestsrc ! audioconvert ! audioresample ! autoaudiosink\", &amp;error);\n  if (error) {\n    gchar *message = g_strdup_printf(\"Unable to build pipeline: %s\", error-&gt;message);\n    g_clear_error (&amp;error);\n    set_ui_message(message, data);\n    g_free (message);\n    return NULL;\n  }\n\n  /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */\n  bus = gst_element_get_bus (data-&gt;pipeline);\n  bus_source = gst_bus_create_watch (bus);\n  g_source_set_callback (bus_source, (GSourceFunc) gst_bus_async_signal_func, NULL, NULL);\n  g_source_attach (bus_source, data-&gt;context);\n  g_source_unref (bus_source);\n  g_signal_connect (G_OBJECT (bus), \"message::error\", (GCallback)error_cb, data);\n  g_signal_connect (G_OBJECT (bus), \"message::state-changed\", (GCallback)state_changed_cb, data);\n  gst_object_unref (bus);\n\n  /* Create a GLib Main Loop and set it to run */\n  GST_DEBUG (\"Entering main loop... (CustomData:%p)\", data);\n  data-&gt;main_loop = g_main_loop_new (data-&gt;context, FALSE);\n  check_initialization_complete (data);\n  g_main_loop_run (data-&gt;main_loop);\n  GST_DEBUG (\"Exited main loop\");\n  g_main_loop_unref (data-&gt;main_loop);\n  data-&gt;main_loop = NULL;\n\n  /* Free resources */\n  g_main_context_pop_thread_default(data-&gt;context);\n  g_main_context_unref (data-&gt;context);\n  gst_element_set_state (data-&gt;pipeline, GST_STATE_NULL);\n  gst_object_unref (data-&gt;pipeline);\n\n  return NULL;\n}\n\n/*\n * Java Bindings\n */\n\n/* Instruct the native code to create its internal data structure, pipeline and thread */\nstatic void gst_native_init (JNIEnv* env, jobject thiz) {\n  CustomData *data = g_new0 (CustomData, 1);\n  SET_CUSTOM_DATA (env, thiz, custom_data_field_id, data);\n  GST_DEBUG_CATEGORY_INIT (debug_category, \"tutorial-2\", 0, \"Android tutorial 2\");\n  gst_debug_set_threshold_for_name(\"tutorial-2\", GST_LEVEL_DEBUG);\n  GST_DEBUG (\"Created CustomData at %p\", data);\n  data-&gt;app = (*env)-&gt;NewGlobalRef (env, thiz);\n  GST_DEBUG (\"Created GlobalRef for app object at %p\", data-&gt;app);\n  pthread_create (&amp;gst_app_thread, NULL, &amp;app_function, data);\n}\n\n/* Quit the main loop, remove the native thread and free resources */\nstatic void gst_native_finalize (JNIEnv* env, jobject thiz) {\n  CustomData *data = GET_CUSTOM_DATA (env, thiz, custom_data_field_id);\n  if (!data) return;\n  GST_DEBUG (\"Quitting main loop...\");\n  g_main_loop_quit (data-&gt;main_loop);\n  GST_DEBUG (\"Waiting for thread to finish...\");\n  pthread_join (gst_app_thread, NULL);\n  GST_DEBUG (\"Deleting GlobalRef for app object at %p\", data-&gt;app);\n  (*env)-&gt;DeleteGlobalRef (env, data-&gt;app);\n  GST_DEBUG (\"Freeing CustomData at %p\", data);\n  g_free (data);\n  SET_CUSTOM_DATA (env, thiz, custom_data_field_id, NULL);\n  GST_DEBUG (\"Done finalizing\");\n}\n\n/* Set pipeline to PLAYING state */\nstatic void gst_native_play (JNIEnv* env, jobject thiz) {\n  CustomData *data = GET_CUSTOM_DATA (env, thiz, custom_data_field_id);\n  if (!data) return;\n  GST_DEBUG (\"Setting state to PLAYING\");\n  gst_element_set_state (data-&gt;pipeline, GST_STATE_PLAYING);\n}\n\n/* Set pipeline to PAUSED state */\nstatic void gst_native_pause (JNIEnv* env, jobject thiz) {\n  CustomData *data = GET_CUSTOM_DATA (env, thiz, custom_data_field_id);\n  if (!data) return;\n  GST_DEBUG (\"Setting state to PAUSED\");\n  gst_element_set_state (data-&gt;pipeline, GST_STATE_PAUSED);\n}\n\n/* Static class initializer: retrieve method and field IDs */\nstatic jboolean gst_native_class_init (JNIEnv* env, jclass klass) {\n  custom_data_field_id = (*env)-&gt;GetFieldID (env, klass, \"native_custom_data\", \"J\");\n  set_message_method_id = (*env)-&gt;GetMethodID (env, klass, \"setMessage\", \"(Ljava/lang/String;)V\");\n  on_gstreamer_initialized_method_id = (*env)-&gt;GetMethodID (env, klass, \"onGStreamerInitialized\", \"()V\");\n\n  if (!custom_data_field_id || !set_message_method_id || !on_gstreamer_initialized_method_id) {\n    /* We emit this message through the Android log instead of the GStreamer log because the later\n     * has not been initialized yet.\n     */\n    __android_log_print (ANDROID_LOG_ERROR, \"tutorial-2\", \"The calling class does not implement all necessary interface methods\");\n    return JNI_FALSE;\n  }\n  return JNI_TRUE;\n}\n\n/* List of implemented native methods */\nstatic JNINativeMethod native_methods[] = {\n  { \"nativeInit\", \"()V\", (void *) gst_native_init},\n  { \"nativeFinalize\", \"()V\", (void *) gst_native_finalize},\n  { \"nativePlay\", \"()V\", (void *) gst_native_play},\n  { \"nativePause\", \"()V\", (void *) gst_native_pause},\n  { \"nativeClassInit\", \"()Z\", (void *) gst_native_class_init}\n};\n\n/* Library initializer */\njint JNI_OnLoad(JavaVM *vm, void *reserved) {\n  JNIEnv *env = NULL;\n\n  java_vm = vm;\n\n  if ((*vm)-&gt;GetEnv(vm, (void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) {\n    __android_log_print (ANDROID_LOG_ERROR, \"tutorial-2\", \"Could not retrieve JNIEnv\");\n    return 0;\n  }\n  jclass klass = (*env)-&gt;FindClass (env, \"org/freedesktop/gstreamer/tutorials/tutorial_2/Tutorial2\");\n  (*env)-&gt;RegisterNatives (env, klass, native_methods, G_N_ELEMENTS(native_methods));\n\n  pthread_key_create (&amp;current_jni_env, detach_current_thread);\n\n  return JNI_VERSION_1_4;\n}\n</code></pre>\n<p>Let\u2019s start with the <code>CustomData</code> structure. We have seen it in most of\nthe basic tutorials, and it is used to hold all our information in one\nplace, so we can easily pass it around to\ncallbacks:</p>\n<pre><code class=\"language-c\">/* Structure to contain all our information, so we can pass it to callbacks */\ntypedef struct _CustomData {\n  jobject app;           /* Application instance, used to call its methods. A global reference is kept. */\n  GstElement *pipeline;  /* The running pipeline */\n  GMainContext *context; /* GLib context used to run the main loop */\n  GMainLoop *main_loop;  /* GLib main loop */\n  gboolean initialized;  /* To avoid informing the UI multiple times about the initialization */\n} CustomData;\n</code></pre>\n<p>We will see the meaning of each member as we go. What is interesting now\nis that <code>CustomData</code> belongs to the application, so a pointer is kept in\nthe Tutorial2 Java class in the <code>private long native_custom_data</code> attribute. Java only holds this pointer for us; it\nis completely handled in C code.</p>\n<p>From C, this pointer can be set and retrieved with the\n<a href=\"http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#wp16613\">SetLongField()</a>\nand\n<a href=\"http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#wp16572\">GetLongField()</a>\nJNI functions, but two convenience macros have been defined,\n<code>SET_CUSTOM_DATA</code> and <code>GET_CUSTOM_DATA</code>. These macros are handy because\nthe <code>long</code> type used in Java is always 64 bits wide, but the pointer\nused in C can be either 32 or 64 bits wide. The macros take care of the\nconversion without warnings.</p>\n<pre><code class=\"language-c\">/* Library initializer */\njint JNI_OnLoad(JavaVM *vm, void *reserved) {\n  JNIEnv *env = NULL;\n\n  java_vm = vm;\n\n  if ((*vm)-&gt;GetEnv(vm, (void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) {\n    __android_log_print (ANDROID_LOG_ERROR, \"tutorial-2\", \"Could not retrieve JNIEnv\");\n    return 0;\n  }\n  jclass klass = (*env)-&gt;FindClass (env, \"org/freedesktop/gstreamer/tutorials/tutorial_2/Tutorial2\");\n  (*env)-&gt;RegisterNatives (env, klass, native_methods, G_N_ELEMENTS(native_methods));\n\n  pthread_key_create (&amp;current_jni_env, detach_current_thread);\n\n  return JNI_VERSION_1_4;\n}\n</code></pre>\n<p>The <code>JNI_OnLoad</code> function is almost the same as the previous tutorial.\nIt registers the list of native methods (which is longer in this\ntutorial). It also\nuses <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_key_create.html\">pthread_key_create()</a>\nto be able to store per-thread information, which is crucial to properly\nmanage the JNI Environment, as shown later.</p>\n<pre><code class=\"language-c\">/* Static class initializer: retrieve method and field IDs */\nstatic jboolean gst_native_class_init (JNIEnv* env, jclass klass) {\n  custom_data_field_id = (*env)-&gt;GetFieldID (env, klass, \"native_custom_data\", \"J\");\n  set_message_method_id = (*env)-&gt;GetMethodID (env, klass, \"setMessage\", \"(Ljava/lang/String;)V\");\n  on_gstreamer_initialized_method_id = (*env)-&gt;GetMethodID (env, klass, \"onGStreamerInitialized\", \"()V\");\n\n  if (!custom_data_field_id || !set_message_method_id || !on_gstreamer_initialized_method_id) {\n    /* We emit this message through the Android log instead of the GStreamer log because the later\n     * has not been initialized yet.\n     */\n    __android_log_print (ANDROID_LOG_ERROR, \"tutorial-2\", \"The calling class does not implement all necessary interface methods\");\n    return JNI_FALSE;\n  }\n  return JNI_TRUE;\n}\n</code></pre>\n<p>This method is called from the static initializer of the Java class,\nwhich is passed as a parameter (since this is called from a static\nmethod, it receives a class object instead of an instance object). In\norder for C code to be able to call a Java method, it needs to know the\nmethod\u2019s\n<a href=\"http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/types.html#wp1064\">MethodID</a>.\nThis ID is obtained from the method\u2019s name and signature and can be\ncached. The purpose of the <code>gst_native_class_init()</code> function is to\nobtain the IDs of all the methods and fields that the C code will need.\nIf some ID cannot be retrieved, the calling Java class does not offer\nthe expected interface and execution should halt (which is not currently\ndone for simplicity).</p>\n<p>Let\u2019s review now the first native method which can be directly called\nfrom Java:</p>\n<h4 id=\"gst_native_init-nativeinit-from-java\"><code>gst_native_init()</code> (<code>nativeInit()</code> from Java)</h4>\n<p>This method is called at the end of Java's <code>onCreate()</code>.</p>\n<pre><code class=\"language-c\">static void gst_native_init (JNIEnv* env, jobject thiz) {\n  CustomData *data = g_new0 (CustomData, 1);\n  SET_CUSTOM_DATA (env, thiz, custom_data_field_id, data);\n</code></pre>\n<p>It first allocates memory for the <code>CustomData</code> structure and passes the\npointer to the Java class with <code>SET_CUSTOM_DATA</code>, so it is remembered.</p>\n<pre><code class=\"language-c\">data-&gt;app = (*env)-&gt;NewGlobalRef (env, thiz);\n</code></pre>\n<p>A pointer to the application class (the <code>Tutorial2</code> class) is also kept\nin <code>CustomData</code> (a <a href=\"http://developer.android.com/guide/practices/jni.html#local_and_global_references\">Global\nReference</a>\nis used) so its methods can be called later.</p>\n<pre><code class=\"language-c\">pthread_create (&amp;gst_app_thread, NULL, &amp;app_function, data);\n</code></pre>\n<p>Finally, a thread is created and it starts running the\n<code>app_function()</code> method.</p>\n<h4 id=\"app_function\"><code>app_function()</code></h4>\n<pre><code class=\"language-c\">/* Main method for the native code. This is executed on its own thread. */\nstatic void *app_function (void *userdata) {\n  JavaVMAttachArgs args;\n  GstBus *bus;\n  CustomData *data = (CustomData *)userdata;\n  GSource *bus_source;\n  GError *error = NULL;\n\n  GST_DEBUG (\"Creating pipeline in CustomData at %p\", data);\n\n  /* Create our own GLib Main Context and make it the default one */\n  data-&gt;context = g_main_context_new ();\n  g_main_context_push_thread_default(data-&gt;context);\n</code></pre>\n<p>It first creates a GLib context so all <code>GSource</code> are kept in the same\nplace. This also helps cleaning after GSources created by other\nlibraries which might not have been properly disposed of. A new context\nis created with <code>g_main_context_new()</code> and then it is made the default\none for the thread with\n<code>g_main_context_push_thread_default()</code>.</p>\n<pre><code class=\"language-c\">data-&gt;pipeline = gst_parse_launch(\"audiotestsrc ! audioconvert ! audioresample ! autoaudiosink\", &amp;error);\nif (error) {\n  gchar *message = g_strdup_printf(\"Unable to build pipeline: %s\", error-&gt;message);\n  g_clear_error (&amp;error);\n  set_ui_message(message, data);\n  g_free (message);\n  return NULL;\n}\n</code></pre>\n<p>It then creates a pipeline the easy way, with <code>gst-parse-launch()</code>. In\nthis case, it is simply an <code>audiotestsrc</code> (which produces a continuous\ntone) and an <code>autoaudiosink</code>, with accompanying adapter elements.</p>\n<pre><code class=\"language-c\">bus = gst_element_get_bus (data-&gt;pipeline);\nbus_source = gst_bus_create_watch (bus);\ng_source_set_callback (bus_source, (GSourceFunc) gst_bus_async_signal_func, NULL, NULL);\ng_source_attach (bus_source, data-&gt;context);\ng_source_unref (bus_source);\ng_signal_connect (G_OBJECT (bus), \"message::error\", (GCallback)error_cb, data);\ng_signal_connect (G_OBJECT (bus), \"message::state-changed\", (GCallback)state_changed_cb, data);\ngst_object_unref (bus);\n</code></pre>\n<p>These lines create a bus signal watch and connect to some interesting\nsignals, just like we have been doing in the basic tutorials. The\ncreation of the watch is done step by step instead of using\n<code>gst_bus_add_signal_watch()</code> to exemplify how to use a custom GLib\ncontext.</p>\n<pre><code class=\"language-c\">GST_DEBUG (\"Entering main loop... (CustomData:%p)\", data);\ndata-&gt;main_loop = g_main_loop_new (data-&gt;context, FALSE);\ncheck_initialization_complete (data);\ng_main_loop_run (data-&gt;main_loop);\nGST_DEBUG (\"Exited main loop\");\ng_main_loop_unref (data-&gt;main_loop);\ndata-&gt;main_loop = NULL;\n</code></pre>\n<p>Finally, the main loop is created and set to run. When it exits (because\nsomebody else calls <code>g_main_loop_quit()</code>) the main loop is disposed of.\nBefore entering the main loop, though,\n<code>check_initialization_complete()</code> is called. This method checks if all\nconditions are met to consider the native code \u201cready\u201d to accept\ncommands. Since having a running main loop is one of the conditions,\n<code>check_initialization_complete()</code> is called here. This method is\nreviewed below.</p>\n<p>Once the main loop has quit, all resources are freed in lines 178 to</p>\n<ol start=\"181\">\n<li>\n</li></ol>\n<h4 id=\"check_initialization_complete\"><code>check_initialization_complete()</code></h4>\n<pre><code class=\"language-c\">static void check_initialization_complete (CustomData *data) {\n  JNIEnv *env = get_jni_env ();\n  if (!data-&gt;initialized &amp;&amp; data-&gt;main_loop) {\n    GST_DEBUG (\"Initialization complete, notifying application. main_loop:%p\", data-&gt;main_loop);\n    (*env)-&gt;CallVoidMethod (env, data-&gt;app, on_gstreamer_initialized_method_id);\n    if ((*env)-&gt;ExceptionCheck (env)) {\n      GST_ERROR (\"Failed to call Java method\");\n      (*env)-&gt;ExceptionClear (env);\n    }\n    data-&gt;initialized = TRUE;\n  }\n}\n</code></pre>\n<p>This method does not do much in this tutorial, but it will also be used\nin the next ones, with progressively more complex functionality. Its\npurpose is to check if the native code is ready to accept commands, and,\nif so, notify the UI code.</p>\n<p>In tutorial 2, the only conditions are 1) the code is not already\ninitialized and 2) the main loop is running. If these two are met, the\nJava <code>onGStreamerInitialized()</code> method is called via the\n<a href=\"http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#wp4256\">CallVoidMethod()</a>\nJNI call.</p>\n<p>Here comes a tricky bit. JNI calls require a JNI Environment, <strong>which is\ndifferent for every thread</strong>. C methods called from Java receive a\n<code>JNIEnv</code> pointer as a parameter, but this is not the situation with\n<code>check_initialization_complete()</code>. Here, we are in a thread which has\nnever been called from Java, so we have no <code>JNIEnv</code>. We need to use the\n<code>JavaVM</code> pointer (passed to us in the <code>JNI_OnLoad()</code> method, and shared\namong all threads) to attach this thread to the Java Virtual Machine and\nobtain a <code>JNIEnv</code>. This <code>JNIEnv</code> is stored in the <a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">Thread-Local\nStorage</a> (TLS) using\nthe pthread key we created in <code>JNI_OnLoad()</code>, so we do not need to\nattach the thread anymore.</p>\n<p>This behavior is implemented in the <code>get_jni_env()</code> method, used for\nexample in <code>check_initialization_complete()</code> as we have just seen. Let\u2019s\nsee how it works, step by step:</p>\n<h4 id=\"get_jni_env\"><code>get_jni_env()</code></h4>\n<pre><code class=\"language-c\">static JNIEnv *get_jni_env (void) {\n  JNIEnv *env;\n  if ((env = pthread_getspecific (current_jni_env)) == NULL) {\n    env = attach_current_thread ();\n    pthread_setspecific (current_jni_env, env);\n  }\n  return env;\n}\n</code></pre>\n<p>It first retrieves the current <code>JNIEnv</code> from the TLS using\n<a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_getspecific.html\">pthread_getspecific()</a>\nand the key we obtained from\n<a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_key_create.html\">pthread_key_create()</a>.\nIf it returns NULL, we never attached this thread, so we do now with\n<code>attach_current_thread()</code> and then store the new <code>JNIEnv</code> into the TLS\nwith\n<a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_setspecific.html\">pthread_setspecific()</a>.</p>\n<h4 id=\"attach_current_thread\"><code>attach_current_thread()</code></h4>\n<p>This method is simply a convenience wrapper around\n<a href=\"http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/invocation.html#attach_current_thread\">AttachCurrentThread()</a>\nto deal with its parameters.</p>\n<h4 id=\"detach_current_thread\"><code>detach_current_thread()</code></h4>\n<p>This method is called by the pthreads library when a TLS key is deleted,\nmeaning that the thread is about to be destroyed. We simply detach the\nthread from the JavaVM with\n<a href=\"http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/invocation.html#detach_current_thread\">DetachCurrentThread()</a>.</p>\n<p>Let's now review the rest of the native methods accessible from Java:</p>\n<h4 id=\"gst_native_finalize-nativefinalize-from-java\"><code>gst_native_finalize()</code> (<code>nativeFinalize()</code> from Java)</h4>\n<pre><code class=\"language-c\">static void gst_native_finalize (JNIEnv* env, jobject thiz) {\n  CustomData *data = GET_CUSTOM_DATA (env, thiz, custom_data_field_id);\n  if (!data) return;\n  GST_DEBUG (\"Quitting main loop...\");\n  g_main_loop_quit (data-&gt;main_loop);\n  GST_DEBUG (\"Waiting for thread to finish...\");\n  pthread_join (gst_app_thread, NULL);\n  GST_DEBUG (\"Deleting GlobalRef for app object at %p\", data-&gt;app);\n  (*env)-&gt;DeleteGlobalRef (env, data-&gt;app);\n  GST_DEBUG (\"Freeing CustomData at %p\", data);\n  g_free (data);\n  SET_CUSTOM_DATA (env, thiz, custom_data_field_id, NULL);\n  GST_DEBUG (\"Done finalizing\");\n}\n</code></pre>\n<p>This method is called from Java in <code>onDestroy()</code>, when the activity is\nabout to be destroyed. Here, we:</p>\n<ul>\n<li>Instruct the GLib main loop to quit with <code>g_main_loop_quit()</code>. This\ncall returns immediately, and the main loop will terminate at its\nearliest convenience.</li>\n<li>Wait for the thread to finish with\n<a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_join.html\">pthread_join()</a>.\nThis call blocks until the <code>app_function()</code> method returns, meaning\nthat the main loop has exited, and the thread has been destroyed.</li>\n<li>Dispose of the global reference we kept for the Java application\nclass (<code>Tutorial2</code>) in <code>CustomData</code>.</li>\n<li>Free <code>CustomData</code> and set the Java pointer inside the\n<code>Tutorial2</code> class to NULL with\n<code>SET_CUSTOM_DATA()</code>.</li>\n</ul>\n<h4 id=\"gst_native_play-and-gst_native_pause-nativeplay-and-nativepause-from-java\"><code>gst_native_play</code> and <code>gst_native_pause()</code> (<code>nativePlay</code> and <code>nativePause()</code> from Java)</h4>\n<p>These two simple methods retrieve <code>CustomData</code> from the passed-in object\nwith <code>GET_CUSTOM_DATA()</code> and set the pipeline found inside <code>CustomData</code>\nto the desired state, returning immediately.</p>\n<p>Finally, let\u2019s see how the GStreamer callbacks are handled:</p>\n<h4 id=\"error_cb-and-state_changed_cb\"><code>error_cb</code> and <code>state_changed_cb</code></h4>\n<p>This tutorial does not do much in these callbacks. They simply parse the\nerror or state changed message and display a message in the UI using the\n<code>set_ui_message()</code> method:</p>\n<h4 id=\"set_ui_message\"><code>set_ui_message()</code></h4>\n<pre><code class=\"language-c\">static void set_ui_message (const gchar *message, CustomData *data) {\n  JNIEnv *env = get_jni_env ();\n  GST_DEBUG (\"Setting message to: %s\", message);\n  jstring jmessage = (*env)-&gt;NewStringUTF(env, message);\n  (*env)-&gt;CallVoidMethod (env, data-&gt;app, set_message_method_id, jmessage);\n  if ((*env)-&gt;ExceptionCheck (env)) {\n    GST_ERROR (\"Failed to call Java method\");\n    (*env)-&gt;ExceptionClear (env);\n  }\n  (*env)-&gt;DeleteLocalRef (env, jmessage);\n}\n</code></pre>\n<p>This is the other method (besides <code>check_initialization_complete()</code>)\nthat needs to call a Java function from a thread which never received an\n<code>JNIEnv</code> pointer directly. Notice how all the complexities of attaching\nthe thread to the JavaVM and storing the JNI environment in the TLS are\nhidden in the simple call to <code>get_jni_env()</code>.</p>\n<p>The desired message (received in\n<a href=\"http://en.wikipedia.org/wiki/ASCII\">ASCII</a>, or modified\n<a href=\"http://en.wikipedia.org/wiki/Modified_UTF-8#Modified_UTF-8\">UTF8</a>), is\nconverted to <a href=\"http://en.wikipedia.org/wiki/UTF-16\">UTF16</a> as required by\nJava using the\n<a href=\"http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#wp17220\">NewStringUTF()</a>\nJNI call.</p>\n<p>The <code>setMessage()</code> Java method is called via the JNI\n<a href=\"http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#wp4256\">CallVoidMethod()</a>\nusing the global reference to the class we are keeping in\n<code>CustomData</code> (<code>data-&gt;app</code>) and the <code>set_message_method_id</code> we cached in\n<code>gst_native_class_init()</code>.</p>\n<p>We check for exceptions with the JNI\n<a href=\"http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#exception_check\">ExceptionCheck()</a>\nmethod and free the UTF16 message with\n<a href=\"http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#DeleteLocalRef\">DeleteLocalRef()</a>.</p>\n<h3 id=\"a-pipeline-on-android-androidmk\">A pipeline on Android [Android.mk]</h3>\n<p><strong>jni/Android.mk</strong></p>\n<pre><code class=\"language-ruby\">LOCAL_PATH := $(call my-dir)\n\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE    := tutorial-2\nLOCAL_SRC_FILES := tutorial-2.c\nLOCAL_SHARED_LIBRARIES := gstreamer_android\nLOCAL_LDLIBS := -llog\ninclude $(BUILD_SHARED_LIBRARY)\n\nifndef GSTREAMER_ROOT\nifndef GSTREAMER_ROOT_ANDROID\n$(error GSTREAMER_ROOT_ANDROID is not defined!)\nendif\nGSTREAMER_ROOT        := $(GSTREAMER_ROOT_ANDROID)\nendif\nGSTREAMER_NDK_BUILD_PATH  := $(GSTREAMER_ROOT)/share/gst-android/ndk-build/\ninclude $(GSTREAMER_NDK_BUILD_PATH)/plugins.mk\nGSTREAMER_PLUGINS         := $(GSTREAMER_PLUGINS_CORE) $(GSTREAMER_PLUGINS_SYS)\ninclude $(GSTREAMER_NDK_BUILD_PATH)/gstreamer-1.0.mk\n</code></pre>\n<p>Notice how the required <code>GSTREAMER_PLUGINS</code> are now\n<code>$(GSTREAMER_PLUGINS_CORE)</code> (For the test source and converter elements)\nand <code>$(GSTREAMER_PLUGINS_SYS)</code> (for the audio sink).</p>\n<p>And this is it! This has been a rather long tutorial, but we covered a\nlot of territory. Building on top of this one, the following ones are\nshorter and focus only on the new topics.</p>\n<h3 id=\"conclusion\">Conclusion</h3>\n<p>This tutorial has shown:</p>\n<ul>\n<li>How to manage multiple threads from C code and have them interact\nwith java.</li>\n<li>How to access Java code from any C thread\nusing <a href=\"http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/invocation.html#attach_current_thread\">AttachCurrentThread()</a>.</li>\n<li>How to allocate a CustomData structure from C and have Java host it,\nso it is available to all threads.</li>\n</ul>\n<p>Most of the methods introduced in this tutorial, like <code>get_jni_env()</code>,\n<code>check_initialization_complete()</code>, <code>app_function()</code> and the API methods\n<code>gst_native_init()</code>, <code>gst_native_finalize()</code> and\n<code>gst_native_class_init()</code> will continue to be used in the following\ntutorials with minimal modifications, so better get used to them!</p>\n<p>As usual, it has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n\t"});