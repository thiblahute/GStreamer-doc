fragment_downloaded_cb({"url": "GStreamer-doc-1.0/tutorials/basic/short-cutting-the-pipeline.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"short-cutting-the-pipeline.md\">\n<h1 id=\"basic-tutorial-8-shortcutting-the-pipeline\">Basic tutorial 8: Short-cutting the pipeline</h1>\n<h2 id=\"goal\">Goal</h2>\n<p>Pipelines constructed with GStreamer do not need to be completely\nclosed. Data can be injected into the pipeline and extracted from it at\nany time, in a variety of ways. This tutorial shows:</p>\n<ul>\n<li>\n<p>How to inject external data into a general GStreamer pipeline.</p>\n</li>\n<li>\n<p>How to extract data from a general GStreamer pipeline.</p>\n</li>\n<li>\n<p>How to access and manipulate this data.</p>\n</li>\n</ul>\n<p><a href=\"../playback/short-cutting-the-pipeline.html\">Playback tutorial 3: Short-cutting the pipeline</a> explains\nhow to achieve the same goals in a playbin-based pipeline.</p>\n<h2 id=\"introduction\">Introduction</h2>\n<p>Applications can interact with the data flowing through a GStreamer\npipeline in several ways. This tutorial describes the easiest one, since\nit uses elements that have been created for this sole purpose.</p>\n<p>The element used to inject application data into a GStreamer pipeline is\n<code>appsrc</code>, and its counterpart, used to extract GStreamer data back to\nthe application is <code>appsink</code>. To avoid confusing the names, think of it\nfrom GStreamer's point of view: <code>appsrc</code> is just a regular source, that\nprovides data magically fallen from the sky (provided by the\napplication, actually). <code>appsink</code> is a regular sink, where the data\nflowing through a GStreamer pipeline goes to die (it is recovered by the\napplication, actually).</p>\n<p><code>appsrc</code> and <code>appsink</code> are so versatile that they offer their own API\n(see their documentation), which can be accessed by linking against the\n<code>gstreamer-app</code> library. In this tutorial, however, we will use a\nsimpler approach and control them through signals.</p>\n<p><code>appsrc</code> can work in a variety of modes: in <strong>pull</strong> mode, it requests\ndata from the application every time it needs it. In <strong>push</strong> mode, the\napplication pushes data at its own pace. Furthermore, in push mode, the\napplication can choose to be blocked in the push function when enough\ndata has already been provided, or it can listen to the\n<code>enough-data</code> and <code>need-data</code> signals to control flow. This example\nimplements the latter approach. Information regarding the other methods\ncan be found in the <code>appsrc</code> documentation.</p>\n<h3 id=\"buffers\">Buffers</h3>\n<p>Data travels through a GStreamer pipeline in chunks called <strong>buffers</strong>.\nSince this example produces and consumes data, we need to know about\n<code>GstBuffer</code>s.</p>\n<p>Source Pads produce buffers, that are consumed by Sink Pads; GStreamer\ntakes these buffers and passes them from element to element.</p>\n<p>A buffer simply represents a unit of data, do not assume that all\nbuffers will have the same size, or represent the same amount of time.\nNeither should you assume that if a single buffer enters an element, a\nsingle buffer will come out. Elements are free to do with the received\nbuffers as they please. <code>GstBuffer</code>s may also contain more than one\nactual memory buffer. Actual memory buffers are abstracted away using\n<code>GstMemory</code> objects, and a <code>GstBuffer</code> can contain multiple <code>GstMemory</code> objects.</p>\n<p>Every buffer has attached time-stamps and duration, that describe in\nwhich moment the content of the buffer should be decoded, rendered or\ndisplayed. Time stamping is a very complex and delicate subject, but\nthis simplified vision should suffice for now.</p>\n<p>As an example, a <code>filesrc</code> (a GStreamer element that reads files)\nproduces buffers with the \u201cANY\u201d caps and no time-stamping information.\nAfter demuxing (see <a href=\"dynamic-pipelines.html\">Basic tutorial 3: Dynamic pipelines</a>)\nbuffers can have some specific caps, for example \u201cvideo/x-h264\u201d. After\ndecoding, each buffer will contain a single video frame with raw caps\n(for example, \u201cvideo/x-raw-yuv\u201d) and very precise time stamps indicating\nwhen should that frame be displayed.</p>\n<h3 id=\"this-tutorial\">This tutorial</h3>\n<p>This tutorial expands <a href=\"multithreading-and-pad-availability.html\">Basic tutorial 7: Multithreading and Pad Availability</a> in\ntwo ways: firstly, the <code>audiotestsrc</code> is replaced by an <code>appsrc</code> that\nwill generate the audio data. Secondly, a new branch is added to the\n<code>tee</code> so data going into the audio sink and the wave display is also\nreplicated into an <code>appsink</code>. The <code>appsink</code> uploads the information back\ninto the application, which then just notifies the user that data has\nbeen received, but it could obviously perform more complex tasks.</p>\n<p><img src=\"images/tutorials/basic-tutorial-8.png\" alt=\"\"></p>\n<h2 id=\"a-crude-waveform-generator\">A crude waveform generator</h2>\n<p>Copy this code into a text file named <code>basic-tutorial-8.c</code> (or find it\nin the SDK installation).</p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n#include &lt;gst/audio/audio.h&gt;\n#include &lt;string.h&gt;\n\n#define CHUNK_SIZE 1024   /* Amount of bytes we are sending in each buffer */\n#define SAMPLE_RATE 44100 /* Samples per second we are sending */\n\n/* Structure to contain all our information, so we can pass it to callbacks */\ntypedef struct _CustomData {\n  GstElement *pipeline, *app_source, *tee, *audio_queue, *audio_convert1, *audio_resample, *audio_sink;\n  GstElement *video_queue, *audio_convert2, *visual, *video_convert, *video_sink;\n  GstElement *app_queue, *app_sink;\n\n  guint64 num_samples;   /* Number of samples generated so far (for timestamp generation) */\n  gfloat a, b, c, d;     /* For waveform generation */\n\n  guint sourceid;        /* To control the GSource */\n\n  GMainLoop *main_loop;  /* GLib's Main Loop */\n} CustomData;\n\n/* This method is called by the idle GSource in the mainloop, to feed CHUNK_SIZE bytes into appsrc.\n * The ide handler is added to the mainloop when appsrc requests us to start sending data (need-data signal)\n * and is removed when appsrc has enough data (enough-data signal).\n */\nstatic gboolean push_data (CustomData *data) {\n  GstBuffer *buffer;\n  GstFlowReturn ret;\n  int i;\n  GstMapInfo map;\n  gint16 *raw;\n  gint num_samples = CHUNK_SIZE / 2; /* Because each sample is 16 bits */\n  gfloat freq;\n\n  /* Create a new empty buffer */\n  buffer = gst_buffer_new_and_alloc (CHUNK_SIZE);\n\n  /* Set its timestamp and duration */\n  GST_BUFFER_TIMESTAMP (buffer) = gst_util_uint64_scale (data-&gt;num_samples, GST_SECOND, SAMPLE_RATE);\n  GST_BUFFER_DURATION (buffer) = gst_util_uint64_scale (CHUNK_SIZE, GST_SECOND, SAMPLE_RATE);\n\n  /* Generate some psychodelic waveforms */\n  gst_buffer_map (buffer, &amp;map, GST_MAP_WRITE);\n  raw = (gint16 *)map.data;\n  data-&gt;c += data-&gt;d;\n  data-&gt;d -= data-&gt;c / 1000;\n  freq = 1100 + 1000 * data-&gt;d;\n  for (i = 0; i &lt; num_samples; i++) {\n    data-&gt;a += data-&gt;b;\n    data-&gt;b -= data-&gt;a / freq;\n    raw[i] = (gint16)(500 * data-&gt;a);\n  }\n  gst_buffer_unmap (buffer, &amp;map);\n  data-&gt;num_samples += num_samples;\n\n  /* Push the buffer into the appsrc */\n  g_signal_emit_by_name (data-&gt;app_source, \"push-buffer\", buffer, &amp;ret);\n\n  /* Free the buffer now that we are done with it */\n  gst_buffer_unref (buffer);\n\n  if (ret != GST_FLOW_OK) {\n    /* We got some error, stop sending data */\n    return FALSE;\n  }\n\n  return TRUE;\n}\n\n/* This signal callback triggers when appsrc needs data. Here, we add an idle handler\n * to the mainloop to start pushing data into the appsrc */\nstatic void start_feed (GstElement *source, guint size, CustomData *data) {\n  if (data-&gt;sourceid == 0) {\n    g_print (\"Start feeding\\n\");\n    data-&gt;sourceid = g_idle_add ((GSourceFunc) push_data, data);\n  }\n}\n\n/* This callback triggers when appsrc has enough data and we can stop sending.\n * We remove the idle handler from the mainloop */\nstatic void stop_feed (GstElement *source, CustomData *data) {\n  if (data-&gt;sourceid != 0) {\n    g_print (\"Stop feeding\\n\");\n    g_source_remove (data-&gt;sourceid);\n    data-&gt;sourceid = 0;\n  }\n}\n\n/* The appsink has received a buffer */\nstatic void new_sample (GstElement *sink, CustomData *data) {\n  GstSample *sample;\n\n  /* Retrieve the buffer */\n  g_signal_emit_by_name (sink, \"pull-sample\", &amp;sample);\n  if (sample) {\n    /* The only thing we do in this example is print a * to indicate a received buffer */\n    g_print (\"*\");\n    gst_buffer_unref (sample);\n  }\n}\n\n/* This function is called when an error message is posted on the bus */\nstatic void error_cb (GstBus *bus, GstMessage *msg, CustomData *data) {\n  GError *err;\n  gchar *debug_info;\n\n  /* Print error details on the screen */\n  gst_message_parse_error (msg, &amp;err, &amp;debug_info);\n  g_printerr (\"Error received from element %s: %s\\n\", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);\n  g_printerr (\"Debugging information: %s\\n\", debug_info ? debug_info : \"none\");\n  g_clear_error (&amp;err);\n  g_free (debug_info);\n\n  g_main_loop_quit (data-&gt;main_loop);\n}\n\nint main(int argc, char *argv[]) {\n  CustomData data;\n  GstPadTemplate *tee_src_pad_template;\n  GstPad *tee_audio_pad, *tee_video_pad, *tee_app_pad;\n  GstPad *queue_audio_pad, *queue_video_pad, *queue_app_pad;\n  GstAudioInfo info;\n  GstCaps *audio_caps;\n  GstBus *bus;\n\n  /* Initialize cumstom data structure */\n  memset (&amp;data, 0, sizeof (data));\n  data.b = 1; /* For waveform generation */\n  data.d = 1;\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* Create the elements */\n  data.app_source = gst_element_factory_make (\"appsrc\", \"audio_source\");\n  data.tee = gst_element_factory_make (\"tee\", \"tee\");\n  data.audio_queue = gst_element_factory_make (\"queue\", \"audio_queue\");\n  data.audio_convert1 = gst_element_factory_make (\"audioconvert\", \"audio_convert1\");\n  data.audio_resample = gst_element_factory_make (\"audioresample\", \"audio_resample\");\n  data.audio_sink = gst_element_factory_make (\"autoaudiosink\", \"audio_sink\");\n  data.video_queue = gst_element_factory_make (\"queue\", \"video_queue\");\n  data.audio_convert2 = gst_element_factory_make (\"audioconvert\", \"audio_convert2\");\n  data.visual = gst_element_factory_make (\"wavescope\", \"visual\");\n  data.video_convert = gst_element_factory_make (\"videoconvert\", \"csp\");\n  data.video_sink = gst_element_factory_make (\"autovideosink\", \"video_sink\");\n  data.app_queue = gst_element_factory_make (\"queue\", \"app_queue\");\n  data.app_sink = gst_element_factory_make (\"appsink\", \"app_sink\");\n\n  /* Create the empty pipeline */\n  data.pipeline = gst_pipeline_new (\"test-pipeline\");\n\n  if (!data.pipeline || !data.app_source || !data.tee || !data.audio_queue || !data.audio_convert1 ||\n      !data.audio_resample || !data.audio_sink || !data.video_queue || !data.audio_convert2 || !data.visual ||\n      !data.video_convert || !data.video_sink || !data.app_queue || !data.app_sink) {\n    g_printerr (\"Not all elements could be created.\\n\");\n    return -1;\n  }\n\n  /* Configure wavescope */\n  g_object_set (data.visual, \"shader\", 0, \"style\", 0, NULL);\n\n  /* Configure appsrc */\n  gst_audio_info_set_format (&amp;info, GST_AUDIO_FORMAT_S16, SAMPLE_RATE, 1, NULL);\n  audio_caps = gst_audio_info_to_caps (&amp;info);\n  g_object_set (data.app_source, \"caps\", audio_caps, \"format\", GST_FORMAT_TIME, NULL);\n  g_signal_connect (data.app_source, \"need-data\", G_CALLBACK (start_feed), &amp;data);\n  g_signal_connect (data.app_source, \"enough-data\", G_CALLBACK (stop_feed), &amp;data);\n\n  /* Configure appsink */\n  g_object_set (data.app_sink, \"emit-signals\", TRUE, \"caps\", audio_caps, NULL);\n  g_signal_connect (data.app_sink, \"new-sample\", G_CALLBACK (new_sample), &amp;data);\n  gst_caps_unref (audio_caps);\n  g_free (audio_caps_text);\n\n  /* Link all elements that can be automatically linked because they have \"Always\" pads */\n  gst_bin_add_many (GST_BIN (data.pipeline), data.app_source, data.tee, data.audio_queue, data.audio_convert1, data.audio_resample,\n      data.audio_sink, data.video_queue, data.audio_convert2, data.visual, data.video_convert, data.video_sink, data.app_queue,\n      data.app_sink, NULL);\n  if (gst_element_link_many (data.app_source, data.tee, NULL) != TRUE ||\n      gst_element_link_many (data.audio_queue, data.audio_convert1, data.audio_resample, data.audio_sink, NULL) != TRUE ||\n      gst_element_link_many (data.video_queue, data.audio_convert2, data.visual, data.video_convert, data.video_sink, NULL) != TRUE ||\n      gst_element_link_many (data.app_queue, data.app_sink, NULL) != TRUE) {\n    g_printerr (\"Elements could not be linked.\\n\");\n    gst_object_unref (data.pipeline);\n    return -1;\n  }\n\n  /* Manually link the Tee, which has \"Request\" pads */\n  tee_src_pad_template = gst_element_class_get_pad_template (GST_ELEMENT_GET_CLASS (data.tee), \"src_%d\");\n  tee_audio_pad = gst_element_request_pad (data.tee, tee_src_pad_template, NULL, NULL);\n  g_print (\"Obtained request pad %s for audio branch.\\n\", gst_pad_get_name (tee_audio_pad));\n  queue_audio_pad = gst_element_get_static_pad (data.audio_queue, \"sink\");\n  tee_video_pad = gst_element_request_pad (data.tee, tee_src_pad_template, NULL, NULL);\n  g_print (\"Obtained request pad %s for video branch.\\n\", gst_pad_get_name (tee_video_pad));\n  queue_video_pad = gst_element_get_static_pad (data.video_queue, \"sink\");\n  tee_app_pad = gst_element_request_pad (data.tee, tee_src_pad_template, NULL, NULL);\n  g_print (\"Obtained request pad %s for app branch.\\n\", gst_pad_get_name (tee_app_pad));\n  queue_app_pad = gst_element_get_static_pad (data.app_queue, \"sink\");\n  if (gst_pad_link (tee_audio_pad, queue_audio_pad) != GST_PAD_LINK_OK ||\n      gst_pad_link (tee_video_pad, queue_video_pad) != GST_PAD_LINK_OK ||\n      gst_pad_link (tee_app_pad, queue_app_pad) != GST_PAD_LINK_OK) {\n    g_printerr (\"Tee could not be linked\\n\");\n    gst_object_unref (data.pipeline);\n    return -1;\n  }\n  gst_object_unref (queue_audio_pad);\n  gst_object_unref (queue_video_pad);\n  gst_object_unref (queue_app_pad);\n\n  /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */\n  bus = gst_element_get_bus (data.pipeline);\n  gst_bus_add_signal_watch (bus);\n  g_signal_connect (G_OBJECT (bus), \"message::error\", (GCallback)error_cb, &amp;data);\n  gst_object_unref (bus);\n\n  /* Start playing the pipeline */\n  gst_element_set_state (data.pipeline, GST_STATE_PLAYING);\n\n  /* Create a GLib Main Loop and set it to run */\n  data.main_loop = g_main_loop_new (NULL, FALSE);\n  g_main_loop_run (data.main_loop);\n\n  /* Release the request pads from the Tee, and unref them */\n  gst_element_release_request_pad (data.tee, tee_audio_pad);\n  gst_element_release_request_pad (data.tee, tee_video_pad);\n  gst_element_release_request_pad (data.tee, tee_app_pad);\n  gst_object_unref (tee_audio_pad);\n  gst_object_unref (tee_video_pad);\n  gst_object_unref (tee_app_pad);\n\n  /* Free resources */\n  gst_element_set_state (data.pipeline, GST_STATE_NULL);\n  gst_object_unref (data.pipeline);\n  return 0;\n}\n</code></pre>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"Information\" id=\"information\">\nNeed help?</p>\n<p>If you need help to compile this code, refer to the <strong>Building the tutorials</strong>  section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Build\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Build\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Build\">Windows</a>, or use this specific command on Linux:</p>\n<p><code>gcc basic-tutorial-8.c -o basic-tutorial-8 `pkg-config --cflags --libs gstreamer-1.0 gst-audio-1.0`</code></p>\n<p>If you need help to run this code, refer to the <strong>Running the tutorials</strong> section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Run\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Run\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Run\">Windows</a>.</p>\n<p>This tutorial plays an audible tone for varying frequency through the audio card and opens a window with a waveform representation of the tone. The waveform should be a sinusoid, but due to the refreshing of the window might not appear so.</p>\n<p>Required libraries: <code>gstreamer-1.0</code></p>\n</blockquote>\n<h2 id=\"walkthrough\">Walkthrough</h2>\n<p>The code to create the pipeline (Lines 131 to 205) is an enlarged\nversion of <a href=\"multithreading-and-pad-availability.html\">Basic tutorial 7: Multithreading and Pad\nAvailability</a>.\nIt involves instantiating all the elements, link the elements with\nAlways Pads, and manually link the Request Pads of the <code>tee</code> element.</p>\n<p>Regarding the configuration of the <code>appsrc</code> and <code>appsink</code> elements:</p>\n<pre><code class=\"language-c\">/* Configure appsrc */\naudio_caps_text = g_strdup_printf (AUDIO_CAPS, SAMPLE_RATE);\naudio_caps = gst_caps_from_string (audio_caps_text);\ng_object_set (data.app_source, \"caps\", audio_caps, NULL);\ng_signal_connect (data.app_source, \"need-data\", G_CALLBACK (start_feed), &amp;data);\ng_signal_connect (data.app_source, \"enough-data\", G_CALLBACK (stop_feed), &amp;data);\n</code></pre>\n<p>The first property that needs to be set on the <code>appsrc</code> is <code>caps</code>. It\nspecifies the kind of data that the element is going to produce, so\nGStreamer can check if linking with downstream elements is possible\n(this is, if the downstream elements will understand this kind of data).\nThis property must be a <code>GstCaps</code> object, which is easily built from a\nstring with <code>gst_caps_from_string()</code>.</p>\n<p>We then connect to the <code>need-data</code> and <code>enough-data</code> signals. These are\nfired by <code>appsrc</code> when its internal queue of data is running low or\nalmost full, respectively. We will use these signals to start and stop\n(respectively) our signal generation process.</p>\n<pre><code class=\"language-c\">/* Configure appsink */\ng_object_set (data.app_sink, \"emit-signals\", TRUE, \"caps\", audio_caps, NULL);\ng_signal_connect (data.app_sink, \"new-sample\", G_CALLBACK (new_sample), &amp;data);\ngst_caps_unref (audio_caps);\ng_free (audio_caps_text);\n</code></pre>\n<p>Regarding the <code>appsink</code> configuration, we connect to the\n<code>new-sample</code> signal, which is emitted every time the sink receives a\nbuffer. Also, the signal emission needs to be enabled through the\n<code>emit-signals</code> property, because, by default, it is disabled.</p>\n<p>Starting the pipeline, waiting for messages and final cleanup is done as\nusual. Let's review the callbacks we have just\nregistered:</p>\n<pre><code class=\"language-c\">/* This signal callback triggers when appsrc needs data. Here, we add an idle handler\n * to the mainloop to start pushing data into the appsrc */\nstatic void start_feed (GstElement *source, guint size, CustomData *data) {\n  if (data-&gt;sourceid == 0) {\n    g_print (\"Start feeding\\n\");\n    data-&gt;sourceid = g_idle_add ((GSourceFunc) push_data, data);\n  }\n}\n</code></pre>\n<p>This function is called when the internal queue of <code>appsrc</code> is about to\nstarve (run out of data). The only thing we do here is register a GLib\nidle function with <code>g_idle_add()</code> that feeds data to <code>appsrc</code> until it\nis full again. A GLib idle function is a method that GLib will call from\nits main loop whenever it is \u201cidle\u201d, this is, when it has no\nhigher-priority tasks to perform. It requires a GLib <code>GMainLoop</code> to be\ninstantiated and running, obviously.</p>\n<p>This is only one of the multiple approaches that <code>appsrc</code> allows. In\nparticular, buffers do not need to be fed into <code>appsrc</code> from the main\nthread using GLib, and you do not need to use the <code>need-data</code> and\n<code>enough-data</code> signals to synchronize with <code>appsrc</code> (although this is\nallegedly the most convenient).</p>\n<p>We take note of the sourceid that <code>g_idle_add()</code> returns, so we can\ndisable it\nlater.</p>\n<pre><code class=\"language-c\">/* This callback triggers when appsrc has enough data and we can stop sending.\n * We remove the idle handler from the mainloop */\nstatic void stop_feed (GstElement *source, CustomData *data) {\n  if (data-&gt;sourceid != 0) {\n    g_print (\"Stop feeding\\n\");\n    g_source_remove (data-&gt;sourceid);\n    data-&gt;sourceid = 0;\n  }\n}\n</code></pre>\n<p>This function is called when the internal queue of <code>appsrc</code> is full\nenough so we stop pushing data. Here we simply remove the idle function\nby using <code>g_source_remove()</code> (The idle function is implemented as a\n<code>GSource</code>).</p>\n<pre><code class=\"language-c\">/* This method is called by the idle GSource in the mainloop, to feed CHUNK_SIZE bytes into appsrc.\n * The ide handler is added to the mainloop when appsrc requests us to start sending data (need-data signal)\n * and is removed when appsrc has enough data (enough-data signal).\n */\nstatic gboolean push_data (CustomData *data) {\n  GstBuffer *buffer;\n  GstFlowReturn ret;\n  int i;\n  gint16 *raw;\n  gint num_samples = CHUNK_SIZE / 2; /* Because each sample is 16 bits */\n  gfloat freq;\n\n  /* Create a new empty buffer */\n  buffer = gst_buffer_new_and_alloc (CHUNK_SIZE);\n\n  /* Set its timestamp and duration */\n  GST_BUFFER_TIMESTAMP (buffer) = gst_util_uint64_scale (data-&gt;num_samples, GST_SECOND, SAMPLE_RATE);\n  GST_BUFFER_DURATION (buffer) = gst_util_uint64_scale (CHUNK_SIZE, GST_SECOND, SAMPLE_RATE);\n\n  /* Generate some psychodelic waveforms */\n  raw = (gint16 *)GST_BUFFER_DATA (buffer);\n</code></pre>\n<p>This is the function that feeds <code>appsrc</code>. It will be called by GLib at\ntimes and rates which are out of our control, but we know that we will\ndisable it when its job is done (when the queue in <code>appsrc</code> is full).</p>\n<p>Its first task is to create a new buffer with a given size (in this\nexample, it is arbitrarily set to 1024 bytes) with\n<code>gst_buffer_new_and_alloc()</code>.</p>\n<p>We count the number of samples that we have generated so far with the\n<code>CustomData.num_samples</code> variable, so we can time-stamp this buffer\nusing the <code>GST_BUFFER_TIMESTAMP</code> macro in <code>GstBuffer</code>.</p>\n<p>Since we are producing buffers of the same size, their duration is the\nsame and is set using the <code>GST_BUFFER_DURATION</code> in <code>GstBuffer</code>.</p>\n<p><code>gst_util_uint64_scale()</code> is a utility function that scales (multiply\nand divide) numbers which can be large, without fear of overflows.</p>\n<p>The bytes that for the buffer can be accessed with GST_BUFFER_DATA in\n<code>GstBuffer</code> (Be careful not to write past the end of the buffer: you\nallocated it, so you know its size).</p>\n<p>We will skip over the waveform generation, since it is outside the scope\nof this tutorial (it is simply a funny way of generating a pretty\npsychedelic wave).</p>\n<pre><code class=\"language-c\">/* Push the buffer into the appsrc */\ng_signal_emit_by_name (data-&gt;app_source, \"push-buffer\", buffer, &amp;ret);\n\n/* Free the buffer now that we are done with it */\ngst_buffer_unref (buffer);\n</code></pre>\n<p>Once we have the buffer ready, we pass it to <code>appsrc</code> with the\n<code>push-buffer</code> action signal (see information box at the end of <a href=\"../playback/playbin-usage.html\">Playback tutorial 1: Playbin usage</a>), and then\n<code>gst_buffer_unref()</code> it since we no longer need it.</p>\n<pre><code class=\"language-c\">/* The appsink has received a buffer */\nstatic void new_sample (GstElement *sink, CustomData *data) {\n  GstSample *sample;\n  /* Retrieve the buffer */\n  g_signal_emit_by_name (sink, \"pull-sample\", &amp;sample);\n  if (sample) {\n    /* The only thing we do in this example is print a * to indicate a received buffer */\n    g_print (\"*\");\n    gst_sample_unref (sample);\n  }\n}\n</code></pre>\n<p>Finally, this is the function that gets called when the\n<code>appsink</code> receives a buffer. We use the <code>pull-sample</code> action signal to\nretrieve the buffer and then just print some indicator on the screen. We\ncan retrieve the data pointer using the <code>GST_BUFFER_DATA</code> macro and the\ndata size using the <code>GST_BUFFER_SIZE</code> macro in <code>GstBuffer</code>. Remember\nthat this buffer does not have to match the buffer that we produced in\nthe <code>push_data</code> function, any element in the path could have altered the\nbuffers in any way (Not in this example: there is only a <code>tee</code> in the\npath between <code>appsrc</code> and <code>appsink</code>, and it does not change the content\nof the buffers).</p>\n<p>We then <code>gst_buffer_unref()</code> the buffer, and this tutorial is done.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial has shown how applications can:</p>\n<ul>\n<li>Inject data into a pipeline using the <code>appsrc</code>element.</li>\n<li>Retrieve data from a pipeline using the <code>appsink</code> element.</li>\n<li>Manipulate this data by accessing the <code>GstBuffer</code>.</li>\n</ul>\n<p>In a playbin-based pipeline, the same goals are achieved in a slightly\ndifferent way. <a href=\"../playback/short-cutting-the-pipeline.html\">Playback tutorial 3: Short-cutting the pipeline</a> shows\nhow to do it.</p>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n\t"});