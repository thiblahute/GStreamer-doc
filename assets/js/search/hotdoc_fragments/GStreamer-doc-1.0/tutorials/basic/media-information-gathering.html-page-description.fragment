fragment_downloaded_cb({"url": "GStreamer-doc-1.0/tutorials/basic/media-information-gathering.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"media-information-gathering.md\">\n<h1 id=\"basic-tutorial-9-media-information-gathering\">Basic tutorial 9: Media information gathering</h1>\n<h2 id=\"goal\">Goal</h2>\n<p>Sometimes you might want to quickly find out what kind of media a file\n(or URI) contains, or if you will be able to play the media at all. You\ncan build a pipeline, set it to run, and watch the bus messages, but\nGStreamer has a utility that does just that for you. This tutorial\nshows:</p>\n<ul>\n<li>\n<p>How to recover information regarding a URI</p>\n</li>\n<li>\n<p>How to find out if a URI is playable</p>\n</li>\n</ul>\n<h2 id=\"introduction\">Introduction</h2>\n<p><code>GstDiscoverer</code> is a utility object found in the <code>pbutils</code> library\n(Plug-in Base utilities) that accepts a URI or list of URIs, and returns\ninformation about them. It can work in synchronous or asynchronous\nmodes.</p>\n<p>In synchronous mode, there is only a single function to call,\n<code>gst_discoverer_discover_uri()</code>, which blocks until the information is\nready. Due to this blocking, it is usually less interesting for\nGUI-based applications and the asynchronous mode is used, as described\nin this tutorial.</p>\n<p>The recovered information includes codec descriptions, stream topology\n(number of streams and sub-streams) and available metadata (like the\naudio language).</p>\n<p>As an example, this is the result\nof discovering https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm</p>\n<pre><code>Duration: 0:00:52.250000000\nTags:\n  video codec: On2 VP8\n  language code: en\n  container format: Matroska\n  application name: ffmpeg2theora-0.24\n  encoder: Xiph.Org libVorbis I 20090709\n  encoder version: 0\n  audio codec: Vorbis\n  nominal bitrate: 80000\n  bitrate: 80000\nSeekable: yes\nStream information:\n  container: WebM\n    audio: Vorbis\n      Tags:\n        language code: en\n        container format: Matroska\n        audio codec: Vorbis\n        application name: ffmpeg2theora-0.24\n        encoder: Xiph.Org libVorbis I 20090709\n        encoder version: 0\n        nominal bitrate: 80000\n        bitrate: 80000\n    video: VP8\n      Tags:\n        video codec: VP8 video\n        container format: Matroska\n</code></pre>\n<p>The following code tries to discover the URI provided through the\ncommand line, and outputs the retrieved information (If no URI is\nprovided it uses a default one).</p>\n<p>This is a simplified version of what the <code>gst-discoverer-1.0</code> tool does\n(<a href=\"gstreamer-tools.html\">Basic tutorial 10: GStreamer tools</a>), which is\nan application that only displays data, but does not perform any\nplayback.</p>\n<h2 id=\"the-gstreamer-discoverer\">The GStreamer Discoverer</h2>\n<p>Copy this code into a text file named <code>basic-tutorial-9.c</code> (or find it\nin the SDK installation).</p>\n<p><strong>basic-tutorial-9.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;string.h&gt;\n#include &lt;gst/gst.h&gt;\n#include &lt;gst/pbutils/pbutils.h&gt;\n\n/* Structure to contain all our information, so we can pass it around */\ntypedef struct _CustomData {\n  GstDiscoverer *discoverer;\n  GMainLoop *loop;\n} CustomData;\n\n/* Print a tag in a human-readable format (name: value) */\nstatic void print_tag_foreach (const GstTagList *tags, const gchar *tag, gpointer user_data) {\n  GValue val = { 0, };\n  gchar *str;\n  gint depth = GPOINTER_TO_INT (user_data);\n\n  gst_tag_list_copy_value (&amp;val, tags, tag);\n\n  if (G_VALUE_HOLDS_STRING (&amp;val))\n    str = g_value_dup_string (&amp;val);\n  else\n    str = gst_value_serialize (&amp;val);\n\n  g_print (\"%*s%s: %s\\n\", 2 * depth, \" \", gst_tag_get_nick (tag), str);\n  g_free (str);\n\n  g_value_unset (&amp;val);\n}\n\n/* Print information regarding a stream */\nstatic void print_stream_info (GstDiscovererStreamInfo *info, gint depth) {\n  gchar *desc = NULL;\n  GstCaps *caps;\n  const GstTagList *tags;\n\n  caps = gst_discoverer_stream_info_get_caps (info);\n\n  if (caps) {\n    if (gst_caps_is_fixed (caps))\n      desc = gst_pb_utils_get_codec_description (caps);\n    else\n      desc = gst_caps_to_string (caps);\n    gst_caps_unref (caps);\n  }\n\n  g_print (\"%*s%s: %s\\n\", 2 * depth, \" \", gst_discoverer_stream_info_get_stream_type_nick (info), (desc ? desc : \"\"));\n\n  if (desc) {\n    g_free (desc);\n    desc = NULL;\n  }\n\n  tags = gst_discoverer_stream_info_get_tags (info);\n  if (tags) {\n    g_print (\"%*sTags:\\n\", 2 * (depth + 1), \" \");\n    gst_tag_list_foreach (tags, print_tag_foreach, GINT_TO_POINTER (depth + 2));\n  }\n}\n\n/* Print information regarding a stream and its substreams, if any */\nstatic void print_topology (GstDiscovererStreamInfo *info, gint depth) {\n  GstDiscovererStreamInfo *next;\n\n  if (!info)\n    return;\n\n  print_stream_info (info, depth);\n\n  next = gst_discoverer_stream_info_get_next (info);\n  if (next) {\n    print_topology (next, depth + 1);\n    gst_discoverer_stream_info_unref (next);\n  } else if (GST_IS_DISCOVERER_CONTAINER_INFO (info)) {\n    GList *tmp, *streams;\n\n    streams = gst_discoverer_container_info_get_streams (GST_DISCOVERER_CONTAINER_INFO (info));\n    for (tmp = streams; tmp; tmp = tmp-&gt;next) {\n      GstDiscovererStreamInfo *tmpinf = (GstDiscovererStreamInfo *) tmp-&gt;data;\n      print_topology (tmpinf, depth + 1);\n    }\n    gst_discoverer_stream_info_list_free (streams);\n  }\n}\n\n/* This function is called every time the discoverer has information regarding\n * one of the URIs we provided.*/\nstatic void on_discovered_cb (GstDiscoverer *discoverer, GstDiscovererInfo *info, GError *err, CustomData *data) {\n  GstDiscovererResult result;\n  const gchar *uri;\n  const GstTagList *tags;\n  GstDiscovererStreamInfo *sinfo;\n\n  uri = gst_discoverer_info_get_uri (info);\n  result = gst_discoverer_info_get_result (info);\n  switch (result) {\n    case GST_DISCOVERER_URI_INVALID:\n      g_print (\"Invalid URI '%s'\\n\", uri);\n      break;\n    case GST_DISCOVERER_ERROR:\n      g_print (\"Discoverer error: %s\\n\", err-&gt;message);\n      break;\n    case GST_DISCOVERER_TIMEOUT:\n      g_print (\"Timeout\\n\");\n      break;\n    case GST_DISCOVERER_BUSY:\n      g_print (\"Busy\\n\");\n      break;\n    case GST_DISCOVERER_MISSING_PLUGINS:{\n      const GstStructure *s;\n      gchar *str;\n\n      s = gst_discoverer_info_get_misc (info);\n      str = gst_structure_to_string (s);\n\n      g_print (\"Missing plugins: %s\\n\", str);\n      g_free (str);\n      break;\n    }\n    case GST_DISCOVERER_OK:\n      g_print (\"Discovered '%s'\\n\", uri);\n      break;\n  }\n\n  if (result != GST_DISCOVERER_OK) {\n    g_printerr (\"This URI cannot be played\\n\");\n    return;\n  }\n\n  /* If we got no error, show the retrieved information */\n\n  g_print (\"\\nDuration: %\" GST_TIME_FORMAT \"\\n\", GST_TIME_ARGS (gst_discoverer_info_get_duration (info)));\n\n  tags = gst_discoverer_info_get_tags (info);\n  if (tags) {\n    g_print (\"Tags:\\n\");\n    gst_tag_list_foreach (tags, print_tag_foreach, GINT_TO_POINTER (1));\n  }\n\n  g_print (\"Seekable: %s\\n\", (gst_discoverer_info_get_seekable (info) ? \"yes\" : \"no\"));\n\n  g_print (\"\\n\");\n\n  sinfo = gst_discoverer_info_get_stream_info (info);\n  if (!sinfo)\n    return;\n\n  g_print (\"Stream information:\\n\");\n\n  print_topology (sinfo, 1);\n\n  gst_discoverer_stream_info_unref (sinfo);\n\n  g_print (\"\\n\");\n}\n\n/* This function is called when the discoverer has finished examining\n * all the URIs we provided.*/\nstatic void on_finished_cb (GstDiscoverer *discoverer, CustomData *data) {\n  g_print (\"Finished discovering\\n\");\n\n  g_main_loop_quit (data-&gt;loop);\n}\n\nint main (int argc, char **argv) {\n  CustomData data;\n  GError *err = NULL;\n  gchar *uri = \"https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm\";\n\n  /* if a URI was provided, use it instead of the default one */\n  if (argc &gt; 1) {\n    uri = argv[1];\n  }\n\n  /* Initialize cumstom data structure */\n  memset (&amp;data, 0, sizeof (data));\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  g_print (\"Discovering '%s'\\n\", uri);\n\n  /* Instantiate the Discoverer */\n  data.discoverer = gst_discoverer_new (5 * GST_SECOND, &amp;err);\n  if (!data.discoverer) {\n    g_print (\"Error creating discoverer instance: %s\\n\", err-&gt;message);\n    g_clear_error (&amp;err);\n    return -1;\n  }\n\n  /* Connect to the interesting signals */\n  g_signal_connect (data.discoverer, \"discovered\", G_CALLBACK (on_discovered_cb), &amp;data);\n  g_signal_connect (data.discoverer, \"finished\", G_CALLBACK (on_finished_cb), &amp;data);\n\n  /* Start the discoverer process (nothing to do yet) */\n  gst_discoverer_start (data.discoverer);\n\n  /* Add a request to process asynchronously the URI passed through the command line */\n  if (!gst_discoverer_discover_uri_async (data.discoverer, uri)) {\n    g_print (\"Failed to start discovering URI '%s'\\n\", uri);\n    g_object_unref (data.discoverer);\n    return -1;\n  }\n\n  /* Create a GLib Main Loop and set it to run, so we can wait for the signals */\n  data.loop = g_main_loop_new (NULL, FALSE);\n  g_main_loop_run (data.loop);\n\n  /* Stop the discoverer process */\n  gst_discoverer_stop (data.discoverer);\n\n  /* Free resources */\n  g_object_unref (data.discoverer);\n  g_main_loop_unref (data.loop);\n\n  return 0;\n}\n</code></pre>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"Information\" id=\"information\">\nNeed help?</p>\n<p>If you need help to compile this code, refer to the <strong>Building the tutorials</strong>  section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Build\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Build\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Build\">Windows</a>, or use this specific command on Linux:</p>\n<p><code>gcc basic-tutorial-9.c -o basic-tutorial-9 `pkg-config --cflags --libs gstreamer-1.0 gstreamer-pbutils-1.0`</code></p>\n<p>If you need help to run this code, refer to the <strong>Running the tutorials</strong> section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Run\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Run\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Run\">Windows</a>.</p>\n<p>This tutorial opens the URI passed as the first parameter in the command line (or a default URI if none is provided) and outputs information about it on the screen. If the media is located on the Internet, the application might take a bit to react depending on your connection speed.</p>\n<p>Required libraries: <code>gstreamer-pbutils-1.0</code> <code>gstreamer-1.0</code></p>\n</blockquote>\n<h2 id=\"walkthrough\">Walkthrough</h2>\n<p>These are the main steps to use the <code>GstDiscoverer</code>:</p>\n<pre><code class=\"language-c\">/* Instantiate the Discoverer */\ndata.discoverer = gst_discoverer_new (5 * GST_SECOND, &amp;err);\nif (!data.discoverer) {\n  g_print (\"Error creating discoverer instance: %s\\n\", err-&gt;message);\n  g_clear_error (&amp;err);\n  return -1;\n}\n</code></pre>\n<p><code>gst_discoverer_new()</code> creates a new Discoverer object. The first\nparameter is the timeout per file, in nanoseconds (use the\n<code>GST_SECOND</code> macro for simplicity).</p>\n<pre><code class=\"language-c\">/* Connect to the interesting signals */\ng_signal_connect (data.discoverer, \"discovered\", G_CALLBACK (on_discovered_cb), &amp;data);\ng_signal_connect (data.discoverer, \"finished\", G_CALLBACK (on_finished_cb), &amp;data);\n</code></pre>\n<p>Connect to the interesting signals, as usual. We discuss them in the\nsnippet for their callbacks.</p>\n<pre><code class=\"language-c\">/* Start the discoverer process (nothing to do yet) */\ngst_discoverer_start (data.discoverer);\n</code></pre>\n<p><code>gst_discoverer_start()</code> launches the discovering process, but we have\nnot provided any URI to discover yet. This is done\nnext:</p>\n<pre><code class=\"language-c\">/* Add a request to process asynchronously the URI passed through the command line */\nif (!gst_discoverer_discover_uri_async (data.discoverer, uri)) {\n  g_print (\"Failed to start discovering URI '%s'\\n\", uri);\n  g_object_unref (data.discoverer);\n  return -1;\n}\n</code></pre>\n<p><code>gst_discoverer_discover_uri_async()</code> enqueues the provided URI for\ndiscovery. Multiple URIs can be enqueued with this function. As the\ndiscovery process for each of them finishes, the registered callback\nfunctions will be fired\nup.</p>\n<pre><code class=\"language-c\">/* Create a GLib Main Loop and set it to run, so we can wait for the signals */\ndata.loop = g_main_loop_new (NULL, FALSE);\ng_main_loop_run (data.loop);\n</code></pre>\n<p>The usual GLib main loop is instantiated and executed. We will get out\nof it when <code>g_main_loop_quit()</code> is called from the\n<code>on_finished_cb</code> callback.</p>\n<pre><code class=\"language-c\">/* Stop the discoverer process */\ngst_discoverer_stop (data.discoverer);\n</code></pre>\n<p>Once we are done with the discoverer, we stop it with\n<code>gst_discoverer_stop()</code> and unref it with <code>g_object_unref()</code>.</p>\n<p>Let's review now the callbacks we have\nregistered:</p>\n<pre><code class=\"language-c\">/* This function is called every time the discoverer has information regarding\n * one of the URIs we provided.*/\nstatic void on_discovered_cb (GstDiscoverer *discoverer, GstDiscovererInfo *info, GError *err, CustomData *data) {\n  GstDiscovererResult result;\n  const gchar *uri;\n  const GstTagList *tags;\n  GstDiscovererStreamInfo *sinfo;\n\n  uri = gst_discoverer_info_get_uri (info);\n  result = gst_discoverer_info_get_result (info);\n</code></pre>\n<p>We got here because the Discoverer has finished working on one URI, and\nprovides us a <code>GstDiscovererInfo</code> structure with all the information.</p>\n<p>The first step is to retrieve the particular URI this call refers to (in\ncase we had multiple discover process running, which is not the case in\nthis example) with <code>gst_discoverer_info_get_uri()</code> and the discovery\nresult with <code>gst_discoverer_info_get_result()</code>.</p>\n<pre><code class=\"language-c\">switch (result) {\n  case GST_DISCOVERER_URI_INVALID:\n    g_print (\"Invalid URI '%s'\\n\", uri);\n    break;\n  case GST_DISCOVERER_ERROR:\n    g_print (\"Discoverer error: %s\\n\", err-&gt;message);\n    break;\n  case GST_DISCOVERER_TIMEOUT:\n    g_print (\"Timeout\\n\");\n    break;\n  case GST_DISCOVERER_BUSY:\n    g_print (\"Busy\\n\");\n    break;\n  case GST_DISCOVERER_MISSING_PLUGINS:{\n    const GstStructure *s;\n    gchar *str;\n\n    s = gst_discoverer_info_get_misc (info);\n    str = gst_structure_to_string (s);\n\n    g_print (\"Missing plugins: %s\\n\", str);\n    g_free (str);\n    break;\n  }\n  case GST_DISCOVERER_OK:\n    g_print (\"Discovered '%s'\\n\", uri);\n    break;\n}\n\nif (result != GST_DISCOVERER_OK) {\n  g_printerr (\"This URI cannot be played\\n\");\n  return;\n}\n</code></pre>\n<p>As the code shows, any result other than <code>GST_DISCOVERER_OK</code> means that\nthere has been some kind of problem, and this URI cannot be played. The\nreasons can vary, but the enum values are quite explicit\n(<code>GST_DISCOVERER_BUSY</code> can only happen when in synchronous mode, which\nis not used in this example).</p>\n<p>If no error happened, information can be retrieved from the\n<code>GstDiscovererInfo</code> structure with the different\n<code>gst_discoverer_info_get_*</code> methods (like,\n<code>gst_discoverer_info_get_duration()</code>, for example).</p>\n<p>Bits of information which are made of lists, like tags and stream info,\nneeds some extra parsing:</p>\n<pre><code class=\"language-c\">tags = gst_discoverer_info_get_tags (info);\nif (tags) {\n  g_print (\"Tags:\\n\");\n  gst_tag_list_foreach (tags, print_tag_foreach, GINT_TO_POINTER (1));\n}\n</code></pre>\n<p>Tags are metadata (labels) attached to the media. They can be examined\nwith <code>gst_tag_list_foreach()</code>, which will call <code>print_tag_foreach</code> for\neach tag found (the list could also be traversed manually, for example,\nor a specific tag could be searched for with\n<code>gst_tag_list_get_string()</code>). The code for <code>print_tag_foreach</code> is pretty\nmuch self-explicative.</p>\n<pre><code class=\"language-c\">sinfo = gst_discoverer_info_get_stream_info (info);\nif (!sinfo)\n  return;\n\ng_print (\"Stream information:\\n\");\n\nprint_topology (sinfo, 1);\n\ngst_discoverer_stream_info_unref (sinfo);\n</code></pre>\n<p><code>gst_discoverer_info_get_stream_info()</code> returns\na <code>GstDiscovererStreamInfo</code> structure that is parsed in\nthe <code>print_topology</code> function, and then discarded\nwith <code>gst_discoverer_stream_info_unref()</code>.</p>\n<pre><code class=\"language-c\">/* Print information regarding a stream and its substreams, if any */\nstatic void print_topology (GstDiscovererStreamInfo *info, gint depth) {\n  GstDiscovererStreamInfo *next;\n\n  if (!info)\n    return;\n\n  print_stream_info (info, depth);\n\n  next = gst_discoverer_stream_info_get_next (info);\n  if (next) {\n    print_topology (next, depth + 1);\n    gst_discoverer_stream_info_unref (next);\n  } else if (GST_IS_DISCOVERER_CONTAINER_INFO (info)) {\n    GList *tmp, *streams;\n\n    streams = gst_discoverer_container_info_get_streams (GST_DISCOVERER_CONTAINER_INFO (info));\n    for (tmp = streams; tmp; tmp = tmp-&gt;next) {\n      GstDiscovererStreamInfo *tmpinf = (GstDiscovererStreamInfo *) tmp-&gt;data;\n      print_topology (tmpinf, depth + 1);\n    }\n    gst_discoverer_stream_info_list_free (streams);\n  }\n}\n</code></pre>\n<p>The <code>print_stream_info</code> function's code is also pretty much\nself-explicative: it prints the stream's capabilities and then the\nassociated caps, using <code>print_tag_foreach</code> too.</p>\n<p>Then, <code>print_topology</code> looks for the next element to display. If\n<code>gst_discoverer_stream_info_get_next()</code> returns a non-NULL stream info,\nit refers to our descendant and that should be displayed. Otherwise, if\nwe are a container, recursively call <code>print_topology</code> on each of our\nchildren obatined with <code>gst_discoverer_container_info_get_streams()</code>.\nOtherwise, we are a final stream, and do not need to recurse (This part\nof the Discoverer API is admittedly a bit obscure).</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial has shown:</p>\n<ul>\n<li>\n<p>How to recover information regarding a URI using the <code>GstDiscoverer</code></p>\n</li>\n<li>\n<p>How to find out if a URI is playable by looking at the return code\nobtained with <code>gst_discoverer_info_get_result()</code>.</p>\n</li>\n</ul>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n\t"});