fragment_downloaded_cb({"url": "GStreamer-doc-1.0/tutorials/basic/playback-speed.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"playback-speed.md\">\n<h1 id=\"basic-tutorial-13-playback-speed\">Basic tutorial 13: Playback speed</h1>\n<h2 id=\"goal\">Goal</h2>\n<p>Fast-forward, reverse-playback and slow-motion are all techniques\ncollectively known as <em>trick modes</em> and they all have in common that\nmodify the normal playback rate. This tutorial shows how to achieve\nthese effects and adds frame-stepping into the deal. In particular, it\nshows:</p>\n<ul>\n<li>How to change the playback rate, faster and slower than normal,\nforward and backwards.</li>\n<li>How to advance a video frame-by-frame</li>\n</ul>\n<h2 id=\"introduction\">Introduction</h2>\n<p>Fast-forward is the technique that plays a media at a speed higher than\nits normal (intended) speed; whereas slow-motion uses a speed lower than\nthe intended one. Reverse playback does the same thing but backwards,\nfrom the end of the stream to the beginning.</p>\n<p>All these techniques do is change the playback rate, which is a variable\nequal to 1.0 for normal playback, greater than 1.0 (in absolute value)\nfor fast modes, lower than 1.0 (in absolute value) for slow modes,\npositive for forward playback and negative for reverse playback.</p>\n<p>GStreamer provides two mechanisms to change the playback rate: Step\nEvents and Seek Events. Step Events allow skipping a given amount of\nmedia besides changing the subsequent playback rate (only to positive\nvalues). Seek Events, additionally, allow jumping to any position in the\nstream and set positive and negative playback rates.</p>\n<p>In <a href=\"time-management.html\">Basic tutorial 4: Time management</a> seek\nevents have already been shown, using a helper function to hide their\ncomplexity. This tutorial explains a bit more how to use these events.</p>\n<p>Step Events are a more convenient way of changing the playback rate,\ndue to the reduced number of parameters needed to create them;\nhowever, they have some downsides, so Seek Events are used in this\ntutorial instead. Step events only affect the sink (at the end of the\npipeline), so they will only work if the rest of the pipeline can\nsupport going at a different speed, Seek events go all the way through\nthe pipeline so every element can react to them. The upside of Step\nevents is that they are much faster to act. Step events are also\nunable to change the playback direction.</p>\n<p>To use these events, they are created and then passed onto the pipeline,\nwhere they propagate upstream until they reach an element that can\nhandle them. If an event is passed onto a bin element like <code>playbin</code>,\nit will simply feed the event to all its sinks, which will result in\nmultiple seeks being performed. The common approach is to retrieve one\nof <code>playbin</code>\u2019s sinks through the <code>video-sink</code> or\n<code>audio-sink</code> properties and feed the event directly into the sink.</p>\n<p>Frame stepping is a technique that allows playing a video frame by\nframe. It is implemented by pausing the pipeline, and then sending Step\nEvents to skip one frame each time.</p>\n<h2 id=\"a-trick-mode-player\">A trick mode player</h2>\n<p>Copy this code into a text file named <code>basic-tutorial-13.c</code>.</p>\n<p><strong>basic-tutorial-13.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;gst/gst.h&gt;\n\ntypedef struct _CustomData {\n  GstElement *pipeline;\n  GstElement *video_sink;\n  GMainLoop *loop;\n\n  gboolean playing;  /* Playing or Paused */\n  gdouble rate;      /* Current playback rate (can be negative) */\n} CustomData;\n\n/* Send seek event to change rate */\nstatic void send_seek_event (CustomData *data) {\n  gint64 position;\n  GstFormat format = GST_FORMAT_TIME;\n  GstEvent *seek_event;\n\n  /* Obtain the current position, needed for the seek event */\n  if (!gst_element_query_position (data-&gt;pipeline, &amp;format, &amp;position)) {\n    g_printerr (\"Unable to retrieve current position.\\n\");\n    return;\n  }\n\n  /* Create the seek event */\n  if (data-&gt;rate &gt; 0) {\n    seek_event = gst_event_new_seek (data-&gt;rate, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_ACCURATE,\n        GST_SEEK_TYPE_SET, position, GST_SEEK_TYPE_NONE, 0);\n  } else {\n    seek_event = gst_event_new_seek (data-&gt;rate, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_ACCURATE,\n        GST_SEEK_TYPE_SET, 0, GST_SEEK_TYPE_SET, position);\n  }\n\n  if (data-&gt;video_sink == NULL) {\n    /* If we have not done so, obtain the sink through which we will send the seek events */\n    g_object_get (data-&gt;pipeline, \"video-sink\", &amp;data-&gt;video_sink, NULL);\n  }\n\n  /* Send the event */\n  gst_element_send_event (data-&gt;video_sink, seek_event);\n\n  g_print (\"Current rate: %g\\n\", data-&gt;rate);\n}\n\n/* Process keyboard input */\nstatic gboolean handle_keyboard (GIOChannel *source, GIOCondition cond, CustomData *data) {\n  gchar *str = NULL;\n\n  if (g_io_channel_read_line (source, &amp;str, NULL, NULL, NULL) != G_IO_STATUS_NORMAL) {\n    return TRUE;\n  }\n\n  switch (g_ascii_tolower (str[0])) {\n  case 'p':\n    data-&gt;playing = !data-&gt;playing;\n    gst_element_set_state (data-&gt;pipeline, data-&gt;playing ? GST_STATE_PLAYING : GST_STATE_PAUSED);\n    g_print (\"Setting state to %s\\n\", data-&gt;playing ? \"PLAYING\" : \"PAUSE\");\n    break;\n  case 's':\n    if (g_ascii_isupper (str[0])) {\n      data-&gt;rate *= 2.0;\n    } else {\n      data-&gt;rate /= 2.0;\n    }\n    send_seek_event (data);\n    break;\n  case 'd':\n    data-&gt;rate *= -1.0;\n    send_seek_event (data);\n    break;\n  case 'n':\n    if (data-&gt;video_sink == NULL) {\n      /* If we have not done so, obtain the sink through which we will send the step events */\n      g_object_get (data-&gt;pipeline, \"video-sink\", &amp;data-&gt;video_sink, NULL);\n    }\n\n    gst_element_send_event (data-&gt;video_sink,\n        gst_event_new_step (GST_FORMAT_BUFFERS, 1, data-&gt;rate, TRUE, FALSE));\n    g_print (\"Stepping one frame\\n\");\n    break;\n  case 'q':\n    g_main_loop_quit (data-&gt;loop);\n    break;\n  default:\n    break;\n  }\n\n  g_free (str);\n\n  return TRUE;\n}\n\nint main(int argc, char *argv[]) {\n  CustomData data;\n  GstStateChangeReturn ret;\n  GIOChannel *io_stdin;\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* Initialize our data structure */\n  memset (&amp;data, 0, sizeof (data));\n\n  /* Print usage map */\n  g_print (\n    \"USAGE: Choose one of the following options, then press enter:\\n\"\n    \" 'P' to toggle between PAUSE and PLAY\\n\"\n    \" 'S' to increase playback speed, 's' to decrease playback speed\\n\"\n    \" 'D' to toggle playback direction\\n\"\n    \" 'N' to move to next frame (in the current direction, better in PAUSE)\\n\"\n    \" 'Q' to quit\\n\");\n\n  /* Build the pipeline */\n  data.pipeline = gst_parse_launch (\"playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm\", NULL);\n\n  /* Add a keyboard watch so we get notified of keystrokes */\n#ifdef G_OS_WIN32\n  io_stdin = g_io_channel_win32_new_fd (fileno (stdin));\n#else\n  io_stdin = g_io_channel_unix_new (fileno (stdin));\n#endif\n  g_io_add_watch (io_stdin, G_IO_IN, (GIOFunc)handle_keyboard, &amp;data);\n\n  /* Start playing */\n  ret = gst_element_set_state (data.pipeline, GST_STATE_PLAYING);\n  if (ret == GST_STATE_CHANGE_FAILURE) {\n    g_printerr (\"Unable to set the pipeline to the playing state.\\n\");\n    gst_object_unref (data.pipeline);\n    return -1;\n  }\n  data.playing = TRUE;\n  data.rate = 1.0;\n\n  /* Create a GLib Main Loop and set it to run */\n  data.loop = g_main_loop_new (NULL, FALSE);\n  g_main_loop_run (data.loop);\n\n  /* Free resources */\n  g_main_loop_unref (data.loop);\n  g_io_channel_unref (io_stdin);\n  gst_element_set_state (data.pipeline, GST_STATE_NULL);\n  if (data.video_sink != NULL)\n    gst_object_unref (data.video_sink);\n  gst_object_unref (data.pipeline);\n  return 0;\n}\n</code></pre>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"Information\" id=\"information\">\nNeed help?</p>\n<p>If you need help to compile this code, refer to the <strong>Building the tutorials</strong>  section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Build\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Build\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Build\">Windows</a>, or use this specific command on Linux:</p>\n<p><code>gcc basic-tutorial-13.c -o basic-tutorial-13 `pkg-config --cflags --libs gstreamer-1.0`</code></p>\n<p>If you need help to run this code, refer to the <strong>Running the tutorials</strong> section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Run\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Run\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Run\">Windows</a>.</p>\n<p>This tutorial opens a window and displays a movie, with accompanying audio. The media is fetched from the Internet, so the window might take a few seconds to appear, depending on your connection speed. The console shows the available commands, composed of a single upper-case or lower-case letter, which you should input followed by the Enter key.</p>\n<p>Required libraries: <code>gstreamer-1.0</code></p>\n</blockquote>\n<h2 id=\"walkthrough\">Walkthrough</h2>\n<p>There is nothing new in the initialization code in the main function:  a\n<code>playbin</code> pipeline is instantiated, an I/O watch is installed to track\nkeystrokes and a GLib main loop is executed.</p>\n<p>Then, in the keyboard handler function:</p>\n<pre><code class=\"language-c\">/* Process keyboard input */\nstatic gboolean handle_keyboard (GIOChannel *source, GIOCondition cond, CustomData *data) {\n  gchar *str = NULL;\n\n  if (g_io_channel_read_line (source, &amp;str, NULL, NULL, NULL) != G_IO_STATUS_NORMAL) {\n    return TRUE;\n  }\n\n  switch (g_ascii_tolower (str[0])) {\n  case 'p':\n    data-&gt;playing = !data-&gt;playing;\n    gst_element_set_state (data-&gt;pipeline, data-&gt;playing ? GST_STATE_PLAYING : GST_STATE_PAUSED);\n    g_print (\"Setting state to %s\\n\", data-&gt;playing ? \"PLAYING\" : \"PAUSE\");\n    break;\n</code></pre>\n<p>Pause / Playing toggle is handled with <code>gst_element_set_state()</code> as in\nprevious tutorials.</p>\n<pre><code class=\"language-c\">case 's':\n  if (g_ascii_isupper (str[0])) {\n    data-&gt;rate *= 2.0;\n  } else {\n    data-&gt;rate /= 2.0;\n  }\n  send_seek_event (data);\n  break;\ncase 'd':\n  data-&gt;rate *= -1.0;\n  send_seek_event (data);\n  break;\n</code></pre>\n<p>Use \u2018S\u2019 and \u2018s\u2019 to double or halve the current playback rate, and \u2018d\u2019 to\nreverse the current playback direction. In both cases, the\n<code>rate</code> variable is updated and <code>send_seek_event</code> is called. Let\u2019s\nreview this function.</p>\n<pre><code class=\"language-c\">/* Send seek event to change rate */\nstatic void send_seek_event (CustomData *data) {\n  gint64 position;\n  GstEvent *seek_event;\n\n  /* Obtain the current position, needed for the seek event */\n  if (!gst_element_query_position (data-&gt;pipeline, GST_FORMAT_TIME, &amp;position)) {\n    g_printerr (\"Unable to retrieve current position.\\n\");\n    return;\n  }\n</code></pre>\n<p>This function creates a new Seek Event and sends it to the pipeline to\nupdate the rate. First, the current position is recovered with\n<code>gst_element_query_position()</code>. This is needed because the Seek Event\njumps to another position in the stream, and, since we do not actually\nwant to move, we jump to the current position. Using a Step Event would\nbe simpler, but this event is not currently fully functional, as\nexplained in the Introduction.</p>\n<pre><code class=\"language-c\">/* Create the seek event */\nif (data-&gt;rate &gt; 0) {\n  seek_event = gst_event_new_seek (data-&gt;rate, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_ACCURATE,\n      GST_SEEK_TYPE_SET, position, GST_SEEK_TYPE_NONE, 0);\n} else {\n  seek_event = gst_event_new_seek (data-&gt;rate, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_ACCURATE,\n      GST_SEEK_TYPE_SET, 0, GST_SEEK_TYPE_SET, position);\n}\n</code></pre>\n<p>The Seek Event is created with <code>gst_event_new_seek()</code>. Its parameters\nare, basically, the new rate, the new start position and the new stop\nposition. Regardless of the playback direction, the start position must\nbe smaller than the stop position, so the two playback directions are\ntreated differently.</p>\n<pre><code class=\"language-c\">if (data-&gt;video_sink == NULL) {\n  /* If we have not done so, obtain the sink through which we will send the seek events */\n  g_object_get (data-&gt;pipeline, \"video-sink\", &amp;data-&gt;video_sink, NULL);\n}\n</code></pre>\n<p>As explained in the Introduction, to avoid performing multiple Seeks,\nthe Event is sent to only one sink, in this case, the video sink. It is\nobtained from <code>playbin</code> through the <code>video-sink</code> property. It is read\nat this time instead at initialization time because the actual sink may\nchange depending on the media contents, and this won\u2019t be known until\nthe pipeline is PLAYING and some media has been read.</p>\n<pre><code class=\"language-c\">/* Send the event */\ngst_element_send_event (data-&gt;video_sink, seek_event);\n</code></pre>\n<p>The new Event is finally sent to the selected sink with\n<code>gst_element_send_event()</code>.</p>\n<p>Back to the keyboard handler, we still miss the frame stepping code,\nwhich is really simple:</p>\n<pre><code class=\"language-c\">case 'n':\n  if (data-&gt;video_sink == NULL) {\n    /* If we have not done so, obtain the sink through which we will send the step events */\n    g_object_get (data-&gt;pipeline, \"video-sink\", &amp;data-&gt;video_sink, NULL);\n  }\n\n  gst_element_send_event (data-&gt;video_sink,\n      gst_event_new_step (GST_FORMAT_BUFFERS, 1, data-&gt;rate, TRUE, FALSE));\n  g_print (\"Stepping one frame\\n\");\n  break;\n</code></pre>\n<p>A new Step Event is created with <code>gst_event_new_step()</code>, whose\nparameters basically specify the amount to skip (1 frame in the example)\nand the new rate (which we do not change).</p>\n<p>The video sink is grabbed from <code>playbin</code> in case we didn\u2019t have it yet,\njust like before.</p>\n<p>And with this we are done. When testing this tutorial, keep in mind that\nbackward playback is not optimal in many elements.</p>\n<blockquote>\n<p><img src=\"images/icons/emoticons/warning.png\" alt=\"Warning\" id=\"warning\"></p>\n<p>Changing the playback rate might only work with local files. If you cannot modify it, try changing the URI passed to <code>playbin</code> in line 114 to a local URI, starting with <code>file:///</code></p>\n</blockquote>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial has shown:</p>\n<ul>\n<li>How to change the playback rate using a Seek Event, created with\n<code>gst_event_new_seek()</code> and fed to the pipeline\nwith <code>gst_element_send_event()</code>.</li>\n<li>How to advance a video frame-by-frame by using Step Events, created\nwith <code>gst_event_new_step()</code>.</li>\n</ul>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n\t"});