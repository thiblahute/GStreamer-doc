fragment_downloaded_cb({"url": "GStreamer-doc-1.0/tutorials/ios/video.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"video.md\">\n<h1 id=\"ios-tutorial-3-video\">iOS tutorial 3: Video</h1>\n<h2 id=\"goal\">Goal</h2>\n<p><img src=\"images/tutorials/ios-video-screenshot.png\" alt=\"screenshot\" id=\"screenshot\"></p>\n<p>Except for <a href=\"../basic/toolkit-integration.html\">Basic tutorial 5: GUI toolkit integration</a>,\nwhich embedded a video window on a GTK application, all tutorials so far\nrelied on GStreamer video sinks to create a window to display their\ncontents. The video sink on iOS is not capable of creating its own\nwindow, so a drawing surface always needs to be provided. This tutorial\nshows:</p>\n<ul>\n<li>How to allocate a drawing surface on the Xcode Interface Builder and\npass it to GStreamer</li>\n</ul>\n<h2 id=\"introduction\">Introduction</h2>\n<p>Since iOS does not provide a windowing system, a GStreamer video sink\ncannot create pop-up windows as it would do on a Desktop platform.\nFortunately, the <code>VideoOverlay</code> interface allows providing video sinks with\nan already created window onto which they can draw, as we have seen\nin <a href=\"../basic/toolkit-integration.html\">Basic tutorial 5: GUI toolkit integration</a>.</p>\n<p>In this tutorial, a <code>UIView</code> widget (actually, a subclass of it) is\nplaced on the main storyboard. In the <code>viewDidLoad</code> method of the\n<code>ViewController</code>, we pass a pointer to this <code>UIView</code>to the instance of\nthe <code>GStreamerBackend</code>, so it can tell the video sink where to draw.</p>\n<h2 id=\"the-user-interface\">The User Interface</h2>\n<p>The storyboard from the previous tutorial is expanded: A <code>UIView</code>is\nadded over the toolbar and pinned to all sides so it takes up all\navailable space (<code>video_container_view</code> outlet). Inside it, another\n<code>UIView</code>is added (<code>video_view</code> outlet) which contains the actual video,\ncentered to its parent, and with a size that adapts to the media size\n(through the <code>video_width_constraint</code> and <code>video_height_constraint</code>\noutlets):</p>\n<p><strong>ViewController.h</strong></p>\n<pre><code>#import &lt;UIKit/UIKit.h&gt;\n#import \"GStreamerBackendDelegate.h\"\n\n@interface ViewController : UIViewController &lt;GStreamerBackendDelegate&gt; {\n    IBOutlet UILabel *message_label;\n    IBOutlet UIBarButtonItem *play_button;\n    IBOutlet UIBarButtonItem *pause_button;\n    IBOutlet UIView *video_view;\n    IBOutlet UIView *video_container_view;\n    IBOutlet NSLayoutConstraint *video_width_constraint;\n    IBOutlet NSLayoutConstraint *video_height_constraint;\n}\n\n-(IBAction) play:(id)sender;\n-(IBAction) pause:(id)sender;\n\n/* From GStreamerBackendDelegate */\n-(void) gstreamerInitialized;\n-(void) gstreamerSetUIMessage:(NSString *)message;\n\n@end\n</code></pre>\n<h2 id=\"the-view-controller\">The View Controller</h2>\n<p>The <code>ViewController</code>class manages the UI, instantiates\nthe <code>GStreamerBackend</code> and also performs some UI-related tasks on its\nbehalf:</p>\n<p><strong>ViewController.m</strong></p>\n<pre><code>#import \"ViewController.h\"\n#import \"GStreamerBackend.h\"\n#import &lt;UIKit/UIKit.h&gt;\n\n@interface ViewController () {\n    GStreamerBackend *gst_backend;\n    int media_width;\n    int media_height;\n}\n\n@end\n\n@implementation ViewController\n\n/*\n * Methods from UIViewController\n */\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n\n    play_button.enabled = FALSE;\n    pause_button.enabled = FALSE;\n\n    /* Make these constant for now, later tutorials will change them */\n    media_width = 320;\n    media_height = 240;\n\n    gst_backend = [[GStreamerBackend alloc] init:self videoView:video_view];\n}\n\n- (void)didReceiveMemoryWarning\n{\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n/* Called when the Play button is pressed */\n-(IBAction) play:(id)sender\n{\n    [gst_backend play];\n}\n\n/* Called when the Pause button is pressed */\n-(IBAction) pause:(id)sender\n{\n    [gst_backend pause];\n}\n\n- (void)viewDidLayoutSubviews\n{\n    CGFloat view_width = video_container_view.bounds.size.width;\n    CGFloat view_height = video_container_view.bounds.size.height;\n\n    CGFloat correct_height = view_width * media_height / media_width;\n    CGFloat correct_width = view_height * media_width / media_height;\n\n    if (correct_height &lt; view_height) {\n        video_height_constraint.constant = correct_height;\n        video_width_constraint.constant = view_width;\n    } else {\n        video_width_constraint.constant = correct_width;\n        video_height_constraint.constant = view_height;\n    }\n}\n\n/*\n * Methods from GstreamerBackendDelegate\n */\n\n-(void) gstreamerInitialized\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        play_button.enabled = TRUE;\n        pause_button.enabled = TRUE;\n        message_label.text = @\"Ready\";\n    });\n}\n\n-(void) gstreamerSetUIMessage:(NSString *)message\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        message_label.text = message;\n    });\n}\n\n@end\n</code></pre>\n<p>We expand the class to remember the width and height of the media we are\ncurrently playing:</p>\n<pre><code>@interface ViewController () {\n    GStreamerBackend *gst_backend;\n    int media_width;\n    int media_height;\n}\n</code></pre>\n<p>In later tutorials this data is retrieved from the GStreamer pipeline,\nbut in this tutorial, for simplicity\u2019s sake, the width and height of the\nmedia is constant and initialized in <code>viewDidLoad</code>:</p>\n<pre><code>- (void)viewDidLoad\n{\n    [super viewDidLoad];\n\n    play_button.enabled = FALSE;\n    pause_button.enabled = FALSE;\n\n    /* Make these constant for now, later tutorials will change them */\n    media_width = 320;\n    media_height = 240;\n\n    gst_backend = [[GStreamerBackend alloc] init:self videoView:video_view];\n}\n</code></pre>\n<p>As shown below, the <code>GStreamerBackend</code> constructor has also been\nexpanded to accept another parameter: the <code>UIView *</code> where the video\nsink should draw.</p>\n<p>The rest of the <code>ViewController</code>code is the same as the previous\ntutorial, except for the code that adapts the <code>video_view</code> size to the\nmedia size, respecting its aspect ratio:</p>\n<pre><code>- (void)viewDidLayoutSubviews\n{\n    CGFloat view_width = video_container_view.bounds.size.width;\n    CGFloat view_height = video_container_view.bounds.size.height;\n\n    CGFloat correct_height = view_width * media_height / media_width;\n    CGFloat correct_width = view_height * media_width / media_height;\n\n    if (correct_height &lt; view_height) {\n        video_height_constraint.constant = correct_height;\n        video_width_constraint.constant = view_width;\n    } else {\n        video_width_constraint.constant = correct_width;\n        video_height_constraint.constant = view_height;\n    }\n}\n</code></pre>\n<p>The <code>viewDidLayoutSubviews</code> method is called every time the main view\nsize has changed (for example, due to a device orientation change) and\nthe entire layout has been recalculated. At this point, we can access\nthe <code>bounds</code> property of the <code>video_container_view</code> to retrieve its new\nsize and change the <code>video_view</code> size accordingly.</p>\n<p>The simple algorithm above maximizes either the width or the height of\nthe <code>video_view</code>, while changing the other axis so the aspect ratio of\nthe media is preserved. The goal is to provide the GStreamer video sink\nwith a surface of the correct proportions, so it does not need to add\nblack borders (<em>letterboxing</em>), which is a waste of processing power.</p>\n<p>The final size is reported to the layout engine by changing the\n<code>constant</code> field in the width and height <code>Constraints</code> of the\n<code>video_view</code>. These constraints have been created in the storyboard and\nare accessible to the <code>ViewController</code>through IBOutlets, as is usually\ndone with other widgets.</p>\n<h2 id=\"the-gstreamer-backend\">The GStreamer Backend</h2>\n<p>The <code>GStreamerBackend</code> class performs all GStreamer-related tasks and\noffers a simplified interface to the application, which does not need to\ndeal with all the GStreamer details. When it needs to perform any UI\naction, it does so through a delegate, which is expected to adhere to\nthe <code>GStreamerBackendDelegate</code> protocol:</p>\n<p><strong>GStreamerBackend.m</strong></p>\n<pre><code>#import \"GStreamerBackend.h\"\n\n#include &lt;gst/gst.h&gt;\n#include &lt;gst/video/video.h&gt;\n\nGST_DEBUG_CATEGORY_STATIC (debug_category);\n#define GST_CAT_DEFAULT debug_category\n\n@interface GStreamerBackend()\n-(void)setUIMessage:(gchar*) message;\n-(void)app_function;\n-(void)check_initialization_complete;\n@end\n\n@implementation GStreamerBackend {\n    id ui_delegate;        /* Class that we use to interact with the user interface */\n    GstElement *pipeline;  /* The running pipeline */\n    GstElement *video_sink;/* The video sink element which receives VideoOverlay commands */\n    GMainContext *context; /* GLib context used to run the main loop */\n    GMainLoop *main_loop;  /* GLib main loop */\n    gboolean initialized;  /* To avoid informing the UI multiple times about the initialization */\n    UIView *ui_video_view; /* UIView that holds the video */\n}\n\n/*\n * Interface methods\n */\n\n-(id) init:(id) uiDelegate videoView:(UIView *)video_view\n{\n    if (self = [super init])\n    {\n        self-&gt;ui_delegate = uiDelegate;\n        self-&gt;ui_video_view = video_view;\n\n        GST_DEBUG_CATEGORY_INIT (debug_category, \"tutorial-3\", 0, \"iOS tutorial 3\");\n        gst_debug_set_threshold_for_name(\"tutorial-3\", GST_LEVEL_DEBUG);\n\n        /* Start the bus monitoring task */\n        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n            [self app_function];\n        });\n    }\n\n    return self;\n}\n\n-(void) dealloc\n{\n    if (pipeline) {\n        GST_DEBUG(\"Setting the pipeline to NULL\");\n        gst_element_set_state(pipeline, GST_STATE_NULL);\n        gst_object_unref(pipeline);\n        pipeline = NULL;\n    }\n}\n\n-(void) play\n{\n    if(gst_element_set_state(pipeline, GST_STATE_PLAYING) == GST_STATE_CHANGE_FAILURE) {\n        [self setUIMessage:\"Failed to set pipeline to playing\"];\n    }\n}\n\n-(void) pause\n{\n    if(gst_element_set_state(pipeline, GST_STATE_PAUSED) == GST_STATE_CHANGE_FAILURE) {\n        [self setUIMessage:\"Failed to set pipeline to paused\"];\n    }\n}\n\n/*\n * Private methods\n */\n\n/* Change the message on the UI through the UI delegate */\n-(void)setUIMessage:(gchar*) message\n{\n    NSString *string = [NSString stringWithUTF8String:message];\n    if(ui_delegate &amp;&amp; [ui_delegate respondsToSelector:@selector(gstreamerSetUIMessage:)])\n    {\n        [ui_delegate gstreamerSetUIMessage:string];\n    }\n}\n\n/* Retrieve errors from the bus and show them on the UI */\nstatic void error_cb (GstBus *bus, GstMessage *msg, GStreamerBackend *self)\n{\n    GError *err;\n    gchar *debug_info;\n    gchar *message_string;\n\n    gst_message_parse_error (msg, &amp;err, &amp;debug_info);\n    message_string = g_strdup_printf (\"Error received from element %s: %s\", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);\n    g_clear_error (&amp;err);\n    g_free (debug_info);\n    [self setUIMessage:message_string];\n    g_free (message_string);\n    gst_element_set_state (self-&gt;pipeline, GST_STATE_NULL);\n}\n\n/* Notify UI about pipeline state changes */\nstatic void state_changed_cb (GstBus *bus, GstMessage *msg, GStreamerBackend *self)\n{\n    GstState old_state, new_state, pending_state;\n    gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);\n    /* Only pay attention to messages coming from the pipeline, not its children */\n    if (GST_MESSAGE_SRC (msg) == GST_OBJECT (self-&gt;pipeline)) {\n        gchar *message = g_strdup_printf(\"State changed to %s\", gst_element_state_get_name(new_state));\n        [self setUIMessage:message];\n        g_free (message);\n    }\n}\n\n/* Check if all conditions are met to report GStreamer as initialized.\n * These conditions will change depending on the application */\n-(void) check_initialization_complete\n{\n    if (!initialized &amp;&amp; main_loop) {\n        GST_DEBUG (\"Initialization complete, notifying application.\");\n        if (ui_delegate &amp;&amp; [ui_delegate respondsToSelector:@selector(gstreamerInitialized)])\n        {\n            [ui_delegate gstreamerInitialized];\n        }\n        initialized = TRUE;\n    }\n}\n\n/* Main method for the bus monitoring code */\n-(void) app_function\n{\n    GstBus *bus;\n    GSource *bus_source;\n    GError *error = NULL;\n\n    GST_DEBUG (\"Creating pipeline\");\n\n    /* Create our own GLib Main Context and make it the default one */\n    context = g_main_context_new ();\n    g_main_context_push_thread_default(context);\n\n    /* Build pipeline */\n    pipeline = gst_parse_launch(\"videotestsrc ! warptv ! videoconvert ! autovideosink\", &amp;error);\n    if (error) {\n        gchar *message = g_strdup_printf(\"Unable to build pipeline: %s\", error-&gt;message);\n        g_clear_error (&amp;error);\n        [self setUIMessage:message];\n        g_free (message);\n        return;\n    }\n\n    /* Set the pipeline to READY, so it can already accept a window handle */\n    gst_element_set_state(pipeline, GST_STATE_READY);\n\n    video_sink = gst_bin_get_by_interface(GST_BIN(pipeline), GST_TYPE_VIDEO_OVERLAY);\n    if (!video_sink) {\n        GST_ERROR (\"Could not retrieve video sink\");\n        return;\n    }\n    gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(video_sink), (guintptr) (id) ui_video_view);\n\n    /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */\n    bus = gst_element_get_bus (pipeline);\n    bus_source = gst_bus_create_watch (bus);\n    g_source_set_callback (bus_source, (GSourceFunc) gst_bus_async_signal_func, NULL, NULL);\n    g_source_attach (bus_source, context);\n    g_source_unref (bus_source);\n    g_signal_connect (G_OBJECT (bus), \"message::error\", (GCallback)error_cb, (__bridge void *)self);\n    g_signal_connect (G_OBJECT (bus), \"message::state-changed\", (GCallback)state_changed_cb, (__bridge void *)self);\n    gst_object_unref (bus);\n\n    /* Create a GLib Main Loop and set it to run */\n    GST_DEBUG (\"Entering main loop...\");\n    main_loop = g_main_loop_new (context, FALSE);\n    [self check_initialization_complete];\n    g_main_loop_run (main_loop);\n    GST_DEBUG (\"Exited main loop\");\n    g_main_loop_unref (main_loop);\n    main_loop = NULL;\n\n    /* Free resources */\n    g_main_context_pop_thread_default(context);\n    g_main_context_unref (context);\n    gst_element_set_state (pipeline, GST_STATE_NULL);\n    gst_object_unref (pipeline);\n\n    return;\n}\n\n@end\n</code></pre>\n<p>The main differences with the previous tutorial are related to the\nhandling of the <code>VideoOverlay</code> interface:</p>\n<pre><code>@implementation GStreamerBackend {\n    id ui_delegate;        /* Class that we use to interact with the user interface */\n    GstElement *pipeline;  /* The running pipeline */\n    GstElement *video_sink;/* The video sink element which receives VideoOverlay commands */\n    GMainContext *context; /* GLib context used to run the main loop */\n    GMainLoop *main_loop;  /* GLib main loop */\n    gboolean initialized;  /* To avoid informing the UI multiple times about the initialization */\n    UIView *ui_video_view; /* UIView that holds the video */\n}\n</code></pre>\n<p>The class is expanded to keep track of the video sink element in the\npipeline and the <code>UIView *</code> onto which rendering is to occur.</p>\n<pre><code>-(id) init:(id) uiDelegate videoView:(UIView *)video_view\n{\n    if (self = [super init])\n    {\n        self-&gt;ui_delegate = uiDelegate;\n        self-&gt;ui_video_view = video_view;\n\n        GST_DEBUG_CATEGORY_INIT (debug_category, \"tutorial-3\", 0, \"iOS tutorial 3\");\n        gst_debug_set_threshold_for_name(\"tutorial-3\", GST_LEVEL_DEBUG);\n\n        /* Start the bus monitoring task */\n        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n            [self app_function];\n        });\n    }\n\n    return self;\n}\n</code></pre>\n<p>The constructor accepts the <code>UIView *</code> as a new parameter, which, at\nthis point, is simply remembered in <code>ui_video_view</code>.</p>\n<pre><code>/* Build pipeline */\npipeline = gst_parse_launch(\"videotestsrc ! warptv ! videoconvert ! autovideosink\", &amp;error);\n</code></pre>\n<p>Then, in the <code>app_function</code>, the pipeline is constructed. This time we\nbuild a video pipeline using a simple <code>videotestsrc</code> element with a\n<code>warptv</code> to add some spice. The video sink is <code>autovideosink</code>, which\nchoses the appropriate sink for the platform (currently,\n<code>glimagesink</code> is the only option for\niOS).</p>\n<pre><code>/* Set the pipeline to READY, so it can already accept a window handle */\ngst_element_set_state(pipeline, GST_STATE_READY);\n\nvideo_sink = gst_bin_get_by_interface(GST_BIN(pipeline), GST_TYPE_VIDEO_OVERLAY);\nif (!video_sink) {\n    GST_ERROR (\"Could not retrieve video sink\");\n    return;\n}\ngst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(video_sink), (guintptr) (id) ui_video_view);\n</code></pre>\n<p>Once the pipeline is built, we set it to READY. In this state, dataflow\nhas not started yet, but the caps of adjacent elements have been\nverified to be compatible and their pads have been linked. Also, the\n<code>autovideosink</code> has already instantiated the actual video sink so we can\nask for it immediately.</p>\n<p>The <code>gst_bin_get_by_interface()</code> method will examine the whole pipeline\nand return a pointer to an element which supports the requested\ninterface. We are asking for the <code>VideoOverlay</code> interface, explained in\n<a href=\"../basic/toolkit-integration.html\">Basic tutorial 5: GUI toolkit integration</a>,\nwhich controls how to perform rendering into foreign (non-GStreamer)\nwindows. The internal video sink instantiated by <code>autovideosink</code> is the\nonly element in this pipeline implementing it, so it will be returned.</p>\n<p>Once we have the video sink, we inform it of the <code>UIView</code> to use for\nrendering, through the <code>gst_video_overlay_set_window_handle()</code> method.</p>\n<h2 id=\"eagluiview\">EaglUIView</h2>\n<p>One last detail remains. In order for <code>glimagesink</code> to be able to draw\non the\n<a href=\"http://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIView_Class/UIView/UIView.html\"><code>UIView</code></a>,\nthe\n<a href=\"http://developer.apple.com/library/ios/#documentation/GraphicsImaging/Reference/CALayer_class/Introduction/Introduction.html#//apple_ref/occ/cl/CALayer\"><code>Layer</code></a> associated\nwith this view must be of the\n<a href=\"http://developer.apple.com/library/ios/#documentation/QuartzCore/Reference/CAEAGLLayer_Class/CAEGLLayer/CAEGLLayer.html#//apple_ref/occ/cl/CAEAGLLayer\"><code>CAEAGLLayer</code></a> class.\nTo this avail, we create the <code>EaglUIView</code> class, derived from\n<code>UIView</code>and overriding the <code>layerClass</code> method:</p>\n<p><strong>EaglUIView.m</strong></p>\n<pre><code>#import \"EaglUIVIew.h\"\n\n#import &lt;QuartzCore/QuartzCore.h&gt;\n\n@implementation EaglUIView\n\n+ (Class) layerClass\n{\n    return [CAEAGLLayer class];\n}\n\n@end\n</code></pre>\n<p>When creating storyboards, bear in mind that the <code>UIView</code>which should\ncontain the video must have <code>EaglUIView</code> as its custom class. This is\neasy to setup from the Xcode interface builder. Take a look at the\ntutorial storyboard to see how to achieve this.</p>\n<p>And this is it, using GStreamer to output video onto an iOS application\nis as simple as it seems.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial has shown:</p>\n<ul>\n<li>How to display video on iOS using a <code>UIView</code>and\nthe <code>VideoOverlay</code> interface.</li>\n<li>How to report the media size to the iOS layout engine through\nruntime manipulation of width and height constraints.</li>\n</ul>\n<p>The following tutorial plays an actual clip and adds a few more controls\nto this tutorial in order to build a simple media player.</p>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n\t"});