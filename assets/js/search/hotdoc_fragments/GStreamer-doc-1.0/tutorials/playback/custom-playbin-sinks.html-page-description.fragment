fragment_downloaded_cb({"url": "GStreamer-doc-1.0/tutorials/playback/custom-playbin-sinks.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"custom-playbin-sinks.md\">\n<h1 id=\"playback-tutorial-7-custom-playbin-sinks\">Playback tutorial 7: Custom playbin sinks</h1>\n<h2 id=\"goal\">Goal</h2>\n<p><code>playbin</code> can be further customized by manually selecting its audio and\nvideo sinks. This allows applications to rely on <code>playbin</code> to retrieve\nand decode the media and then manage the final render/display\nthemselves. This tutorial shows:</p>\n<ul>\n<li>How to replace the sinks selected by <code>playbin</code>.</li>\n<li>How to use a complex pipeline as a sink.</li>\n</ul>\n<h2 id=\"introduction\">Introduction</h2>\n<p>Two properties of <code>playbin</code> allow selecting the desired audio and video\nsinks: <code>audio-sink</code> and <code>video-sink</code> (respectively). The application\nonly needs to instantiate the appropriate <code>GstElement</code> and pass it to\n<code>playbin</code> through these properties.</p>\n<p>This method, though, only allows using a single Element as sink. If a\nmore complex pipeline is required, for example, an equalizer plus an\naudio sink, it needs to be wrapped in a Bin, so it looks to\n<code>playbin</code> as if it was a single Element.</p>\n<p>A Bin (<code>GstBin</code>) is a container that encapsulates partial pipelines so\nthey can be managed as single elements. As an example, the\n<code>GstPipeline</code> we have been using in all tutorials is a type of\n<code>GstBin</code>, which does not interact with external Elements. Elements\ninside a Bin connect to external elements through Ghost Pads\n(<code>GstGhostPad</code>), this is, Pads on the surface of the Bin which simply\nforward data from an external Pad to a given Pad on an internal Element.</p>\n<p><img src=\"images/bin-element-ghost.png\" alt=\"\"></p>\n<p><strong>Figure 1:</strong> A Bin with two Elements and one Ghost Pad.</p>\n<p><code>GstBin</code>s are also a type of <code>GstElement</code>, so they can be used wherever\nan Element is required, in particular, as sinks for <code>playbin</code> (and they\nare then known as <strong>sink-bins</strong>).</p>\n<h2 id=\"an-equalized-player\">An equalized player</h2>\n<p>Copy this code into a text file named <code>playback-tutorial-7.c</code>.</p>\n<p><strong>playback-tutorial7.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\nint main(int argc, char *argv[]) {\n  GstElement *pipeline, *bin, *equalizer, *convert, *sink;\n  GstPad *pad, *ghost_pad;\n  GstBus *bus;\n  GstMessage *msg;\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* Build the pipeline */\n  pipeline = gst_parse_launch (\"playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm\", NULL);\n\n  /* Create the elements inside the sink bin */\n  equalizer = gst_element_factory_make (\"equalizer-3bands\", \"equalizer\");\n  convert = gst_element_factory_make (\"audioconvert\", \"convert\");\n  sink = gst_element_factory_make (\"autoaudiosink\", \"audio_sink\");\n  if (!equalizer || !convert || !sink) {\n    g_printerr (\"Not all elements could be created.\\n\");\n    return -1;\n  }\n\n  /* Create the sink bin, add the elements and link them */\n  bin = gst_bin_new (\"audio_sink_bin\");\n  gst_bin_add_many (GST_BIN (bin), equalizer, convert, sink, NULL);\n  gst_element_link_many (equalizer, convert, sink, NULL);\n  pad = gst_element_get_static_pad (equalizer, \"sink\");\n  ghost_pad = gst_ghost_pad_new (\"sink\", pad);\n  gst_pad_set_active (ghost_pad, TRUE);\n  gst_element_add_pad (bin, ghost_pad);\n  gst_object_unref (pad);\n\n  /* Configure the equalizer */\n  g_object_set (G_OBJECT (equalizer), \"band1\", (gdouble)-24.0, NULL);\n  g_object_set (G_OBJECT (equalizer), \"band2\", (gdouble)-24.0, NULL);\n\n  /* Set playbin's audio sink to be our sink bin */\n  g_object_set (GST_OBJECT (pipeline), \"audio-sink\", bin, NULL);\n\n  /* Start playing */\n  gst_element_set_state (pipeline, GST_STATE_PLAYING);\n\n  /* Wait until error or EOS */\n  bus = gst_element_get_bus (pipeline);\n  msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS);\n\n  /* Free resources */\n  if (msg != NULL)\n    gst_message_unref (msg);\n  gst_object_unref (bus);\n  gst_element_set_state (pipeline, GST_STATE_NULL);\n  gst_object_unref (pipeline);\n  return 0;\n}\n</code></pre>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"information\" id=\"information\"> If you need help to compile this code, refer to the\n<strong>Building the tutorials</strong> section for your platform: <a href=\"../../installing/on-mac-osx.html\">Mac</a> or\n<a href=\"../../installing/on-windows.html\">Windows</a> or use this specific command on Linux:</p>\n<p><code>gcc playback-tutorial-7.c -o playback-tutorial-7 `pkg-config --cflags --libs gstreamer-1.0`</code></p>\n<p>If you need help to run this code, refer to the <strong>Running the\ntutorials</strong> section for your platform: <a href=\"../../installing/on-mac-osx.html#building-the-tutorials\">Mac OS X</a>, <a href=\"../../installing/on-windows.html#running-the-tutorials\">Windows</a>, for\n<a href=\"../../installing/for-ios-development.html#building-the-tutorials\">iOS</a> or for <a href=\"../../installing/for-android-development.html#building-the-tutorials\">android</a>.</p>\n<p>This tutorial opens a window and displays a movie, with accompanying audio. The media is fetched from the Internet, so the window might take a few seconds to appear, depending on your connection speed. The higher frequency bands have been attenuated, so the movie sound should have a more powerful bass component.&lt;</p>\n<p>Required libraries: <code>gstreamer-1.0</code></p>\n</blockquote>\n<h2 id=\"walkthrough\">Walkthrough</h2>\n<pre><code class=\"language-c\">/* Create the elements inside the sink bin */\nequalizer = gst_element_factory_make (\"equalizer-3bands\", \"equalizer\");\nconvert = gst_element_factory_make (\"audioconvert\", \"convert\");\nsink = gst_element_factory_make (\"autoaudiosink\", \"audio_sink\");\nif (!equalizer || !convert || !sink) {\n  g_printerr (\"Not all elements could be created.\\n\");\n  return -1;\n}\n</code></pre>\n<p>All the Elements that compose our sink-bin are instantiated. We use an\n<code>equalizer-3bands</code> and an <code>autoaudiosink</code>, with an <code>audioconvert</code> in\nbetween, because we are not sure of the capabilities of the audio sink\n(since they are hardware-dependant).</p>\n<pre><code class=\"language-c\">/* Create the sink bin, add the elements and link them */\nbin = gst_bin_new (\"audio_sink_bin\");\ngst_bin_add_many (GST_BIN (bin), equalizer, convert, sink, NULL);\ngst_element_link_many (equalizer, convert, sink, NULL);\n</code></pre>\n<p>This adds the new Elements to the Bin and links them just as we would do\nif this was a pipeline.</p>\n<pre><code class=\"language-c\">pad = gst_element_get_static_pad (equalizer, \"sink\");\nghost_pad = gst_ghost_pad_new (\"sink\", pad);\ngst_pad_set_active (ghost_pad, TRUE);\ngst_element_add_pad (bin, ghost_pad);\ngst_object_unref (pad);\n</code></pre>\n<p>Now we need to create a Ghost Pad so this partial pipeline inside the\nBin can be connected to the outside. This Ghost Pad will be connected to\na Pad in one of the internal Elements (the sink pad of the equalizer),\nso we retrieve this Pad with <code>gst_element_get_static_pad()</code>. Remember\nfrom <a href=\"../basic/multithreading-and-pad-availability.html\">Basic tutorial 7: Multithreading and Pad Availability</a> that\nif this was a Request Pad instead of an Always Pad, we would need to use\n<code>gst_element_request_pad()</code>.</p>\n<p>The Ghost Pad is created with <code>gst_ghost_pad_new()</code> (pointing to the\ninner Pad we just acquired), and activated with <code>gst_pad_set_active()</code>.\nIt is then added to the Bin with <code>gst_element_add_pad()</code>, transferring\nownership of the Ghost Pad to the bin, so we do not have to worry about\nreleasing it.</p>\n<p>Finally, the sink Pad we obtained from the equalizer needs to be release\nwith <code>gst_object_unref()</code>.</p>\n<p>At this point, we have a functional sink-bin, which we can use as the\naudio sink in <code>playbin</code>. We just need to instruct <code>playbin</code> to use it:</p>\n<pre><code class=\"language-c\">/* Set playbin's audio sink to be our sink bin */\ng_object_set (GST_OBJECT (pipeline), \"audio-sink\", bin, NULL);\n</code></pre>\n<p>It is as simple as setting the <code>audio-sink</code> property on <code>playbin</code> to\nthe newly created sink.</p>\n<pre><code class=\"language-c\">/* Configure the equalizer */\ng_object_set (G_OBJECT (equalizer), \"band1\", (gdouble)-24.0, NULL);\ng_object_set (G_OBJECT (equalizer), \"band2\", (gdouble)-24.0, NULL);\n</code></pre>\n<p>The only bit remaining is to configure the equalizer. For this example,\nthe two higher frequency bands are set to the maximum attenuation so the\nbass is boosted. Play a bit with the values to feel the difference (Look\nat the documentation for the <code>equalizer-3bands</code> element for the allowed\nrange of values).</p>\n<h2 id=\"exercise\">Exercise</h2>\n<p>Build a video bin instead of an audio bin, using one of the many\ninteresting video filters GStreamer offers, like <code>solarize</code>,\n<code>vertigotv</code> or any of the Elements in the <code>effectv</code> plugin. Remember to\nuse the color space conversion element <code>videoconvert</code> if your\npipeline fails to link due to incompatible caps.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial has shown:</p>\n<ul>\n<li>How to set your own sinks to <code>playbin</code> using the audio-sink and\nvideo-sink properties.</li>\n<li>How to wrap a piece of pipeline into a <code>GstBin</code> so it can be used as\na <strong>sink-bin</strong> by <code>playbin</code>.</li>\n</ul>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n\t"});