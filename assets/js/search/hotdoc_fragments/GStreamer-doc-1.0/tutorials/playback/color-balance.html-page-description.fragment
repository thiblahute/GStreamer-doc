fragment_downloaded_cb({"url": "GStreamer-doc-1.0/tutorials/playback/color-balance.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"color-balance.md\">\n<h1 id=\"playback-tutorial-5-color-balance\">Playback tutorial 5: Color Balance</h1>\n<h2 id=\"goal\">Goal</h2>\n<p>Brightness, Contrast, Hue and Saturation are common video adjustments,\nwhich are collectively known as Color Balance settings in GStreamer.\nThis tutorial shows:</p>\n<ul>\n<li>How to find out the available color balance channels</li>\n<li>How to change them</li>\n</ul>\n<h2 id=\"introduction\">Introduction</h2>\n<p><a href=\"../basic/toolkit-integration.html\">Basic tutorial 5: GUI toolkit integration</a> has\nalready explained the concept of GObject interfaces: applications use\nthem to find out if certain functionality is available, regardless of\nthe actual element which implements it.</p>\n<p><code>playbin</code> implements the Color Balance interface (<code>GstColorBalance</code>),\nwhich allows access to the color balance settings. If any of the\nelements in the <code>playbin</code> pipeline support this interface,\n<code>playbin</code> simply forwards it to the application, otherwise, a\ncolorbalance element is inserted in the pipeline.</p>\n<p>This interface allows querying for the available color balance channels\n(<code>GstColorBalanceChannel</code>), along with their name and valid range of\nvalues, and then modify the current value of any of them.</p>\n<h2 id=\"color-balance-example\">Color balance example</h2>\n<p>Copy this code into a text file named <code>playback-tutorial-5.c</code>.</p>\n<p><strong>playback-tutorial-5.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;gst/gst.h&gt;\n#include &lt;gst/video/colorbalance.h&gt;\n\ntypedef struct _CustomData {\n  GstElement *pipeline;\n  GMainLoop *loop;\n} CustomData;\n\n/* Process a color balance command */\nstatic void update_color_channel (const gchar *channel_name, gboolean increase, GstColorBalance *cb) {\n  gdouble step;\n  gint value;\n  GstColorBalanceChannel *channel = NULL;\n  const GList *channels, *l;\n\n  /* Retrieve the list of channels and locate the requested one */\n  channels = gst_color_balance_list_channels (cb);\n  for (l = channels; l != NULL; l = l-&gt;next) {\n    GstColorBalanceChannel *tmp = (GstColorBalanceChannel *)l-&gt;data;\n\n    if (g_strrstr (tmp-&gt;label, channel_name)) {\n      channel = tmp;\n      break;\n    }\n  }\n  if (!channel)\n    return;\n\n  /* Change the channel's value */\n  step = 0.1 * (channel-&gt;max_value - channel-&gt;min_value);\n  value = gst_color_balance_get_value (cb, channel);\n  if (increase) {\n    value = (gint)(value + step);\n    if (value &gt; channel-&gt;max_value)\n      value = channel-&gt;max_value;\n  } else {\n    value = (gint)(value - step);\n    if (value &lt; channel-&gt;min_value)\n      value = channel-&gt;min_value;\n  }\n  gst_color_balance_set_value (cb, channel, value);\n}\n\n/* Output the current values of all Color Balance channels */\nstatic void print_current_values (GstElement *pipeline) {\n  const GList *channels, *l;\n\n  /* Output Color Balance values */\n  channels = gst_color_balance_list_channels (GST_COLOR_BALANCE (pipeline));\n  for (l = channels; l != NULL; l = l-&gt;next) {\n    GstColorBalanceChannel *channel = (GstColorBalanceChannel *)l-&gt;data;\n    gint value = gst_color_balance_get_value (GST_COLOR_BALANCE (pipeline), channel);\n    g_print (\"%s: %3d%% \", channel-&gt;label,\n        100 * (value - channel-&gt;min_value) / (channel-&gt;max_value - channel-&gt;min_value));\n  }\n  g_print (\"\\n\");\n}\n\n/* Process keyboard input */\nstatic gboolean handle_keyboard (GIOChannel *source, GIOCondition cond, CustomData *data) {\n  gchar *str = NULL;\n\n  if (g_io_channel_read_line (source, &amp;str, NULL, NULL, NULL) != G_IO_STATUS_NORMAL) {\n    return TRUE;\n  }\n\n  switch (g_ascii_tolower (str[0])) {\n  case 'c':\n    update_color_channel (\"CONTRAST\", g_ascii_isupper (str[0]), GST_COLOR_BALANCE (data-&gt;pipeline));\n    break;\n  case 'b':\n    update_color_channel (\"BRIGHTNESS\", g_ascii_isupper (str[0]), GST_COLOR_BALANCE (data-&gt;pipeline));\n    break;\n  case 'h':\n    update_color_channel (\"HUE\", g_ascii_isupper (str[0]), GST_COLOR_BALANCE (data-&gt;pipeline));\n    break;\n  case 's':\n    update_color_channel (\"SATURATION\", g_ascii_isupper (str[0]), GST_COLOR_BALANCE (data-&gt;pipeline));\n    break;\n  case 'q':\n    g_main_loop_quit (data-&gt;loop);\n    break;\n  default:\n    break;\n  }\n\n  g_free (str);\n\n  print_current_values (data-&gt;pipeline);\n\n  return TRUE;\n}\n\nint main(int argc, char *argv[]) {\n  CustomData data;\n  GstStateChangeReturn ret;\n  GIOChannel *io_stdin;\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* Initialize our data structure */\n  memset (&amp;data, 0, sizeof (data));\n\n  /* Print usage map */\n  g_print (\n    \"USAGE: Choose one of the following options, then press enter:\\n\"\n    \" 'C' to increase contrast, 'c' to decrease contrast\\n\"\n    \" 'B' to increase brightness, 'b' to decrease brightness\\n\"\n    \" 'H' to increase hue, 'h' to decrease hue\\n\"\n    \" 'S' to increase saturation, 's' to decrease saturation\\n\"\n    \" 'Q' to quit\\n\");\n\n  /* Build the pipeline */\n  data.pipeline = gst_parse_launch (\"playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm\", NULL);\n\n  /* Add a keyboard watch so we get notified of keystrokes */\n#ifdef G_OS_WIN32\n  io_stdin = g_io_channel_win32_new_fd (fileno (stdin));\n#else\n  io_stdin = g_io_channel_unix_new (fileno (stdin));\n#endif\n  g_io_add_watch (io_stdin, G_IO_IN, (GIOFunc)handle_keyboard, &amp;data);\n\n  /* Start playing */\n  ret = gst_element_set_state (data.pipeline, GST_STATE_PLAYING);\n  if (ret == GST_STATE_CHANGE_FAILURE) {\n    g_printerr (\"Unable to set the pipeline to the playing state.\\n\");\n    gst_object_unref (data.pipeline);\n    return -1;\n  }\n  print_current_values (data.pipeline);\n\n  /* Create a GLib Main Loop and set it to run */\n  data.loop = g_main_loop_new (NULL, FALSE);\n  g_main_loop_run (data.loop);\n\n  /* Free resources */\n  g_main_loop_unref (data.loop);\n  g_io_channel_unref (io_stdin);\n  gst_element_set_state (data.pipeline, GST_STATE_NULL);\n  gst_object_unref (data.pipeline);\n  return 0;\n}\n</code></pre>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"information\" id=\"information\"> If you need help to compile this code, refer to the\n<strong>Building the tutorials</strong> section for your platform: <a href=\"../../installing/on-mac-osx.html\">Mac</a> or\n<a href=\"../../installing/on-windows.html\">Windows</a> or use this specific command on Linux:</p>\n<p><code>gcc playback-tutorial-5.c -o playback-tutorial-5 `pkg-config --cflags --libs gstreamer-1.0 gstreamer-video-1.0`</code></p>\n<p>If you need help to run this code, refer to the <strong>Running the\ntutorials</strong> section for your platform: <a href=\"../../installing/on-mac-osx.html#building-the-tutorials\">Mac OS X</a>, <a href=\"../../installing/on-windows.html#running-the-tutorials\">Windows</a>, for\n<a href=\"../../installing/for-ios-development.html#building-the-tutorials\">iOS</a> or for <a href=\"../../installing/for-android-development.html#building-the-tutorials\">android</a>.</p>\n<p>This tutorial opens a window and displays a movie, with accompanying audio. The media is fetched from the Internet, so the window might take a few seconds to appear, depending on your connection speed.</p>\n<p>The console should print all commands (Each command is a single upper-case or lower-case letter) and list all available Color Balance channels, typically, CONTRAST, BRIGHTNESS, HUE and SATURATION. Type each command (letter) followed by the Enter key.</p>\n<p>Required libraries: <code>gstreamer-1.0 gstreamer-video-1.0</code></p>\n</blockquote>\n<h2 id=\"walkthrough\">Walkthrough</h2>\n<p>The <code>main()</code> function is fairly simple. A <code>playbin</code> pipeline is\ninstantiated and set to run, and a keyboard watch is installed so\nkeystrokes can be monitored.</p>\n<pre><code class=\"language-c\">/* Output the current values of all Color Balance channels */\nstatic void print_current_values (GstElement *pipeline) {\n  const GList *channels, *l;\n\n  /* Output Color Balance values */\n  channels = gst_color_balance_list_channels (GST_COLOR_BALANCE (pipeline));\n  for (l = channels; l != NULL; l = l-&gt;next) {\n    GstColorBalanceChannel *channel = (GstColorBalanceChannel *)l-&gt;data;\n    gint value = gst_color_balance_get_value (GST_COLOR_BALANCE (pipeline), channel);\n    g_print (\"%s: %3d%% \", channel-&gt;label,\n        100 * (value - channel-&gt;min_value) / (channel-&gt;max_value - channel-&gt;min_value));\n  }\n  g_print (\"\\n\");\n}\n</code></pre>\n<p>This method prints the current value for all channels, and exemplifies\nhow to retrieve the list of channels. This is accomplished through the\n<code>gst_color_balance_list_channels()</code> method. It returns a <code>GList</code> which\nneeds to be traversed.</p>\n<p>Each element in the list is a <code>GstColorBalanceChannel</code> structure,\ninforming of the channel\u2019s name, minimum value and maximum value.\n<code>gst_color_balance_get_value()</code> can then be called on each channel to\nretrieve the current value.</p>\n<p>In this example, the minimum and maximum values are used to output the\ncurrent value as a percentage.</p>\n<pre><code class=\"language-c\">/* Process a color balance command */\nstatic void update_color_channel (const gchar *channel_name, gboolean increase, GstColorBalance *cb) {\n  gdouble step;\n  gint value;\n  GstColorBalanceChannel *channel = NULL;\n  const GList *channels, *l;\n\n  /* Retrieve the list of channels and locate the requested one */\n  channels = gst_color_balance_list_channels (cb);\n  for (l = channels; l != NULL; l = l-&gt;next) {\n    GstColorBalanceChannel *tmp = (GstColorBalanceChannel *)l-&gt;data;\n\n    if (g_strrstr (tmp-&gt;label, channel_name)) {\n      channel = tmp;\n      break;\n    }\n  }\n  if (!channel)\n    return;\n</code></pre>\n<p>This method locates the specified channel by name and increases or\ndecreases it as requested. Again, the list of channels is retrieved and\nparsed looking for the channel with the specified name. Obviously, this\nlist could be parsed only once and the pointers to the channels be\nstored and indexed by something more efficient than a string.</p>\n<pre><code class=\"language-c\">  /* Change the channel's value */\n  step = 0.1 * (channel-&gt;max_value - channel-&gt;min_value);\n  value = gst_color_balance_get_value (cb, channel);\n  if (increase) {\n    value = (gint)(value + step);\n    if (value &gt; channel-&gt;max_value)\n      value = channel-&gt;max_value;\n  } else {\n    value = (gint)(value - step);\n    if (value &lt; channel-&gt;min_value)\n      value = channel-&gt;min_value;\n  }\n  gst_color_balance_set_value (cb, channel, value);\n}\n</code></pre>\n<p>The current value for the channel is then retrieved, changed (the\nincrement is proportional to its dynamic range), clamped (to avoid\nout-of-range values) and set using <code>gst_color_balance_set_value()</code>.</p>\n<p>And there is not much more to it. Run the program and observe the effect\nof changing each of the channels in real time.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial has shown how to use the color balance interface.\nParticularly, it has shown:</p>\n<ul>\n<li>How to retrieve the list of color available balance channels\nwith <code>gst_color_balance_list_channels()</code></li>\n<li>How to manipulate the current value of each channel using\n<code>gst_color_balance_get_value()</code> and <code>gst_color_balance_set_value()</code></li>\n</ul>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n\t"});