fragment_downloaded_cb({"url": "libgstreamer-doc-1.0/c/gstbus.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gstbus.h\">\n<h1 id=\"gstbus\">GstBus</h1><p>The <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer/html/GstBus.html#GstBus-struct\">GstBus</a> is an object responsible for delivering <a href=\"../../libgstreamer-doc-1.0/c/gstmessage.html#GstMessage\">GstMessage</a> packets in\na first-in first-out way from the streaming threads (see <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer/html/GstTask.html#GstTask-struct\">GstTask</a>) to the\napplication.</p>\n<p>Since the application typically only wants to deal with delivery of these\nmessages from one thread, the GstBus will marshall the messages between\ndifferent threads. This is important since the actual streaming of media\nis done in another thread than the application.</p>\n<p>The GstBus provides support for <a href=\"https://developer.gnome.org/glib/unstable/glib-The-Main-Event-Loop.html#GSource\">GSource</a> based notifications. This makes it\npossible to handle the delivery in the glib mainloop.</p>\n<p>The <a href=\"https://developer.gnome.org/glib/unstable/glib-The-Main-Event-Loop.html#GSource\">GSource</a> callback function <a href=\"../../libgstreamer-doc-1.0/c/gstbus.html#gst_bus_async_signal_func\">gst_bus_async_signal_func</a> can be used to\nconvert all bus messages into signal emissions.</p>\n<p>A message is posted on the bus with the <a href=\"../../libgstreamer-doc-1.0/c/gstbus.html#gst_bus_post\">gst_bus_post</a> method. With the\n<a href=\"../../libgstreamer-doc-1.0/c/gstbus.html#gst_bus_peek\">gst_bus_peek</a> and <a href=\"../../libgstreamer-doc-1.0/c/gstbus.html#gst_bus_pop\">gst_bus_pop</a> methods one can look at or retrieve a\npreviously posted message.</p>\n<p>The bus can be polled with the <a href=\"../../libgstreamer-doc-1.0/c/gstbus.html#gst_bus_poll\">gst_bus_poll</a> method. This methods blocks\nup to the specified timeout value until one of the specified messages types\nis posted on the bus. The application can then <a href=\"../../libgstreamer-doc-1.0/c/gstbus.html#gst_bus_pop\">gst_bus_pop</a> the messages\nfrom the bus to handle them.\nAlternatively the application can register an asynchronous bus function\nusing <a href=\"../../libgstreamer-doc-1.0/c/gstbus.html#gst_bus_add_watch_full\">gst_bus_add_watch_full</a> or <a href=\"../../libgstreamer-doc-1.0/c/gstbus.html#gst_bus_add_watch\">gst_bus_add_watch</a>. This function will\ninstall a <a href=\"https://developer.gnome.org/glib/unstable/glib-The-Main-Event-Loop.html#GSource\">GSource</a> in the default glib main loop and will deliver messages\na short while after they have been posted. Note that the main loop should\nbe running for the asynchronous callbacks.</p>\n<p>It is also possible to get messages from the bus without any thread\nmarshalling with the <a href=\"../../libgstreamer-doc-1.0/c/gstbus.html#gst_bus_set_sync_handler\">gst_bus_set_sync_handler</a> method. This makes it\npossible to react to a message in the same thread that posted the\nmessage on the bus. This should only be used if the application is able\nto deal with messages from different threads.</p>\n<p>Every <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer/html/GstPipeline.html#GstPipeline-struct\">GstPipeline</a> has one bus.</p>\n<p>Note that a <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer/html/GstPipeline.html#GstPipeline-struct\">GstPipeline</a> will set its bus into flushing state when changing\nfrom READY to NULL state.</p>\n\n</div>\n\n\n"});