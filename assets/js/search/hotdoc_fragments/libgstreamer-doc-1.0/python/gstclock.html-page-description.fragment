fragment_downloaded_cb({"url": "libgstreamer-doc-1.0/python/gstclock.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gstclock.h\">\n<h1 id=\"gstclock\">GstClock</h1><p>GStreamer uses a global clock to synchronize the plugins in a pipeline.\nDifferent clock implementations are possible by implementing this abstract\nbase class or, more conveniently, by subclassing <a href=\"gstsystemclock.html#GstSystemClock\">Gst.SystemClock</a>.</p>\n<p>The <a href=\"gstclock.html#GstClock\">Gst.Clock</a> returns a monotonically increasing time with the method\n<a href=\"gstclock.html#gst_clock_get_time\">Gst.Clock.get_time</a>. Its accuracy and base time depend on the specific\nclock implementation but time is always expressed in nanoseconds. Since the\nbaseline of the clock is undefined, the clock time returned is not\nmeaningful in itself, what matters are the deltas between two clock times.\nThe time returned by a clock is called the absolute time.</p>\n<p>The pipeline uses the clock to calculate the running time. Usually all\nrenderers synchronize to the global clock using the buffer timestamps, the\nnewsegment events and the element's base time, see <a href=\"gstpipeline.html#GstPipeline\">Gst.Pipeline</a>.</p>\n<p>A clock implementation can support periodic and single shot clock\nnotifications both synchronous and asynchronous.</p>\n<p>One first needs to create a <a href=\"gstclock.html#GstClockID\">Gst.ClockID</a> for the periodic or single shot\nnotification using <a href=\"gstclock.html#gst_clock_new_single_shot_id\">Gst.Clock.new_single_shot_id</a> or\n<a href=\"gstclock.html#gst_clock_new_periodic_id\">Gst.Clock.new_periodic_id</a>.</p>\n<p>To perform a blocking wait for the specific time of the <a href=\"gstclock.html#GstClockID\">Gst.ClockID</a> use the\n<a href=\"gstclock.html#gst_clock_id_wait\">Gst.Clock.id_wait</a>. To receive a callback when the specific time is reached\nin the clock use <a href=\"gstclock.html#gst_clock_id_wait_async\">Gst.Clock.id_wait_async</a>. Both these calls can be\ninterrupted with the <a href=\"gstclock.html#gst_clock_id_unschedule\">Gst.Clock.id_unschedule</a> call. If the blocking wait is\nunscheduled a return value of <a href=\"gstclock.html#GST_CLOCK_UNSCHEDULED\">Gst.ClockReturn.unscheduled</a> is returned.</p>\n<p>Periodic callbacks scheduled async will be repeatedly called automatically\nuntil it is unscheduled. To schedule a sync periodic callback,\n<a href=\"gstclock.html#gst_clock_id_wait\">Gst.Clock.id_wait</a> should be called repeatedly.</p>\n<p>The async callbacks can happen from any thread, either provided by the core\nor from a streaming thread. The application should be prepared for this.</p>\n<p>A <a href=\"gstclock.html#GstClockID\">Gst.ClockID</a> that has been unscheduled cannot be used again for any wait\noperation, a new <a href=\"gstclock.html#GstClockID\">Gst.ClockID</a> should be created and the old unscheduled one\nshould be destroyed with <a href=\"gstclock.html#gst_clock_id_unref\">Gst.Clock.id_unref</a>.</p>\n<p>It is possible to perform a blocking wait on the same <a href=\"gstclock.html#GstClockID\">Gst.ClockID</a> from\nmultiple threads. However, registering the same <a href=\"gstclock.html#GstClockID\">Gst.ClockID</a> for multiple\nasync notifications is not possible, the callback will only be called for\nthe thread registering the entry last.</p>\n<p>None of the wait operations unref the <a href=\"gstclock.html#GstClockID\">Gst.ClockID</a>, the owner is responsible\nfor unreffing the ids itself. This holds for both periodic and single shot\nnotifications. The reason being that the owner of the <a href=\"gstclock.html#GstClockID\">Gst.ClockID</a> has to\nkeep a handle to the <a href=\"gstclock.html#GstClockID\">Gst.ClockID</a> to unblock the wait on FLUSHING events or\nstate changes and if the entry would be unreffed automatically, the handle\nmight become invalid without any notification.</p>\n<p>These clock operations do not operate on the running time, so the callbacks\nwill also occur when not in PLAYING state as if the clock just keeps on\nrunning. Some clocks however do not progress when the element that provided\nthe clock is not PLAYING.</p>\n<p>When a clock has the <a href=\"gstclock.html#GST_CLOCK_FLAG_CAN_SET_MASTER\">Gst.ClockFlags.can_set_master</a> flag set, it can be\nslaved to another <a href=\"gstclock.html#GstClock\">Gst.Clock</a> with the <a href=\"gstclock.html#gst_clock_set_master\">Gst.Clock.set_master</a>. The clock will\nthen automatically be synchronized to this master clock by repeatedly\nsampling the master clock and the slave clock and recalibrating the slave\nclock with <a href=\"gstclock.html#gst_clock_set_calibration\">Gst.Clock.set_calibration</a>. This feature is mostly useful for\nplugins that have an internal clock but must operate with another clock\nselected by the <a href=\"gstpipeline.html#GstPipeline\">Gst.Pipeline</a>.  They can track the offset and rate difference\nof their internal clock relative to the master clock by using the\n<a href=\"gstclock.html#gst_clock_get_calibration\">Gst.Clock.get_calibration</a> function.</p>\n<p>The master/slave synchronisation can be tuned with the <a href=\"gstclock.html#GstClock:timeout\">timeout</a>,\n<a href=\"gstclock.html#GstClock:window-size\">window-size</a> and <a href=\"gstclock.html#GstClock:window-threshold\">window-threshold</a> properties.\nThe <a href=\"gstclock.html#GstClock:timeout\">timeout</a> property defines the interval to sample the master\nclock and run the calibration functions. <a href=\"gstclock.html#GstClock:window-size\">window-size</a> defines the\nnumber of samples to use when calibrating and <a href=\"gstclock.html#GstClock:window-threshold\">window-threshold</a>\ndefines the minimum number of samples before the calibration is performed.</p>\n\n</div>\n\n\n"});