fragment_downloaded_cb({"url": "gst-plugins-base-rtsp-1.0/gstrtspconnection.html#gst_rtsp_watch_write_data", "fragment": "gst_rtsp_watch_write_data \nGstRtsp.RTSPWatch.write_data \nGstRtsp.prototype.write_data \nWrite data using the connection of the watch. If it cannot be sent immediately it will be queued for transmission in watch. The contents of message will then be serialized and transmitted when the connection of the watch becomes writable. In case the message is queued the ID returned in id will be non zero and used as the ID argument in the message_sent callback. \nThis function will take ownership of data and g_free it after use. \nIf the amount of queued data exceeds the limits set with gst_rtsp_watch_set_send_backlog this function will return GST_RTSP_ENOMEM. \nParameters \na GstRTSPWatch \nthe data to queue \nthe size of data \nlocation for a message ID or NULL \nGST_RTSP_OK on success. GST_RTSP_ENOMEM when the backlog limits are reached. GST_RTSP_EINTR when watch was flushing. \nWrite data using the connection of the watch. If it cannot be sent immediately it will be queued for transmission in watch. The contents of message will then be serialized and transmitted when the connection of the watch becomes writable. In case the message is queued the ID returned in id will be non zero and used as the ID argument in the message_sent callback. \nThis function will take ownership of data and GLib.free it after use. \nIf the amount of queued data exceeds the limits set with GstRtsp.RTSPWatch.set_send_backlog this function will return GstRtsp.RTSPResult.ENOMEM. \nParameters \na GstRtsp.RTSPWatch \nthe data to queue \nthe size of data \nReturns a tuple made of \nGstRtsp.RTSPResult.OK on success. GstRtsp.RTSPResult.ENOMEM when the backlog limits are reached. GstRtsp.RTSPResult.EINTR when watch was flushing. \nGstRtsp.RTSPResult.OK on success. GstRtsp.RTSPResult.ENOMEM when the backlog limits are reached. GstRtsp.RTSPResult.EINTR when watch was flushing. \nWrite data using the connection of the watch. If it cannot be sent immediately it will be queued for transmission in watch. The contents of message will then be serialized and transmitted when the connection of the watch becomes writable. In case the message is queued the ID returned in id will be non zero and used as the ID argument in the message_sent callback. \nThis function will take ownership of data and prototype.free it after use. \nIf the amount of queued data exceeds the limits set with GstRtsp.prototype.set_send_backlog this function will return GstRtsp.RTSPResult.ENOMEM. \nParameters \na GstRtsp.RTSPWatch \nthe data to queue \nthe size of data \nReturns a tuple made of \nGstRtsp.RTSPResult.OK on success. GstRtsp.RTSPResult.ENOMEM when the backlog limits are reached. GstRtsp.RTSPResult.EINTR when watch was flushing. \nGstRtsp.RTSPResult.OK on success. GstRtsp.RTSPResult.ENOMEM when the backlog limits are reached. GstRtsp.RTSPResult.EINTR when watch was flushing. \n"});