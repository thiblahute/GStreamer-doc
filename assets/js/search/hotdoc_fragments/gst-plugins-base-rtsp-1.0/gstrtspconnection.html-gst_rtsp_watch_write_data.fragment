fragment_downloaded_cb({"url": "gst-plugins-base-rtsp-1.0/gstrtspconnection.html#gst_rtsp_watch_write_data", "fragment": "Gst.Rtsp.RTSPWatch.WriteData \nGst.Rtsp.RTSPWatch.WriteData \nGst.Rtsp.RTSPWatch.WriteData \nGst.Rtsp.RTSPWatch.WriteData \nWrite data using the connection of the watch. If it cannot be sent immediately it will be queued for transmission in watch. The contents of message will then be serialized and transmitted when the connection of the watch becomes writable. In case the message is queued the ID returned in id will be non zero and used as the ID argument in the message_sent callback. \nThis function will take ownership of data and GLib.Global.Free it after use. \nIf the amount of queued data exceeds the limits set with Gst.Rtsp.RTSPWatch.SetSendBacklog this function will return Gst.Rtsp.RTSPResult.Enomem. \nParameters \na Gst.Rtsp.RTSPWatch \nthe data to queue \nthe size of data \nReturns a tuple made of \nGst.Rtsp.RTSPResult.Ok on success. Gst.Rtsp.RTSPResult.Enomem when the backlog limits are reached. Gst.Rtsp.RTSPResult.Eintr when watch was flushing. \nGst.Rtsp.RTSPResult.Ok on success. Gst.Rtsp.RTSPResult.Enomem when the backlog limits are reached. Gst.Rtsp.RTSPResult.Eintr when watch was flushing. \nWrite data using the connection of the watch. If it cannot be sent immediately it will be queued for transmission in watch. The contents of message will then be serialized and transmitted when the connection of the watch becomes writable. In case the message is queued the ID returned in id will be non zero and used as the ID argument in the message_sent callback. \nThis function will take ownership of data and GLib.Global.Free it after use. \nIf the amount of queued data exceeds the limits set with Gst.Rtsp.RTSPWatch.SetSendBacklog this function will return Gst.Rtsp.RTSPResult.Enomem. \nParameters \na Gst.Rtsp.RTSPWatch \nthe data to queue \nthe size of data \nlocation for a message ID or null \nGst.Rtsp.RTSPResult.Ok on success. Gst.Rtsp.RTSPResult.Enomem when the backlog limits are reached. Gst.Rtsp.RTSPResult.Eintr when watch was flushing. \nWrite data using the connection of the watch. If it cannot be sent immediately it will be queued for transmission in watch. The contents of message will then be serialized and transmitted when the connection of the watch becomes writable. In case the message is queued the ID returned in id will be non zero and used as the ID argument in the message_sent callback. \nThis function will take ownership of data and GLib.Global.Free it after use. \nIf the amount of queued data exceeds the limits set with Gst.Rtsp.RTSPWatch.SetSendBacklog this function will return Gst.Rtsp.RTSPResult.Enomem. \nParameters \nthe data to queue \nthe size of data \nlocation for a message ID or null \nGst.Rtsp.RTSPResult.Ok on success. Gst.Rtsp.RTSPResult.Enomem when the backlog limits are reached. Gst.Rtsp.RTSPResult.Eintr when watch was flushing. \nWrite data using the connection of the watch. If it cannot be sent immediately it will be queued for transmission in watch. The contents of message will then be serialized and transmitted when the connection of the watch becomes writable. In case the message is queued the ID returned in id will be non zero and used as the ID argument in the message_sent callback. \nThis function will take ownership of data and GLib.Global.Free it after use. \nIf the amount of queued data exceeds the limits set with Gst.Rtsp.RTSPWatch.SetSendBacklog this function will return Gst.Rtsp.RTSPResult.Enomem. \nParameters \na Gst.Rtsp.RTSPWatch \nthe data to queue \nthe size of data \nReturns a tuple made of \nGst.Rtsp.RTSPResult.Ok on success. Gst.Rtsp.RTSPResult.Enomem when the backlog limits are reached. Gst.Rtsp.RTSPResult.Eintr when watch was flushing. \nGst.Rtsp.RTSPResult.Ok on success. Gst.Rtsp.RTSPResult.Enomem when the backlog limits are reached. Gst.Rtsp.RTSPResult.Eintr when watch was flushing. \n"});