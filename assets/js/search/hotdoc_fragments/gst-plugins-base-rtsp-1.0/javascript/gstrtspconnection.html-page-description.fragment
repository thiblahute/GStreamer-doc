fragment_downloaded_cb({"url": "gst-plugins-base-rtsp-1.0/javascript/gstrtspconnection.html#page-description", "fragment": "Clear the list of authentication directives stored in conn. \nClose the connected conn. After this call the connection is in the same state as when it was first created. \nAttempt to connect to the url of conn made with GstRtsp.prototype.rtsp_connection_create. If timeout is null this function can block forever. If timeout contains a valid timeout this function will return GstRtsp.RTSPResult.prototype.etimeout after the timeout expired. \nThis function can be cancelled with GstRtsp.RTSPConnection.prototype.flush. \nAttempt to connect to the url of conn made with GstRtsp.prototype.rtsp_connection_create. If timeout is null this function can block forever. If timeout contains a valid timeout this function will return GstRtsp.RTSPResult.prototype.etimeout after the timeout expired. If conn is set to tunneled response will contain a response to the tunneling request messages. \nThis function can be cancelled with GstRtsp.RTSPConnection.prototype.flush. \nIf conn received the first tunnel connection and conn2 received the second tunnel connection link the two connections together so that conn manages the tunneled connection. \nAfter this call conn2 cannot be used anymore and must be freed with GstRtsp.RTSPConnection.prototype.free. \nIf conn2 is null then only the base64 decoding context will be setup for conn. \nStart or stop the flushing action on conn. When flushing all current and future actions on conn will return GstRtsp.RTSPResult.prototype.eintr until the connection is set to non flushing mode again. \nClose and free conn. \nRetrieve the IP address of the other end of conn. \nGet the file descriptor for reading. \nGet the TLS connection of conn. \nFor client side this will return the Gio.TlsClientConnection when connected over TLS. \nFor server side connections this function will create a GTlsServerConnection when called the first time and will return that same connection on subsequent calls. The server is then responsible for configuring the TLS connection. \nGets the anchor certificate authorities database that will be used after a server certificate can t be verified with the default certificate database. \nGets a Gio.TlsInteraction object to be used when the connection or certificate database need to interact with the user. This will be used to prompt the user for passwords where necessary. \nGets the TLS validation flags used to verify the peer certificate when a TLS connection is established. \nGet the tunnel session id the connection. \nRetrieve the URL of the other end of conn. \nGet the file descriptor for writing. \nGet the tunneling state of the connection. \nCalculate the next timeout for conn storing the result in timeout. \nWait up to the specified timeout for the connection to become available for at least one of the operations specified in events. When the function returns with GstRtsp.RTSPResult.prototype.ok revents will contain a bitmask of available operations on conn. \ntimeout can be null in which case this function might block forever. \nThis function can be cancelled with GstRtsp.RTSPConnection.prototype.flush. \nAttempt to read size bytes into data from the connected conn blocking up to the specified timeout. timeout can be null in which case this function might block forever. \nThis function can be cancelled with GstRtsp.RTSPConnection.prototype.flush. \nAttempt to read into message from the connected conn blocking up to the specified timeout. timeout can be null in which case this function might block forever. \nThis function can be cancelled with GstRtsp.RTSPConnection.prototype.flush. \nReset the timeout of conn. \nAttempt to send message to the connected conn blocking up to the specified timeout. timeout can be null in which case this function might block forever. \nThis function can be cancelled with GstRtsp.RTSPConnection.prototype.flush. \nConfigure conn for authentication mode method with user and pass as the user and password respectively. \nSetup conn with authentication directives. This is not necesary for methods GstRtsp.RTSPAuthMethod.prototype.none and GstRtsp.RTSPAuthMethod.prototype.basic. For GstRtsp.RTSPAuthMethod.prototype.digest directives should be taken from the digest challenge in the WWW Authenticate response header and can include realm domain nonce opaque stale algorithm qop as per RFC2617. \nBy setting the HTTP mode to true the message parsing will support HTTP messages in addition to the RTSP messages. It will also disable the automatic handling of setting up an HTTP tunnel. \nSet the IP address of the server. \nSet the proxy host and port. \nConfigure conn to use the specified DSCP value. \nSets if the GstRtsp.RTSPConnection should remember the session id from the last response received and force it onto any further requests. \nThe default value is true \nSets the anchor certificate authorities database. This certificate database will be used to verify the server s certificate in case it can t be verified with the default certificate database first. \nSets a Gio.TlsInteraction object to be used when the connection or certificate database need to interact with the user. This will be used to prompt the user for passwords where necessary. \nSets the TLS validation flags to be used to verify the peer certificate when a TLS connection is established. \nSet the HTTP tunneling state of the connection. This must be configured before the conn is connected. \nAttempt to write size bytes of data to the connected conn blocking up to the specified timeout. timeout can be null in which case this function might block forever. \nThis function can be cancelled with GstRtsp.RTSPConnection.prototype.flush. \nAdds a GstRtsp.RTSPWatch to a context so that it will be executed within that context. \nGet the maximum amount of bytes and messages that will be queued in watch. See GstRtsp.RTSPWatch.prototype.set_send_backlog. \nReset watch this is usually called after GstRtsp.RTSPConnection.prototype.do_tunnel when the file descriptors of the connection might have changed. \nSend a message using the connection of the watch. If it cannot be sent immediately it will be queued for transmission in watch. The contents of message will then be serialized and transmitted when the connection of the watch becomes writable. In case the message is queued the ID returned in id will be non zero and used as the ID argument in the message_sent callback. \nWhen flushing is true abort a call to GstRtsp.RTSPWatch.prototype.wait_backlog and make sure GstRtsp.RTSPWatch.prototype.write_data returns immediately with GstRtsp.RTSPResult.prototype.eintr. And empty the queue. \nSet the maximum amount of bytes and messages that will be queued in watch. When the maximum amounts are exceeded GstRtsp.RTSPWatch.prototype.write_data and GstRtsp.RTSPWatch.prototype.send_message will return GstRtsp.RTSPResult.prototype.enomem. \nA value of for bytes or messages means no limits. \nDecreases the reference count of watch by one. If the resulting reference count is zero the watch and associated memory will be destroyed. \nWait until there is place in the backlog queue timeout is reached or watch is set to flushing. \nIf timeout is null this function can block forever. If timeout contains a valid timeout this function will return GstRtsp.RTSPResult.prototype.etimeout after the timeout expired. \nThe typically use of this function is when gst_rtsp_watch_write_data returns GstRtsp.RTSPResult.prototype.enomem. The caller then calls this function to wait for free space in the backlog queue and try again. \nWrite data using the connection of the watch. If it cannot be sent immediately it will be queued for transmission in watch. The contents of message will then be serialized and transmitted when the connection of the watch becomes writable. In case the message is queued the ID returned in id will be non zero and used as the ID argument in the message_sent callback. \nThis function will take ownership of data and GLib.prototype.free it after use. \nIf the amount of queued data exceeds the limits set with GstRtsp.RTSPWatch.prototype.set_send_backlog this function will return GstRtsp.RTSPResult.prototype.enomem. \nAccept a new connection on socket and create a new GstRtsp.RTSPConnection for handling communication on new socket. \nCreate a newly allocated GstRtsp.RTSPConnection from url and store it in conn. The connection will not yet attempt to connect to url use GstRtsp.RTSPConnection.prototype.connect. \nA copy of url will be made. \nCreate a new GstRtsp.RTSPConnection for handling communication on the existing socket socket. The initial_buffer contains zero terminated data already read from socket which should be used before starting to read new data. \n"});