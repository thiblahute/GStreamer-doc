fragment_downloaded_cb({"url": "gst-plugins-base-tag-doc-1.0/python/gsttagdemux.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gsttagdemux.h\">\n<h1 id=\"gsttagdemux\">GstTagDemux</h1><p>Provides a base class for demuxing tags at the beginning or end of a\nstream and handles things like typefinding, querying, seeking, and\ndifferent modes of operation (chain-based, pull_range-based, and providing\ndownstream elements with random access if upstream supports that). The tag\nis stripped from the output, and all offsets are adjusted for the tag\nsizes, so that to the downstream element the stream will appear as if\nthere was no tag at all. Also, once the tag has been parsed, GstTagDemux\nwill try to determine the media type of the resulting stream and add a\nsource pad with the appropriate caps in order to facilitate auto-plugging.</p>\n<h2 id=\"deriving-from-gsttagdemux\">Deriving from GstTagDemux</h2>\n<p>Subclasses have to do four things:</p>\n<ul>\n<li>In their base init function, they must add a pad template for the sink\npad to the element class, describing the media type they can parse in\nthe caps of the pad template.</li>\n<li>In their class init function, they must override\nGST_TAG_DEMUX_CLASS(demux_klass)-&gt;identify_tag with their own identify\nfunction.</li>\n<li>In their class init function, they must override\nGST_TAG_DEMUX_CLASS(demux_klass)-&gt;parse_tag with their own parse\nfunction.</li>\n<li>In their class init function, they must also set\nGST_TAG_DEMUX_CLASS(demux_klass)-&gt;min_start_size and/or\nGST_TAG_DEMUX_CLASS(demux_klass)-&gt;min_end_size to the minimum size required\nfor the identify function to decide whether the stream has a supported tag\nor not. A class parsing ID3v1 tags, for example, would set min_end_size to\n128 bytes.</li>\n</ul>\n\n</div>\n\n\n"});