fragment_downloaded_cb({"url": "libgstcheck-1.0/python/gsttestclock.html#page-description", "fragment": "Advancing the time of a GstCheck.TestClock \nDemonstration of how to work with clock notifications and GstCheck.TestClock \nGstTestClock \nGst.Clock allows for setting up single shot or periodic clock notifications as well as waiting for these notifications synchronously using Gst.Clock.id_wait or asynchronously using Gst.Clock.id_wait_async or Gst.Clock.id_wait_async This is used by many GStreamer elements among them GstBaseSrc not introspectable and GstBaseSink not introspectable \nGstCheck.TestClock keeps track of these clock notifications. By calling GstCheck.TestClock.wait_for_next_pending_id or GstCheck.TestClock.wait_for_multiple_pending_ids a unit tests may wait for the next one or several clock notifications to be requested. Additionally unit tests may release blocked waits in a controlled fashion by calling GstCheck.TestClock.process_next_clock_id. This way a unit test can control the inaccuracy jitter of clock notifications since the test can decide to release blocked waits when the clock time has advanced exactly to or past the requested clock notification time. \nThere are also interfaces for determining if a notification belongs to a GstCheck.TestClock or not as well as getting the number of requested clock notifications so far. \nN.B. When a unit test waits for a certain amount of clock notifications to be requested in GstCheck.TestClock.wait_for_next_pending_id or GstCheck.TestClock.wait_for_multiple_pending_ids then these functions may block for a long time. If they block forever then the expected clock notifications were never requested from GstCheck.TestClock and so the assumptions in the code of the unit test are wrong. The unit test case runner in gstcheck is expected to catch these cases either by the default test case timeout or the one set for the unit test by calling tcase_set_timeout \nThe sample code below assumes that the element under test will delay a buffer pushed on the source pad by some latency until it arrives on the sink pad. Moreover it is assumed that the element will at some point call Gst.Clock.id_wait to synchronously wait for a specific time. The first buffer sent will arrive exactly on time only delayed by the latency. The second buffer will arrive a little late ms due to simulated jitter in the clock notification. \nSince GstCheck.TestClock is only supposed to be used in unit tests it calls g_assert not introspectable g_assert_cmpint not introspectable or g_assert_cmpuint not introspectable to validate all function arguments. This will highlight any issues with the unit test code itself. \nA GstCheck.TestClock structure which is based on a Gst.Clock along with some private data. \nCreates a new test clock with its time set to the specified time. \nMT safe. \nFinds the latest time inside the list. \nMT safe. \nRetrieve the requested time for the next pending clock notification. \nMT safe. \nDetermine the number of pending clock notifications that have been requested from the test_clock. \nMT safe. \nDetermines if the pending_id is the next clock notification scheduled to be triggered given the current time of the test_clock. \nMT safe. \nReturn True if pending_id is the next clock notification to be triggered False otherwise. \nProcesses and releases the pending IDs in the list. \nMT safe. \nMT safe. \nBlocks until at least count clock notifications have been requested from test_clock. There is no timeout for this wait see the main description of GstCheck.TestClock. \nMT safe. \nWaits until a clock notification is requested from test_clock. There is no timeout for this wait see the main description of GstCheck.TestClock. A reference to the pending clock notification is stored in pending_id. \nMT safe. \nBlocks until at least count clock notifications have been requested from test_clock. There is no timeout for this wait see the main description of GstCheck.TestClock. \n"});