fragment_downloaded_cb({"url": "libgstcheck-1.0/javascript/gsttestclock.html#advancing-the-time-of-a-gstchecktestclock", "fragment": "Advancing the time of a GstCheck.TestClock \nGst.Clock allows for setting up single shot or periodic clock notifications as well as waiting for these notifications synchronously using Gst.Clock.prototype.id_wait or asynchronously using Gst.Clock.prototype.id_wait_async or Gst.Clock.prototype.id_wait_async This is used by many GStreamer elements among them GstBase.BaseSrc and GstBase.BaseSink. \nGstCheck.TestClock keeps track of these clock notifications. By calling GstCheck.TestClock.prototype.wait_for_next_pending_id or GstCheck.TestClock.prototype.wait_for_multiple_pending_ids a unit tests may wait for the next one or several clock notifications to be requested. Additionally unit tests may release blocked waits in a controlled fashion by calling GstCheck.TestClock.prototype.process_next_clock_id. This way a unit test can control the inaccuracy jitter of clock notifications since the test can decide to release blocked waits when the clock time has advanced exactly to or past the requested clock notification time. \nThere are also interfaces for determining if a notification belongs to a GstCheck.TestClock or not as well as getting the number of requested clock notifications so far. \nN.B. When a unit test waits for a certain amount of clock notifications to be requested in GstCheck.TestClock.prototype.wait_for_next_pending_id or GstCheck.TestClock.prototype.wait_for_multiple_pending_ids then these functions may block for a long time. If they block forever then the expected clock notifications were never requested from GstCheck.TestClock and so the assumptions in the code of the unit test are wrong. The unit test case runner in gstcheck is expected to catch these cases either by the default test case timeout or the one set for the unit test by calling tcase_set_timeout \nThe sample code below assumes that the element under test will delay a buffer pushed on the source pad by some latency until it arrives on the sink pad. Moreover it is assumed that the element will at some point call Gst.Clock.prototype.id_wait to synchronously wait for a specific time. The first buffer sent will arrive exactly on time only delayed by the latency. The second buffer will arrive a little late ms due to simulated jitter in the clock notification. \n"});