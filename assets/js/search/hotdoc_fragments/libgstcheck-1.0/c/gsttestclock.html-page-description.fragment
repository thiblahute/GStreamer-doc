fragment_downloaded_cb({"url": "libgstcheck-1.0/c/gsttestclock.html#page-description", "fragment": "Advancing the time of a GstTestClock \nDemonstration of how to work with clock notifications and GstTestClock \nGstTestClock \nGstClock allows for setting up single shot or periodic clock notifications as well as waiting for these notifications synchronously using gst_clock_id_wait or asynchronously using gst_clock_id_wait_async or gst_clock_id_wait_async This is used by many GStreamer elements among them GstBaseSrc and GstBaseSink. \nGstTestClock keeps track of these clock notifications. By calling gst_test_clock_wait_for_next_pending_id or gst_test_clock_wait_for_multiple_pending_ids a unit tests may wait for the next one or several clock notifications to be requested. Additionally unit tests may release blocked waits in a controlled fashion by calling gst_test_clock_process_next_clock_id. This way a unit test can control the inaccuracy jitter of clock notifications since the test can decide to release blocked waits when the clock time has advanced exactly to or past the requested clock notification time. \nThere are also interfaces for determining if a notification belongs to a GstTestClock or not as well as getting the number of requested clock notifications so far. \nN.B. When a unit test waits for a certain amount of clock notifications to be requested in gst_test_clock_wait_for_next_pending_id or gst_test_clock_wait_for_multiple_pending_ids then these functions may block for a long time. If they block forever then the expected clock notifications were never requested from GstTestClock and so the assumptions in the code of the unit test are wrong. The unit test case runner in gstcheck is expected to catch these cases either by the default test case timeout or the one set for the unit test by calling tcase_set_timeout \nThe sample code below assumes that the element under test will delay a buffer pushed on the source pad by some latency until it arrives on the sink pad. Moreover it is assumed that the element will at some point call gst_clock_id_wait to synchronously wait for a specific time. The first buffer sent will arrive exactly on time only delayed by the latency. The second buffer will arrive a little late ms due to simulated jitter in the clock notification. \nSince GstTestClock is only supposed to be used in unit tests it calls g_assert g_assert_cmpint or g_assert_cmpuint to validate all function arguments. This will highlight any issues with the unit test code itself. \nA GstTestClock structure which is based on a GstClock along with some private data. \nCreates a new test clock with its time set to the specified time. \nMT safe. \nFinds the latest time inside the list. \nMT safe. \nRetrieve the requested time for the next pending clock notification. \nMT safe. \nDetermines if the pending_id is the next clock notification scheduled to be triggered given the current time of the test_clock. \nMT safe. \nReturn TRUE if pending_id is the next clock notification to be triggered FALSE otherwise. \nProcesses and releases the pending IDs in the list. \nMT safe. \nMT safe. \nBlocks until at least count clock notifications have been requested from test_clock. There is no timeout for this wait see the main description of GstTestClock. \nMT safe. \nWaits until a clock notification is requested from test_clock. There is no timeout for this wait see the main description of GstTestClock. A reference to the pending clock notification is stored in pending_id. \nMT safe. \nBlocks until at least count clock notifications have been requested from test_clock. There is no timeout for this wait see the main description of GstTestClock. \n"});