fragment_downloaded_cb({"url": "gst-plugins-good-doc-1.0/element-rtpsession.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"element-rtpsession\">\n<h1 id=\"rtpsession1\">rtpsession</h1><p>The RTP session manager models participants with unique SSRC in an RTP\nsession. This session can be used to send and receive RTP and RTCP packets.\nBased on what REQUEST pads are requested from the session manager, specific\nfunctionality can be activated.</p>\n<p>The session manager currently implements RFC 3550 including:</p>\n<ul>\n<li>\n<p>RTP packet validation based on consecutive sequence numbers.</p>\n</li>\n<li>\n<p>Maintainance of the SSRC participant database.</p>\n</li>\n<li>\n<p>Keeping per participant statistics based on received RTCP packets.</p>\n</li>\n<li>\n<p>Scheduling of RR/SR RTCP packets.</p>\n</li>\n<li>\n<p>Support for multiple sender SSRC.</p>\n</li>\n</ul>\n<p>The rtpsession will not demux packets based on SSRC or payload type, nor will\nit correct for packet reordering and jitter. Use GstRtpsSrcDemux,\n<a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpptdemux.html#GstRtpPtDemux-struct\">GstRtpPtDemux</a> and GstRtpJitterBuffer in addition to <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpsession.html#GstRtpSession-struct\">GstRtpSession</a> to\nperform these tasks. It is usually a good idea to use <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpbin.html#GstRtpBin-struct\">GstRtpBin</a>, which\ncombines all these features in one element.</p>\n<p>To use <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpsession.html#GstRtpSession-struct\">GstRtpSession</a> as an RTP receiver, request a recv_rtp_sink pad, which will\nautomatically create recv_rtp_src pad. Data received on the recv_rtp_sink pad\nwill be processed in the session and after being validated forwarded on the\nrecv_rtp_src pad.</p>\n<p>To also use <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpsession.html#GstRtpSession-struct\">GstRtpSession</a> as an RTCP receiver, request a recv_rtcp_sink pad,\nwhich will automatically create a sync_src pad. Packets received on the RTCP\npad will be used by the session manager to update the stats and database of\nthe other participants. SR packets will be forwarded on the sync_src pad\nso that they can be used to perform inter-stream synchronisation when needed.</p>\n<p>If you want the session manager to generate and send RTCP packets, request\nthe send_rtcp_src pad. Packet pushed on this pad contain SR/RR RTCP reports\nthat should be sent to all participants in the session.</p>\n<p>To use <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpsession.html#GstRtpSession-struct\">GstRtpSession</a> as a sender, request a send_rtp_sink pad, which will\nautomatically create a send_rtp_src pad. The session manager will\nforward the packets on the send_rtp_src pad after updating its internal state.</p>\n<p>The session manager needs the clock-rate of the payload types it is handling\nand will signal the <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpsession.html#GstRtpSession-request-pt-map\">GstRtpSession::request-pt-map</a> signal when it needs such a\nmapping. One can clear the cached values with the <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtpsession.html#GstRtpSession-clear-pt-map\">GstRtpSession::clear-pt-map</a>\nsignal.</p>\n<h2 id=\"example-pipelines\">Example pipelines</h2>\n<pre><code class=\"language-[\"> gst-launch-1.0 udpsrc port=5000 caps=\"application/x-rtp, ...\" ! .recv_rtp_sink rtpsession .recv_rtp_src ! rtptheoradepay ! theoradec ! xvimagesink\n ]| Receive theora RTP packets from port 5000 and send them to the depayloader,\n decoder and display. Note that the application/x-rtp caps on udpsrc should be\n configured based on some negotiation process such as RTSP for this pipeline\n to work correctly.\n |[\n gst-launch-1.0 udpsrc port=5000 caps=\"application/x-rtp, ...\" ! .recv_rtp_sink rtpsession name=session \\\n        .recv_rtp_src ! rtptheoradepay ! theoradec ! xvimagesink \\\n     udpsrc port=5001 caps=\"application/x-rtcp\" ! session.recv_rtcp_sink\n ]| Receive theora RTP packets from port 5000 and send them to the depayloader,\n decoder and display. Receive RTCP packets from port 5001 and process them in\n the session manager.\n Note that the application/x-rtp caps on udpsrc should be\n configured based on some negotiation process such as RTSP for this pipeline\n to work correctly.\n |[\n gst-launch-1.0 videotestsrc ! theoraenc ! rtptheorapay ! .send_rtp_sink rtpsession .send_rtp_src ! udpsink port=5000\n ]| Send theora RTP packets through the session manager and out on UDP port\n 5000.\n |[\n gst-launch-1.0 videotestsrc ! theoraenc ! rtptheorapay ! .send_rtp_sink rtpsession name=session .send_rtp_src \\\n     ! udpsink port=5000  session.send_rtcp_src ! udpsink port=5001\n ]| Send theora RTP packets through the session manager and out on UDP port\n 5000. Send RTCP packets on port 5001. Note that this pipeline will not preroll\n correctly because the second udpsink will not preroll correctly (no RTCP\n packets are sent in the PAUSED state). Applications should manually set and\n keep (see gst_element_set_locked_state()) the RTCP udpsink to the PLAYING state.\n</code></pre>\n\n</div>\n\n\n"});