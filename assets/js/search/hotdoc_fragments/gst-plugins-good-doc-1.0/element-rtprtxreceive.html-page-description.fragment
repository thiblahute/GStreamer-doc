fragment_downloaded_cb({"url": "gst-plugins-good-doc-1.0/element-rtprtxreceive.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"element-rtprtxreceive\">\n<h1 id=\"rtprtxreceive1\">rtprtxreceive</h1><p>The receiver will listen to the custom retransmission events from the\ndownstream jitterbuffer and will remember the SSRC1 of the stream and\nseqnum that was requested. When it sees a packet with one of the stored\nseqnum, it associates the SSRC2 of the stream with the SSRC1 of the\nmaster stream. From then it knows that SSRC2 is the retransmission\nstream of SSRC1. This algorithm is stated in RFC 4588. For this\nalgorithm to work, RFC4588 also states that no two pending retransmission\nrequests can exist for the same seqnum and different SSRCs or else it\nwould be impossible to associate the retransmission with the original\nrequester SSRC.\nWhen the RTX receiver has associated the retransmission packets,\nit can depayload and forward them to the source pad of the element.\nRTX is SSRC-multiplexed. See <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-good/html/gst-plugins-good-plugins-rtprtxsend.html#GstRtpRtxSend-struct\">GstRtpRtxSend</a></p>\n<h2 id=\"example-pipelines\">Example pipelines</h2>\n<pre><code class=\"language-[\"> gst-launch-1.0 rtpsession name=rtpsession \\\n         audiotestsrc ! speexenc ! rtpspeexpay pt=97 ! rtprtxsend rtx-payload-type=99 ! \\\n             identity drop-probability=0.1 ! rtpsession.send_rtp_sink \\\n             rtpsession.send_rtp_src ! udpsink host=\"127.0.0.1\" port=5000 \\\n         udpsrc port=5001 ! rtpsession.recv_rtcp_sink \\\n         rtpsession.send_rtcp_src ! udpsink host=\"127.0.0.1\" port=5002 sync=false async=false\n ]| Send audio stream through port 5000. (5001 and 5002 are just the rtcp link with the receiver)\n |[\n gst-launch-1.0 rtpsession name=rtpsession \\\n         udpsrc port=5000 caps=\"application/x-rtp,media=(string)audio,clock-rate=(int)44100,encoding-name=(string)SPEEX,encoding-params=(string)1,octet-align=(string)1\" ! \\\n             rtpsession.recv_rtp_sink \\\n             rtpsession.recv_rtp_src ! rtprtxreceive rtx-payload-types=\"99\" ! rtpjitterbuffer do-retransmission=true ! rtpspeexdepay ! \\\n             speexdec ! audioconvert ! autoaudiosink \\\n         rtpsession.send_rtcp_src ! udpsink host=\"127.0.0.1\" port=5001 \\\n         udpsrc port=5002 ! rtpsession.recv_rtcp_sink sync=fakse async=false\n ]| Receive audio stream from port 5000. (5001 and 5002 are just the rtcp link with the sender)\n On sender side make sure to use a different payload type for the stream and\n its associated retransmission stream (see #GstRtpRtxSend). Note that several retransmission streams can\n have the same payload type so this is not deterministic. Actually the\n rtprtxreceiver element does the association using seqnum values.\n On receiver side set all the retransmission payload types (Those informations are retrieve\n through SDP).\n You should still hear a clear sound when setting drop-probability to something greater than 0.\n The rtpjitterbuffer will generate a custom upstream event GstRTPRetransmissionRequest when\n it assumes that one packet is missing. Then this request is translated to a FB NACK in the rtcp link\n Finally the rtpsession of the sender side re-convert it in a GstRTPRetransmissionRequest that will\n be handle by rtprtxsend.\n When increasing this value it may be possible that even the retransmission stream would be dropped\n so the receiver will ask to resend the packets again and again until it actually receive them.\n If the value is too high the rtprtxsend will not be able to retrieve the packet in its list of\n stored packets. For learning purpose you could try to increase the max-size-packets or max-size-time\n rtprtxsender's properties.\n Also note that you should use rtprtxsend through rtpbin and its set-aux-send property. See #GstRtpBin.\n |[\n gst-launch-1.0 rtpsession name=rtpsession0 \\\n         audiotestsrc wave=0 ! speexenc ! rtpspeexpay pt=97 ! rtprtxsend rtx-payload-type=99 seqnum-offset=1 ! \\\n             identity drop-probability=0.1 ! rtpsession0.send_rtp_sink \\\n             rtpsession0.send_rtp_src ! udpsink host=\"127.0.0.1\" port=5000 \\\n         udpsrc port=5001 ! rtpsession0.recv_rtcp_sink \\\n         rtpsession0.send_rtcp_src ! udpsink host=\"127.0.0.1\" port=5002 sync=false async=false \\\n                rtpsession name=rtpsession1 \\\n         audiotestsrc wave=0 ! speexenc ! rtpspeexpay pt=97 ! rtprtxsend rtx-payload-type=99 seqnum-offset=10 ! \\\n             identity drop-probability=0.1 ! rtpsession1.send_rtp_sink \\\n             rtpsession1.send_rtp_src ! udpsink host=\"127.0.0.1\" port=5000 \\\n         udpsrc port=5004 ! rtpsession1.recv_rtcp_sink \\\n         rtpsession1.send_rtcp_src ! udpsink host=\"127.0.0.1\" port=5002 sync=false async=false\n ]| Send two audio streams to port 5000.\n |[\n gst-launch-1.0 rtpsession name=rtpsession\n         udpsrc port=5000 caps=\"application/x-rtp,media=(string)audio,clock-rate=(int)44100,encoding-name=(string)SPEEX,encoding-params=(string)1,octet-align=(string)1\" ! \\\n             rtpsession.recv_rtp_sink \\\n             rtpsession.recv_rtp_src ! rtprtxreceive rtx-payload-types=\"99\" ! rtpssrcdemux name=demux \\\n             demux. ! queue ! rtpjitterbuffer do-retransmission=true ! rtpspeexdepay ! speexdec ! audioconvert ! autoaudiosink \\\n             demux. ! queue ! rtpjitterbuffer do-retransmission=true ! rtpspeexdepay ! speexdec ! audioconvert ! autoaudiosink \\\n         rtpsession.send_rtcp_src ! ! tee name=t ! queue ! udpsink host=\"127.0.0.1\" port=5001 t. ! queue ! udpsink host=\"127.0.0.1\" port=5004 \\\n         udpsrc port=5002 ! rtpsession.recv_rtcp_sink sync=fakse async=false\n ]| Receive audio stream from port 5000.\n On sender side the two streams have the same payload type for master streams, Same about retransmission streams.\n The streams are sent to the network through two distincts sessions.\n But we need to set a different seqnum-offset to make sure their seqnum navigate at a different rate like in concrete cases.\n We could also choose the same seqnum offset but we would require to set a different initial seqnum value.\n This is also why the rtprtxreceive can succeed to do the association between master and retransmission stream.\n On receiver side the same session is used to receive the two streams. So the rtpssrcdemux is here to demultiplex\n those two streams. The rtprtxreceive is responsible for reconstructing the original packets from the two retransmission streams.\n You can play with the drop-probability value for one or both streams.\n You should hear a clear sound. (after a few seconds the two streams wave feel synchronized)\n</code></pre>\n\n</div>\n\n\n"});