fragment_downloaded_cb({"url": "gst-plugins-base-rtp-1.0/c/gstrtpbuffer.html#page-description", "fragment": "Adds a RFC header extension with a one byte header to the end of the RTP header. If there is already a RFC header extension with a one byte header the new extension will be appended. It will not work if there is already a header extension that does not follow the mecanism described in RFC or if there is a header extension with a two bytes header as described in RFC In that case use gst_rtp_buffer_add_extension_twobytes_header \nAdds a RFC header extension with a two bytes header to the end of the RTP header. If there is already a RFC header extension with a two bytes header the new extension will be appended. It will not work if there is already a header extension that does not follow the mecanism described in RFC or if there is a header extension with a one byte header as described in RFC In that case use gst_rtp_buffer_add_extension_onebyte_header \nGet the CSRC count of the RTP packet in buffer. \nSimilar to gst_rtp_buffer_get_extension_data but more suitable for language bindings usage. bits will contain the extension bits of custom data and the extension data not including the extension header is placed in a new GBytes structure. \nIf rtp did not contain an extension this function will return NULL with bits unchanged. If there is an extension header but no extension data then an empty GBytes will be returned. \nGet the extension data. bits will contain the extension bits of custom data. data will point to the data in the extension and wordlen will contain the length of data in bits words. \nIf buffer did not contain an extension this function will return FALSE with bits data and wordlen unchanged. \nParses RFC style header extensions with a one byte header. It will return the nth extension with the requested id. \nParses RFC style header extensions with a two bytes header. It will return the nth extension with the requested id. \nReturn the total length of the header in buffer. This include the length of the fixed header the CSRC list and the extension header. \nReturn the total length of the packet in buffer. \nCreate a buffer of the payload of the RTP packet in buffer. This function will internally create a subbuffer of buffer so that a memcpy can be avoided. \nSimilar to gst_rtp_buffer_get_payload but more suitable for language bindings usage. The return value is a pointer to a GBytes structure containing the payload data in rtp. \nGet the length of the payload of the RTP packet in buffer. \nCreate a subbuffer of the payload of the RTP packet in buffer. offset bytes are skipped in the payload and the subbuffer will be of size len. If len is the total payload starting from offset is subbuffered. \nGet the payload type of the RTP packet in buffer. \nSet the extension bit of the rtp buffer and fill in the bits and length of the extension header. If the existing extension data is not large enough it will be made larger. \nSet the total rtp size to len. The data in the buffer will be made larger if needed. Any padding will be removed from the packet. \nSet the payload type of the RTP packet in buffer to payload_type. \nCalculate the header length of an RTP packet with csrc_count CSRC entries. An RTP packet can have at most CSRC entries. \nCalculate the total length of an RTP packet with a payload size of payload_len a padding of pad_len and a csrc_count CSRC entries. \nCalculate the length of the payload of an RTP packet with size packet_len a padding of pad_len and a csrc_count CSRC entries. \nCompare two sequence numbers taking care of wraparounds. This function returns the difference between seqnum1 and seqnum2. \nGet the default clock rate for the static payload type payload_type. \nCreate a new GstBuffer that can hold an RTP packet that is exactly packet_len long. The length of the payload depends on pad_len and csrc_count and can be calculated with gst_rtp_buffer_calc_payload_len. All RTP header fields will be set to FALSE. \nThe GstBuffer was once wrapped in a retransmitted packet as specified by RFC \nGST_RTP_BUFFER_FLAG_LAST \nSkip mapping and validation of RTP padding and RTP pad count when present. Useful for buffers where the padding may be encrypted. \nGST_RTP_BUFFER_MAP_FLAG_LAST \n"});