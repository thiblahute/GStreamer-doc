fragment_downloaded_cb({"url": "gst-plugins-base-rtp-1.0/c/gstrtpbasepayload.html#page-description", "fragment": "Virtual Methods \ngboolean dynamic \nguint16 seqnum \nguint mtu \nGstRTPBasePayloadPrivate priv \nCheck if the packet with size and duration would exceed the configured maximum size. \nPush list to the peer element of the payloader. The SSRC payload type seqnum and timestamp of the RTP buffer will be updated first. \nThis function takes ownership of list. \nSet the rtp options of the payloader. These options will be set in the caps of the payloader. Subclasses must call this method before calling gst_rtp_base_payload_push or gst_rtp_base_payload_set_outcaps. \nConfigure the output caps with the optional parameters. \nVariable arguments should be in the form field name field type as a GType value s The last variable argument should be NULL. \nTry to use the offset fields to generate perfect RTP timestamps. When this option is disabled RTP timestamps are generated from GST_BUFFER_PTS of each payloaded buffer. The PTSes of buffers may not necessarily increment with the amount of data in each input buffer consider e.g. the case where the buffer arrives from a network which means that the PTS is unrelated to the amount of data. Because the RTP timestamps are generated from GST_BUFFER_PTS this can result in RTP timestamps that also don t increment with the amount of data in the payloaded packet. To circumvent this it is possible to set the perfect rtptime option enabled. When this option is enabled the payloader will increment the RTP timestamps based on GST_BUFFER_OFFSET which relates to the amount of data in each packet rather than the GST_BUFFER_PTS of each buffer and therefore the RTP timestamps will more closely correlate with the amount of data in each buffer. Currently GstRTPBasePayload is limited to handling perfect RTP timestamps for audio streams. \nFlags Read Write \nForce buffers to be multiples of this duration in ns disables \nFlags Read Write \nFlags Read Write \ngpointer _gst_reserved \n"});