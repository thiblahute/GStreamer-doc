fragment_downloaded_cb({"url": "gst-plugins-base-rtp-1.0/javascript/gstrtpbuffer.html#page-description", "fragment": "Adds a RFC header extension with a one byte header to the end of the RTP header. If there is already a RFC header extension with a one byte header the new extension will be appended. It will not work if there is already a header extension that does not follow the mecanism described in RFC or if there is a header extension with a two bytes header as described in RFC In that case use GstRtp.RTPBuffer.prototype.add_extension_twobytes_header \nAdds a RFC header extension with a two bytes header to the end of the RTP header. If there is already a RFC header extension with a two bytes header the new extension will be appended. It will not work if there is already a header extension that does not follow the mecanism described in RFC or if there is a header extension with a one byte header as described in RFC In that case use GstRtp.RTPBuffer.prototype.add_extension_onebyte_header \nGet the CSRC at index idx in buffer. \nGet the CSRC count of the RTP packet in buffer. \nCheck if the extension bit is set on the RTP packet in buffer. \nSimilar to gst_rtp_buffer_get_extension_data but more suitable for language bindings usage. bits will contain the extension bits of custom data and the extension data not including the extension header is placed in a new GLib.Bytes structure. \nIf rtp did not contain an extension this function will return null with bits unchanged. If there is an extension header but no extension data then an empty GLib.Bytes will be returned. \nParses RFC style header extensions with a one byte header. It will return the nth extension with the requested id. \nParses RFC style header extensions with a two bytes header. It will return the nth extension with the requested id. \nReturn the total length of the header in buffer. This include the length of the fixed header the CSRC list and the extension header. \nCheck if the marker bit is set on the RTP packet in buffer. \nReturn the total length of the packet in buffer. \nCheck if the padding bit is set on the RTP packet in buffer. \nCreate a buffer of the payload of the RTP packet in buffer. This function will internally create a subbuffer of buffer so that a memcpy can be avoided. \nSimilar to gst_rtp_buffer_get_payload but more suitable for language bindings usage. The return value is a pointer to a GLib.Bytes structure containing the payload data in rtp. \nGet the length of the payload of the RTP packet in buffer. \nCreate a subbuffer of the payload of the RTP packet in buffer. offset bytes are skipped in the payload and the subbuffer will be of size len. If len is the total payload starting from offset is subbuffered. \nGet the payload type of the RTP packet in buffer. \nGet the sequence number of the RTP packet in buffer. \nGet the SSRC of the RTP packet in buffer. \nGet the timestamp of the RTP packet in buffer. \nGet the version number of the RTP packet in buffer. \nSet the amount of padding in the RTP packet in buffer to len. If len is the padding is removed. \nNOTE This function does not work correctly. \nModify the CSRC at index idx in buffer to csrc. \nSet the extension bit on the RTP packet in buffer to extension. \nSet the extension bit of the rtp buffer and fill in the bits and length of the extension header. If the existing extension data is not large enough it will be made larger. \nSet the marker bit on the RTP packet in buffer to marker. \nSet the total rtp size to len. The data in the buffer will be made larger if needed. Any padding will be removed from the packet. \nSet the padding bit on the RTP packet in buffer to padding. \nSet the payload type of the RTP packet in buffer to payload_type. \nSet the sequence number of the RTP packet in buffer to seq. \nSet the SSRC on the RTP packet in buffer to ssrc. \nSet the timestamp of the RTP packet in buffer to timestamp. \nSet the version of the RTP packet in buffer to version. \nAllocate enough data in buffer to hold an RTP packet with csrc_count CSRCs a payload length of payload_len and padding of pad_len. buffer must be writable and all previous memory in buffer will be freed. If pad_len is the padding bit will be set. All other RTP header fields will be set to FALSE. \nCalculate the header length of an RTP packet with csrc_count CSRC entries. An RTP packet can have at most CSRC entries. \nCalculate the total length of an RTP packet with a payload size of payload_len a padding of pad_len and a csrc_count CSRC entries. \nCalculate the length of the payload of an RTP packet with size packet_len a padding of pad_len and a csrc_count CSRC entries. \nCompare two sequence numbers taking care of wraparounds. This function returns the difference between seqnum1 and seqnum2. \nGet the default clock rate for the static payload type payload_type. \nUpdate the exttimestamp field with timestamp. For the first call of the method exttimestamp should point to a location with a value of \nThis function makes sure that the returned value is a constantly increasing value even in the case where there is a timestamp wraparound. \nAllocate a new Gst.Buffer with enough data to hold an RTP packet with csrc_count CSRCs a payload length of payload_len and padding of pad_len. All other RTP header fields will be set to FALSE. \nCreate a new Gst.Buffer that can hold an RTP packet that is exactly packet_len long. The length of the payload depends on pad_len and csrc_count and can be calculated with GstRtp.prototype.rtp_buffer_calc_payload_len. All RTP header fields will be set to FALSE. \nCreate a new buffer and set the data to a copy of len bytes of data and the size to len. The data will be freed when the buffer is freed. \nCreate a new buffer and set the data and size of the buffer to data and len respectively. data will be freed when the buffer is unreffed so this function transfers ownership of data to the new buffer. \nThe Gst.Buffer was once wrapped in a retransmitted packet as specified by RFC \nGstRtp.RTPBufferFlags.prototype.last \nSkip mapping and validation of RTP padding and RTP pad count when present. Useful for buffers where the padding may be encrypted. \nGstRtp.RTPBufferMapFlags.prototype.last \n"});