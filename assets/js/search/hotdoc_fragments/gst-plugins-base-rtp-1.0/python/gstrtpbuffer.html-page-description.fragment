fragment_downloaded_cb({"url": "gst-plugins-base-rtp-1.0/python/gstrtpbuffer.html#page-description", "fragment": "Adds a RFC header extension with a one byte header to the end of the RTP header. If there is already a RFC header extension with a one byte header the new extension will be appended. It will not work if there is already a header extension that does not follow the mecanism described in RFC or if there is a header extension with a two bytes header as described in RFC In that case use GstRtp.RTPBuffer.add_extension_twobytes_header \nAdds a RFC header extension with a two bytes header to the end of the RTP header. If there is already a RFC header extension with a two bytes header the new extension will be appended. It will not work if there is already a header extension that does not follow the mecanism described in RFC or if there is a header extension with a one byte header as described in RFC In that case use GstRtp.RTPBuffer.add_extension_onebyte_header \nSimilar to gst_rtp_buffer_get_extension_data but more suitable for language bindings usage. bits will contain the extension bits of custom data and the extension data not including the extension header is placed in a new GLib.Bytes structure. \nIf rtp did not contain an extension this function will return None with bits unchanged. If there is an extension header but no extension data then an empty GLib.Bytes will be returned. \nParses RFC style header extensions with a one byte header. It will return the nth extension with the requested id. \nParses RFC style header extensions with a two bytes header. It will return the nth extension with the requested id. \nCreate a buffer of the payload of the RTP packet in buffer. This function will internally create a subbuffer of buffer so that a memcpy can be avoided. \nSimilar to gst_rtp_buffer_get_payload but more suitable for language bindings usage. The return value is a pointer to a GLib.Bytes structure containing the payload data in rtp. \nGet the length of the payload of the RTP packet in buffer. \nCreate a subbuffer of the payload of the RTP packet in buffer. offset bytes are skipped in the payload and the subbuffer will be of size len. If len is the total payload starting from offset is subbuffered. \nGet the payload type of the RTP packet in buffer. \nSet the extension bit of the rtp buffer and fill in the bits and length of the extension header. If the existing extension data is not large enough it will be made larger. \nSet the payload type of the RTP packet in buffer to payload_type. \nAllocate enough data in buffer to hold an RTP packet with csrc_count CSRCs a payload length of payload_len and padding of pad_len. buffer must be writable and all previous memory in buffer will be freed. If pad_len is the padding bit will be set. All other RTP header fields will be set to FALSE. \nCalculate the header length of an RTP packet with csrc_count CSRC entries. An RTP packet can have at most CSRC entries. \nCalculate the total length of an RTP packet with a payload size of payload_len a padding of pad_len and a csrc_count CSRC entries. \nCalculate the length of the payload of an RTP packet with size packet_len a padding of pad_len and a csrc_count CSRC entries. \nCompare two sequence numbers taking care of wraparounds. This function returns the difference between seqnum1 and seqnum2. \nGet the default clock rate for the static payload type payload_type. \nUpdate the exttimestamp field with timestamp. For the first call of the method exttimestamp should point to a location with a value of \nThis function makes sure that the returned value is a constantly increasing value even in the case where there is a timestamp wraparound. \nCreate a new Gst.Buffer that can hold an RTP packet that is exactly packet_len long. The length of the payload depends on pad_len and csrc_count and can be calculated with GstRtp.rtp_buffer_calc_payload_len. All RTP header fields will be set to FALSE. \nCreate a new buffer and set the data to a copy of len bytes of data and the size to len. The data will be freed when the buffer is freed. \nCreate a new buffer and set the data and size of the buffer to data and len respectively. data will be freed when the buffer is unreffed so this function transfers ownership of data to the new buffer. \nThe Gst.Buffer was once wrapped in a retransmitted packet as specified by RFC \nGstRtp.RTPBufferFlags.last \nSkip mapping and validation of RTP padding and RTP pad count when present. Useful for buffers where the padding may be encrypted. \nGstRtp.RTPBufferMapFlags.last \n"});