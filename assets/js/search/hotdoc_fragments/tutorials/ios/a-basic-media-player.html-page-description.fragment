fragment_downloaded_cb({"url": "tutorials/ios/a-basic-media-player.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"a-basic-media-player.md\">\n<h1 id=\"ios-tutorial-4-a-basic-media-player\">iOS tutorial 4: A basic media player</h1>\n<h2 id=\"goal\">Goal</h2>\n<p><img src=\"images/tutorials/ios-a-basic-media-player-screenshot.png\" alt=\"screenshot\" id=\"screenshot\"></p>\n<p>Enough testing with synthetic images and audio tones! This tutorial\nfinally plays actual media, streamed directly from the Internet, in your\niOS device. It shows:</p>\n<ul>\n<li>How to keep the User Interface regularly updated with the current\nplayback position and duration</li>\n<li>How to implement a <a href=\"http://developer.apple.com/library/ios/#documentation/UIKit/Reference/UISlider_Class/Reference/Reference.html\">Time\nSlider</a></li>\n<li>How to report the media size to adapt the display surface</li>\n</ul>\n<p>It also uses the knowledge gathered in the <a href=\"../basic/index.html\">Basic tutorials</a> regarding:</p>\n<ul>\n<li>How to use <code>playbin</code> to play any kind of media</li>\n<li>How to handle network resilience problems</li>\n</ul>\n<h2 id=\"introduction\">Introduction</h2>\n<p>From the previous tutorials, we already have almost all necessary\npieces to build a media player. The most complex part is assembling a\npipeline which retrieves, decodes and displays the media, but we\nalready know that the <code>playbin</code> element can take care of all that for\nus. We only need to replace the manual pipeline we used in\n<a href=\"video.html\">iOS tutorial 3: Video</a> with a single-element <code>playbin</code> pipeline\nand we are good to go!</p>\n<p>However, we can do better than. We will add a <a href=\"http://developer.apple.com/library/ios/#documentation/UIKit/Reference/UISlider_Class/Reference/Reference.html\">Time\nSlider</a>,\nwith a moving thumb that will advance as our current position in the\nmedia advances. We will also allow the user to drag the thumb, to jump\n(or <em>seek</em>) to a different position.</p>\n<p>And finally, we will make the video surface adapt to the media size, so\nthe video sink is not forced to draw black borders around the clip.\nThis also allows the iOS layout to adapt more nicely to the actual\nmedia content. You can still force the video surface to have a specific\nsize if you really want to.</p>\n<h2 id=\"the-user-interface\">The User Interface</h2>\n<p>The User Interface from the previous tutorial is expanded again. A\n<code>UISlider</code> has been added to the toolbar, to keep track of the current\nposition in the clip, and allow the user to change it. Also, a\n(read-only) <code>UITextField</code> is added to show the exact clip position and\nduration.</p>\n<p><strong>VideoViewController.h</strong></p>\n<pre><code>#import &lt;UIKit/UIKit.h&gt;\n#import \"GStreamerBackendDelegate.h\"\n\n@interface VideoViewController : UIViewController &lt;GStreamerBackendDelegate&gt; {\n    IBOutlet UILabel *message_label;\n    IBOutlet UIBarButtonItem *play_button;\n    IBOutlet UIBarButtonItem *pause_button;\n    IBOutlet UIView *video_view;\n    IBOutlet UIView *video_container_view;\n    IBOutlet NSLayoutConstraint *video_width_constraint;\n    IBOutlet NSLayoutConstraint *video_height_constraint;\n    IBOutlet UIToolbar *toolbar;\n    IBOutlet UITextField *time_label;\n    IBOutlet UISlider *time_slider;\n}\n\n@property (retain,nonatomic) NSString *uri;\n\n-(IBAction) play:(id)sender;\n-(IBAction) pause:(id)sender;\n-(IBAction) sliderValueChanged:(id)sender;\n-(IBAction) sliderTouchDown:(id)sender;\n-(IBAction) sliderTouchUp:(id)sender;\n\n/* From GStreamerBackendDelegate */\n-(void) gstreamerInitialized;\n-(void) gstreamerSetUIMessage:(NSString *)message;\n\n@end\n</code></pre>\n<p>Note how we register callbacks for some of the Actions the\n<a href=\"http://developer.apple.com/library/ios/#documentation/UIKit/Reference/UISlider_Class/Reference/Reference.html\">UISlider</a> generates.\nAlso note that the class has been renamed from <code>ViewController</code> to\n<code>VideoViewController</code>, since the next tutorial adds another\n<code>ViewController</code> and we will need to differentiate.</p>\n<h2 id=\"the-video-view-controller\">The Video View Controller</h2>\n<p>The <code>ViewController</code>class manages the UI, instantiates\nthe <code>GStreamerBackend</code> and also performs some UI-related tasks on its\nbehalf:</p>\n<p><img src=\"images/icons/grey_arrow_down.gif\" alt=\"\">Due to the extension of this code,\nthis view is collapsed by default. Click here to expand\u2026</p>\n<p><strong>VideoViewController.m</strong></p>\n<pre><code>#import \"VideoViewController.h\"\n#import \"GStreamerBackend.h\"\n#import &lt;UIKit/UIKit.h&gt;\n\n@interface VideoViewController () {\n    GStreamerBackend *gst_backend;\n    int media_width;                /* Width of the clip */\n    int media_height;               /* height of the clip */\n    Boolean dragging_slider;        /* Whether the time slider is being dragged or not */\n    Boolean is_local_media;         /* Whether this clip is stored locally or is being streamed */\n    Boolean is_playing_desired;     /* Whether the user asked to go to PLAYING */\n}\n\n@end\n\n@implementation VideoViewController\n\n@synthesize uri;\n\n/*\n * Private methods\n */\n\n/* The text widget acts as an slave for the seek bar, so it reflects what the seek bar shows, whether\n * it is an actual pipeline position or the position the user is currently dragging to. */\n- (void) updateTimeWidget\n{\n    NSInteger position = time_slider.value / 1000;\n    NSInteger duration = time_slider.maximumValue / 1000;\n    NSString *position_txt = @\" -- \";\n    NSString *duration_txt = @\" -- \";\n\n    if (duration &gt; 0) {\n        NSUInteger hours = duration / (60 * 60);\n        NSUInteger minutes = (duration / 60) % 60;\n        NSUInteger seconds = duration % 60;\n\n        duration_txt = [NSString stringWithFormat:@\"%02u:%02u:%02u\", hours, minutes, seconds];\n    }\n    if (position &gt; 0) {\n        NSUInteger hours = position / (60 * 60);\n        NSUInteger minutes = (position / 60) % 60;\n        NSUInteger seconds = position % 60;\n\n        position_txt = [NSString stringWithFormat:@\"%02u:%02u:%02u\", hours, minutes, seconds];\n    }\n\n    NSString *text = [NSString stringWithFormat:@\"%@ / %@\",\n                      position_txt, duration_txt];\n\n    time_label.text = text;\n}\n\n/*\n * Methods from UIViewController\n */\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n\n    play_button.enabled = FALSE;\n    pause_button.enabled = FALSE;\n\n    /* As soon as the GStreamer backend knows the real values, these ones will be replaced */\n    media_width = 320;\n    media_height = 240;\n\n    uri = @\"https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-368p.ogv\";\n\n    gst_backend = [[GStreamerBackend alloc] init:self videoView:video_view];\n}\n\n- (void)viewDidDisappear:(BOOL)animated\n{\n    if (gst_backend)\n    {\n        [gst_backend deinit];\n    }\n}\n\n- (void)didReceiveMemoryWarning\n{\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n/* Called when the Play button is pressed */\n-(IBAction) play:(id)sender\n{\n    [gst_backend play];\n    is_playing_desired = YES;\n}\n\n/* Called when the Pause button is pressed */\n-(IBAction) pause:(id)sender\n{\n    [gst_backend pause];\n    is_playing_desired = NO;\n}\n\n/* Called when the time slider position has changed, either because the user dragged it or\n * we programmatically changed its position. dragging_slider tells us which one happened */\n- (IBAction)sliderValueChanged:(id)sender {\n    if (!dragging_slider) return;\n    // If this is a local file, allow scrub seeking, this is, seek as soon as the slider is moved.\n    if (is_local_media)\n        [gst_backend setPosition:time_slider.value];\n    [self updateTimeWidget];\n}\n\n/* Called when the user starts to drag the time slider */\n- (IBAction)sliderTouchDown:(id)sender {\n    [gst_backend pause];\n    dragging_slider = YES;\n}\n\n/* Called when the user stops dragging the time slider */\n- (IBAction)sliderTouchUp:(id)sender {\n    dragging_slider = NO;\n    // If this is a remote file, scrub seeking is probably not going to work smoothly enough.\n    // Therefore, perform only the seek when the slider is released.\n    if (!is_local_media)\n        [gst_backend setPosition:time_slider.value];\n    if (is_playing_desired)\n        [gst_backend play];\n}\n\n/* Called when the size of the main view has changed, so we can\n * resize the sub-views in ways not allowed by storyboarding. */\n- (void)viewDidLayoutSubviews\n{\n    CGFloat view_width = video_container_view.bounds.size.width;\n    CGFloat view_height = video_container_view.bounds.size.height;\n\n    CGFloat correct_height = view_width * media_height / media_width;\n    CGFloat correct_width = view_height * media_width / media_height;\n\n    if (correct_height &lt; view_height) {\n        video_height_constraint.constant = correct_height;\n        video_width_constraint.constant = view_width;\n    } else {\n        video_width_constraint.constant = correct_width;\n        video_height_constraint.constant = view_height;\n    }\n\n    time_slider.frame = CGRectMake(time_slider.frame.origin.x, time_slider.frame.origin.y, toolbar.frame.size.width - time_slider.frame.origin.x - 8, time_slider.frame.size.height);\n}\n\n/*\n * Methods from GstreamerBackendDelegate\n */\n\n-(void) gstreamerInitialized\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        play_button.enabled = TRUE;\n        pause_button.enabled = TRUE;\n        message_label.text = @\"Ready\";\n        [gst_backend setUri:uri];\n        is_local_media = [uri hasPrefix:@\"file://\"];\n        is_playing_desired = NO;\n    });\n}\n\n-(void) gstreamerSetUIMessage:(NSString *)message\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        message_label.text = message;\n    });\n}\n\n-(void) mediaSizeChanged:(NSInteger)width height:(NSInteger)height\n{\n    media_width = width;\n    media_height = height;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self viewDidLayoutSubviews];\n        [video_view setNeedsLayout];\n        [video_view layoutIfNeeded];\n    });\n}\n\n-(void) setCurrentPosition:(NSInteger)position duration:(NSInteger)duration\n{\n    /* Ignore messages from the pipeline if the time sliders is being dragged */\n    if (dragging_slider) return;\n\n    dispatch_async(dispatch_get_main_queue(), ^{\n        time_slider.maximumValue = duration;\n        time_slider.value = position;\n        [self updateTimeWidget];\n    });\n}\n\n@end\n</code></pre>\n<p>Supporting arbitrary media URIs</p>\n<p>The <code>GStreamerBackend</code>  provides the <code>setUri()</code> method so we can\nindicate the URI of the media to play. Since <code>playbin</code> will be taking\ncare of retrieving the media, we can use local or remote URIs\nindistinctly (<code>file://</code> or <code>http://</code>, for example). From the UI code,\nthough, we want to keep track of whether the file is local or remote,\nbecause we will not offer the same functionalities. We keep track of\nthis in the <code>is_local_media</code> variable, which is set when the URI is set,\nin the <code>gstreamerInitialized</code> method:</p>\n<pre><code>-(void) gstreamerInitialized\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        play_button.enabled = TRUE;\n        pause_button.enabled = TRUE;\n        message_label.text = @\"Ready\";\n        [gst_backend setUri:uri];\n        is_local_media = [uri hasPrefix:@\"file://\"];\n        is_playing_desired = NO;\n    });\n}\n</code></pre>\n<p>Reporting media size</p>\n<p>Every time the size of the media changes (which could happen mid-stream,\nfor some kind of streams), or when it is first detected,\n<code>GStreamerBackend</code>  calls our <code>mediaSizeChanged()</code> callback:</p>\n<pre><code>-(void) mediaSizeChanged:(NSInteger)width height:(NSInteger)height\n{\n    media_width = width;\n    media_height = height;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self viewDidLayoutSubviews];\n        [video_view setNeedsLayout];\n        [video_view layoutIfNeeded];\n    });\n}\n</code></pre>\n<p>Here we simply store the new size and ask the layout to be recalculated.\nAs we have already seen in <a href=\"a-running-pipeline.html\">iOS tutorial 2: A running pipeline</a>,\nmethods which change the UI must be called from the main thread, and we\nare now in a callback from some GStreamer internal thread. Hence, the\nusage\nof <code>dispatch_async()</code><a href=\"http://developer.android.com/reference/android/app/Activity.html#runOnUiThread(java.lang.Runnable)\">.</a></p>\n<h3 id=\"refreshing-the-time-slider\">Refreshing the Time Slider</h3>\n<p><a href=\"../basic/toolkit-integration.html\">Basic tutorial 5: GUI toolkit integration</a> has\nalready shown how to implement a Seek Bar (or <a href=\"http://developer.apple.com/library/ios/#documentation/UIKit/Reference/UISlider_Class/Reference/Reference.html\">Time\nSlider</a>\nin this tutorial) using the GTK+ toolkit. The implementation on iOS is\nvery similar.</p>\n<p>The Seek Bar accomplishes to functions: First, it moves on its own to\nreflect the current playback position in the media. Second, it can be\ndragged by the user to seek to a different position.</p>\n<p>To realize the first function, <code>GStreamerBackend</code>  will periodically\ncall our <code>setCurrentPosition</code> method so we can update the position of\nthe thumb in the Seek Bar. Again we do so from the UI thread, using\n<code>dispatch_async()</code>.</p>\n<pre><code>-(void) setCurrentPosition:(NSInteger)position duration:(NSInteger)duration\n{\n    /* Ignore messages from the pipeline if the time sliders is being dragged */\n    if (dragging_slider) return;\n\n    dispatch_async(dispatch_get_main_queue(), ^{\n        time_slider.maximumValue = duration;\n        time_slider.value = position;\n        [self updateTimeWidget];\n    });\n}\n</code></pre>\n<p>Also note that if the user is currently dragging the slider (the\n<code>dragging_slider</code> variable is explained below) we ignore\n<code>setCurrentPosition</code> calls from <code>GStreamerBackend</code>, as they would\ninterfere with the user\u2019s actions.</p>\n<p>To the left of the Seek Bar (refer to the screenshot at the top of this\npage), there is\na <a href=\"https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UITextField_Class/Reference/UITextField.html\">TextField</a> widget\nwhich we will use to display the current position and duration in\n\"<code>HH:mm:ss / HH:mm:ss\"</code> textual format. The <code>updateTimeWidget</code> method\ntakes care of it, and must be called every time the Seek Bar is\nupdated:</p>\n<pre><code>/* The text widget acts as an slave for the seek bar, so it reflects what the seek bar shows, whether\n * it is an actual pipeline position or the position the user is currently dragging to. */\n- (void) updateTimeWidget\n{\n    NSInteger position = time_slider.value / 1000;\n    NSInteger duration = time_slider.maximumValue / 1000;\n    NSString *position_txt = @\" -- \";\n    NSString *duration_txt = @\" -- \";\n\n    if (duration &gt; 0) {\n        NSUInteger hours = duration / (60 * 60);\n        NSUInteger minutes = (duration / 60) % 60;\n        NSUInteger seconds = duration % 60;\n\n        duration_txt = [NSString stringWithFormat:@\"%02u:%02u:%02u\", hours, minutes, seconds];\n    }\n    if (position &gt; 0) {\n        NSUInteger hours = position / (60 * 60);\n        NSUInteger minutes = (position / 60) % 60;\n        NSUInteger seconds = position % 60;\n\n        position_txt = [NSString stringWithFormat:@\"%02u:%02u:%02u\", hours, minutes, seconds];\n    }\n\n    NSString *text = [NSString stringWithFormat:@\"%@ / %@\",\n                      position_txt, duration_txt];\n\n    time_label.text = text;\n}\n</code></pre>\n<p>Seeking with the Seek Bar</p>\n<p>To perform the second function of the Seek Bar (allowing the user to\nseek by dragging the thumb), we register some callbacks through IBAction\noutlets. Refer to the storyboard in this tutorial\u2019s project to see which\noutlets are connected. We will be notified when the user starts dragging\nthe Slider, when the Slider position changes and when the users releases\nthe Slider.</p>\n<pre><code>/* Called when the user starts to drag the time slider */\n- (IBAction)sliderTouchDown:(id)sender {\n    [gst_backend pause];\n    dragging_slider = YES;\n}\n</code></pre>\n<p><code>sliderTouchDown</code> is called when the user starts dragging. Here we pause\nthe pipeline because if the user is searching for a particular scene, we\ndo not want it to keep moving. We also mark that a drag operation is in\nprogress in the\n<code>dragging_slider</code> variable.</p>\n<pre><code>/* Called when the time slider position has changed, either because the user dragged it or\n * we programmatically changed its position. dragging_slider tells us which one happened */\n- (IBAction)sliderValueChanged:(id)sender {\n    if (!dragging_slider) return;\n    // If this is a local file, allow scrub seeking, this is, seek as soon as the slider is moved.\n    if (is_local_media)\n        [gst_backend setPosition:time_slider.value];\n    [self updateTimeWidget];\n}\n</code></pre>\n<p><code>sliderValueChanged</code> is called every time the Slider\u2019s thumb moves, be\nit because the user dragged it, or because we changed its value form the\nprogram. We discard the latter case using the\n<code>dragging_slider</code> variable.</p>\n<p>As the comment says, if this is a local media, we allow scrub seeking,\nthis is, we jump to the indicated position as soon as the thumb moves.\nOtherwise, the seek operation will be performed when the thumb is\nreleased, and the only thing we do here is update the textual time\nwidget.</p>\n<pre><code>/* Called when the user stops dragging the time slider */\n- (IBAction)sliderTouchUp:(id)sender {\n    dragging_slider = NO;\n    // If this is a remote file, scrub seeking is probably not going to work smoothly enough.\n    // Therefore, perform only the seek when the slider is released.\n    if (!is_local_media)\n        [gst_backend setPosition:time_slider.value];\n    if (is_playing_desired)\n        [gst_backend play];\n}\n</code></pre>\n<p>Finally, <code>sliderTouchUp</code> is called when the thumb is released. We\nperform the seek operation if the file was non-local, restore the\npipeline to the desired playing state and end the dragging operation by\nsetting <code>dragging_slider</code> to NO.</p>\n<p>This concludes the User interface part of this tutorial. Let\u2019s review\nnow the <code>GStreamerBackend</code>  class that allows this to work.</p>\n<h2 id=\"the-gstreamer-backend\">The GStreamer Backend</h2>\n<p>The <code>GStreamerBackend</code> class performs all GStreamer-related tasks and\noffers a simplified interface to the application, which does not need to\ndeal with all the GStreamer details. When it needs to perform any UI\naction, it does so through a delegate, which is expected to adhere to\nthe <code>GStreamerBackendDelegate</code> protocol.</p>\n<p><strong>GStreamerBackend.m</strong></p>\n<pre><code>#import \"GStreamerBackend.h\"\n\n#include &lt;gst/gst.h&gt;\n#include &lt;gst/video/video.h&gt;\n\nGST_DEBUG_CATEGORY_STATIC (debug_category);\n#define GST_CAT_DEFAULT debug_category\n\n/* Do not allow seeks to be performed closer than this distance. It is visually useless, and will probably\n * confuse some demuxers. */\n#define SEEK_MIN_DELAY (500 * GST_MSECOND)\n\n@interface GStreamerBackend()\n-(void)setUIMessage:(gchar*) message;\n-(void)app_function;\n-(void)check_initialization_complete;\n@end\n\n@implementation GStreamerBackend {\n    id ui_delegate;              /* Class that we use to interact with the user interface */\n    GstElement *pipeline;        /* The running pipeline */\n    GstElement *video_sink;      /* The video sink element which receives VideoOverlay commands */\n    GMainContext *context;       /* GLib context used to run the main loop */\n    GMainLoop *main_loop;        /* GLib main loop */\n    gboolean initialized;        /* To avoid informing the UI multiple times about the initialization */\n    UIView *ui_video_view;       /* UIView that holds the video */\n    GstState state;              /* Current pipeline state */\n    GstState target_state;       /* Desired pipeline state, to be set once buffering is complete */\n    gint64 duration;             /* Cached clip duration */\n    gint64 desired_position;     /* Position to seek to, once the pipeline is running */\n    GstClockTime last_seek_time; /* For seeking overflow prevention (throttling) */\n    gboolean is_live;            /* Live streams do not use buffering */\n}\n\n/*\n * Interface methods\n */\n\n-(id) init:(id) uiDelegate videoView:(UIView *)video_view\n{\n    if (self = [super init])\n    {\n        self-&gt;ui_delegate = uiDelegate;\n        self-&gt;ui_video_view = video_view;\n        self-&gt;duration = GST_CLOCK_TIME_NONE;\n\n        GST_DEBUG_CATEGORY_INIT (debug_category, \"tutorial-4\", 0, \"iOS tutorial 4\");\n        gst_debug_set_threshold_for_name(\"tutorial-4\", GST_LEVEL_DEBUG);\n\n        /* Start the bus monitoring task */\n        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n            [self app_function];\n        });\n    }\n\n    return self;\n}\n\n-(void) deinit\n{\n    if (main_loop) {\n        g_main_loop_quit(main_loop);\n    }\n}\n\n-(void) play\n{\n    target_state = GST_STATE_PLAYING;\n    is_live = (gst_element_set_state (pipeline, GST_STATE_PLAYING) == GST_STATE_CHANGE_NO_PREROLL);\n}\n\n-(void) pause\n{\n    target_state = GST_STATE_PAUSED;\n    is_live = (gst_element_set_state (pipeline, GST_STATE_PAUSED) == GST_STATE_CHANGE_NO_PREROLL);\n}\n\n-(void) setUri:(NSString*)uri\n{\n    const char *char_uri = [uri UTF8String];\n    g_object_set(pipeline, \"uri\", char_uri, NULL);\n    GST_DEBUG (\"URI set to %s\", char_uri);\n}\n\n-(void) setPosition:(NSInteger)milliseconds\n{\n    gint64 position = (gint64)(milliseconds * GST_MSECOND);\n    if (state &gt;= GST_STATE_PAUSED) {\n        execute_seek(position, self);\n    } else {\n        GST_DEBUG (\"Scheduling seek to %\" GST_TIME_FORMAT \" for later\", GST_TIME_ARGS (position));\n        self-&gt;desired_position = position;\n    }\n}\n\n/*\n * Private methods\n */\n\n/* Change the message on the UI through the UI delegate */\n-(void)setUIMessage:(gchar*) message\n{\n    NSString *string = [NSString stringWithUTF8String:message];\n    if(ui_delegate &amp;&amp; [ui_delegate respondsToSelector:@selector(gstreamerSetUIMessage:)])\n    {\n        [ui_delegate gstreamerSetUIMessage:string];\n    }\n}\n\n/* Tell the application what is the current position and clip duration */\n-(void) setCurrentUIPosition:(gint)pos duration:(gint)dur\n{\n    if(ui_delegate &amp;&amp; [ui_delegate respondsToSelector:@selector(setCurrentPosition:duration:)])\n    {\n        [ui_delegate setCurrentPosition:pos duration:dur];\n    }\n}\n\n/* If we have pipeline and it is running, query the current position and clip duration and inform\n * the application */\nstatic gboolean refresh_ui (GStreamerBackend *self) {\n    gint64 position;\n\n    /* We do not want to update anything unless we have a working pipeline in the PAUSED or PLAYING state */\n    if (!self || !self-&gt;pipeline || self-&gt;state &lt; GST_STATE_PAUSED)\n        return TRUE;\n\n    /* If we didn't know it yet, query the stream duration */\n    if (!GST_CLOCK_TIME_IS_VALID (self-&gt;duration)) {\n        gst_element_query_duration (self-&gt;pipeline, GST_FORMAT_TIME, &amp;self-&gt;duration);\n    }\n\n    if (gst_element_query_position (self-&gt;pipeline, GST_FORMAT_TIME, &amp;position)) {\n        /* The UI expects these values in milliseconds, and GStreamer provides nanoseconds */\n        [self setCurrentUIPosition:position / GST_MSECOND duration:self-&gt;duration / GST_MSECOND];\n    }\n    return TRUE;\n}\n\n/* Forward declaration for the delayed seek callback */\nstatic gboolean delayed_seek_cb (GStreamerBackend *self);\n\n/* Perform seek, if we are not too close to the previous seek. Otherwise, schedule the seek for\n * some time in the future. */\nstatic void execute_seek (gint64 position, GStreamerBackend *self) {\n    gint64 diff;\n\n    if (position == GST_CLOCK_TIME_NONE)\n        return;\n\n    diff = gst_util_get_timestamp () - self-&gt;last_seek_time;\n\n    if (GST_CLOCK_TIME_IS_VALID (self-&gt;last_seek_time) &amp;&amp; diff &lt; SEEK_MIN_DELAY) {\n        /* The previous seek was too close, delay this one */\n        GSource *timeout_source;\n\n        if (self-&gt;desired_position == GST_CLOCK_TIME_NONE) {\n            /* There was no previous seek scheduled. Setup a timer for some time in the future */\n            timeout_source = g_timeout_source_new ((SEEK_MIN_DELAY - diff) / GST_MSECOND);\n            g_source_set_callback (timeout_source, (GSourceFunc)delayed_seek_cb, (__bridge void *)self, NULL);\n            g_source_attach (timeout_source, self-&gt;context);\n            g_source_unref (timeout_source);\n        }\n        /* Update the desired seek position. If multiple requests are received before it is time\n         * to perform a seek, only the last one is remembered. */\n        self-&gt;desired_position = position;\n        GST_DEBUG (\"Throttling seek to %\" GST_TIME_FORMAT \", will be in %\" GST_TIME_FORMAT,\n                   GST_TIME_ARGS (position), GST_TIME_ARGS (SEEK_MIN_DELAY - diff));\n    } else {\n        /* Perform the seek now */\n        GST_DEBUG (\"Seeking to %\" GST_TIME_FORMAT, GST_TIME_ARGS (position));\n        self-&gt;last_seek_time = gst_util_get_timestamp ();\n        gst_element_seek_simple (self-&gt;pipeline, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, position);\n        self-&gt;desired_position = GST_CLOCK_TIME_NONE;\n    }\n}\n\n/* Delayed seek callback. This gets called by the timer setup in the above function. */\nstatic gboolean delayed_seek_cb (GStreamerBackend *self) {\n    GST_DEBUG (\"Doing delayed seek to %\" GST_TIME_FORMAT, GST_TIME_ARGS (self-&gt;desired_position));\n    execute_seek (self-&gt;desired_position, self);\n    return FALSE;\n}\n\n/* Retrieve errors from the bus and show them on the UI */\nstatic void error_cb (GstBus *bus, GstMessage *msg, GStreamerBackend *self)\n{\n    GError *err;\n    gchar *debug_info;\n    gchar *message_string;\n\n    gst_message_parse_error (msg, &amp;err, &amp;debug_info);\n    message_string = g_strdup_printf (\"Error received from element %s: %s\", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);\n    g_clear_error (&amp;err);\n    g_free (debug_info);\n    [self setUIMessage:message_string];\n    g_free (message_string);\n    gst_element_set_state (self-&gt;pipeline, GST_STATE_NULL);\n}\n\n/* Called when the End Of the Stream is reached. Just move to the beginning of the media and pause. */\nstatic void eos_cb (GstBus *bus, GstMessage *msg, GStreamerBackend *self) {\n    self-&gt;target_state = GST_STATE_PAUSED;\n    self-&gt;is_live = (gst_element_set_state (self-&gt;pipeline, GST_STATE_PAUSED) == GST_STATE_CHANGE_NO_PREROLL);\n    execute_seek (0, self);\n}\n\n/* Called when the duration of the media changes. Just mark it as unknown, so we re-query it in the next UI refresh. */\nstatic void duration_cb (GstBus *bus, GstMessage *msg, GStreamerBackend *self) {\n    self-&gt;duration = GST_CLOCK_TIME_NONE;\n}\n\n/* Called when buffering messages are received. We inform the UI about the current buffering level and\n * keep the pipeline paused until 100% buffering is reached. At that point, set the desired state. */\nstatic void buffering_cb (GstBus *bus, GstMessage *msg, GStreamerBackend *self) {\n    gint percent;\n\n    if (self-&gt;is_live)\n        return;\n\n    gst_message_parse_buffering (msg, &amp;percent);\n    if (percent &lt; 100 &amp;&amp; self-&gt;target_state &gt;= GST_STATE_PAUSED) {\n        gchar * message_string = g_strdup_printf (\"Buffering %d%%\", percent);\n        gst_element_set_state (self-&gt;pipeline, GST_STATE_PAUSED);\n        [self setUIMessage:message_string];\n        g_free (message_string);\n    } else if (self-&gt;target_state &gt;= GST_STATE_PLAYING) {\n        gst_element_set_state (self-&gt;pipeline, GST_STATE_PLAYING);\n    } else if (self-&gt;target_state &gt;= GST_STATE_PAUSED) {\n        [self setUIMessage:\"Buffering complete\"];\n    }\n}\n\n/* Called when the clock is lost */\nstatic void clock_lost_cb (GstBus *bus, GstMessage *msg, GStreamerBackend *self) {\n    if (self-&gt;target_state &gt;= GST_STATE_PLAYING) {\n        gst_element_set_state (self-&gt;pipeline, GST_STATE_PAUSED);\n        gst_element_set_state (self-&gt;pipeline, GST_STATE_PLAYING);\n    }\n}\n\n/* Retrieve the video sink's Caps and tell the application about the media size */\nstatic void check_media_size (GStreamerBackend *self) {\n    GstElement *video_sink;\n    GstPad *video_sink_pad;\n    GstCaps *caps;\n    GstVideoInfo info;\n\n    /* Retrieve the Caps at the entrance of the video sink */\n    g_object_get (self-&gt;pipeline, \"video-sink\", &amp;video_sink, NULL);\n\n    /* Do nothing if there is no video sink (this might be an audio-only clip */\n    if (!video_sink) return;\n\n    video_sink_pad = gst_element_get_static_pad (video_sink, \"sink\");\n    caps = gst_pad_get_current_caps (video_sink_pad);\n\n    if (gst_video_info_from_caps(&amp;info, caps)) {\n        info.width = info.width * info.par_n / info.par_d\n        GST_DEBUG (\"Media size is %dx%d, notifying application\", info.width, info.height);\n\n        if (self-&gt;ui_delegate &amp;&amp; [self-&gt;ui_delegate respondsToSelector:@selector(mediaSizeChanged:info.height:)])\n        {\n            [self-&gt;ui_delegate mediaSizeChanged:info.width height:info.height];\n        }\n    }\n\n    gst_caps_unref(caps);\n    gst_object_unref (video_sink_pad);\n    gst_object_unref(video_sink);\n}\n\n/* Notify UI about pipeline state changes */\nstatic void state_changed_cb (GstBus *bus, GstMessage *msg, GStreamerBackend *self)\n{\n    GstState old_state, new_state, pending_state;\n    gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);\n    /* Only pay attention to messages coming from the pipeline, not its children */\n    if (GST_MESSAGE_SRC (msg) == GST_OBJECT (self-&gt;pipeline)) {\n        self-&gt;state = new_state;\n        gchar *message = g_strdup_printf(\"State changed to %s\", gst_element_state_get_name(new_state));\n        [self setUIMessage:message];\n        g_free (message);\n\n        if (old_state == GST_STATE_READY &amp;&amp; new_state == GST_STATE_PAUSED)\n        {\n            check_media_size(self);\n\n            /* If there was a scheduled seek, perform it now that we have moved to the Paused state */\n            if (GST_CLOCK_TIME_IS_VALID (self-&gt;desired_position))\n                execute_seek (self-&gt;desired_position, self);\n        }\n    }\n}\n\n/* Check if all conditions are met to report GStreamer as initialized.\n * These conditions will change depending on the application */\n-(void) check_initialization_complete\n{\n    if (!initialized &amp;&amp; main_loop) {\n        GST_DEBUG (\"Initialization complete, notifying application.\");\n        if (ui_delegate &amp;&amp; [ui_delegate respondsToSelector:@selector(gstreamerInitialized)])\n        {\n            [ui_delegate gstreamerInitialized];\n        }\n        initialized = TRUE;\n    }\n}\n\n/* Main method for the bus monitoring code */\n-(void) app_function\n{\n    GstBus *bus;\n    GSource *timeout_source;\n    GSource *bus_source;\n    GError *error = NULL;\n\n    GST_DEBUG (\"Creating pipeline\");\n\n    /* Create our own GLib Main Context and make it the default one */\n    context = g_main_context_new ();\n    g_main_context_push_thread_default(context);\n\n    /* Build pipeline */\n    pipeline = gst_parse_launch(\"playbin\", &amp;error);\n    if (error) {\n        gchar *message = g_strdup_printf(\"Unable to build pipeline: %s\", error-&gt;message);\n        g_clear_error (&amp;error);\n        [self setUIMessage:message];\n        g_free (message);\n        return;\n    }\n\n    /* Set the pipeline to READY, so it can already accept a window handle */\n    gst_element_set_state(pipeline, GST_STATE_READY);\n\n    video_sink = gst_bin_get_by_interface(GST_BIN(pipeline), GST_TYPE_VIDEO_OVERLAY);\n    if (!video_sink) {\n        GST_ERROR (\"Could not retrieve video sink\");\n        return;\n    }\n    gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(video_sink), (guintptr) (id) ui_video_view);\n\n    /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */\n    bus = gst_element_get_bus (pipeline);\n    bus_source = gst_bus_create_watch (bus);\n    g_source_set_callback (bus_source, (GSourceFunc) gst_bus_async_signal_func, NULL, NULL);\n    g_source_attach (bus_source, context);\n    g_source_unref (bus_source);\n    g_signal_connect (G_OBJECT (bus), \"message::error\", (GCallback)error_cb, (__bridge void *)self);\n    g_signal_connect (G_OBJECT (bus), \"message::eos\", (GCallback)eos_cb, (__bridge void *)self);\n    g_signal_connect (G_OBJECT (bus), \"message::state-changed\", (GCallback)state_changed_cb, (__bridge void *)self);\n    g_signal_connect (G_OBJECT (bus), \"message::duration\", (GCallback)duration_cb, (__bridge void *)self);\n    g_signal_connect (G_OBJECT (bus), \"message::buffering\", (GCallback)buffering_cb, (__bridge void *)self);\n    g_signal_connect (G_OBJECT (bus), \"message::clock-lost\", (GCallback)clock_lost_cb, (__bridge void *)self);\n    gst_object_unref (bus);\n\n    /* Register a function that GLib will call 4 times per second */\n    timeout_source = g_timeout_source_new (250);\n    g_source_set_callback (timeout_source, (GSourceFunc)refresh_ui, (__bridge void *)self, NULL);\n    g_source_attach (timeout_source, context);\n    g_source_unref (timeout_source);\n\n    /* Create a GLib Main Loop and set it to run */\n    GST_DEBUG (\"Entering main loop...\");\n    main_loop = g_main_loop_new (context, FALSE);\n    [self check_initialization_complete];\n    g_main_loop_run (main_loop);\n    GST_DEBUG (\"Exited main loop\");\n    g_main_loop_unref (main_loop);\n    main_loop = NULL;\n\n    /* Free resources */\n    g_main_context_pop_thread_default(context);\n    g_main_context_unref (context);\n    gst_element_set_state (pipeline, GST_STATE_NULL);\n    gst_object_unref (pipeline);\n    pipeline = NULL;\n\n    ui_delegate = NULL;\n    ui_video_view = NULL;\n\n    return;\n}\n\n@end\n</code></pre>\n<p>Supporting arbitrary media URIs</p>\n<p>The UI code will call <code>setUri</code> whenever it wants to change the playing\nURI (in this tutorial the URI never changes, but it does in the next\none):</p>\n<pre><code>-(void) setUri:(NSString*)uri\n{\n    const char *char_uri = [uri UTF8String];\n    g_object_set(pipeline, \"uri\", char_uri, NULL);\n    GST_DEBUG (\"URI set to %s\", char_uri);\n}\n</code></pre>\n<p>We first need to obtain a plain <code>char *</code> from within the <code>NSString *</code> we\nget, using the <code>UTF8String</code> method.</p>\n<p><code>playbin</code>\u2019s URI is exposed as a common GObject property, so we simply\nset it with <code>g_object_set()</code>.</p>\n<h3 id=\"reporting-media-size\">Reporting media size</h3>\n<p>Some codecs allow the media size (width and height of the video) to\nchange during playback. For simplicity, this tutorial assumes that they\ndo not. Therefore, in the READY to PAUSED state change, once the Caps of\nthe decoded media are known, we inspect them\nin <code>check_media_size()</code>:</p>\n<pre><code>/* Retrieve the video sink's Caps and tell the application about the media size */\nstatic void check_media_size (GStreamerBackend *self) {\n    GstElement *video_sink;\n    GstPad *video_sink_pad;\n    GstCaps *caps;\n    GstVideoInfo info;\n\n    /* Retrieve the Caps at the entrance of the video sink */\n    g_object_get (self-&gt;pipeline, \"video-sink\", &amp;video_sink, NULL);\n\n    /* Do nothing if there is no video sink (this might be an audio-only clip */\n    if (!video_sink) return;\n\n    video_sink_pad = gst_element_get_static_pad (video_sink, \"sink\");\n    caps = gst_pad_get_current_caps (video_sink_pad);\n\n    if (gst_video_info_from_caps(&amp;info, caps)) {\n        info.width = info.width * info.par_n / info.par_d;\n        GST_DEBUG (\"Media size is %dx%d, notifying application\", info.width, info.height);\n\n        if (self-&gt;ui_delegate &amp;&amp; [self-&gt;ui_delegate respondsToSelector:@selector(mediaSizeChanged:info.height:)])\n        {\n            [self-&gt;ui_delegate mediaSizeChanged:info.width height:info.height];\n        }\n    }\n\n    gst_caps_unref(caps);\n    gst_object_unref (video_sink_pad);\n    gst_object_unref(video_sink);\n}\n</code></pre>\n<p>We first retrieve the video sink element from the pipeline, using\nthe <code>video-sink</code> property of <code>playbin</code>, and then its sink Pad. The\nnegotiated Caps of this Pad, which we recover using\n<code>gst_pad_get_current_caps()</code>,  are the Caps of the decoded media.</p>\n<p>The helper functions <code>gst_video_format_parse_caps()</code> and\n<code>gst_video_parse_caps_pixel_aspect_ratio()</code> turn the Caps into\nmanageable integers, which we pass to the application through\nits <code>mediaSizeChanged</code> callback.</p>\n<h3 id=\"refreshing-the-seek-bar\">Refreshing the Seek Bar</h3>\n<p>To keep the UI updated, a GLib timer is installed in\nthe <code>app_function</code> that fires 4 times per second (or every 250ms),\nright before entering the main loop:</p>\n<pre><code>    /* Register a function that GLib will call 4 times per second */\n    timeout_source = g_timeout_source_new (250);\n    g_source_set_callback (timeout_source, (GSourceFunc)refresh_ui, (__bridge void *)self, NULL);\n    g_source_attach (timeout_source, context);\n    g_source_unref (timeout_source);\n</code></pre>\n<p>Then, in the refresh_ui\nmethod:</p>\n<pre><code>/* If we have pipeline and it is running, query the current position and clip duration and inform\n * the application */\nstatic gboolean refresh_ui (GStreamerBackend *self) {\n    gint64 position;\n\n    /* We do not want to update anything unless we have a working pipeline in the PAUSED or PLAYING state */\n    if (!self || !self-&gt;pipeline || self-&gt;state &lt; GST_STATE_PAUSED)\n        return TRUE;\n\n    /* If we didn't know it yet, query the stream duration */\n    if (!GST_CLOCK_TIME_IS_VALID (self-&gt;duration)) {\n        gst_element_query_duration (self-&gt;pipeline, GST_FORMAT_TIME, &amp;self-&gt;duration);\n    }\n\n    if (gst_element_query_position (self-&gt;pipeline, GST_FORMAT_TIME, &amp;position)) {\n        /* The UI expects these values in milliseconds, and GStreamer provides nanoseconds */\n        [self setCurrentUIPosition:position / GST_MSECOND duration:self-&gt;duration / GST_MSECOND];\n    }\n    return TRUE;\n}\n</code></pre>\n<p>If it is unknown, the clip duration is retrieved, as explained in\n<a href=\"../basic/time-management.html\">Basic tutorial 4: Time management</a>. The current position is\nretrieved next, and the UI is informed of both through its\n<code>setCurrentUIPosition</code> callback.</p>\n<p>Bear in mind that all time-related measures returned by GStreamer are in\nnanoseconds, whereas, for simplicity, we decided to make the UI code\nwork in milliseconds.</p>\n<h3 id=\"seeking-with-the-seek-bar\">Seeking with the Seek Bar</h3>\n<p>The UI code already takes care of most of the complexity of seeking by\ndragging the thumb of the Seek Bar. From the <code>GStreamerBackend</code>, we just\nneed to honor the calls to <code>setPosition</code> and instruct the pipeline to\njump to the indicated position.</p>\n<p>There are, though, a couple of caveats. Firstly, seeks are only possible\nwhen the pipeline is in the PAUSED or PLAYING state, and we might\nreceive seek requests before that happens. Secondly, dragging the Seek\nBar can generate a very high number of seek requests in a short period\nof time, which is visually useless and will impair responsiveness. Let\u2019s\nsee how to overcome these problems.</p>\n<h4 id=\"delayed-seeks\">Delayed seeks</h4>\n<p>In <code>setPosition</code>:</p>\n<pre><code>-(void) setPosition:(NSInteger)milliseconds\n{\n    gint64 position = (gint64)(milliseconds * GST_MSECOND);\n    if (state &gt;= GST_STATE_PAUSED) {\n        execute_seek(position, self);\n    } else {\n        GST_DEBUG (\"Scheduling seek to %\" GST_TIME_FORMAT \" for later\", GST_TIME_ARGS (position));\n        self-&gt;desired_position = position;\n    }\n}\n</code></pre>\n<p>If we are already in the correct state for seeking, execute it right\naway; otherwise, store the desired position in\nthe <code>desired_position</code> variable. Then, in\nthe <code>state_changed_cb()</code> callback:</p>\n<pre><code>        if (old_state == GST_STATE_READY &amp;&amp; new_state == GST_STATE_PAUSED)\n        {\n            check_media_size(self);\n\n            /* If there was a scheduled seek, perform it now that we have moved to the Paused state */\n            if (GST_CLOCK_TIME_IS_VALID (self-&gt;desired_position))\n                execute_seek (self-&gt;desired_position, self);\n        }\n</code></pre>\n<p>Once the pipeline moves from the READY to the PAUSED state, we check if\nthere is a pending seek operation and execute it.\nThe <code>desired_position</code> variable is reset inside <code>execute_seek()</code>.</p>\n<h4 id=\"seek-throttling\">Seek throttling</h4>\n<p>A seek is potentially a lengthy operation. The demuxer (the element\ntypically in charge of seeking) needs to estimate the appropriate byte\noffset inside the media file that corresponds to the time position to\njump to. Then, it needs to start decoding from that point until the\ndesired position is reached. If the initial estimate is accurate, this\nwill not take long, but, on some container formats, or when indexing\ninformation is missing, it can take up to several seconds.</p>\n<p>If a demuxer is in the process of performing a seek and receives a\nsecond one, it is up to it to finish the first one, start the second one\nor abort both, which is a bad thing. A simple method to avoid this issue\nis <em>throttling</em>, which means that we will only allow one seek every half\na second (for example): after performing a seek, only the last seek\nrequest received during the next 500ms is stored, and will be honored\nonce this period elapses.</p>\n<p>To achieve this, all seek requests are routed through\nthe <code>execute_seek()</code> method:</p>\n<pre><code>/* Perform seek, if we are not too close to the previous seek. Otherwise, schedule the seek for\n * some time in the future. */\nstatic void execute_seek (gint64 position, GStreamerBackend *self) {\n    gint64 diff;\n\n    if (position == GST_CLOCK_TIME_NONE)\n        return;\n\n    diff = gst_util_get_timestamp () - self-&gt;last_seek_time;\n\n    if (GST_CLOCK_TIME_IS_VALID (self-&gt;last_seek_time) &amp;&amp; diff &lt; SEEK_MIN_DELAY) {\n        /* The previous seek was too close, delay this one */\n        GSource *timeout_source;\n\n        if (self-&gt;desired_position == GST_CLOCK_TIME_NONE) {\n            /* There was no previous seek scheduled. Setup a timer for some time in the future */\n            timeout_source = g_timeout_source_new ((SEEK_MIN_DELAY - diff) / GST_MSECOND);\n            g_source_set_callback (timeout_source, (GSourceFunc)delayed_seek_cb, (__bridge void *)self, NULL);\n            g_source_attach (timeout_source, self-&gt;context);\n            g_source_unref (timeout_source);\n        }\n        /* Update the desired seek position. If multiple requests are received before it is time\n         * to perform a seek, only the last one is remembered. */\n        self-&gt;desired_position = position;\n        GST_DEBUG (\"Throttling seek to %\" GST_TIME_FORMAT \", will be in %\" GST_TIME_FORMAT,\n                   GST_TIME_ARGS (position), GST_TIME_ARGS (SEEK_MIN_DELAY - diff));\n    } else {\n        /* Perform the seek now */\n        GST_DEBUG (\"Seeking to %\" GST_TIME_FORMAT, GST_TIME_ARGS (position));\n        self-&gt;last_seek_time = gst_util_get_timestamp ();\n        gst_element_seek_simple (self-&gt;pipeline, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, position);\n        self-&gt;desired_position = GST_CLOCK_TIME_NONE;\n    }\n}\n</code></pre>\n<p>The time at which the last seek was performed is stored in\nthe <code>last_seek_time</code> variable. This is wall clock time, not to be\nconfused with the stream time carried in the media time stamps, and is\nobtained with <code>gst_util_get_timestamp()</code>.</p>\n<p>If enough time has passed since the last seek operation, the new one is\ndirectly executed and <code>last_seek_time</code> is updated. Otherwise, the new\nseek is scheduled for later. If there is no previously scheduled seek, a\none-shot timer is setup to trigger 500ms after the last seek operation.\nIf another seek was already scheduled, its desired position is simply\nupdated with the new one.</p>\n<p>The one-shot timer calls <code>delayed_seek_cb()</code>, which simply\ncalls <code>execute_seek()</code> again.</p>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"information\" id=\"information\">\nIdeally, <code>execute_seek()</code> will now find that enough time has indeed passed since the last seek and the scheduled one will proceed. It might happen, though, that after 500ms of the previous seek, and before the timer wakes up, yet another seek comes through and is executed. <code>delayed_seek_cb()</code> needs to check for this condition to avoid performing two very close seeks, and therefore calls <code>execute_seek()</code> instead of performing the seek itself.</p>\n<p>This is not a complete solution: the scheduled seek will still be executed, even though a more-recent seek has already been executed that should have cancelled it. However, it is a good tradeoff between functionality and simplicity.</p>\n</blockquote>\n<h3 id=\"network-resilience\">Network resilience</h3>\n<p><a href=\"../basic/streaming.html\">Basic tutorial 12: Streaming</a> has already\nshown how to adapt to the variable nature of the network bandwidth by\nusing buffering. The same procedure is used here, by listening to the\nbuffering\nmessages:</p>\n<pre><code>g_signal_connect (G_OBJECT (bus), \"message::buffering\", (GCallback)buffering_cb, (__bridge void *)self);\n</code></pre>\n<p>And pausing the pipeline until buffering is complete (unless this is a\nlive\nsource):</p>\n<pre><code>/* Called when buffering messages are received. We inform the UI about the current buffering level and\n * keep the pipeline paused until 100% buffering is reached. At that point, set the desired state. */\nstatic void buffering_cb (GstBus *bus, GstMessage *msg, GStreamerBackend *self) {\n    gint percent;\n\n    if (self-&gt;is_live)\n        return;\n\n    gst_message_parse_buffering (msg, &amp;percent);\n    if (percent &lt; 100 &amp;&amp; self-&gt;target_state &gt;= GST_STATE_PAUSED) {\n        gchar * message_string = g_strdup_printf (\"Buffering %d%%\", percent);\n        gst_element_set_state (self-&gt;pipeline, GST_STATE_PAUSED);\n        [self setUIMessage:message_string];\n        g_free (message_string);\n    } else if (self-&gt;target_state &gt;= GST_STATE_PLAYING) {\n        gst_element_set_state (self-&gt;pipeline, GST_STATE_PLAYING);\n    } else if (self-&gt;target_state &gt;= GST_STATE_PAUSED) {\n        [self setUIMessage:\"Buffering complete\"];\n    }\n}\n</code></pre>\n<p><code>target_state</code> is the state in which we have been instructed to set the\npipeline, which might be different to the current state, because\nbuffering forces us to go to PAUSED. Once buffering is complete we set\nthe pipeline to the <code>target_state</code>.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial has shown how to embed a <code>playbin</code> pipeline into an iOS\napplication. This, effectively, turns such application into a basic\nmedia player, capable of streaming and decoding all the formats\nGStreamer understands. More particularly, it has shown:</p>\n<ul>\n<li>How to keep the User Interface regularly updated by using a timer,\nquerying the pipeline position and calling a UI code method.</li>\n<li>How to implement a Seek Bar which follows the current position and\ntransforms thumb motion into reliable seek events.</li>\n<li>How to report the media size to adapt the display surface, by\nreading the sink Caps at the appropriate moment and telling the UI\nabout it.</li>\n</ul>\n<p>The next tutorial adds the missing bits to turn the application built\nhere into an acceptable iOS media player.</p>\n\n</div>\n\n\n        "});