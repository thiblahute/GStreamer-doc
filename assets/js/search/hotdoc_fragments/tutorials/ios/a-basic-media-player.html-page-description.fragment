fragment_downloaded_cb({"url": "tutorials/ios/a-basic-media-player.html#page-description", "fragment": "\nEnough testing with synthetic images and audio tones This tutorial finally plays actual media streamed directly from the Internet in your iOS device. It shows \nIt also uses the knowledge gathered in the Basic tutorials regarding \nFrom the previous tutorials we already have almost all necessary pieces to build a media player. The most complex part is assembling a pipeline which retrieves decodes and displays the media but we already know that the playbin element can take care of all that for us. We only need to replace the manual pipeline we used in iOS tutorial Video with a single element playbin pipeline and we are good to go \nHowever we can do better than. We will add a Time Slider with a moving thumb that will advance as our current position in the media advances. We will also allow the user to drag the thumb to jump or seek to a different position. \nAnd finally we will make the video surface adapt to the media size so the video sink is not forced to draw black borders around the clip. This also allows the iOS layout to adapt more nicely to the actual media content. You can still force the video surface to have a specific size if you really want to. \nThe User Interface from the previous tutorial is expanded again. A UISlider has been added to the toolbar to keep track of the current position in the clip and allow the user to change it. Also a read only UITextField is added to show the exact clip position and duration. \nVideoViewController.h \nNote how we register callbacks for some of the Actions the UISlider generates. Also note that the class has been renamed from ViewController to VideoViewController since the next tutorial adds another ViewController and we will need to differentiate. \nThe ViewControllerclass manages the UI instantiates the GStreamerBackend and also performs some UI related tasks on its behalf \nDue to the extension of this code this view is collapsed by default. Click here to expand \nVideoViewController.m \nSupporting arbitrary media URIs \nThe GStreamerBackend provides the setUri method so we can indicate the URI of the media to play. Since playbin will be taking care of retrieving the media we can use local or remote URIs indistinctly file or http for example From the UI code though we want to keep track of whether the file is local or remote because we will not offer the same functionalities. We keep track of this in the is_local_media variable which is set when the URI is set in the gstreamerInitialized method \nReporting media size \nEvery time the size of the media changes which could happen mid stream for some kind of streams or when it is first detected GStreamerBackend calls our mediaSizeChanged callback \nHere we simply store the new size and ask the layout to be recalculated. As we have already seen in iOS tutorial A running pipeline methods which change the UI must be called from the main thread and we are now in a callback from some GStreamer internal thread. Hence the usage of dispatch_async \nBasic tutorial GUI toolkit integration has already shown how to implement a Seek Bar or Time Slider in this tutorial using the GTK toolkit. The implementation on iOS is very similar. \nThe Seek Bar accomplishes to functions First it moves on its own to reflect the current playback position in the media. Second it can be dragged by the user to seek to a different position. \nTo realize the first function GStreamerBackend will periodically call our setCurrentPosition method so we can update the position of the thumb in the Seek Bar. Again we do so from the UI thread using dispatch_async \nAlso note that if the user is currently dragging the slider the dragging_slider variable is explained below we ignore setCurrentPosition calls from GStreamerBackend as they would interfere with the user s actions. \nTo the left of the Seek Bar refer to the screenshot at the top of this page there is a TextField widget which we will use to display the current position and duration in HH mm ss HH mm ss textual format. The updateTimeWidget method takes care of it and must be called every time the Seek Bar is updated \nSeeking with the Seek Bar \nTo perform the second function of the Seek Bar allowing the user to seek by dragging the thumb we register some callbacks through IBAction outlets. Refer to the storyboard in this tutorial s project to see which outlets are connected. We will be notified when the user starts dragging the Slider when the Slider position changes and when the users releases the Slider. \nsliderTouchDown is called when the user starts dragging. Here we pause the pipeline because if the user is searching for a particular scene we do not want it to keep moving. We also mark that a drag operation is in progress in the dragging_slider variable. \nsliderValueChanged is called every time the Slider s thumb moves be it because the user dragged it or because we changed its value form the program. We discard the latter case using the dragging_slider variable. \nAs the comment says if this is a local media we allow scrub seeking this is we jump to the indicated position as soon as the thumb moves. Otherwise the seek operation will be performed when the thumb is released and the only thing we do here is update the textual time widget. \nFinally sliderTouchUp is called when the thumb is released. We perform the seek operation if the file was non local restore the pipeline to the desired playing state and end the dragging operation by setting dragging_slider to NO. \nThis concludes the User interface part of this tutorial. Let s review now the GStreamerBackend class that allows this to work. \nThe GStreamerBackend class performs all GStreamer related tasks and offers a simplified interface to the application which does not need to deal with all the GStreamer details. When it needs to perform any UI action it does so through a delegate which is expected to adhere to the GStreamerBackendDelegate protocol. \nGStreamerBackend.m \nSupporting arbitrary media URIs \nThe UI code will call setUri whenever it wants to change the playing URI in this tutorial the URI never changes but it does in the next one \nWe first need to obtain a plain char from within the NSString we get using the UTF8String method. \nplaybin s URI is exposed as a common GObject property so we simply set it with g_object_set \nSome codecs allow the media size width and height of the video to change during playback. For simplicity this tutorial assumes that they do not. Therefore in the READY to PAUSED state change once the Caps of the decoded media are known we inspect them in check_media_size \nWe first retrieve the video sink element from the pipeline using the video sink property of playbin and then its sink Pad. The negotiated Caps of this Pad which we recover using gst_pad_get_current_caps are the Caps of the decoded media. \nThe helper functions gst_video_format_parse_caps and gst_video_parse_caps_pixel_aspect_ratio turn the Caps into manageable integers which we pass to the application through its mediaSizeChanged callback. \nTo keep the UI updated a GLib timer is installed in the app_function that fires times per second or every ms right before entering the main loop \nThen in the refresh_ui method \nIf it is unknown the clip duration is retrieved as explained in Basic tutorial Time management. The current position is retrieved next and the UI is informed of both through its setCurrentUIPosition callback. \nBear in mind that all time related measures returned by GStreamer are in nanoseconds whereas for simplicity we decided to make the UI code work in milliseconds. \nThe UI code already takes care of most of the complexity of seeking by dragging the thumb of the Seek Bar. From the GStreamerBackend we just need to honor the calls to setPosition and instruct the pipeline to jump to the indicated position. \nThere are though a couple of caveats. Firstly seeks are only possible when the pipeline is in the PAUSED or PLAYING state and we might receive seek requests before that happens. Secondly dragging the Seek Bar can generate a very high number of seek requests in a short period of time which is visually useless and will impair responsiveness. Let s see how to overcome these problems. \nIn setPosition \nIf we are already in the correct state for seeking execute it right away otherwise store the desired position in the desired_position variable. Then in the state_changed_cb callback \nOnce the pipeline moves from the READY to the PAUSED state we check if there is a pending seek operation and execute it. The desired_position variable is reset inside execute_seek \nA seek is potentially a lengthy operation. The demuxer the element typically in charge of seeking needs to estimate the appropriate byte offset inside the media file that corresponds to the time position to jump to. Then it needs to start decoding from that point until the desired position is reached. If the initial estimate is accurate this will not take long but on some container formats or when indexing information is missing it can take up to several seconds. \nIf a demuxer is in the process of performing a seek and receives a second one it is up to it to finish the first one start the second one or abort both which is a bad thing. A simple method to avoid this issue is throttling which means that we will only allow one seek every half a second for example after performing a seek only the last seek request received during the next ms is stored and will be honored once this period elapses. \nTo achieve this all seek requests are routed through the execute_seek method \nThe time at which the last seek was performed is stored in the last_seek_time variable. This is wall clock time not to be confused with the stream time carried in the media time stamps and is obtained with gst_util_get_timestamp \nIf enough time has passed since the last seek operation the new one is directly executed and last_seek_time is updated. Otherwise the new seek is scheduled for later. If there is no previously scheduled seek a one shot timer is setup to trigger ms after the last seek operation. If another seek was already scheduled its desired position is simply updated with the new one. \nThe one shot timer calls delayed_seek_cb which simply calls execute_seek again. \nIdeally execute_seek will now find that enough time has indeed passed since the last seek and the scheduled one will proceed. It might happen though that after ms of the previous seek and before the timer wakes up yet another seek comes through and is executed. delayed_seek_cb needs to check for this condition to avoid performing two very close seeks and therefore calls execute_seek instead of performing the seek itself. \nThis is not a complete solution the scheduled seek will still be executed even though a more recent seek has already been executed that should have cancelled it. However it is a good tradeoff between functionality and simplicity. \nBasic tutorial Streaming has already shown how to adapt to the variable nature of the network bandwidth by using buffering. The same procedure is used here by listening to the buffering messages \nAnd pausing the pipeline until buffering is complete unless this is a live source \ntarget_state is the state in which we have been instructed to set the pipeline which might be different to the current state because buffering forces us to go to PAUSED. Once buffering is complete we set the pipeline to the target_state. \nThis tutorial has shown how to embed a playbin pipeline into an iOS application. This effectively turns such application into a basic media player capable of streaming and decoding all the formats GStreamer understands. More particularly it has shown \nThe next tutorial adds the missing bits to turn the application built here into an acceptable iOS media player. \n"});