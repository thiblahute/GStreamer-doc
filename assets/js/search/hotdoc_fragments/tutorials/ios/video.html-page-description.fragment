fragment_downloaded_cb({"url": "tutorials/ios/video.html#page-description", "fragment": "\nExcept for Basic tutorial GUI toolkit integration which embedded a video window on a GTK application all tutorials so far relied on GStreamer video sinks to create a window to display their contents. The video sink on iOS is not capable of creating its own window so a drawing surface always needs to be provided. This tutorial shows \nSince iOS does not provide a windowing system a GStreamer video sink cannot create pop up windows as it would do on a Desktop platform. Fortunately the VideoOverlay interface allows providing video sinks with an already created window onto which they can draw as we have seen in Basic tutorial GUI toolkit integration. \nIn this tutorial a UIView widget actually a subclass of it is placed on the main storyboard. In the viewDidLoad method of the ViewController we pass a pointer to this UIViewto the instance of the GStreamerBackend so it can tell the video sink where to draw. \nThe storyboard from the previous tutorial is expanded A UIViewis added over the toolbar and pinned to all sides so it takes up all available space video_container_view outlet Inside it another UIViewis added video_view outlet which contains the actual video centered to its parent and with a size that adapts to the media size through the video_width_constraint and video_height_constraint outlets \nViewController.h \nThe ViewControllerclass manages the UI instantiates the GStreamerBackend and also performs some UI related tasks on its behalf \nViewController.m \nWe expand the class to remember the width and height of the media we are currently playing \nIn later tutorials this data is retrieved from the GStreamer pipeline but in this tutorial for simplicity s sake the width and height of the media is constant and initialized in viewDidLoad \nAs shown below the GStreamerBackend constructor has also been expanded to accept another parameter the UIView where the video sink should draw. \nThe rest of the ViewControllercode is the same as the previous tutorial except for the code that adapts the video_view size to the media size respecting its aspect ratio \nThe viewDidLayoutSubviews method is called every time the main view size has changed for example due to a device orientation change and the entire layout has been recalculated. At this point we can access the bounds property of the video_container_view to retrieve its new size and change the video_view size accordingly. \nThe simple algorithm above maximizes either the width or the height of the video_view while changing the other axis so the aspect ratio of the media is preserved. The goal is to provide the GStreamer video sink with a surface of the correct proportions so it does not need to add black borders letterboxing which is a waste of processing power. \nThe final size is reported to the layout engine by changing the constant field in the width and height Constraints of the video_view. These constraints have been created in the storyboard and are accessible to the ViewControllerthrough IBOutlets as is usually done with other widgets. \nThe GStreamerBackend class performs all GStreamer related tasks and offers a simplified interface to the application which does not need to deal with all the GStreamer details. When it needs to perform any UI action it does so through a delegate which is expected to adhere to the GStreamerBackendDelegate protocol \nGStreamerBackend.m \nThe main differences with the previous tutorial are related to the handling of the VideoOverlay interface \nThe class is expanded to keep track of the video sink element in the pipeline and the UIView onto which rendering is to occur. \nThe constructor accepts the UIView as a new parameter which at this point is simply remembered in ui_video_view. \nThen in the app_function the pipeline is constructed. This time we build a video pipeline using a simple videotestsrc element with a warptv to add some spice. The video sink is autovideosink which choses the appropriate sink for the platform currently glimagesink is the only option for iOS \nOnce the pipeline is built we set it to READY. In this state dataflow has not started yet but the caps of adjacent elements have been verified to be compatible and their pads have been linked. Also the autovideosink has already instantiated the actual video sink so we can ask for it immediately. \nThe gst_bin_get_by_interface method will examine the whole pipeline and return a pointer to an element which supports the requested interface. We are asking for the VideoOverlay interface explained in Basic tutorial GUI toolkit integration which controls how to perform rendering into foreign non GStreamer windows. The internal video sink instantiated by autovideosink is the only element in this pipeline implementing it so it will be returned. \nOnce we have the video sink we inform it of the UIView to use for rendering through the gst_video_overlay_set_window_handle method. \nOne last detail remains. In order for glimagesink to be able to draw on the UIView the Layer associated with this view must be of the CAEAGLLayer class. To this avail we create the EaglUIView class derived from UIViewand overriding the layerClass method \nEaglUIView.m \nWhen creating storyboards bear in mind that the UIViewwhich should contain the video must have EaglUIView as its custom class. This is easy to setup from the Xcode interface builder. Take a look at the tutorial storyboard to see how to achieve this. \nAnd this is it using GStreamer to output video onto an iOS application is as simple as it seems. \nThis tutorial has shown \nThe following tutorial plays an actual clip and adds a few more controls to this tutorial in order to build a simple media player. \nIt has been a pleasure having you here and see you soon \n"});