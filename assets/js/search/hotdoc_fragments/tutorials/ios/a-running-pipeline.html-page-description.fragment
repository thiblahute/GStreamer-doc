fragment_downloaded_cb({"url": "tutorials/ios/a-running-pipeline.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"a-running-pipeline.md\">\n<h1 id=\"ios-tutorial-2-a-running-pipeline\">iOS tutorial 2: A running pipeline</h1>\n<h2 id=\"goal\">Goal</h2>\n<p><img src=\"images/tutorials/ios-a-running-pipeline-screenshot.png\" alt=\"screenshot\" id=\"screenshot\"></p>\n<p>As seen in the <a href=\"../basic/index.html\">Basic</a> and\n<a href=\"../playback/index.html\">Playback</a> tutorials, GStreamer integrates\nnicely with GLib\u2019s main loops, so pipeline operation and user interface\ncan be monitored simultaneously in a very simple way. However, platforms\nlike iOS or Android do not use GLib and therefore extra care must be\ntaken to keep track of the pipeline progress without blocking the user\ninterface (UI).</p>\n<p>This tutorial shows:</p>\n<ul>\n<li>How to move the GStreamer-handling code to a separate Dispatch Queue\nwhereas UI managing still happens from the Main Dispatch Queue</li>\n<li>How to communicate between the Objective-C UI code and the C\nGStreamer code</li>\n</ul>\n<h2 id=\"introduction\">Introduction</h2>\n<p>When using a Graphical User Interface (UI), if the application waits for\nGStreamer calls to complete the user experience will suffer. The usual\napproach, with the <a href=\"http://www.gtk.org/\">GTK+ toolkit</a> for example, is\nto relinquish control to a GLib <code>GMainLoop</code> and let it control the\nevents coming from the UI or GStreamer.</p>\n<p>Other graphical toolkits that are not based on GLib, like the <a href=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Cocoa.html\">Cocoa\nTouch</a>\nframework used on iOS devices, cannot use this option, though. The\nsolution used in this tutorial uses a GLib <code>GMainLoop</code> for its\nsimplicity, but moves it to a separate thread (a <a href=\"http://developer.apple.com/library/ios/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html\">Dispatch\nQueue</a>\ndifferent than the main one) so it does not block the user interface\noperation.</p>\n<p>Additionally, this tutorial shows a few places where caution has to be\ntaken when calling from Objective-C to C and vice versa.</p>\n<p>The code below builds a pipeline with an <code>audiotestsrc</code> and\nan <code>autoaudiosink</code> (it plays an audible tone). Two buttons in the UI\nallow setting the pipeline to PLAYING or PAUSED. A Label in the UI shows\nmessages sent from the C code (for errors and state changes).</p>\n<h2 id=\"the-user-interface\">The User Interface</h2>\n<p>A toolbar at the bottom of the screen contains a Play and a Pause\nbutton. Over the toolbar there is a Label used to display messages from\nGStreamer. This tutorial does not require more elements, but the\nfollowing lessons will build their User Interfaces on top of this one,\nadding more components.</p>\n<h2 id=\"the-view-controller\">The View Controller</h2>\n<p>The <code>ViewController</code> class manages the UI, instantiates\nthe <code>GStreamerBackend</code> and also performs some UI-related tasks on its\nbehalf:</p>\n<p><strong>ViewController.m</strong></p>\n<pre><code>#import \"ViewController.h\"\n#import \"GStreamerBackend.h\"\n#import &lt;UIKit/UIKit.h&gt;\n\n@interface ViewController () {\n    GStreamerBackend *gst_backend;\n}\n\n@end\n\n@implementation ViewController\n\n/*\n * Methods from UIViewController\n */\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n\n    play_button.enabled = FALSE;\n    pause_button.enabled = FALSE;\n\n    gst_backend = [[GStreamerBackend alloc] init:self];\n}\n\n- (void)didReceiveMemoryWarning\n{\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n/* Called when the Play button is pressed */\n-(IBAction) play:(id)sender\n{\n    [gst_backend play];\n}\n\n/* Called when the Pause button is pressed */\n-(IBAction) pause:(id)sender\n{\n    [gst_backend pause];\n}\n\n/*\n * Methods from GstreamerBackendDelegate\n */\n\n-(void) gstreamerInitialized\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        play_button.enabled = TRUE;\n        pause_button.enabled = TRUE;\n        message_label.text = @\"Ready\";\n    });\n}\n\n-(void) gstreamerSetUIMessage:(NSString *)message\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        message_label.text = message;\n    });\n}\n\n@end\n</code></pre>\n<p>An instance of the <code>GStreamerBackend</code> in stored inside the class:</p>\n<pre><code>@interface ViewController () {\n    GStreamerBackend *gst_backend;\n}\n</code></pre>\n<p>This instance is created in the <code>viewDidLoad</code> function through a custom\n<code>init:</code> method in the <code>GStreamerBackend</code>:</p>\n<pre><code>- (void)viewDidLoad\n{\n    [super viewDidLoad];\n\n    play_button.enabled = FALSE;\n    pause_button.enabled = FALSE;\n\n    gst_backend = [[GStreamerBackend alloc] init:self];\n}\n</code></pre>\n<p>This custom method is required to pass the object that has to be used as\nthe UI delegate (in this case, ourselves, the <code>ViewController</code>).</p>\n<p>The Play and Pause buttons are also disabled in the\n<code>viewDidLoad</code> function, and they are not re-enabled until the\n<code>GStreamerBackend</code> reports that it is initialized and ready.</p>\n<pre><code>/* Called when the Play button is pressed */\n-(IBAction) play:(id)sender\n{\n    [gst_backend play];\n}\n\n/* Called when the Pause button is pressed */\n-(IBAction) pause:(id)sender\n{\n    [gst_backend pause];\n}\n</code></pre>\n<p>These two methods are called when the user presses the Play or Pause\nbuttons, and simply forward the call to the appropriate method in the\n<code>GStreamerBackend</code>.</p>\n<pre><code>-(void) gstreamerInitialized\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        play_button.enabled = TRUE;\n        pause_button.enabled = TRUE;\n        message_label.text = @\"Ready\";\n    });\n}\n</code></pre>\n<p>The <code>gstreamerInitialized</code> method is defined in the\n<code>GStreamerBackendDelegate</code> protocol and indicates that the backend is\nready to accept commands. In this case, the Play and Pause buttons are\nre-enabled and the Label text is set to \u201cReady\u201d. This method is called\nfrom a Dispatch Queue other than the Main one; therefore the need for\nthe\n<a href=\"https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/dispatch_async.3.html\">dispatch_async()</a> call\nwrapping all UI code.</p>\n<pre><code>-(void) gstreamerSetUIMessage:(NSString *)message\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        message_label.text = message;\n    });\n}\n</code></pre>\n<p>The <code>gstreamerSetUIMessage:</code> method also belongs to the\n<code>GStreamerBackendDelegate</code> protocol. It is called when the backend wants\nto report some message to the user. In this case, the message is copied\nonto the Label in the UI, again, from within a\n<a href=\"https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/dispatch_async.3.html\">dispatch_async()</a> call.</p>\n<h2 id=\"the-gstreamer-backend\">The GStreamer Backend</h2>\n<p>The <code>GStreamerBackend</code> class performs all GStreamer-related tasks and\noffers a simplified interface to the application, which does not need to\ndeal with all the GStreamer details. When it needs to perform any UI\naction, it does so through a delegate, which is expected to adhere to\nthe <code>GStreamerBackendDelegate</code> protocol:</p>\n<p><strong>GStreamerBackend.m</strong></p>\n<pre><code>#import \"GStreamerBackend.h\"\n\n#include &lt;gst/gst.h&gt;\n\nGST_DEBUG_CATEGORY_STATIC (debug_category);\n#define GST_CAT_DEFAULT debug_category\n\n@interface GStreamerBackend()\n-(void)setUIMessage:(gchar*) message;\n-(void)app_function;\n-(void)check_initialization_complete;\n@end\n\n@implementation GStreamerBackend {\n    id ui_delegate;        /* Class that we use to interact with the user interface */\n    GstElement *pipeline;  /* The running pipeline */\n    GMainContext *context; /* GLib context used to run the main loop */\n    GMainLoop *main_loop;  /* GLib main loop */\n    gboolean initialized;  /* To avoid informing the UI multiple times about the initialization */\n}\n\n/*\n * Interface methods\n */\n\n-(id) init:(id) uiDelegate\n{\n    if (self = [super init])\n    {\n        self-&gt;ui_delegate = uiDelegate;\n\n        GST_DEBUG_CATEGORY_INIT (debug_category, \"tutorial-2\", 0, \"iOS tutorial 2\");\n        gst_debug_set_threshold_for_name(\"tutorial-2\", GST_LEVEL_DEBUG);\n\n        /* Start the bus monitoring task */\n        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n            [self app_function];\n        });\n    }\n\n    return self;\n}\n\n-(void) dealloc\n{\n    if (pipeline) {\n        GST_DEBUG(\"Setting the pipeline to NULL\");\n        gst_element_set_state(pipeline, GST_STATE_NULL);\n        gst_object_unref(pipeline);\n        pipeline = NULL;\n    }\n}\n\n-(void) play\n{\n    if(gst_element_set_state(pipeline, GST_STATE_PLAYING) == GST_STATE_CHANGE_FAILURE) {\n        [self setUIMessage:\"Failed to set pipeline to playing\"];\n    }\n}\n\n-(void) pause\n{\n    if(gst_element_set_state(pipeline, GST_STATE_PAUSED) == GST_STATE_CHANGE_FAILURE) {\n        [self setUIMessage:\"Failed to set pipeline to paused\"];\n    }\n}\n\n/*\n * Private methods\n */\n\n/* Change the message on the UI through the UI delegate */\n-(void)setUIMessage:(gchar*) message\n{\n    NSString *string = [NSString stringWithUTF8String:message];\n    if(ui_delegate &amp;&amp; [ui_delegate respondsToSelector:@selector(gstreamerSetUIMessage:)])\n    {\n        [ui_delegate gstreamerSetUIMessage:string];\n    }\n}\n\n/* Retrieve errors from the bus and show them on the UI */\nstatic void error_cb (GstBus *bus, GstMessage *msg, GStreamerBackend *self)\n{\n    GError *err;\n    gchar *debug_info;\n    gchar *message_string;\n\n    gst_message_parse_error (msg, &amp;err, &amp;debug_info);\n    message_string = g_strdup_printf (\"Error received from element %s: %s\", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);\n    g_clear_error (&amp;err);\n    g_free (debug_info);\n    [self setUIMessage:message_string];\n    g_free (message_string);\n    gst_element_set_state (self-&gt;pipeline, GST_STATE_NULL);\n}\n\n/* Notify UI about pipeline state changes */\nstatic void state_changed_cb (GstBus *bus, GstMessage *msg, GStreamerBackend *self)\n{\n    GstState old_state, new_state, pending_state;\n    gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);\n    /* Only pay attention to messages coming from the pipeline, not its children */\n    if (GST_MESSAGE_SRC (msg) == GST_OBJECT (self-&gt;pipeline)) {\n        gchar *message = g_strdup_printf(\"State changed to %s\", gst_element_state_get_name(new_state));\n        [self setUIMessage:message];\n        g_free (message);\n    }\n}\n\n/* Check if all conditions are met to report GStreamer as initialized.\n * These conditions will change depending on the application */\n-(void) check_initialization_complete\n{\n    if (!initialized &amp;&amp; main_loop) {\n        GST_DEBUG (\"Initialization complete, notifying application.\");\n        if (ui_delegate &amp;&amp; [ui_delegate respondsToSelector:@selector(gstreamerInitialized)])\n        {\n            [ui_delegate gstreamerInitialized];\n        }\n        initialized = TRUE;\n    }\n}\n\n/* Main method for the bus monitoring code */\n-(void) app_function\n{\n    GstBus *bus;\n    GSource *bus_source;\n    GError *error = NULL;\n\n    GST_DEBUG (\"Creating pipeline\");\n\n    /* Create our own GLib Main Context and make it the default one */\n    context = g_main_context_new ();\n    g_main_context_push_thread_default(context);\n\n    /* Build pipeline */\n    pipeline = gst_parse_launch(\"audiotestsrc ! audioconvert ! audioresample ! autoaudiosink\", &amp;error);\n    if (error) {\n        gchar *message = g_strdup_printf(\"Unable to build pipeline: %s\", error-&gt;message);\n        g_clear_error (&amp;error);\n        [self setUIMessage:message];\n        g_free (message);\n        return;\n    }\n\n    /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */\n    bus = gst_element_get_bus (pipeline);\n    bus_source = gst_bus_create_watch (bus);\n    g_source_set_callback (bus_source, (GSourceFunc) gst_bus_async_signal_func, NULL, NULL);\n    g_source_attach (bus_source, context);\n    g_source_unref (bus_source);\n    g_signal_connect (G_OBJECT (bus), \"message::error\", (GCallback)error_cb, (__bridge void *)self);\n    g_signal_connect (G_OBJECT (bus), \"message::state-changed\", (GCallback)state_changed_cb, (__bridge void *)self);\n    gst_object_unref (bus);\n\n    /* Create a GLib Main Loop and set it to run */\n    GST_DEBUG (\"Entering main loop...\");\n    main_loop = g_main_loop_new (context, FALSE);\n    [self check_initialization_complete];\n    g_main_loop_run (main_loop);\n    GST_DEBUG (\"Exited main loop\");\n    g_main_loop_unref (main_loop);\n    main_loop = NULL;\n\n    /* Free resources */\n    g_main_context_pop_thread_default(context);\n    g_main_context_unref (context);\n    gst_element_set_state (pipeline, GST_STATE_NULL);\n    gst_object_unref (pipeline);\n\n    return;\n}\n\n@end\n</code></pre>\n<h4 id=\"interface-methods\">Interface methods:</h4>\n<pre><code>-(id) init:(id) uiDelegate\n{\n    if (self = [super init])\n    {\n        self-&gt;ui_delegate = uiDelegate;\n\n        GST_DEBUG_CATEGORY_INIT (debug_category, \"tutorial-2\", 0, \"iOS tutorial 2\");\n        gst_debug_set_threshold_for_name(\"tutorial-2\", GST_LEVEL_DEBUG);\n\n        /* Start the bus monitoring task */\n        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n            [self app_function];\n        });\n    }\n\n    return self;\n}\n</code></pre>\n<p>The <code>init:</code> method creates the instance by calling <code>[super init]</code>,\nstores the delegate object that will handle the UI interaction and\nlaunches the <code>app_function</code>, from a separate, concurrent, Dispatch\nQueue. The <code>app_function</code> monitors the GStreamer bus for messages and\nwarns the application when interesting things happen.</p>\n<p><code>init:</code> also registers a new GStreamer debug category and sets its\nthreshold, so we can see the debug output from within Xcode and keep\ntrack of our application progress.</p>\n<pre><code>-(void) dealloc\n{\n    if (pipeline) {\n        GST_DEBUG(\"Setting the pipeline to NULL\");\n        gst_element_set_state(pipeline, GST_STATE_NULL);\n        gst_object_unref(pipeline);\n        pipeline = NULL;\n    }\n}\n</code></pre>\n<p>The <code>dealloc</code> method takes care of bringing the pipeline to the NULL\nstate and releasing it.</p>\n<pre><code>-(void) play\n{\n    if(gst_element_set_state(pipeline, GST_STATE_PLAYING) == GST_STATE_CHANGE_FAILURE) {\n        [self setUIMessage:\"Failed to set pipeline to playing\"];\n    }\n}\n\n-(void) pause\n{\n    if(gst_element_set_state(pipeline, GST_STATE_PAUSED) == GST_STATE_CHANGE_FAILURE) {\n        [self setUIMessage:\"Failed to set pipeline to paused\"];\n    }\n}\n</code></pre>\n<p>The <code>play</code> and <code>pause</code> methods simply try to set the pipeline to the\ndesired state and warn the application if something fails.</p>\n<h4 id=\"private-methods\">Private methods:</h4>\n<pre><code>/* Change the message on the UI through the UI delegate */\n-(void)setUIMessage:(gchar*) message\n{\n    NSString *string = [NSString stringWithUTF8String:message];\n    if(ui_delegate &amp;&amp; [ui_delegate respondsToSelector:@selector(gstreamerSetUIMessage:)])\n    {\n        [ui_delegate gstreamerSetUIMessage:string];\n    }\n}\n</code></pre>\n<p><code>setUIMessage:</code> turns the C strings that GStreamer uses (UTF8 <code>char *</code>)\ninto <code>NSString *</code> and displays them through the\n<code>gstreamerSetUIMessage</code> method of the <code>GStreamerBackendDelegate</code>. The\nimplementation of this method is marked as <code>@optional</code>, and hence the\ncheck for its existence in the delegate with <code>respondsToSelector:</code></p>\n<pre><code>/* Retrieve errors from the bus and show them on the UI */\nstatic void error_cb (GstBus *bus, GstMessage *msg, GStreamerBackend *self)\n{\n    GError *err;\n    gchar *debug_info;\n    gchar *message_string;\n\n    gst_message_parse_error (msg, &amp;err, &amp;debug_info);\n    message_string = g_strdup_printf (\"Error received from element %s: %s\", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);\n    g_clear_error (&amp;err);\n    g_free (debug_info);\n    [self setUIMessage:message_string];\n    g_free (message_string);\n    gst_element_set_state (self-&gt;pipeline, GST_STATE_NULL);\n}\n\n/* Notify UI about pipeline state changes */\nstatic void state_changed_cb (GstBus *bus, GstMessage *msg, GStreamerBackend *self)\n{\n    GstState old_state, new_state, pending_state;\n    gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);\n    /* Only pay attention to messages coming from the pipeline, not its children */\n    if (GST_MESSAGE_SRC (msg) == GST_OBJECT (self-&gt;pipeline)) {\n        gchar *message = g_strdup_printf(\"State changed to %s\", gst_element_state_get_name(new_state));\n        [self setUIMessage:message];\n        g_free (message);\n    }\n}\n</code></pre>\n<p>The <code>error_cb()</code> and <code>state_changed_cb()</code> are callbacks registered to\nthe <code>error</code> and <code>state-changed</code> events in GStreamer, and their goal is\nto inform the user about these events. These callbacks have been widely\nused in the <a href=\"../basic/index.html\">Basic tutorials</a> and their\nimplementation is very similar, except for two points:</p>\n<p>Firstly, the messages are conveyed to the user through the\n<code>setUIMessage:</code> private method discussed above.</p>\n<p>Secondly, they require an instance of a <code>GStreamerBackend</code> object in\norder to call its instance method <code>setUIMessage:</code>, which is passed\nthrough the <code>userdata</code> pointer of the callbacks (the <code>self</code> pointer in\nthese implementations). This is discussed below when registering the\ncallbacks in the <code>app_function</code>.</p>\n<pre><code>/* Check if all conditions are met to report GStreamer as initialized.\n * These conditions will change depending on the application */\n-(void) check_initialization_complete\n{\n    if (!initialized &amp;&amp; main_loop) {\n        GST_DEBUG (\"Initialization complete, notifying application.\");\n        if (ui_delegate &amp;&amp; [ui_delegate respondsToSelector:@selector(gstreamerInitialized)])\n        {\n            [ui_delegate gstreamerInitialized];\n        }\n        initialized = TRUE;\n    }\n}\n</code></pre>\n<p><code>check_initialization_complete()</code> verifies that all conditions are met\nto consider the backend ready to accept commands and tell the\napplication if so. In this simple tutorial the only conditions are that\nthe main loop exists and that we have not already told the application\nabout this fact. Later (more complex) tutorials include additional\nconditions.</p>\n<p>Finally, most of the GStreamer work is performed in the app_function.\nIt exists with almost identical content in the Android tutorial, which\nexemplifies how the same code can run on both platforms with little\nchange.</p>\n<pre><code>    /* Create our own GLib Main Context and make it the default one */\n    context = g_main_context_new ();\n    g_main_context_push_thread_default(context);\n</code></pre>\n<p>It first creates a GLib context so all <code>GSource</code>s are kept in the same\nplace. This also helps cleaning after GSources created by other\nlibraries which might not have been properly disposed of. A new context\nis created with <code>g_main_context_new()</code> and then it is made the default\none for the thread with <code>g_main_context_push_thread_default()</code>.</p>\n<pre><code>    /* Build pipeline */\n    pipeline = gst_parse_launch(\"audiotestsrc ! audioconvert ! audioresample ! autoaudiosink\", &amp;error);\n    if (error) {\n        gchar *message = g_strdup_printf(\"Unable to build pipeline: %s\", error-&gt;message);\n        g_clear_error (&amp;error);\n        [self setUIMessage:message];\n        g_free (message);\n        return;\n    }\n</code></pre>\n<p>It then creates a pipeline the easy way, with <code>gst_parse_launch()</code>. In\nthis case, it is simply an  <code>audiotestsrc</code> (which produces a continuous\ntone) and an <code>autoaudiosink</code>, with accompanying adapter\nelements.</p>\n<pre><code>    /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */\n    bus = gst_element_get_bus (pipeline);\n    bus_source = gst_bus_create_watch (bus);\n    g_source_set_callback (bus_source, (GSourceFunc) gst_bus_async_signal_func, NULL, NULL);\n    g_source_attach (bus_source, context);\n    g_source_unref (bus_source);\n    g_signal_connect (G_OBJECT (bus), \"message::error\", (GCallback)error_cb, (__bridge void *)self);\n    g_signal_connect (G_OBJECT (bus), \"message::state-changed\", (GCallback)state_changed_cb, (__bridge void *)self);\n    gst_object_unref (bus);\n</code></pre>\n<p>These lines create a bus signal watch and connect to some interesting\nsignals, just like we have been doing in the <a href=\"../basic/index.html\">Basic\ntutorials</a>. The creation of the watch is done\nstep by step instead of using <code>gst_bus_add_signal_watch()</code> to exemplify\nhow to use a custom GLib context. The interesting bit here is the usage\nof a\n<a href=\"http://clang.llvm.org/docs/AutomaticReferenceCounting.html#bridged-casts\">__bridge</a>\ncast to convert an Objective-C object into a plain C pointer. In this\ncase we do not worry much about transferal of ownership of the object,\nbecause it travels through C-land untouched. It re-emerges at the\ndifferent callbacks through the userdata pointer and cast again to a\n<code>GStreamerBackend *</code>.</p>\n<pre><code>    /* Create a GLib Main Loop and set it to run */\n    GST_DEBUG (\"Entering main loop...\");\n    main_loop = g_main_loop_new (context, FALSE);\n    [self check_initialization_complete];\n    g_main_loop_run (main_loop);\n    GST_DEBUG (\"Exited main loop\");\n    g_main_loop_unref (main_loop);\n    main_loop = NULL;\n</code></pre>\n<p>Finally, the main loop is created and set to run. Before entering the\nmain loop, though, <code>check_initialization_complete()</code> is called. Upon\nexit, the main loop is disposed of.</p>\n<p>And this is it! This has been a rather long tutorial, but we covered a\nlot of territory. Building on top of this one, the following ones are\nshorter and focus only on the new topics.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial has shown:</p>\n<ul>\n<li>How to handle GStreamer code from a separate thread using a\n<a href=\"http://developer.apple.com/library/ios/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html\">Dispatch\nQueue</a> other\nthan the Main one.</li>\n<li>How to pass objects between the Objective-C UI code and the C\nGStreamer code.</li>\n</ul>\n<p>Most of the methods introduced in this tutorial,\nlike <code>check_initialization_complete()</code>and <code>app_function()</code>, and the\ninterface methods <code>init:</code>, <code>play:</code>, <code>pause:</code>,\n<code>gstreamerInitialized:</code> and <code>setUIMessage:</code> will continue to be used in\nthe following tutorials with minimal modifications, so better get used\nto them!</p>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n\t"});