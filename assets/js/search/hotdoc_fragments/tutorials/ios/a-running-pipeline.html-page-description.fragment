fragment_downloaded_cb({"url": "tutorials/ios/a-running-pipeline.html#page-description", "fragment": "\nAs seen in the Basic and Playback tutorials GStreamer integrates nicely with GLib s main loops so pipeline operation and user interface can be monitored simultaneously in a very simple way. However platforms like iOS or Android do not use GLib and therefore extra care must be taken to keep track of the pipeline progress without blocking the user interface UI \nThis tutorial shows \nWhen using a Graphical User Interface UI if the application waits for GStreamer calls to complete the user experience will suffer. The usual approach with the GTK toolkit for example is to relinquish control to a GLib GMainLoop and let it control the events coming from the UI or GStreamer. \nOther graphical toolkits that are not based on GLib like the Cocoa Touch framework used on iOS devices cannot use this option though. The solution used in this tutorial uses a GLib GMainLoop for its simplicity but moves it to a separate thread a Dispatch Queue different than the main one so it does not block the user interface operation. \nAdditionally this tutorial shows a few places where caution has to be taken when calling from Objective C to C and vice versa. \nThe code below builds a pipeline with an audiotestsrc and an autoaudiosink it plays an audible tone Two buttons in the UI allow setting the pipeline to PLAYING or PAUSED. A Label in the UI shows messages sent from the C code for errors and state changes \nA toolbar at the bottom of the screen contains a Play and a Pause button. Over the toolbar there is a Label used to display messages from GStreamer. This tutorial does not require more elements but the following lessons will build their User Interfaces on top of this one adding more components. \nThe ViewController class manages the UI instantiates the GStreamerBackend and also performs some UI related tasks on its behalf \nViewController.m \nAn instance of the GStreamerBackend in stored inside the class \nThis instance is created in the viewDidLoad function through a custom init method in the GStreamerBackend \nThis custom method is required to pass the object that has to be used as the UI delegate in this case ourselves the ViewController \nThe Play and Pause buttons are also disabled in the viewDidLoad function and they are not re enabled until the GStreamerBackend reports that it is initialized and ready. \nThese two methods are called when the user presses the Play or Pause buttons and simply forward the call to the appropriate method in the GStreamerBackend. \nThe gstreamerInitialized method is defined in the GStreamerBackendDelegate protocol and indicates that the backend is ready to accept commands. In this case the Play and Pause buttons are re enabled and the Label text is set to Ready This method is called from a Dispatch Queue other than the Main one therefore the need for the dispatch_async call wrapping all UI code. \nThe gstreamerSetUIMessage method also belongs to the GStreamerBackendDelegate protocol. It is called when the backend wants to report some message to the user. In this case the message is copied onto the Label in the UI again from within a dispatch_async call. \nThe GStreamerBackend class performs all GStreamer related tasks and offers a simplified interface to the application which does not need to deal with all the GStreamer details. When it needs to perform any UI action it does so through a delegate which is expected to adhere to the GStreamerBackendDelegate protocol \nGStreamerBackend.m \nThe init method creates the instance by calling super init stores the delegate object that will handle the UI interaction and launches the app_function from a separate concurrent Dispatch Queue. The app_function monitors the GStreamer bus for messages and warns the application when interesting things happen. \ninit also registers a new GStreamer debug category and sets its threshold so we can see the debug output from within Xcode and keep track of our application progress. \nThe dealloc method takes care of bringing the pipeline to the NULL state and releasing it. \nThe play and pause methods simply try to set the pipeline to the desired state and warn the application if something fails. \nsetUIMessage turns the C strings that GStreamer uses UTF8 char into NSString and displays them through the gstreamerSetUIMessage method of the GStreamerBackendDelegate. The implementation of this method is marked as optional and hence the check for its existence in the delegate with respondsToSelector \nThe error_cb and state_changed_cb are callbacks registered to the error and state changed events in GStreamer and their goal is to inform the user about these events. These callbacks have been widely used in the Basic tutorials and their implementation is very similar except for two points \nFirstly the messages are conveyed to the user through the setUIMessage private method discussed above. \nSecondly they require an instance of a GStreamerBackend object in order to call its instance method setUIMessage which is passed through the userdata pointer of the callbacks the self pointer in these implementations This is discussed below when registering the callbacks in the app_function. \ncheck_initialization_complete verifies that all conditions are met to consider the backend ready to accept commands and tell the application if so. In this simple tutorial the only conditions are that the main loop exists and that we have not already told the application about this fact. Later more complex tutorials include additional conditions. \nFinally most of the GStreamer work is performed in the app_function. It exists with almost identical content in the Android tutorial which exemplifies how the same code can run on both platforms with little change. \nIt first creates a GLib context so all GSources are kept in the same place. This also helps cleaning after GSources created by other libraries which might not have been properly disposed of. A new context is created with g_main_context_new and then it is made the default one for the thread with g_main_context_push_thread_default \nIt then creates a pipeline the easy way with gst_parse_launch In this case it is simply an audiotestsrc which produces a continuous tone and an autoaudiosink with accompanying adapter elements. \nThese lines create a bus signal watch and connect to some interesting signals just like we have been doing in the Basic tutorials. The creation of the watch is done step by step instead of using gst_bus_add_signal_watch to exemplify how to use a custom GLib context. The interesting bit here is the usage of a __bridge cast to convert an Objective C object into a plain C pointer. In this case we do not worry much about transferal of ownership of the object because it travels through C land untouched. It re emerges at the different callbacks through the userdata pointer and cast again to a GStreamerBackend \nFinally the main loop is created and set to run. Before entering the main loop though check_initialization_complete is called. Upon exit the main loop is disposed of. \nAnd this is it This has been a rather long tutorial but we covered a lot of territory. Building on top of this one the following ones are shorter and focus only on the new topics. \nThis tutorial has shown \nMost of the methods introduced in this tutorial like check_initialization_complete and app_function and the interface methods init play pause gstreamerInitialized and setUIMessage will continue to be used in the following tutorials with minimal modifications so better get used to them \nIt has been a pleasure having you here and see you soon \n"});