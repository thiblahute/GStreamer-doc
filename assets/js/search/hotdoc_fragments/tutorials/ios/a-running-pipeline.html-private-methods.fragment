fragment_downloaded_cb({"url": "tutorials/ios/a-running-pipeline.html#private-methods", "fragment": "Private methods \nsetUIMessage turns the C strings that GStreamer uses UTF8 char into NSString and displays them through the gstreamerSetUIMessage method of the GStreamerBackendDelegate. The implementation of this method is marked as optional and hence the check for its existence in the delegate with respondsToSelector \nThe error_cb and state_changed_cb are callbacks registered to the error and state changed events in GStreamer and their goal is to inform the user about these events. These callbacks have been widely used in the Basic tutorials and their implementation is very similar except for two points \nFirstly the messages are conveyed to the user through the setUIMessage private method discussed above. \nSecondly they require an instance of a GStreamerBackend object in order to call its instance method setUIMessage which is passed through the userdata pointer of the callbacks the self pointer in these implementations This is discussed below when registering the callbacks in the app_function. \ncheck_initialization_complete verifies that all conditions are met to consider the backend ready to accept commands and tell the application if so. In this simple tutorial the only conditions are that the main loop exists and that we have not already told the application about this fact. Later more complex tutorials include additional conditions. \nFinally most of the GStreamer work is performed in the app_function. It exists with almost identical content in the Android tutorial which exemplifies how the same code can run on both platforms with little change. \nIt first creates a GLib context so all GSources are kept in the same place. This also helps cleaning after GSources created by other libraries which might not have been properly disposed of. A new context is created with g_main_context_new and then it is made the default one for the thread with g_main_context_push_thread_default \nIt then creates a pipeline the easy way with gst_parse_launch In this case it is simply an audiotestsrc which produces a continuous tone and an autoaudiosink with accompanying adapter elements. \nThese lines create a bus signal watch and connect to some interesting signals just like we have been doing in the Basic tutorials. The creation of the watch is done step by step instead of using gst_bus_add_signal_watch to exemplify how to use a custom GLib context. The interesting bit here is the usage of a __bridge cast to convert an Objective C object into a plain C pointer. In this case we do not worry much about transferal of ownership of the object because it travels through C land untouched. It re emerges at the different callbacks through the userdata pointer and cast again to a GStreamerBackend \nFinally the main loop is created and set to run. Before entering the main loop though check_initialization_complete is called. Upon exit the main loop is disposed of. \nAnd this is it This has been a rather long tutorial but we covered a lot of territory. Building on top of this one the following ones are shorter and focus only on the new topics. \n"});