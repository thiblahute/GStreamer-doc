fragment_downloaded_cb({"url": "tutorials/ios/video.html#the-gstreamer-backend", "fragment": "The GStreamer Backend \nThe GStreamerBackend class performs all GStreamer related tasks and offers a simplified interface to the application which does not need to deal with all the GStreamer details. When it needs to perform any UI action it does so through a delegate which is expected to adhere to the GStreamerBackendDelegate protocol \nGStreamerBackend.m \nThe main differences with the previous tutorial are related to the handling of the VideoOverlay interface \nThe class is expanded to keep track of the video sink element in the pipeline and the UIView onto which rendering is to occur. \nThe constructor accepts the UIView as a new parameter which at this point is simply remembered in ui_video_view. \nThen in the app_function the pipeline is constructed. This time we build a video pipeline using a simple videotestsrc element with a warptv to add some spice. The video sink is autovideosink which choses the appropriate sink for the platform currently glimagesink is the only option for iOS \nOnce the pipeline is built we set it to READY. In this state dataflow has not started yet but the caps of adjacent elements have been verified to be compatible and their pads have been linked. Also the autovideosink has already instantiated the actual video sink so we can ask for it immediately. \nThe gst_bin_get_by_interface method will examine the whole pipeline and return a pointer to an element which supports the requested interface. We are asking for the VideoOverlay interface explained in Basic tutorial GUI toolkit integration which controls how to perform rendering into foreign non GStreamer windows. The internal video sink instantiated by autovideosink is the only element in this pipeline implementing it so it will be returned. \nOnce we have the video sink we inform it of the UIView to use for rendering through the gst_video_overlay_set_window_handle method. \n"});