fragment_downloaded_cb({"url": "tutorials/basic/streaming.html#introduction", "fragment": "Introduction \nWhen streaming media chunks are decoded and queued for presentation as soon as they arrive form the network. This means that if a chunk is delayed which is not an uncommon situation at all on the Internet the presentation queue might run dry and media playback could stall. \nThe universal solution is to build a buffer this is allow a certain number of media chunks to be queued before starting playback. In this way playback start is delayed a bit but if some chunks are late reproduction is not impacted as there are more chunks in the queue waiting. \nAs it turns out this solution is already implemented in GStreamer but the previous tutorials have not been benefiting from it. Some elements like the queue2 and multiqueue found inside playbin are capable of building this buffer and post bus messages regarding the buffer level the state of the queue An application wanting to have more network resilience then should listen to these messages and pause playback if the buffer level is not high enough usually whenever it is below \nTo achieve synchronization among multiple sinks for example and audio and a video sink a global clock is used. This clock is selected by GStreamer among all elements which can provide one. Under some circumstances for example an RTP source switching streams or changing the output device this clock can be lost and a new one needs to be selected. This happens mostly when dealing with streaming so the process is explained in this tutorial. \nWhen the clock is lost the application receives a message on the bus to select a new one the application just needs to set the pipeline to PAUSED and then to PLAYING again. \n"});