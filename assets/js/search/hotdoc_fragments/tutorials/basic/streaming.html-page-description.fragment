fragment_downloaded_cb({"url": "tutorials/basic/streaming.html#page-description", "fragment": "Playing media straight from the Internet without storing it locally is known as Streaming. We have been doing it throughout the tutorials whenever we used a URI starting with http This tutorial shows a couple of additional points to keep in mind when streaming. In particular \nWhen streaming media chunks are decoded and queued for presentation as soon as they arrive form the network. This means that if a chunk is delayed which is not an uncommon situation at all on the Internet the presentation queue might run dry and media playback could stall. \nThe universal solution is to build a buffer this is allow a certain number of media chunks to be queued before starting playback. In this way playback start is delayed a bit but if some chunks are late reproduction is not impacted as there are more chunks in the queue waiting. \nAs it turns out this solution is already implemented in GStreamer but the previous tutorials have not been benefiting from it. Some elements like the queue2 and multiqueue found inside playbin are capable of building this buffer and post bus messages regarding the buffer level the state of the queue An application wanting to have more network resilience then should listen to these messages and pause playback if the buffer level is not high enough usually whenever it is below \nTo achieve synchronization among multiple sinks for example and audio and a video sink a global clock is used. This clock is selected by GStreamer among all elements which can provide one. Under some circumstances for example an RTP source switching streams or changing the output device this clock can be lost and a new one needs to be selected. This happens mostly when dealing with streaming so the process is explained in this tutorial. \nWhen the clock is lost the application receives a message on the bus to select a new one the application just needs to set the pipeline to PAUSED and then to PLAYING again. \nCopy this code into a text file named basic tutorial c. \nbasic tutorial c \nNeed help \nIf you need help to compile this code refer to the Building the tutorials section for your platform Linux Mac OS X or Windows or use this specific command on Linux \ngcc basic tutorial c o basic tutorial pkg config cflags libs gstreamer \nIf you need help to run this code refer to the Running the tutorials section for your platform Linux Mac OS X or Windows. \nThis tutorial opens a window and displays a movie with accompanying audio. The media is fetched from the Internet so the window might take a few seconds to appear depending on your connection speed. In the console window you should see a buffering message and playback should only start when the buffering reaches This percentage might not change at all if your connection is fast enough and buffering is not required. \nRequired libraries gstreamer \nThe only special thing this tutorial does is react to certain messages therefore the initialization code is very simple and should be self explanative by now. The only new bit is the detection of live streams \nLive streams cannot be paused so they behave in PAUSED state as if they were in the PLAYING state. Setting live streams to PAUSED succeeds but returns GST_STATE_CHANGE_NO_PREROLL instead of GST_STATE_CHANGE_SUCCESS to indicate that this is a live stream. We are receiving the NO_PROROLL return code even though we are trying to set the pipeline to PLAYING because state changes happen progressively from NULL to READY to PAUSED and then to PLAYING \nWe care about live streams because we want to disable buffering for them so we take note of the result of gst_element_set_state in the is_live variable. \nLet s now review the interesting parts of the message parsing callback \nFirst if this is a live source ignore buffering messages. \nWe parse the buffering message with gst_message_parse_buffering to retrieve the buffering level. \nThen we print the buffering level on the console and set the pipeline to PAUSED if it is below Otherwise we set the pipeline to PLAYING. \nAt startup we will see the buffering level rise up to before playback starts which is what we wanted to achieve. If later on the network becomes slow or unresponsive and our buffer depletes we will receive new buffering messages with levels below so we will pause the pipeline again until enough buffer has been built up. \nFor the second network issue the loss of clock we simply set the pipeline to PAUSED and back to PLAYING so a new clock is selected waiting for new media chunks to be received if necessary. \nThis tutorial has described how to add network resilience to your application with two very simple precautions \nHandling these messages improves the application s response to network problems increasing the overall playback smoothness. \nIt has been a pleasure having you here and see you soon \n"});