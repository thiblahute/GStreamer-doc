fragment_downloaded_cb({"url": "tutorials/basic/streaming.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"streaming.md\">\n        <h1 id=\"basic-tutorial-12-streaming\">Basic tutorial 12: Streaming</h1>\n<h2 id=\"goal\">Goal</h2>\n<p>Playing media straight from the Internet without storing it locally is\nknown as Streaming. We have been doing it throughout the tutorials\nwhenever we used a URI starting with <code>http://</code>. This tutorial shows a\ncouple of additional points to keep in mind when streaming. In\nparticular:</p>\n<ul>\n<li>How to enable buffering (to alleviate network problems)</li>\n<li>How to recover from interruptions (lost clock)</li>\n</ul>\n<h2 id=\"introduction\">Introduction</h2>\n<p>When streaming, media chunks are decoded and queued for presentation as\nsoon as they arrive form the network. This means that if a chunk is\ndelayed (which is not an uncommon situation at all on the Internet) the\npresentation queue might run dry and media playback could stall.</p>\n<p>The universal solution is to build a \u201cbuffer\u201d, this is, allow a certain\nnumber of media chunks to be queued before starting playback. In this\nway, playback start is delayed a bit, but, if some chunks are late,\nreproduction is not impacted as there are more chunks in the queue,\nwaiting.</p>\n<p>As it turns out, this solution is already implemented in GStreamer, but\nthe previous tutorials have not been benefiting from it. Some elements,\nlike the <code>queue2</code> and <code>multiqueue</code> found inside <code>playbin</code>, are capable\nof building this buffer and post bus messages regarding the buffer level\n(the state of the queue). An application wanting to have more network\nresilience, then, should listen to these messages and pause playback if\nthe buffer level is not high enough (usually, whenever it is below\n100%).</p>\n<p>To achieve synchronization among multiple sinks (for example and audio\nand a video sink) a global clock is used. This clock is selected by\nGStreamer among all elements which can provide one. Under some\ncircumstances, for example, an RTP source switching streams or changing\nthe output device, this clock can be lost and a new one needs to be\nselected. This happens mostly when dealing with streaming, so the\nprocess is explained in this tutorial.</p>\n<p>When the clock is lost, the application receives a message on the bus;\nto select a new one, the application just needs to set the pipeline to\nPAUSED and then to PLAYING again.</p>\n<h2 id=\"a-networkresilient-example\">A network-resilient example</h2>\n<p>Copy this code into a text file named <code>basic-tutorial-12.c</code>.</p>\n<p><strong>basic-tutorial-12.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct _CustomData {\n  gboolean is_live;\n  GstElement *pipeline;\n  GMainLoop *loop;\n} CustomData;\n\nstatic void cb_message (GstBus *bus, GstMessage *msg, CustomData *data) {\n\n  switch (GST_MESSAGE_TYPE (msg)) {\n    case GST_MESSAGE_ERROR: {\n      GError *err;\n      gchar *debug;\n\n      gst_message_parse_error (msg, &amp;err, &amp;debug);\n      g_print (\"Error: %s\\n\", err-&gt;message);\n      g_error_free (err);\n      g_free (debug);\n\n      gst_element_set_state (data-&gt;pipeline, GST_STATE_READY);\n      g_main_loop_quit (data-&gt;loop);\n      break;\n    }\n    case GST_MESSAGE_EOS:\n      /* end-of-stream */\n      gst_element_set_state (data-&gt;pipeline, GST_STATE_READY);\n      g_main_loop_quit (data-&gt;loop);\n      break;\n    case GST_MESSAGE_BUFFERING: {\n      gint percent = 0;\n\n      /* If the stream is live, we do not care about buffering. */\n      if (data-&gt;is_live) break;\n\n      gst_message_parse_buffering (msg, &amp;percent);\n      g_print (\"Buffering (%3d%%)\\r\", percent);\n      /* Wait until buffering is complete before start/resume playing */\n      if (percent &lt; 100)\n        gst_element_set_state (data-&gt;pipeline, GST_STATE_PAUSED);\n      else\n        gst_element_set_state (data-&gt;pipeline, GST_STATE_PLAYING);\n      break;\n    }\n    case GST_MESSAGE_CLOCK_LOST:\n      /* Get a new clock */\n      gst_element_set_state (data-&gt;pipeline, GST_STATE_PAUSED);\n      gst_element_set_state (data-&gt;pipeline, GST_STATE_PLAYING);\n      break;\n    default:\n      /* Unhandled message */\n      break;\n    }\n}\n\nint main(int argc, char *argv[]) {\n  GstElement *pipeline;\n  GstBus *bus;\n  GstStateChangeReturn ret;\n  GMainLoop *main_loop;\n  CustomData data;\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* Initialize our data structure */\n  memset (&amp;data, 0, sizeof (data));\n\n  /* Build the pipeline */\n  pipeline = gst_parse_launch (\"playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm\", NULL);\n  bus = gst_element_get_bus (pipeline);\n\n  /* Start playing */\n  ret = gst_element_set_state (pipeline, GST_STATE_PLAYING);\n  if (ret == GST_STATE_CHANGE_FAILURE) {\n    g_printerr (\"Unable to set the pipeline to the playing state.\\n\");\n    gst_object_unref (pipeline);\n    return -1;\n  } else if (ret == GST_STATE_CHANGE_NO_PREROLL) {\n    data.is_live = TRUE;\n  }\n\n  main_loop = g_main_loop_new (NULL, FALSE);\n  data.loop = main_loop;\n  data.pipeline = pipeline;\n\n  gst_bus_add_signal_watch (bus);\n  g_signal_connect (bus, \"message\", G_CALLBACK (cb_message), &amp;data);\n\n  g_main_loop_run (main_loop);\n\n  /* Free resources */\n  g_main_loop_unref (main_loop);\n  gst_object_unref (bus);\n  gst_element_set_state (pipeline, GST_STATE_NULL);\n  gst_object_unref (pipeline);\n  return 0;\n}\n</code></pre>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"Information\" id=\"information\">\nNeed help?</p>\n<p>If you need help to compile this code, refer to the <strong>Building the tutorials</strong>  section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Build\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Build\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Build\">Windows</a>, or use this specific command on Linux:</p>\n<p><code>gcc basic-tutorial-12.c -o basic-tutorial-12 `pkg-config --cflags --libs gstreamer-1.0`</code></p>\n<p>If you need help to run this code, refer to the <strong>Running the tutorials</strong> section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Run\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Run\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Run\">Windows</a>.</p>\n<p>This tutorial opens a window and displays a movie, with accompanying audio. The media is fetched from the Internet, so the window might take a few seconds to appear, depending on your connection speed. In the console window, you should see a buffering message, and playback should only start when the buffering reaches 100%. This percentage might not change at all if your connection is fast enough and buffering is not required.</p>\n<p>Required libraries: <code>gstreamer-1.0</code></p>\n</blockquote>\n<h2 id=\"walkthrough\">Walkthrough</h2>\n<p>The only special thing this tutorial does is react to certain messages;\ntherefore, the initialization code is very simple and should be\nself-explanative by now. The only new bit is the detection of live\nstreams:</p>\n<pre><code class=\"language-c\">/* Start playing */\nret = gst_element_set_state (pipeline, GST_STATE_PLAYING);\nif (ret == GST_STATE_CHANGE_FAILURE) {\n  g_printerr (\"Unable to set the pipeline to the playing state.\\n\");\n  gst_object_unref (pipeline);\n  return -1;\n} else if (ret == GST_STATE_CHANGE_NO_PREROLL) {\n  data.is_live = TRUE;\n}\n</code></pre>\n<p>Live streams cannot be paused, so they behave in PAUSED state as if they\nwere in the PLAYING state. Setting live streams to PAUSED succeeds, but\nreturns <code>GST_STATE_CHANGE_NO_PREROLL</code>, instead of\n<code>GST_STATE_CHANGE_SUCCESS</code> to indicate that this is a live stream. We\nare receiving the NO_PROROLL return code even though we are trying to\nset the pipeline to PLAYING, because state changes happen progressively\n(from NULL to READY, to PAUSED and then to PLAYING).</p>\n<p>We care about live streams because we want to disable buffering for\nthem, so we take note of the result of <code>gst_element_set_state()</code> in the\n<code>is_live</code> variable.</p>\n<p>Let\u2019s now review the interesting parts of the message parsing callback:</p>\n<pre><code class=\"language-c\">case GST_MESSAGE_BUFFERING: {\n  gint percent = 0;\n\n  /* If the stream is live, we do not care about buffering. */\n  if (data-&gt;is_live) break;\n\n  gst_message_parse_buffering (msg, &amp;percent);\n  g_print (\"Buffering (%3d%%)\\r\", percent);\n  /* Wait until buffering is complete before start/resume playing */\n  if (percent &lt; 100)\n    gst_element_set_state (data-&gt;pipeline, GST_STATE_PAUSED);\n  else\n    gst_element_set_state (data-&gt;pipeline, GST_STATE_PLAYING);\n  break;\n}\n</code></pre>\n<p>First, if this is a live source, ignore buffering messages.</p>\n<p>We parse the buffering message with <code>gst_message_parse_buffering()</code> to\nretrieve the buffering level.</p>\n<p>Then, we print the buffering level on the console and set the pipeline\nto PAUSED if it is below 100%. Otherwise, we set the pipeline to\nPLAYING.</p>\n<p>At startup, we will see the buffering level rise up to 100% before\nplayback starts, which is what we wanted to achieve. If, later on, the\nnetwork becomes slow or unresponsive and our buffer depletes, we will\nreceive new buffering messages with levels below 100% so we will pause\nthe pipeline again until enough buffer has been built up.</p>\n<pre><code class=\"language-c\">case GST_MESSAGE_CLOCK_LOST:\n  /* Get a new clock */\n  gst_element_set_state (data-&gt;pipeline, GST_STATE_PAUSED);\n  gst_element_set_state (data-&gt;pipeline, GST_STATE_PLAYING);\n  break;\n</code></pre>\n<p>For the second network issue, the loss of clock, we simply set the\npipeline to PAUSED and back to PLAYING, so a new clock is selected,\nwaiting for new media chunks to be received if necessary.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial has described how to add network resilience to your\napplication with two very simple precautions:</p>\n<ul>\n<li>Taking care of buffering messages sent by the pipeline</li>\n<li>Taking care of clock loss</li>\n</ul>\n<p>Handling these messages improves the application\u2019s response to network\nproblems, increasing the overall playback smoothness.</p>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n        \n\n    </div>\n\n\n        "});