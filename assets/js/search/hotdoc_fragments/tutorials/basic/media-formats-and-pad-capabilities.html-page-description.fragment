fragment_downloaded_cb({"url": "tutorials/basic/media-formats-and-pad-capabilities.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"media-formats-and-pad-capabilities.md\">\n<h1 id=\"basic-tutorial-6-media-formats-and-pad-capabilities\">Basic tutorial 6: Media formats and Pad Capabilities</h1>\n<h2 id=\"goal\">Goal</h2>\n<p>Pad Capabilities are a fundamental element of GStreamer, although most\nof the time they are invisible because the framework handles them\nautomatically. This somewhat theoretical tutorial shows:</p>\n<ul>\n<li>\n<p>What are Pad Capabilities.</p>\n</li>\n<li>\n<p>How to retrieve them.</p>\n</li>\n<li>\n<p>When to retrieve them.</p>\n</li>\n<li>\n<p>Why you need to know about them.</p>\n</li>\n</ul>\n<h2 id=\"introduction\">Introduction</h2>\n<h3 id=\"pads\">Pads</h3>\n<p>As it has already been shown, Pads allow information to enter and leave\nan element. The <em>Capabilities</em> (or <em>Caps</em>, for short) of a Pad, then,\nspecify what kind of information can travel through the Pad. For\nexample, \u201cRGB video with a resolution of 320x200 pixels and 30 frames\nper second\u201d, or \u201c16-bits per sample audio, 5.1 channels at 44100 samples\nper second\u201d, or even compressed formats like mp3 or h264.</p>\n<p>Pads can support multiple Capabilities (for example, a video sink can\nsupport video in different types of RGB or YUV formats) and Capabilities can be\nspecified as <em>ranges</em> (for example, an audio sink can support samples\nrates from 1 to 48000 samples per second). However, the actual\ninformation traveling from Pad to Pad must have only one well-specified\ntype. Through a process known as <em>negotiation</em>, two linked Pads agree on\na common type, and thus the Capabilities of the Pads become <em>fixed</em>\n(they only have one type and do not contain ranges). The walkthrough of\nthe sample code below should make all this clear.</p>\n<p><strong>In order for two elements to be linked together, they must share a\ncommon subset of Capabilities</strong> (Otherwise they could not possibly\nunderstand each other). This is the main goal of Capabilities.</p>\n<p>As an application developer, you will usually build pipelines by linking\nelements together (to a lesser extent if you use all-in-all elements\nlike <code>playbin</code>). In this case, you need to know the <em>Pad Caps</em> (as they\nare familiarly referred to) of your elements, or, at least, know what\nthey are when GStreamer refuses to link two elements with a negotiation\nerror.</p>\n<h3 id=\"pad-templates\">Pad templates</h3>\n<p>Pads are created from <em>Pad Templates</em>, which indicate all possible\nCapabilities a Pad could ever have. Templates are useful to create several\nsimilar Pads, and also allow early refusal of connections between\nelements: If the Capabilities of their Pad Templates do not have a\ncommon subset (their <em>intersection</em> is empty), there is no need to\nnegotiate further.</p>\n<p>Pad Templates can be viewed as the first step in the negotiation\nprocess. As the process evolves, actual Pads are instantiated and their\nCapabilities refined until they are fixed (or negotiation fails).</p>\n<h3 id=\"capabilities-examples\">Capabilities examples</h3>\n<pre><code>SINK template: 'sink'\n  Availability: Always\n  Capabilities:\n    audio/x-raw\n               format: S16LE\n                 rate: [ 1, 2147483647 ]\n             channels: [ 1, 2 ]\n    audio/x-raw\n               format: U8\n                 rate: [ 1, 2147483647 ]\n             channels: [ 1, 2 ]\n</code></pre>\n<p>This pad is a sink which is always available on the element (we will not\ntalk about availability for now). It supports two kinds of media, both\nraw audio in integer format (<code>audio/x-raw</code>): signed, 16-bit little endian and\nunsigned 8-bit. The square brackets indicate a range: for instance, the\nnumber of channels varies from 1 to 2.</p>\n<pre><code>SRC template: 'src'\n  Availability: Always\n  Capabilities:\n    video/x-raw\n                width: [ 1, 2147483647 ]\n               height: [ 1, 2147483647 ]\n            framerate: [ 0/1, 2147483647/1 ]\n               format: { I420, NV12, NV21, YV12, YUY2, Y42B, Y444, YUV9, YVU9, Y41B, Y800, Y8, GREY, Y16 , UYVY, YVYU, IYU1, v308, AYUV, A420 }\n</code></pre>\n<p><code>video/x-raw</code> indicates that this source pad outputs raw video. It\nsupports a wide range of dimensions and framerates, and a set of YUV\nformats (The curly braces indicate a <em>list</em>). All these formats\nindicate different packing and subsampling of the image planes.</p>\n<h3 id=\"last-remarks\">Last remarks</h3>\n<p>You can use the <code>gst-inspect-1.0</code> tool described in <a href=\"gstreamer-tools.html\">Basic tutorial 10:\nGStreamer tools</a> to\nlearn about the Caps of any GStreamer element.</p>\n<p>Bear in mind that some elements query the underlying hardware for\nsupported formats and offer their Pad Caps accordingly (They usually do\nthis when entering the READY state or higher). Therefore, the shown caps\ncan vary from platform to platform, or even from one execution to the\nnext (even though this case is rare).</p>\n<p>This tutorial instantiates two elements (this time, through their\nfactories), shows their Pad Templates, links them and sets the pipeline\nto play. On each state change, the Capabilities of the sink element's\nPad are shown, so you can observe how the negotiation proceeds until the\nPad Caps are fixed.</p>\n<h2 id=\"a-trivial-pad-capabilities-example\">A trivial Pad Capabilities Example</h2>\n<p>Copy this code into a text file named <code>basic-tutorial-6.c</code> (or find it\nin the SDK installation).</p>\n<p><strong>basic-tutorial-6.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\n/* Functions below print the Capabilities in a human-friendly format */\nstatic gboolean print_field (GQuark field, const GValue * value, gpointer pfx) {\n  gchar *str = gst_value_serialize (value);\n\n  g_print (\"%s  %15s: %s\\n\", (gchar *) pfx, g_quark_to_string (field), str);\n  g_free (str);\n  return TRUE;\n}\n\nstatic void print_caps (const GstCaps * caps, const gchar * pfx) {\n  guint i;\n\n  g_return_if_fail (caps != NULL);\n\n  if (gst_caps_is_any (caps)) {\n    g_print (\"%sANY\\n\", pfx);\n    return;\n  }\n  if (gst_caps_is_empty (caps)) {\n    g_print (\"%sEMPTY\\n\", pfx);\n    return;\n  }\n\n  for (i = 0; i &lt; gst_caps_get_size (caps); i++) {\n    GstStructure *structure = gst_caps_get_structure (caps, i);\n\n    g_print (\"%s%s\\n\", pfx, gst_structure_get_name (structure));\n    gst_structure_foreach (structure, print_field, (gpointer) pfx);\n  }\n}\n\n/* Prints information about a Pad Template, including its Capabilities */\nstatic void print_pad_templates_information (GstElementFactory * factory) {\n  const GList *pads;\n  GstStaticPadTemplate *padtemplate;\n\n  g_print (\"Pad Templates for %s:\\n\", gst_element_factory_get_longname (factory));\n  if (!gst_element_factory_get_num_pad_templates (factory)) {\n    g_print (\"  none\\n\");\n    return;\n  }\n\n  pads = gst_element_factory_get_static_pad_templates (factory);\n  while (pads) {\n    padtemplate = pads-&gt;data\n    pads = g_list_next (pads);\n\n    if (padtemplate-&gt;direction == GST_PAD_SRC)\n      g_print (\"  SRC template: '%s'\\n\", padtemplate-&gt;name_template);\n    else if (padtemplate-&gt;direction == GST_PAD_SINK)\n      g_print (\"  SINK template: '%s'\\n\", padtemplate-&gt;name_template);\n    else\n      g_print (\"  UNKNOWN!!! template: '%s'\\n\", padtemplate-&gt;name_template);\n\n    if (padtemplate-&gt;presence == GST_PAD_ALWAYS)\n      g_print (\"    Availability: Always\\n\");\n    else if (padtemplate-&gt;presence == GST_PAD_SOMETIMES)\n      g_print (\"    Availability: Sometimes\\n\");\n    else if (padtemplate-&gt;presence == GST_PAD_REQUEST) {\n      g_print (\"    Availability: On request\\n\");\n    } else\n      g_print (\"    Availability: UNKNOWN!!!\\n\");\n\n    if (padtemplate-&gt;static_caps.string) {\n      GstCaps *caps;\n      g_print (\"    Capabilities:\\n\");\n      caps = gst_static_caps_get (&amp;padtemplate-&gt;static_caps);\n      print_caps (caps, \"      \");\n      gst_caps_unref (caps);\n\n    }\n\n    g_print (\"\\n\");\n  }\n}\n\n/* Shows the CURRENT capabilities of the requested pad in the given element */\nstatic void print_pad_capabilities (GstElement *element, gchar *pad_name) {\n  GstPad *pad = NULL;\n  GstCaps *caps = NULL;\n\n  /* Retrieve pad */\n  pad = gst_element_get_static_pad (element, pad_name);\n  if (!pad) {\n    g_printerr (\"Could not retrieve pad '%s'\\n\", pad_name);\n    return;\n  }\n\n  /* Retrieve negotiated caps (or acceptable caps if negotiation is not finished yet) */\n  caps = gst_pad_get_current_caps (pad);\n  if (!caps)\n    caps = gst_pad_query_caps (pad, NULL);\n\n  /* Print and free */\n  g_print (\"Caps for the %s pad:\\n\", pad_name);\n  print_caps (caps, \"      \");\n  gst_caps_unref (caps);\n  gst_object_unref (pad);\n}\n\nint main(int argc, char *argv[]) {\n  GstElement *pipeline, *source, *sink;\n  GstElementFactory *source_factory, *sink_factory;\n  GstBus *bus;\n  GstMessage *msg;\n  GstStateChangeReturn ret;\n  gboolean terminate = FALSE;\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* Create the element factories */\n  source_factory = gst_element_factory_find (\"audiotestsrc\");\n  sink_factory = gst_element_factory_find (\"autoaudiosink\");\n  if (!source_factory || !sink_factory) {\n    g_printerr (\"Not all element factories could be created.\\n\");\n    return -1;\n  }\n\n  /* Print information about the pad templates of these factories */\n  print_pad_templates_information (source_factory);\n  print_pad_templates_information (sink_factory);\n\n  /* Ask the factories to instantiate actual elements */\n  source = gst_element_factory_create (source_factory, \"source\");\n  sink = gst_element_factory_create (sink_factory, \"sink\");\n\n  /* Create the empty pipeline */\n  pipeline = gst_pipeline_new (\"test-pipeline\");\n\n  if (!pipeline || !source || !sink) {\n    g_printerr (\"Not all elements could be created.\\n\");\n    return -1;\n  }\n\n  /* Build the pipeline */\n  gst_bin_add_many (GST_BIN (pipeline), source, sink, NULL);\n  if (gst_element_link (source, sink) != TRUE) {\n    g_printerr (\"Elements could not be linked.\\n\");\n    gst_object_unref (pipeline);\n    return -1;\n  }\n\n  /* Print initial negotiated caps (in NULL state) */\n  g_print (\"In NULL state:\\n\");\n  print_pad_capabilities (sink, \"sink\");\n\n  /* Start playing */\n  ret = gst_element_set_state (pipeline, GST_STATE_PLAYING);\n  if (ret == GST_STATE_CHANGE_FAILURE) {\n    g_printerr (\"Unable to set the pipeline to the playing state (check the bus for error messages).\\n\");\n  }\n\n  /* Wait until error, EOS or State Change */\n  bus = gst_element_get_bus (pipeline);\n  do {\n    msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS |\n        GST_MESSAGE_STATE_CHANGED);\n\n    /* Parse message */\n    if (msg != NULL) {\n      GError *err;\n      gchar *debug_info;\n\n      switch (GST_MESSAGE_TYPE (msg)) {\n        case GST_MESSAGE_ERROR:\n          gst_message_parse_error (msg, &amp;err, &amp;debug_info);\n          g_printerr (\"Error received from element %s: %s\\n\", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);\n          g_printerr (\"Debugging information: %s\\n\", debug_info ? debug_info : \"none\");\n          g_clear_error (&amp;err);\n          g_free (debug_info);\n          terminate = TRUE;\n          break;\n        case GST_MESSAGE_EOS:\n          g_print (\"End-Of-Stream reached.\\n\");\n          terminate = TRUE;\n          break;\n        case GST_MESSAGE_STATE_CHANGED:\n          /* We are only interested in state-changed messages from the pipeline */\n          if (GST_MESSAGE_SRC (msg) == GST_OBJECT (pipeline)) {\n            GstState old_state, new_state, pending_state;\n            gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);\n            g_print (\"\\nPipeline state changed from %s to %s:\\n\",\n                gst_element_state_get_name (old_state), gst_element_state_get_name (new_state));\n            /* Print the current capabilities of the sink element */\n            print_pad_capabilities (sink, \"sink\");\n          }\n          break;\n        default:\n          /* We should not reach here because we only asked for ERRORs, EOS and STATE_CHANGED */\n          g_printerr (\"Unexpected message received.\\n\");\n          break;\n      }\n      gst_message_unref (msg);\n    }\n  } while (!terminate);\n\n  /* Free resources */\n  gst_object_unref (bus);\n  gst_element_set_state (pipeline, GST_STATE_NULL);\n  gst_object_unref (pipeline);\n  gst_object_unref (source_factory);\n  gst_object_unref (sink_factory);\n  return 0;\n}\n</code></pre>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"Information\" id=\"information\">\nNeed help?</p>\n<p>If you need help to compile this code, refer to the <strong>Building the tutorials</strong>  section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Build\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Build\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Build\">Windows</a>, or use this specific command on Linux:</p>\n<p><code>gcc basic-tutorial-6.c -o basic-tutorial-6 `pkg-config --cflags --libs gstreamer-1.0`</code></p>\n<p>If you need help to run this code, refer to the <strong>Running the tutorials</strong> section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Run\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Run\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Run\">Windows</a>.</p>\n<p>This tutorial simply displays information regarding the Pad Capabilities in different time instants.</p>\n<p>Required libraries: <code>gstreamer-1.0</code></p>\n</blockquote>\n<h2 id=\"walkthrough\">Walkthrough</h2>\n<p>The <code>print_field</code>, <code>print_caps</code> and <code>print_pad_templates</code> simply\ndisplay, in a human-friendly format, the capabilities structures. If you\nwant to learn about the internal organization of the\n<code>GstCaps</code> structure, read  the <code>GStreamer Documentation</code> regarding Pad\nCaps.</p>\n<pre><code class=\"language-c\">/* Shows the CURRENT capabilities of the requested pad in the given element */\nstatic void print_pad_capabilities (GstElement *element, gchar *pad_name) {\n  GstPad *pad = NULL;\n  GstCaps *caps = NULL;\n\n  /* Retrieve pad */\n  pad = gst_element_get_static_pad (element, pad_name);\n  if (!pad) {\n    g_printerr (\"Could not retrieve pad '%s'\\n\", pad_name);\n    return;\n  }\n\n  /* Retrieve negotiated caps (or acceptable caps if negotiation is not finished yet) */\n  caps = gst_pad_get_current_caps (pad);\n  if (!caps)\n    caps = gst_pad_query_caps (pad, NULL);\n\n  /* Print and free */\n  g_print (\"Caps for the %s pad:\\n\", pad_name);\n  print_caps (caps, \"      \");\n  gst_caps_unref (caps);\n  gst_object_unref (pad);\n}\n</code></pre>\n<p><code>gst_element_get_static_pad()</code> retrieves the named Pad from the given\nelement. This Pad is <em>static</em> because it is always present in the\nelement. To know more about Pad availability read the <code>GStreamer documentation</code> about Pads.</p>\n<p>Then we call <code>gst_pad_get_current_caps()</code> to retrieve the Pad's\ncurrent Capabilities, which can be fixed or not, depending on the state\nof the negotiation process. They could even be non-existent, in which\ncase, we call <code>gst_pad_query_caps()</code> to retrieve the currently\nacceptable Pad Capabilities. The currently acceptable Caps will be the\nPad Template's Caps in the NULL state, but might change in later states,\nas the actual hardware Capabilities might be queried.</p>\n<p>We then print these Capabilities.</p>\n<pre><code class=\"language-c\">/* Create the element factories */\nsource_factory = gst_element_factory_find (\"audiotestsrc\");\nsink_factory = gst_element_factory_find (\"autoaudiosink\");\nif (!source_factory || !sink_factory) {\n  g_printerr (\"Not all element factories could be created.\\n\");\n  return -1;\n}\n\n/* Print information about the pad templates of these factories */\nprint_pad_templates_information (source_factory);\nprint_pad_templates_information (sink_factory);\n\n/* Ask the factories to instantiate actual elements */\nsource = gst_element_factory_create (source_factory, \"source\");\nsink = gst_element_factory_create (sink_factory, \"sink\");\n</code></pre>\n<p>In the previous tutorials we created the elements directly using\n<code>gst_element_factory_make()</code> and skipped talking about factories, but we\nwill do now. A <code>GstElementFactory</code> is in charge of instantiating a\nparticular type of element, identified by its factory name.</p>\n<p>You can use <code>gst_element_factory_find()</code> to create a factory of type\n\u201cvideotestsrc\u201d, and then use it to instantiate multiple \u201cvideotestsrc\u201d\nelements using <code>gst_element_factory_create()</code>.\n<code>gst_element_factory_make()</code> is really a shortcut for\n<code>gst_element_factory_find()</code>+ <code>gst_element_factory_create()</code>.</p>\n<p>The Pad Templates can already be accessed through the factories, so they\nare printed as soon as the factories are created.</p>\n<p>We skip the pipeline creation and start, and go to the State-Changed\nmessage handling:</p>\n<pre><code class=\"language-c\">case GST_MESSAGE_STATE_CHANGED:\n  /* We are only interested in state-changed messages from the pipeline */\n  if (GST_MESSAGE_SRC (msg) == GST_OBJECT (pipeline)) {\n    GstState old_state, new_state, pending_state;\n    gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);\n    g_print (\"\\nPipeline state changed from %s to %s:\\n\",\n        gst_element_state_get_name (old_state), gst_element_state_get_name (new_state));\n    /* Print the current capabilities of the sink element */\n    print_pad_capabilities (sink, \"sink\");\n  }\n  break;\n</code></pre>\n<p>This simply prints the current Pad Caps every time the state of the\npipeline changes. You should see, in the output, how the initial caps\n(the Pad Template's Caps) are progressively refined until they are\ncompletely fixed (they contain a single type with no ranges).</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial has shown:</p>\n<ul>\n<li>\n<p>What are Pad Capabilities and Pad Template Capabilities.</p>\n</li>\n<li>\n<p>How to retrieve them\nwith <code>gst_pad_get_current_caps()</code> or <code>gst_pad_query_caps()</code>.</p>\n</li>\n<li>\n<p>That they have different meaning depending on the state of the\npipeline (initially they indicate all the possible Capabilities,\nlater they indicate the currently negotiated Caps for the Pad).</p>\n</li>\n<li>\n<p>That Pad Caps are important to know beforehand if two elements can\nbe linked together.</p>\n</li>\n<li>\n<p>That Pad Caps can be found using the <code>gst-inspect-1.0</code> tool described\nin <a href=\"gstreamer-tools.html\">Basic tutorial 10: GStreamer\ntools</a>.</p>\n</li>\n</ul>\n<p>Next tutorial shows how data can be manually injected into and extracted\nfrom the GStreamer pipeline.</p>\n<p>Remember that attached to this page you should find the complete source\ncode of the tutorial and any accessory files needed to build it.\nIt has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n\t"});