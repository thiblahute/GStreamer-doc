fragment_downloaded_cb({"url": "tutorials/basic/media-formats-and-pad-capabilities.html#page-description", "fragment": "Pad Capabilities are a fundamental element of GStreamer although most of the time they are invisible because the framework handles them automatically. This somewhat theoretical tutorial shows \nWhat are Pad Capabilities. \nHow to retrieve them. \nWhen to retrieve them. \nWhy you need to know about them. \nAs it has already been shown Pads allow information to enter and leave an element. The Capabilities or Caps for short of a Pad then specify what kind of information can travel through the Pad. For example RGB video with a resolution of x200 pixels and frames per second or bits per sample audio channels at samples per second or even compressed formats like mp3 or h264. \nPads can support multiple Capabilities for example a video sink can support video in different types of RGB or YUV formats and Capabilities can be specified as ranges for example an audio sink can support samples rates from to samples per second However the actual information traveling from Pad to Pad must have only one well specified type. Through a process known as negotiation two linked Pads agree on a common type and thus the Capabilities of the Pads become fixed they only have one type and do not contain ranges The walkthrough of the sample code below should make all this clear. \nIn order for two elements to be linked together they must share a common subset of Capabilities Otherwise they could not possibly understand each other This is the main goal of Capabilities. \nAs an application developer you will usually build pipelines by linking elements together to a lesser extent if you use all in all elements like playbin In this case you need to know the Pad Caps as they are familiarly referred to of your elements or at least know what they are when GStreamer refuses to link two elements with a negotiation error. \nPads are created from Pad Templates which indicate all possible Capabilities a Pad could ever have. Templates are useful to create several similar Pads and also allow early refusal of connections between elements If the Capabilities of their Pad Templates do not have a common subset their intersection is empty there is no need to negotiate further. \nPad Templates can be viewed as the first step in the negotiation process. As the process evolves actual Pads are instantiated and their Capabilities refined until they are fixed or negotiation fails \nThis pad is a sink which is always available on the element we will not talk about availability for now It supports two kinds of media both raw audio in integer format audio x raw signed bit little endian and unsigned bit. The square brackets indicate a range for instance the number of channels varies from to \nvideo x raw indicates that this source pad outputs raw video. It supports a wide range of dimensions and framerates and a set of YUV formats The curly braces indicate a list All these formats indicate different packing and subsampling of the image planes. \nYou can use the gst inspect tool described in Basic tutorial GStreamer tools to learn about the Caps of any GStreamer element. \nBear in mind that some elements query the underlying hardware for supported formats and offer their Pad Caps accordingly They usually do this when entering the READY state or higher Therefore the shown caps can vary from platform to platform or even from one execution to the next even though this case is rare \nThis tutorial instantiates two elements this time through their factories shows their Pad Templates links them and sets the pipeline to play. On each state change the Capabilities of the sink element s Pad are shown so you can observe how the negotiation proceeds until the Pad Caps are fixed. \nCopy this code into a text file named basic tutorial c or find it in your GStreamer installation \nbasic tutorial c \nNeed help \nIf you need help to compile this code refer to the Building the tutorials section for your platform Linux Mac OS X or Windows or use this specific command on Linux \ngcc basic tutorial c o basic tutorial pkg config cflags libs gstreamer \nIf you need help to run this code refer to the Running the tutorials section for your platform Linux Mac OS X or Windows. \nThis tutorial simply displays information regarding the Pad Capabilities in different time instants. \nRequired libraries gstreamer \nThe print_field print_caps and print_pad_templates simply display in a human friendly format the capabilities structures. If you want to learn about the internal organization of the GstCaps structure read the GStreamer Documentation regarding Pad Caps. \ngst_element_get_static_pad retrieves the named Pad from the given element. This Pad is static because it is always present in the element. To know more about Pad availability read the GStreamer documentation about Pads. \nThen we call gst_pad_get_current_caps to retrieve the Pad s current Capabilities which can be fixed or not depending on the state of the negotiation process. They could even be non existent in which case we call gst_pad_query_caps to retrieve the currently acceptable Pad Capabilities. The currently acceptable Caps will be the Pad Template s Caps in the NULL state but might change in later states as the actual hardware Capabilities might be queried. \nWe then print these Capabilities. \nIn the previous tutorials we created the elements directly using gst_element_factory_make and skipped talking about factories but we will do now. A GstElementFactory is in charge of instantiating a particular type of element identified by its factory name. \nYou can use gst_element_factory_find to create a factory of type videotestsrc and then use it to instantiate multiple videotestsrc elements using gst_element_factory_create gst_element_factory_make is really a shortcut for gst_element_factory_find gst_element_factory_create \nThe Pad Templates can already be accessed through the factories so they are printed as soon as the factories are created. \nWe skip the pipeline creation and start and go to the State Changed message handling \nThis simply prints the current Pad Caps every time the state of the pipeline changes. You should see in the output how the initial caps the Pad Template s Caps are progressively refined until they are completely fixed they contain a single type with no ranges \nThis tutorial has shown \nWhat are Pad Capabilities and Pad Template Capabilities. \nHow to retrieve them with gst_pad_get_current_caps or gst_pad_query_caps \nThat they have different meaning depending on the state of the pipeline initially they indicate all the possible Capabilities later they indicate the currently negotiated Caps for the Pad \nThat Pad Caps are important to know beforehand if two elements can be linked together. \nThat Pad Caps can be found using the gst inspect tool described in Basic tutorial GStreamer tools. \nNext tutorial shows how data can be manually injected into and extracted from the GStreamer pipeline. \nRemember that attached to this page you should find the complete source code of the tutorial and any accessory files needed to build it. It has been a pleasure having you here and see you soon \n"});