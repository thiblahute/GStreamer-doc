fragment_downloaded_cb({"url": "tutorials/basic/time-management.html#page-description", "fragment": "This tutorial shows how to use GStreamer time related facilities. In particular \nHow to query the pipeline for information like stream position or duration. \nHow to seek jump to a different position time instant inside the stream. \nGstQuery is a mechanism that allows asking an element or pad for a piece of information. In this example we ask the pipeline if seeking is allowed some sources like live streams do not allow seeking If it is allowed then once the movie has been running for ten seconds we skip to a different position using a seek. \nIn the previous tutorials once we had the pipeline setup and running our main function just sat and waited to receive an ERROR or an EOS through the bus. Here we modify this function to periodically wake up and query the pipeline for the stream position so we can print it on screen. This is similar to what a media player would do updating the User Interface on a periodic basis. \nFinally the stream duration is queried and updated whenever it changes. \nCopy this code into a text file named basic tutorial c or find it in your GStreamer installation \nbasic tutorial c \nNeed help \nIf you need help to compile this code refer to the Building the tutorials section for your platform Linux Mac OS X or Windows or use this specific command on Linux \ngcc basic tutorial c o basic tutorial pkg config cflags libs gstreamer \nIf you need help to run this code refer to the Running the tutorials section for your platform Linux Mac OS X or Windows. \nThis tutorial opens a window and displays a movie with accompanying audio. The media is fetched from the Internet so the window might take a few seconds to appear depending on your connection speed. seconds into the movie it skips to a new position \nRequired libraries gstreamer \nWe start by defining a structure to contain all our information so we can pass it around to other functions. In particular in this example we move the message handling code to its own function handle_message because it is growing a bit too big. \nWe would then build a pipeline composed of a single element a playbin which we already saw in Basic tutorial Hello world However playbin is in itself a pipeline and in this case it is the only element in the pipeline so we use directly the playbin element. We will skip the details the URI of the clip is given to playbin via the URI property and the pipeline is set to the playing state. \nPreviously we did not provide a timeout to gst_bus_timed_pop_filtered meaning that it didn t return until a message was received. Now we use a timeout of milliseconds so if no message is received times per second the function will return with a NULL instead of a GstMessage. We are going to use this to update our UI Note that the timeout period is specified in nanoseconds so usage of the GST_SECOND or GST_MSECOND macros is highly recommended. \nIf we got a message we process it in the handle_message function next subsection otherwise \nFirst off if we are not in the PLAYING state we do not want to do anything here since most queries would fail. Otherwise it is time to refresh the screen. \nWe get here approximately times per second a good enough refresh rate for our UI. We are going to print on screen the current media position which we can learn be querying the pipeline. This involves a few steps that will be shown in the next subsection but since position and duration are common enough queries GstElement offers easier ready made alternatives \ngst_element_query_position hides the management of the query object and directly provides us with the result. \nNow is a good moment to know the length of the stream with another GstElement helper function gst_element_query_duration \nNote the usage of the GST_TIME_FORMAT and GST_TIME_ARGS macros to provide user friendly representation of GStreamer times. \nNow we perform the seek simply by calling gst_element_seek_simple on the pipeline. A lot of the intricacies of seeking are hidden in this method which is a good thing \nLet s review the parameters \nGST_FORMAT_TIME indicates that we are specifying the destination in time as opposite to bytes and other more obscure mechanisms \nThen come the GstSeekFlags let s review the most common \nGST_SEEK_FLAG_FLUSH This discards all data currently in the pipeline before doing the seek. Might pause a bit while the pipeline is refilled and the new data starts to show up but greatly increases the responsiveness of the application. If this flag is not provided stale data might be shown for a while until the new position appears at the end of the pipeline. \nGST_SEEK_FLAG_KEY_UNIT Most encoded video streams cannot seek to arbitrary positions only to certain frames called Key Frames. When this flag is used the seek will actually move to the closest key frame and start producing data straight away. If this flag is not used the pipeline will move internally to the closest key frame it has no other alternative but data will not be shown until it reaches the requested position. Not providing the flag is more accurate but might take longer to react. \nGST_SEEK_FLAG_ACCURATE Some media clips do not provide enough indexing information meaning that seeking to arbitrary positions is time consuming. In these cases GStreamer usually estimates the position to seek to and usually works just fine. If this precision is not good enough for your case you see seeks not going to the exact time you asked for then provide this flag. Be warned that it might take longer to calculate the seeking position very long on some files \nAnd finally we provide the position to seek to. Since we asked for GST_FORMAT_TIME this position is in nanoseconds so we use the GST_SECOND macro for simplicity. \nThe handle_message function processes all messages received through the pipeline s bus. ERROR and EOS handling is the same as in previous tutorials so we skip to the interesting part \nThis message is posted on the bus whenever the duration of the stream changes. Here we simply mark the current duration as invalid so it gets re queried later. \nSeeks and time queries generally only get a valid reply when in the PAUSED or PLAYING state since all elements have had a chance to receive information and configure themselves. Here we take note of whether we are in the PLAYING state or not with the playing variable. \nAlso if we have just entered the PLAYING state we do our first query. We ask the pipeline if seeking is allowed on this stream \ngst_query_new_seeking creates a new query object of the seeking type with GST_FORMAT_TIME format. This indicates that we are interested in seeking by specifying the new time to which we want to move. We could also ask for GST_FORMAT_BYTES and then seek to a particular byte position inside the source file but this is normally less useful. \nThis query object is then passed to the pipeline with gst_element_query The result is stored in the same query and can be easily retrieved with gst_query_parse_seeking It extracts a boolean indicating if seeking is allowed and the range in which seeking is possible. \nDon t forget to unref the query object when you are done with it. \nAnd that s it With this knowledge a media player can be built which periodically updates a slider based on the current stream position and allows seeking by moving the slider \nThis tutorial has shown \nHow to query the pipeline for information using GstQuery \nHow to obtain common information like position and duration using gst_element_query_position and gst_element_query_duration \nHow to seek to an arbitrary position in the stream using gst_element_seek_simple \nIn which states all these operations can be performed. \nThe next tutorial shows how to integrate GStreamer with a Graphical User Interface toolkit. \nRemember that attached to this page you should find the complete source code of the tutorial and any accessory files needed to build it. \nIt has been a pleasure having you here and see you soon \n"});