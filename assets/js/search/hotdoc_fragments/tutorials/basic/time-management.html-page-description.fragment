fragment_downloaded_cb({"url": "tutorials/basic/time-management.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"time-management.md\">\n<h1 id=\"basic-tutorial-4-time-management\">Basic tutorial 4: Time management</h1>\n<h2 id=\"goal\">Goal</h2>\n<p>This tutorial shows how to use GStreamer time-related facilities. In\nparticular:</p>\n<ul>\n<li>\n<p>How to query the pipeline for information like stream position or\nduration.</p>\n</li>\n<li>\n<p>How to seek (jump) to a different position (time instant) inside the\nstream.</p>\n</li>\n</ul>\n<h2 id=\"introduction\">Introduction</h2>\n<p><code>GstQuery</code> is a mechanism that allows asking an element or pad for a\npiece of information. In this example we ask the pipeline if seeking is\nallowed (some sources, like live streams, do not allow seeking). If it\nis allowed, then, once the movie has been running for ten seconds, we\nskip to a different position using a seek.</p>\n<p>In the previous tutorials, once we had the pipeline setup and running,\nour main function just sat and waited to receive an ERROR or an EOS\nthrough the bus. Here we modify this function to periodically wake up\nand query the pipeline for the stream position, so we can print it on\nscreen. This is similar to what a media player would do, updating the\nUser Interface on a periodic basis.</p>\n<p>Finally, the stream duration is queried and updated whenever it changes.</p>\n<h2 id=\"seeking-example\">Seeking example</h2>\n<p>Copy this code into a text file named <code>basic-tutorial-4.c</code> (or find it\nin the SDK installation).</p>\n<p><strong>basic-tutorial-4.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\n/* Structure to contain all our information, so we can pass it around */\ntypedef struct _CustomData {\n  GstElement *playbin;  /* Our one and only element */\n  gboolean playing;      /* Are we in the PLAYING state? */\n  gboolean terminate;    /* Should we terminate execution? */\n  gboolean seek_enabled; /* Is seeking enabled for this media? */\n  gboolean seek_done;    /* Have we performed the seek already? */\n  gint64 duration;       /* How long does this media last, in nanoseconds */\n} CustomData;\n\n/* Forward definition of the message processing function */\nstatic void handle_message (CustomData *data, GstMessage *msg);\n\nint main(int argc, char *argv[]) {\n  CustomData data;\n  GstBus *bus;\n  GstMessage *msg;\n  GstStateChangeReturn ret;\n\n  data.playing = FALSE;\n  data.terminate = FALSE;\n  data.seek_enabled = FALSE;\n  data.seek_done = FALSE;\n  data.duration = GST_CLOCK_TIME_NONE;\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* Create the elements */\n  data.playbin = gst_element_factory_make (\"playbin\", \"playbin\");\n\n  if (!data.playbin) {\n    g_printerr (\"Not all elements could be created.\\n\");\n    return -1;\n  }\n\n  /* Set the URI to play */\n  g_object_set (data.playbin, \"uri\", \"https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm\", NULL);\n\n  /* Start playing */\n  ret = gst_element_set_state (data.playbin, GST_STATE_PLAYING);\n  if (ret == GST_STATE_CHANGE_FAILURE) {\n    g_printerr (\"Unable to set the pipeline to the playing state.\\n\");\n    gst_object_unref (data.playbin);\n    return -1;\n  }\n\n  /* Listen to the bus */\n  bus = gst_element_get_bus (data.playbin);\n  do {\n    msg = gst_bus_timed_pop_filtered (bus, 100 * GST_MSECOND,\n        GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_ERROR | GST_MESSAGE_EOS | GST_MESSAGE_DURATION);\n\n    /* Parse message */\n    if (msg != NULL) {\n      handle_message (&amp;data, msg);\n    } else {\n      /* We got no message, this means the timeout expired */\n      if (data.playing) {\n        gint64 current = -1;\n\n        /* Query the current position of the stream */\n        if (!gst_element_query_position (data.playbin, GST_TIME_FORMAT, &amp;current)) {\n          g_printerr (\"Could not query current position.\\n\");\n        }\n\n        /* If we didn't know it yet, query the stream duration */\n        if (!GST_CLOCK_TIME_IS_VALID (data.duration)) {\n          if (!gst_element_query_duration (data.playbin, GST_TIME_FORMAT, &amp;data.duration)) {\n            g_printerr (\"Could not query current duration.\\n\");\n          }\n        }\n\n        /* Print current position and total duration */\n        g_print (\"Position %\" GST_TIME_FORMAT \" / %\" GST_TIME_FORMAT \"\\r\",\n            GST_TIME_ARGS (current), GST_TIME_ARGS (data.duration));\n\n        /* If seeking is enabled, we have not done it yet, and the time is right, seek */\n        if (data.seek_enabled &amp;&amp; !data.seek_done &amp;&amp; current &gt; 10 * GST_SECOND) {\n          g_print (\"\\nReached 10s, performing seek...\\n\");\n          gst_element_seek_simple (data.playbin, GST_FORMAT_TIME,\n              GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, 30 * GST_SECOND);\n          data.seek_done = TRUE;\n        }\n      }\n    }\n  } while (!data.terminate);\n\n  /* Free resources */\n  gst_object_unref (bus);\n  gst_element_set_state (data.playbin, GST_STATE_NULL);\n  gst_object_unref (data.playbin);\n  return 0;\n}\n\nstatic void handle_message (CustomData *data, GstMessage *msg) {\n  GError *err;\n  gchar *debug_info;\n\n  switch (GST_MESSAGE_TYPE (msg)) {\n    case GST_MESSAGE_ERROR:\n      gst_message_parse_error (msg, &amp;err, &amp;debug_info);\n      g_printerr (\"Error received from element %s: %s\\n\", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);\n      g_printerr (\"Debugging information: %s\\n\", debug_info ? debug_info : \"none\");\n      g_clear_error (&amp;err);\n      g_free (debug_info);\n      data-&gt;terminate = TRUE;\n      break;\n    case GST_MESSAGE_EOS:\n      g_print (\"End-Of-Stream reached.\\n\");\n      data-&gt;terminate = TRUE;\n      break;\n    case GST_MESSAGE_DURATION:\n      /* The duration has changed, mark the current one as invalid */\n      data-&gt;duration = GST_CLOCK_TIME_NONE;\n      break;\n    case GST_MESSAGE_STATE_CHANGED: {\n      GstState old_state, new_state, pending_state;\n      gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);\n      if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data-&gt;playbin)) {\n        g_print (\"Pipeline state changed from %s to %s:\\n\",\n            gst_element_state_get_name (old_state), gst_element_state_get_name (new_state));\n\n        /* Remember whether we are in the PLAYING state or not */\n        data-&gt;playing = (new_state == GST_STATE_PLAYING);\n\n        if (data-&gt;playing) {\n          /* We just moved to PLAYING. Check if seeking is possible */\n          GstQuery *query;\n          gint64 start, end;\n          query = gst_query_new_seeking (GST_FORMAT_TIME);\n          if (gst_element_query (data-&gt;playbin, query)) {\n            gst_query_parse_seeking (query, NULL, &amp;data-&gt;seek_enabled, &amp;start, &amp;end);\n            if (data-&gt;seek_enabled) {\n              g_print (\"Seeking is ENABLED from %\" GST_TIME_FORMAT \" to %\" GST_TIME_FORMAT \"\\n\",\n                  GST_TIME_ARGS (start), GST_TIME_ARGS (end));\n            } else {\n              g_print (\"Seeking is DISABLED for this stream.\\n\");\n            }\n          }\n          else {\n            g_printerr (\"Seeking query failed.\");\n          }\n          gst_query_unref (query);\n        }\n      }\n    } break;\n    default:\n      /* We should not reach here */\n      g_printerr (\"Unexpected message received.\\n\");\n      break;\n  }\n  gst_message_unref (msg);\n}\n</code></pre>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"Information\" id=\"information\">\nNeed help?</p>\n<p>If you need help to compile this code, refer to the <strong>Building the tutorials</strong>  section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Build\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Build\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Build\">Windows</a>, or use this specific command on Linux:</p>\n<p><code>gcc basic-tutorial-4.c -o basic-tutorial-4 `pkg-config --cflags --libs gstreamer-1.0`</code></p>\n<p>If you need help to run this code, refer to the <strong>Running the tutorials</strong> section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Run\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Run\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Run\">Windows</a>.</p>\n<p>This tutorial opens a window and displays a movie, with accompanying audio. The media is fetched from the Internet, so the window might take a few seconds to appear, depending on your connection speed. 10 seconds into the movie it skips to a new position</p>\n<p>Required libraries: <code>gstreamer-1.0</code></p>\n</blockquote>\n<h2 id=\"walkthrough\">Walkthrough</h2>\n<pre><code>/* Structure to contain all our information, so we can pass it around */\ntypedef struct _CustomData {\n  GstElement *playbin;  /* Our one and only element */\n  gboolean playing;      /* Are we in the PLAYING state? */\n  gboolean terminate;    /* Should we terminate execution? */\n  gboolean seek_enabled; /* Is seeking enabled for this media? */\n  gboolean seek_done;    /* Have we performed the seek already? */\n  gint64 duration;       /* How long does this media last, in nanoseconds */\n} CustomData;\n\n/* Forward definition of the message processing function */\nstatic void handle_message (CustomData *data, GstMessage *msg);\n</code></pre>\n<p>We start by defining a structure to contain all our information, so we\ncan pass it around to other functions. In particular, in this example we\nmove the message handling code to its own function\n<code>handle_message</code> because it is growing a bit too big.</p>\n<p>We would then build a pipeline composed of a single element, a\n<code>playbin</code>, which we already saw in <a href=\"hello-world.html\">Basic tutorial 1: Hello\nworld!</a>. However,\n<code>playbin</code> is in itself a pipeline, and in this case it is the only\nelement in the pipeline, so we use directly the <code>playbin</code> element. We\nwill skip the details: the URI of the clip is given to <code>playbin</code> via\nthe URI property and the pipeline is set to the playing state.</p>\n<pre><code>msg = gst_bus_timed_pop_filtered (bus, 100 * GST_MSECOND,\n    GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_ERROR | GST_MESSAGE_EOS | GST_MESSAGE_DURATION);\n</code></pre>\n<p>Previously we did not provide a timeout to\n<code>gst_bus_timed_pop_filtered()</code>, meaning that it didn't return until a\nmessage was received. Now we use a timeout of 100 milliseconds, so, if\nno message is received, 10 times per second the function will return\nwith a NULL instead of a <code>GstMessage</code>. We are going to use this to\nupdate our \u201cUI\u201d. Note that the timeout period is specified in\nnanoseconds, so usage of the <code>GST_SECOND</code> or <code>GST_MSECOND</code> macros is\nhighly recommended.</p>\n<p>If we got a message, we process it in the <code>handle_message``</code>function\n(next subsection), otherwise:</p>\n<h3 id=\"user-interface-resfreshing\">User interface resfreshing</h3>\n<pre><code>/* We got no message, this means the timeout expired */\nif (data.playing) {\n</code></pre>\n<p>First off, if we are not in the PLAYING state, we do not want to do\nanything here, since most queries would fail. Otherwise, it is time to\nrefresh the screen.</p>\n<p>We get here approximately 10 times per second, a good enough refresh\nrate for our UI. We are going to print on screen the current media\nposition, which we can learn be querying the pipeline. This involves a\nfew steps that will be shown in the next subsection, but, since position\nand duration are common enough queries, <code>GstElement</code> offers easier,\nready-made alternatives:</p>\n<pre><code>/* Query the current position of the stream */\nif (!gst_element_query_position (data.pipeline, GST_FORMAT_TIME, &amp;current)) {\n  g_printerr (\"Could not query current position.\\n\");\n}\n</code></pre>\n<p><code>gst_element_query_position()</code> hides the management of the query object\nand directly provides us with the result.</p>\n<pre><code>/* If we didn't know it yet, query the stream duration */\nif (!GST_CLOCK_TIME_IS_VALID (data.duration)) {\n  if (!gst_element_query_duration (data.pipeline, GST_TIME_FORMAT, &amp;data.duration)) {\n     g_printerr (\"Could not query current duration.\\n\");\n  }\n}\n</code></pre>\n<p>Now is a good moment to know the length of the stream, with\nanother <code>GstElement</code> helper function: <code>gst_element_query_duration()</code></p>\n<pre><code>/* Print current position and total duration */\ng_print (\"Position %\" GST_TIME_FORMAT \" / %\" GST_TIME_FORMAT \"\\r\",\n    GST_TIME_ARGS (current), GST_TIME_ARGS (data.duration));\n</code></pre>\n<p>Note the usage of the <code>GST_TIME_FORMAT</code> and <code>GST_TIME_ARGS</code> macros to\nprovide user-friendly representation of GStreamer\ntimes.</p>\n<pre><code>/* If seeking is enabled, we have not done it yet, and the time is right, seek */\nif (data.seek_enabled &amp;&amp; !data.seek_done &amp;&amp; current &gt; 10 * GST_SECOND) {\n  g_print (\"\\nReached 10s, performing seek...\\n\");\n  gst_element_seek_simple (data.pipeline, GST_FORMAT_TIME,\n      GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, 30 * GST_SECOND);\n  data.seek_done = TRUE;\n}\n</code></pre>\n<p>Now we perform the seek, \u201csimply\u201d by\ncalling <code>gst_element_seek_simple()</code> on the pipeline. A lot of the\nintricacies of seeking are hidden in this method, which is a good\nthing!</p>\n<p>Let's review the parameters:</p>\n<p><code>GST_FORMAT_TIME</code> indicates that we are specifying the destination in\ntime, as opposite to bytes (and other more obscure mechanisms).</p>\n<p>Then come the GstSeekFlags, let's review the most common:</p>\n<p><code>GST_SEEK_FLAG_FLUSH</code>: This discards all data currently in the pipeline\nbefore doing the seek. Might pause a bit while the pipeline is refilled\nand the new data starts to show up, but greatly increases the\n\u201cresponsiveness\u201d of the application. If this flag is not provided,\n\u201cstale\u201d data might be shown for a while until the new position appears\nat the end of the pipeline.</p>\n<p><code>GST_SEEK_FLAG_KEY_UNIT</code>: Most encoded video streams cannot seek to\narbitrary positions, only to certain frames called Key Frames. When this\nflag is used, the seek will actually move to the closest key frame and\nstart producing data straight away. If this flag is not used, the\npipeline will move internally to the closest key frame (it has no other\nalternative) but data will not be shown until it reaches the requested\nposition. Not providing the flag is more accurate, but might take longer\nto react.</p>\n<p><code>GST_SEEK_FLAG_ACCURATE</code>: Some media clips do not provide enough\nindexing information, meaning that seeking to arbitrary positions is\ntime-consuming. In these cases, GStreamer usually estimates the position\nto seek to, and usually works just fine. If this precision is not good\nenough for your case (you see seeks not going to the exact time you\nasked for), then provide this flag. Be warned that it might take longer\nto calculate the seeking position (very long, on some files).</p>\n<p>And finally we provide the position to seek to. Since we asked\nfor <code>GST_FORMAT_TIME</code> , this position is in nanoseconds, so we use\nthe <code>GST_SECOND</code> macro for simplicity.</p>\n<h3 id=\"message-pump\">Message Pump</h3>\n<p>The <code>handle_message</code> function processes all messages received through\nthe pipeline's bus. ERROR and EOS handling is the same as in previous\ntutorials, so we skip to the interesting part:</p>\n<pre><code>case GST_MESSAGE_DURATION:\n  /* The duration has changed, mark the current one as invalid */\n  data-&gt;duration = GST_CLOCK_TIME_NONE;\n  break;\n</code></pre>\n<p>This message is posted on the bus whenever the duration of the stream\nchanges. Here we simply mark the current duration as invalid, so it gets\nre-queried later.</p>\n<pre><code>case GST_MESSAGE_STATE_CHANGED: {\n  GstState old_state, new_state, pending_state;\n  gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);\n  if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data-&gt;pipeline)) {\n    g_print (\"Pipeline state changed from %s to %s:\\n\",\n        gst_element_state_get_name (old_state), gst_element_state_get_name (new_state));\n\n    /* Remember whether we are in the PLAYING state or not */\n    data-&gt;playing = (new_state == GST_STATE_PLAYING);\n</code></pre>\n<p>Seeks and time queries generally only get a valid reply when in the\nPAUSED or PLAYING state, since all elements have had a chance to\nreceive information and configure themselves. Here we take note of\nwhether we are in the PLAYING state or not with the <code>playing</code>\nvariable.</p>\n<p>Also, if we have just entered the PLAYING state, we do our first query.\nWe ask the pipeline if seeking is allowed on this stream:</p>\n<pre><code>if (data-&gt;playing) {\n  /* We just moved to PLAYING. Check if seeking is possible */\n  GstQuery *query;\n  gint64 start, end;\n  query = gst_query_new_seeking (GST_FORMAT_TIME);\n  if (gst_element_query (data-&gt;pipeline, query)) {\n    gst_query_parse_seeking (query, NULL, &amp;data-&gt;seek_enabled, &amp;start, &amp;end);\n    if (data-&gt;seek_enabled) {\n      g_print (\"Seeking is ENABLED from %\" GST_TIME_FORMAT \" to %\" GST_TIME_FORMAT \"\\n\",\n          GST_TIME_ARGS (start), GST_TIME_ARGS (end));\n    } else {\n      g_print (\"Seeking is DISABLED for this stream.\\n\");\n    }\n  }\n  else {\n    g_printerr (\"Seeking query failed.\");\n  }\n  gst_query_unref (query);\n}\n</code></pre>\n<p><code>gst_query_new_seeking()</code> creates a new query object of the \"seeking\"\ntype, with <code>GST_FORMAT_TIME</code> format. This indicates that we are\ninterested in seeking by specifying the new time to which we want to\nmove. We could also ask for <code>GST_FORMAT_BYTES</code>, and then seek to a\nparticular byte position inside the source file, but this is normally\nless useful.</p>\n<p>This query object is then passed to the pipeline with\n<code>gst_element_query()</code>. The result is stored in the same query, and can\nbe easily retrieved with <code>gst_query_parse_seeking()</code>. It extracts a\nboolean indicating if seeking is allowed, and the range in which seeking\nis possible.</p>\n<p>Don't forget to unref the query object when you are done with it.</p>\n<p>And that's it! With this knowledge a media player can be built which\nperiodically updates a slider based on the current stream position and\nallows seeking by moving the slider!</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial has shown:</p>\n<ul>\n<li>\n<p>How to query the pipeline for information using <code>GstQuery</code></p>\n</li>\n<li>\n<p>How to obtain common information like position and duration\nusing <code>gst_element_query_position()</code> and <code>gst_element_query_duration()</code></p>\n</li>\n<li>\n<p>How to seek to an arbitrary position in the stream\nusing <code>gst_element_seek_simple()</code></p>\n</li>\n<li>\n<p>In which states all these operations can be performed.</p>\n</li>\n</ul>\n<p>The next tutorial shows how to integrate GStreamer with a Graphical User\nInterface toolkit.</p>\n<p>Remember that attached to this page you should find the complete source\ncode of the tutorial and any accessory files needed to build it.</p>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n\t"});