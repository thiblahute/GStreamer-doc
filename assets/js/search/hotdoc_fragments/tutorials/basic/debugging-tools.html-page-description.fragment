fragment_downloaded_cb({"url": "tutorials/basic/debugging-tools.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"debugging-tools.md\">\n<h1 id=\"basic-tutorial-11-debugging-tools\">Basic tutorial 11: Debugging tools</h1>\n<h2 id=\"goal\">Goal</h2>\n<p>Sometimes things won\u2019t go as expected and the error messages retrieved\nfrom the bus (if any) just don\u2019t provide enough information. Luckily,\nGStreamer ships with massive amounts of debug information, which usually\nhint what the problem might be. This tutorial shows:</p>\n<ul>\n<li>\n<p>How to get more debug information from GStreamer.</p>\n</li>\n<li>\n<p>How to print your own debug information into the GStreamer log.</p>\n</li>\n<li>\n<p>How to get pipeline graphs</p>\n</li>\n</ul>\n<h2 id=\"printing-debug-information\">Printing debug information</h2>\n<h3 id=\"the-debug-log\">The debug log</h3>\n<p>GStreamer and its plugins are full of debug traces, this is, places in\nthe code where a particularly interesting piece of information is\nprinted to the console, along with time stamping, process, category,\nsource code file, function and element information.</p>\n<p>The debug output is controlled with the <code>GST_DEBUG</code> environment\nvariable. Here\u2019s an example with\n<code>GST_DEBUG=2</code>:</p>\n<pre><code>0:00:00.868050000  1592   09F62420 WARN                 filesrc gstfilesrc.c:1044:gst_file_src_start:&lt;filesrc0&gt; error: No such file \"non-existing-file.webm\"\n</code></pre>\n<p>As you can see, this is quite a bit of information. In fact, the\nGStreamer debug log is so verbose, that when fully enabled it can render\napplications unresponsive (due to the console scrolling) or fill up\nmegabytes of text files (when redirected to a file). For this reason,\nthe logs are categorized, and you seldom need to enable all categories\nat once.</p>\n<p>The first category is the Debug Level, which is a number specifying the\namount of desired output:</p>\n<table>\n<thead>\n<tr>\n<th> #</th>\n<th> Name</th>\n<th> Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> 0</td>\n<td> none</td>\n<td> No debug information is output.</td>\n</tr>\n<tr>\n<td> 1</td>\n<td> ERROR</td>\n<td> Logs all fatal errors. These are errors that do not allow the core or elements to perform the requested action. The application can still recover if programmed to handle the conditions that triggered the error.</td>\n</tr>\n<tr>\n<td> 2</td>\n<td> WARNING</td>\n<td> Logs all warnings. Typically these are non-fatal, but user-visible problems are expected to happen.</td>\n</tr>\n<tr>\n<td> 3</td>\n<td> FIXME</td>\n<td> Logs all \"fixme\" messages. Those typically that a codepath that is known to be incomplete has been triggered. It may work in most cases, but mauy cause problems in specific instances.</td>\n</tr>\n<tr>\n<td> 4</td>\n<td> INFO</td>\n<td> Logs all informational messages. These are typically used for events in the system that only happen once, or are important and rare enough to be logged at this level.</td>\n</tr>\n<tr>\n<td> 5</td>\n<td> DEBUG</td>\n<td> Logs all debug messages. These are general debug messages for events that happen only a limited number of times during an object's lifetime; these include setup, teardown, change of parameters, ...</td>\n</tr>\n<tr>\n<td> 6</td>\n<td> LOG</td>\n<td> Logs all log messages. These are messages for events that happen repeatedly during an object's lifetime; these include streaming and steady-state conditions. This is used for log messages that happen on every buffer in an element for example.</td>\n</tr>\n<tr>\n<td> 7</td>\n<td> TRACE</td>\n<td> Logs all trace messages. Those are message that happen very very often. This is for example is each each time the reference count of a GstMiniObject, such as a GstBuffer or GstEvent, is modified.</td>\n</tr>\n<tr>\n<td> 8</td>\n<td> MEMDUMP</td>\n<td> Logs all memory dump messages. This is the heaviest logging and may include dumping the content of blocks of memory.</td>\n</tr></tbody></table>\n<p>To enable debug output, set the <code>GST_DEBUG</code> environment variable to the\ndesired debug level. All levels below that will also be shown (i.e., if\nyou set <code>GST_DEBUG=2</code>, you will get both <code>ERROR</code> and\n<code>WARNING</code> messages).</p>\n<p>Furthermore, each plugin or part of the GStreamer defines its own\ncategory, so you can specify a debug level for each individual category.\nFor example, <code>GST_DEBUG=2,audiotestsrc:6</code>, will use Debug Level 6 for\nthe <code>audiotestsrc</code> element, and 2 for all the others.</p>\n<p>The <code>GST_DEBUG</code> environment variable, then, is a comma-separated list of\n<em>category</em>:<em>level</em> pairs, with an optional <em>level</em> at the beginning,\nrepresenting the default debug level for all categories.</p>\n<p>The <code>'*'</code> wildcard is also available. For example\n<code>GST_DEBUG=2,audio*:6</code> will use Debug Level 5 for all categories\nstarting with the word <code>audio</code>. <code>GST_DEBUG=*:2</code> is equivalent to\n<code>GST_DEBUG=2</code>.</p>\n<p>Use <code>gst-launch-1.0 --gst-debug-help</code> to obtain the list of all\nregistered categories. Bear in mind that each plugin registers its own\ncategories, so, when installing or removing plugins, this list can\nchange.</p>\n<p>Use <code>GST_DEBUG</code> when the error information posted on the GStreamer bus\ndoes not help you nail down a problem. It is common practice to redirect\nthe output log to a file, and then examine it later, searching for\nspecific messages.</p>\n<p>The content of each line in the debug output\nis:</p>\n<pre><code>0:00:00.868050000  1592   09F62420 WARN                 filesrc gstfilesrc.c:1044:gst_file_src_start:&lt;filesrc0&gt; error: No such file \"non-existing-file.webm\"\n</code></pre>\n<table>\n<thead>\n<tr>\n<th> Example</th>\n<th> Explained</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> <code>0:00:00.868050000</code></td>\n<td> Time stamp in HH:MM:SS.sssssssss format since the start of the program</td>\n</tr>\n<tr>\n<td> <code>1592</code></td>\n<td> Process ID from which the message was issued. Useful when your problem involves multiple processes</td>\n</tr>\n<tr>\n<td> <code>09F62420</code></td>\n<td> Thread ID from which the message was issued. Useful when your problem involves multiple threads</td>\n</tr>\n<tr>\n<td> <code>WARN</code></td>\n<td> Debug level of the message</td>\n</tr>\n<tr>\n<td> <code>filesrc</code></td>\n<td> Debug Category of the message</td>\n</tr>\n<tr>\n<td> <code>gstfilesrc.c:1044</code></td>\n<td> Source file and line in the GStreamer source code where this message is printed</td>\n</tr>\n<tr>\n<td> <code>gst_file_src_start</code></td>\n<td> Function from which the message was issued</td>\n</tr>\n<tr>\n<td> <code>&amp;lt;filesrc0&amp;gt;</code></td>\n<td> Name of the object that issued the message. It can be an element, a Pad, or something else. Useful when you have multiple elements of the same kind and need to distinguish among them. Naming your elements with the name property will make this debug output more readable (otherwise, GStreamer assigns each new element a unique name).</td>\n</tr>\n<tr>\n<td> <code>error: No such file &amp;quot;non-existing-file.webm&amp;quot;</code></td>\n<td> The actual message.</td>\n</tr></tbody></table>\n<h3 id=\"adding-your-own-debug-information\">Adding your own debug information</h3>\n<p>In the parts of your code that interact with GStreamer, it is\ninteresting to use GStreamer\u2019s debugging facilities. In this way, you\nhave all debug output in the same file and the temporal relationship\nbetween different messages is preserved.</p>\n<p>To do so, use the <code>GST_ERROR()</code>, <code>GST_WARNING()</code>, <code>GST_INFO()</code>,\n<code>GST_LOG()</code> and <code>GST_DEBUG()</code> macros. They accept the same parameters as\n<code>printf</code>, and they use the <code>default</code> category (<code>default</code> will be shown\nas the Debug category in the output log).</p>\n<p>To change the category to something more meaningful, add these two lines\nat the top of your code:</p>\n<pre><code class=\"language-c\">GST_DEBUG_CATEGORY_STATIC (my_category);\n#define GST_CAT_DEFAULT my_category\n</code></pre>\n<p>And then this one after you have initialized GStreamer with\n<code>gst_init()</code>:</p>\n<pre><code class=\"language-c\">GST_DEBUG_CATEGORY_INIT (my_category, \"my category\", 0, \"This is my very own\");\n</code></pre>\n<p>This registers a new category (this is, for the duration of your\napplication: it is not stored in any file), and sets it as the default\ncategory for your code. See the documentation\nfor <code>GST_DEBUG_CATEGORY_INIT()</code>.</p>\n<h3 id=\"getting-pipeline-graphs\">Getting pipeline graphs</h3>\n<p>For those cases where your pipeline starts to grow too large and you\nlose track of what is connected with what, GStreamer has the capability\nto output graph files. These are <code>.dot</code> files, readable with free\nprograms like <a href=\"http://www.graphviz.org\">GraphViz</a>, that describe the\ntopology of your pipeline, along with the caps negotiated in each link.</p>\n<p>This is also very handy when using all-in-one elements like <code>playbin</code>\nor <code>uridecodebin</code>, which instantiate several elements inside them. Use\nthe <code>.dot</code> files to learn what pipeline they have created inside (and\nlearn a bit of GStreamer along the way).</p>\n<p>To obtain <code>.dot</code> files, simply set\nthe <code>GST_DEBUG_DUMP_DOT_DIR</code> environment variable to point to the\nfolder where you want the files to be placed. <code>gst-launch-1.0</code> will create\na <code>.dot</code> file at each state change, so you can see the evolution of the\ncaps negotiation. Unset the variable to disable this facility. From\nwithin your application, you can use the\n<code>GST_DEBUG_BIN_TO_DOT_FILE()</code> and\n<code>GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS()</code> macros to generate <code>.dot</code> files\nat your convenience.</p>\n<p>Here you have an example of the kind of pipelines that playbin\ngenerates. It is very complex because <code>playbin</code> can handle many\ndifferent cases: Your manual pipelines normally do not need to be this\nlong. If your manual pipeline is starting to get very big, consider\nusing <code>playbin</code>.</p>\n<p><img src=\"images/playbin.png\" alt=\"\"></p>\n<p>To download the full-size picture, use the attachments link at the top\nof this page (It's the paperclip icon).</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial has shown:</p>\n<ul>\n<li>How to get more debug information from GStreamer using the\n<code>GST_DEBUG</code> environment variable.</li>\n<li>How to print your own debug information into the GStreamer log with\nthe <code>GST_ERROR()</code> macro and relatives.</li>\n<li>How to get pipeline graphs with the\n<code>GST_DEBUG_DUMP_DOT_DIR</code> environment variable.</li>\n</ul>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n\t"});