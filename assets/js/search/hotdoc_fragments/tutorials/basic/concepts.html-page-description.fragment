fragment_downloaded_cb({"url": "tutorials/basic/concepts.html#page-description", "fragment": "The previous tutorial showed how to build a pipeline automatically. Now we are going to build a pipeline manually by instantiating each element and linking them all together. In the process we will learn \nWhat is a GStreamer element and how to create one. \nHow to connect elements to each other. \nHow to customize an element s behavior. \nHow to watch the bus for error conditions and extract information from GStreamer messages. \nCopy this code into a text file named basic tutorial c or find it in your GStreamer installation \nbasic tutorial c \nNeed help \nIf you need help to compile this code refer to the Building the tutorials section for your platform Linux Mac OS X or Windows or use this specific command on Linux \ngcc basic tutorial c o basic tutorial pkg config cflags libs gstreamer \nIf you need help to run this code refer to the Running the tutorials section for your platform Linux Mac OS X or Windows. \nThis tutorial opens a window and displays a test pattern without audio \nRequired libraries gstreamer \nThe elements are GStreamer s basic construction blocks. They process the data as it flows downstream from the source elements data producers to the sink elements data consumers passing through filter elements. \n\nFigure Example pipeline \nWe will skip GStreamer initialization since it is the same as the previous tutorial \nAs seen in this code new elements can be created with gst_element_factory_make The first parameter is the type of element to create Basic tutorial Handy elements shows a few common types and Basic tutorial GStreamer tools shows how to obtain the list of all available types The second parameter is the name we want to give to this particular instance. Naming your elements is useful to retrieve them later if you didn t keep a pointer and for more meaningful debug output If you pass NULL for the name however GStreamer will provide a unique name for you. \nFor this tutorial we create two elements a videotestsrc and an autovideosink. \nvideotestsrc is a source element it produces data which creates a test video pattern. This element is useful for debugging purposes and tutorials and is not usually found in real applications. \nautovideosink is a sink element it consumes data which displays on a window the images it receives. There exist several video sinks depending on the operating system with a varying range of capabilities. autovideosink automatically selects and instantiates the best one so you do not have to worry with the details and your code is more platform independent. \nAll elements in GStreamer must typically be contained inside a pipeline before they can be used because it takes care of some clocking and messaging functions. We create the pipeline with gst_pipeline_new \nA pipeline is a particular type of bin which is the element used to contain other elements. Therefore all methods which apply to bins also apply to pipelines. In our case we call gst_bin_add_many to add the elements to the pipeline mind the cast This function accepts a list of elements to be added ending with NULL. Individual elements can be added with gst_bin_add \nThese elements however are not linked with each other yet. For this we need to use gst_element_link Its first parameter is the source and the second one the destination. The order counts because links must be established following the data flow this is from source elements to sink elements Keep in mind that only elements residing in the same bin can be linked together so remember to add them to the pipeline before trying to link them \nMost GStreamer elements have customizable properties named attributes that can be modified to change the element s behavior writable properties or inquired to find out about the element s internal state readable properties \nProperties are read from with g_object_get and written to with g_object_set \ng_object_set accepts a NULL terminated list of property name property value pairs so multiple properties can be changed in one go. \nGStreamer elements are all a particular kind of GObject which is the entity offering property facilities. This is why the property handling methods have the g_ prefix. \nThe line of code above changes the pattern property of videotestsrc which controls the type of test video the element outputs. Try different values \nThe names and possible values of all the properties an element exposes can be found using the gst inspect tool described in Basic tutorial GStreamer tools. \nAt this point we have the whole pipeline built and setup and the rest of the tutorial is very similar to the previous one but we are going to add more error checking \nWe call gst_element_set_state but this time we check its return value for errors. Changing states is a delicate process and a few more details are given in Basic tutorial Dynamic pipelines. \ngst_bus_timed_pop_filtered waits for execution to end and returns with a GstMessage which we previously ignored. We asked gst_bus_timed_pop_filtered to return when GStreamer encountered either an error condition or an EOS so we need to check which one happened and print a message on screen Your application will probably want to undertake more complex actions \nGstMessage is a very versatile structure which can deliver virtually any kind of information. Fortunately GStreamer provides a series of parsing functions for each kind of message. \nIn this case once we know the message contains an error by using the GST_MESSAGE_TYPE macro we can use gst_message_parse_error which returns a GLib GError error structure and a string useful for debugging. Examine the code to see how these are used and freed afterward. \nAt this point it is worth introducing the GStreamer bus a bit more formally. It is the object responsible for delivering to the application the GstMessages generated by the elements in order and to the application thread. This last point is important because the actual streaming of media is done in another thread than the application. \nMessages can be extracted from the bus synchronously with gst_bus_timed_pop_filtered and its siblings or asynchronously using signals shown in the next tutorial Your application should always keep an eye on the bus to be notified of errors and other playback related issues. \nThe rest of the code is the cleanup sequence which is the same as in Basic tutorial Hello world \nIf you feel like practicing try this exercise Add a video filter element in between the source and the sink of this pipeline. Use vertigotv for a nice effect. You will need to create it add it to the pipeline and link it with the other elements. \nDepending on your platform and available plugins you might get a negotiation error because the sink does not understand what the filter is producing more about negotiation in Basic tutorial Media formats and Pad Capabilities In this case try to add an element called videoconvert after the filter this is build a pipeline of elements. More on videoconvert in Basic tutorial Handy elements \nThis tutorial showed \nHow to create elements with gst_element_factory_make \nHow to create an empty pipeline with gst_pipeline_new \nHow to add elements to the pipeline with gst_bin_add_many \nHow to link the elements with each other with gst_element_link \nThis concludes the first of the two tutorials devoted to basic GStreamer concepts. The second one comes next. \nRemember that attached to this page you should find the complete source code of the tutorial and any accessory files needed to build it. \nIt has been a pleasure having you here and see you soon \n"});