fragment_downloaded_cb({"url": "tutorials/basic/concepts.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"concepts.md\">\n<h1 id=\"basic-tutorial-2-gstreamer-concepts\">Basic tutorial 2: GStreamer concepts</h1>\n<h2 id=\"goal\">Goal</h2>\n<p>The previous tutorial showed how to build a pipeline automatically. Now\nwe are going to build a pipeline manually by instantiating each element\nand linking them all together. In the process, we will learn:</p>\n<ul>\n<li>\n<p>What is a GStreamer element and how to create one.</p>\n</li>\n<li>\n<p>How to connect elements to each other.</p>\n</li>\n<li>\n<p>How to customize an element's behavior.</p>\n</li>\n<li>\n<p>How to watch the bus for error conditions and extract information\nfrom GStreamer messages.</p>\n</li>\n</ul>\n<h2 id=\"manual-hello-world\">Manual Hello World</h2>\n<p>Copy this code into a text file named <code>basic-tutorial-2.c</code> (or find it\nin the SDK installation).</p>\n<p><strong>basic-tutorial-2.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\nint main(int argc, char *argv[]) {\n  GstElement *pipeline, *source, *sink;\n  GstBus *bus;\n  GstMessage *msg;\n  GstStateChangeReturn ret;\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* Create the elements */\n  source = gst_element_factory_make (\"videotestsrc\", \"source\");\n  sink = gst_element_factory_make (\"autovideosink\", \"sink\");\n\n  /* Create the empty pipeline */\n  pipeline = gst_pipeline_new (\"test-pipeline\");\n\n  if (!pipeline || !source || !sink) {\n    g_printerr (\"Not all elements could be created.\\n\");\n    return -1;\n  }\n\n  /* Build the pipeline */\n  gst_bin_add_many (GST_BIN (pipeline), source, sink, NULL);\n  if (gst_element_link (source, sink) != TRUE) {\n    g_printerr (\"Elements could not be linked.\\n\");\n    gst_object_unref (pipeline);\n    return -1;\n  }\n\n  /* Modify the source's properties */\n  g_object_set (source, \"pattern\", 0, NULL);\n\n  /* Start playing */\n  ret = gst_element_set_state (pipeline, GST_STATE_PLAYING);\n  if (ret == GST_STATE_CHANGE_FAILURE) {\n    g_printerr (\"Unable to set the pipeline to the playing state.\\n\");\n    gst_object_unref (pipeline);\n    return -1;\n  }\n\n  /* Wait until error or EOS */\n  bus = gst_element_get_bus (pipeline);\n  msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS);\n\n  /* Parse message */\n  if (msg != NULL) {\n    GError *err;\n    gchar *debug_info;\n\n    switch (GST_MESSAGE_TYPE (msg)) {\n      case GST_MESSAGE_ERROR:\n        gst_message_parse_error (msg, &amp;err, &amp;debug_info);\n        g_printerr (\"Error received from element %s: %s\\n\", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);\n        g_printerr (\"Debugging information: %s\\n\", debug_info ? debug_info : \"none\");\n        g_clear_error (&amp;err);\n        g_free (debug_info);\n        break;\n      case GST_MESSAGE_EOS:\n        g_print (\"End-Of-Stream reached.\\n\");\n        break;\n      default:\n        /* We should not reach here because we only asked for ERRORs and EOS */\n        g_printerr (\"Unexpected message received.\\n\");\n        break;\n    }\n    gst_message_unref (msg);\n  }\n\n  /* Free resources */\n  gst_object_unref (bus);\n  gst_element_set_state (pipeline, GST_STATE_NULL);\n  gst_object_unref (pipeline);\n  return 0;\n}\n</code></pre>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"Information\" id=\"information\">\nNeed help?</p>\n<p>If you need help to compile this code, refer to the <strong>Building the tutorials</strong>  section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Build\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Build\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Build\">Windows</a>, or use this specific command on Linux:</p>\n<p><code>gcc basic-tutorial-2.c -o basic-tutorial-2 `pkg-config --cflags --libs gstreamer-1.0`</code></p>\n<p>If you need help to run this code, refer to the <strong>Running the tutorials</strong> section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Run\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Run\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Run\">Windows</a>.</p>\n<p>This tutorial opens a window and displays a test pattern, without audio</p>\n<p>Required libraries: <code>gstreamer-1.0</code></p>\n</blockquote>\n<h2 id=\"walkthrough\">Walkthrough</h2>\n<p>The basic construction block of GStreamer are the elements, which\nprocess the data as it flows <em>downstream</em> from the source elements (the\nproducers of data) to the sink elements (the consumers of data), passing\nthrough filter elements.</p>\n<p><img src=\"images/figure-1.png\" alt=\"\"></p>\n<p><strong>Figure 1</strong>. Example pipeline</p>\n<h3 id=\"element-creation\">Element creation</h3>\n<p>We will skip GStreamer initialization, since it is the same as the\nprevious tutorial:</p>\n<pre><code class=\"language-c\">/* Create the elements */\nsource = gst_element_factory_make (\"videotestsrc\", \"source\");\nsink = gst_element_factory_make (\"autovideosink\", \"sink\");\n</code></pre>\n<p>As seen in this code, new elements can be created\nwith <code>gst_element_factory_make()</code>. The first parameter is the type of\nelement to create (<a href=\"handy-elements.html\">Basic tutorial 14: Handy\nelements</a> shows a\nfew common types, and <a href=\"gstreamer-tools.html\">Basic tutorial 10: GStreamer\ntools</a> shows how to\nobtain the list of all available types). The second parameter is the\nname we want to give to this particular instance. Naming your elements\nis useful to retrieve them later if you didn't keep a pointer (and for\nmore meaningful debug output). If you pass NULL for the name, however,\nGStreamer will provide a unique name for you.</p>\n<p>For this tutorial we create two elements: a <code>videotestsrc</code> and\nan <code>autovideosink</code>.</p>\n<p><code>videotestsrc</code> is a source element (it produces data), which creates a\ntest video pattern. This element is useful for debugging purposes (and\ntutorials) and is not usually found in real applications.</p>\n<p><code>autovideosink</code> is a sink element (it consumes data), which displays on\na window the images it receives. There exist several video sinks,\ndepending on the operating system, with a varying range of capabilities.\n<code>autovideosink</code> automatically selects and instantiates the best one, so\nyou do not have to worry with the details, and your code is more\nplatform-independent.</p>\n<h3 id=\"pipeline-creation\">Pipeline creation</h3>\n<pre><code class=\"language-c\">/* Create the empty pipeline */\npipeline = gst_pipeline_new (\"test-pipeline\");\n</code></pre>\n<p>All elements in GStreamer must typically be contained inside a pipeline\nbefore they can be used, because it takes care of some clocking and\nmessaging functions. We create the pipeline with <code>gst_pipeline_new()</code>.</p>\n<pre><code class=\"language-c\">/* Build the pipeline */\ngst_bin_add_many (GST_BIN (pipeline), source, sink, NULL);\nif (gst_element_link (source, sink) != TRUE) {\n  g_printerr (\"Elements could not be linked.\\n\");\n  gst_object_unref (pipeline);\n  return -1;\n}\n</code></pre>\n<p>A pipeline is a particular type of <code>bin</code>, which is the element used to\ncontain other elements. Therefore all methods which apply to bins also\napply to pipelines. In our case, we call <code>gst_bin_add_many()</code> to add the\nelements to the pipeline (mind the cast). This function accepts a list\nof elements to be added, ending with NULL. Individual elements can be\nadded with <code>gst_bin_add()</code>.</p>\n<p>These elements, however, are not linked with each other yet. For this,\nwe need to use <code>gst_element_link()</code>. Its first parameter is the source,\nand the second one the destination. The order counts, because links must\nbe established following the data flow (this is, from source elements to\nsink elements). Keep in mind that only elements residing in the same bin\ncan be linked together, so remember to add them to the pipeline before\ntrying to link them!</p>\n<h3 id=\"properties\">Properties</h3>\n<pre><code class=\"language-c\">/* Modify the source's properties */\ng_object_set (source, \"pattern\", 0, NULL);\n</code></pre>\n<p>Most GStreamer elements have customizable properties: named attributes\nthat can be modified to change the element's behavior (writable\nproperties) or inquired to find out about the element's internal state\n(readable properties).</p>\n<p>Properties are read from with <code>g_object_get()</code> and written to\nwith <code>g_object_set()</code>.</p>\n<p><code>g_object_set()</code> accepts a NULL-terminated list of property-name,\nproperty-value pairs, so multiple properties can be changed in one go\n(GStreamer elements are all a particular kind of <code>GObject</code>, which is the\nentity offering property facilities: This is why the property handling\nmethods have the <code>g_</code> prefix).</p>\n<p>The line of code above changes the \u201cpattern\u201d property of <code>videotestsrc</code>,\nwhich controls the type of test video the element outputs. Try different\nvalues!</p>\n<p>The names and possible values of all the properties an element exposes\ncan be found using the gst-inspect-1.0 tool described in <a href=\"gstreamer-tools.html\">Basic tutorial 10:\nGStreamer tools</a>.</p>\n<h3 id=\"error-checking\">Error checking</h3>\n<p>At this point, we have the whole pipeline built and setup, and the rest\nof the tutorial is very similar to the previous one, but we are going to\nadd more error checking:</p>\n<pre><code class=\"language-c\">/* Start playing */\nret = gst_element_set_state (pipeline, GST_STATE_PLAYING);\nif (ret == GST_STATE_CHANGE_FAILURE) {\n  g_printerr (\"Unable to set the pipeline to the playing state.\\n\");\n  gst_object_unref (pipeline);\n  return -1;\n}\n</code></pre>\n<p>We call <code>gst_element_set_state()</code>, but this time we check its return\nvalue for errors. Changing states is a delicate process and a few more\ndetails are given in <a href=\"dynamic-pipelines.html\">Basic tutorial 3: Dynamic\npipelines</a>.</p>\n<pre><code class=\"language-c\">/* Wait until error or EOS */\nbus = gst_element_get_bus (pipeline);\nmsg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS);\n\n/* Parse message */\nif (msg != NULL) {\n  GError *err;\n  gchar *debug_info;\n\n  switch (GST_MESSAGE_TYPE (msg)) {\n    case GST_MESSAGE_ERROR:\n      gst_message_parse_error (msg, &amp;err, &amp;debug_info);\n      g_printerr (\"Error received from element %s: %s\\n\", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);\n      g_printerr (\"Debugging information: %s\\n\", debug_info ? debug_info : \"none\");\n      g_clear_error (&amp;err);\n      g_free (debug_info);\n      break;\n    case GST_MESSAGE_EOS:\n      g_print (\"End-Of-Stream reached.\\n\");\n      break;\n    default:\n      /* We should not reach here because we only asked for ERRORs and EOS */\n      g_printerr (\"Unexpected message received.\\n\");\n      break;\n  }\n  gst_message_unref (msg);\n}\n</code></pre>\n<p><code>gst_bus_timed_pop_filtered()</code> waits for execution to end and returns\nwith a <code>GstMessage</code> which we previously ignored. We\nasked <code>gst_bus_timed_pop_filtered()</code> to return when GStreamer\nencountered either an error condition or an EOS, so we need to check\nwhich one happened, and print a message on screen (Your application will\nprobably want to undertake more complex actions).</p>\n<p><code>GstMessage</code> is a very versatile structure which can deliver virtually\nany kind of information. Fortunately, GStreamer provides a series of\nparsing functions for each kind of message.</p>\n<p>In this case, once we know the message contains an error (by using the\n<code>GST_MESSAGE_TYPE()</code> macro), we can use\n<code>gst_message_parse_error()</code> which returns a GLib <code>GError</code> error\nstructure and a string useful for debugging. Examine the code to see how\nthese are used and freed afterward.</p>\n<h3 id=\"the-gstreamer-bus\">The GStreamer bus</h3>\n<p>At this point it is worth introducing the GStreamer bus a bit more\nformally. It is the object responsible for delivering to the application\nthe <code>GstMessage</code>s generated by the elements, in order and to the\napplication thread. This last point is important, because the actual\nstreaming of media is done in another thread than the application.</p>\n<p>Messages can be extracted from the bus synchronously with\n<code>gst_bus_timed_pop_filtered()</code> and its siblings, or asynchronously,\nusing signals (shown in the next tutorial). Your application should\nalways keep an eye on the bus to be notified of errors and other\nplayback-related issues.</p>\n<p>The rest of the code is the cleanup sequence, which is the same as\nin <a href=\"hello-world.html\">Basic tutorial 1: Hello\nworld!</a>.</p>\n<h2 id=\"exercise\">Exercise</h2>\n<p>If you feel like practicing, try this exercise: Add a video filter\nelement in between the source and the sink of this pipeline. Use\n<code>vertigotv</code> for a nice effect. You will need to create it, add it to the\npipeline, and link it with the other elements.</p>\n<p>Depending on your platform and available plugins, you might get a\n\u201cnegotiation\u201d error, because the sink does not understand what the\nfilter is producing (more about negotiation in <a href=\"media-formats-and-pad-capabilities.html\">Basic tutorial 6: Media\nformats and Pad\nCapabilities</a>).\nIn this case, try to add an element called <code>videoconvert</code> after the\nfilter (this is, build a pipeline of 4 elements. More on\n<code>videoconvert</code> in <a href=\"handy-elements.html\">Basic tutorial 14: Handy\nelements</a>).</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial showed:</p>\n<ul>\n<li>\n<p>How to create elements with <code>gst_element_factory_make()</code></p>\n</li>\n<li>\n<p>How to create an empty pipeline with <code>gst_pipeline_new()</code></p>\n</li>\n<li>\n<p>How to add elements to the pipeline with <code>gst_bin_add_many()</code></p>\n</li>\n<li>\n<p>How to link the elements with each other with <code>gst_element_link()</code></p>\n</li>\n</ul>\n<p>This concludes the first of the two tutorials devoted to basic GStreamer\nconcepts. The second one comes next.</p>\n<p>Remember that attached to this page you should find the complete source\ncode of the tutorial and any accessory files needed to build it.</p>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n        "});