fragment_downloaded_cb({"url": "tutorials/basic/multithreading-and-pad-availability.html#page-description", "fragment": "GStreamer handles multithreading automatically but under some circumstances you might need to decouple threads manually. This tutorial shows how to do this and in addition completes the exposition about Pad Availability. More precisely this document explains \nHow to create new threads of execution for some parts of the pipeline \nWhat is the Pad Availability \nHow to replicate streams \nGStreamer is a multithreaded framework. This means that internally it creates and destroys threads as it needs them for example to decouple streaming from the application thread. Moreover plugins are also free to create threads for their own processing for example a video decoder could create threads to take full advantage of a CPU with cores. \nOn top of this when building the pipeline an application can specify explicitly that a branch a part of the pipeline runs on a different thread for example to have the audio and video decoders executing simultaneously \nThis is accomplished using the queue element which works as follows. The sink pad just enqueues data and returns control. On a different thread data is dequeued and pushed downstream. This element is also used for buffering as seen later in the streaming tutorials. The size of the queue can be controlled through properties. \nThis example builds the following pipeline \n\nThe source is a synthetic audio signal a continuous tone which is split using a tee element it sends through its source pads everything it receives through its sink pad One branch then sends the signal to the audio card and the other renders a video of the waveform and sends it to the screen. \nAs seen in the picture queues create a new thread so this pipeline runs in threads. Pipelines with more than one sink usually need to be multithreaded because to be synchronized sinks usually block execution until all other sinks are ready and they cannot get ready if there is only one thread being blocked by the first sink. \nIn Basic tutorial Dynamic pipelines we saw an element uridecodebin which had no pads to begin with and they appeared as data started to flow and the element learned about the media. These are called Sometimes Pads and contrast with the regular pads which are always available and are called Always Pads. \nThe third kind of pad is the Request Pad which is created on demand. The classical example is the tee element which has one sink pad and no initial source pads they need to be requested and then tee adds them. In this way an input stream can be replicated any number of times. The disadvantage is that linking elements with Request Pads is not as automatic as linking Always Pads as the walkthrough for this example will show. \nAlso to request or release pads in the PLAYING or PAUSED states you need to take additional cautions Pad blocking which are not described in this tutorial. It is safe to request or release pads in the NULL or READY states though. \nWithout further delay let s see the code. \nCopy this code into a text file named basic tutorial c or find it in your GStreamer installation \nbasic tutorial c \nNeed help \nIf you need help to compile this code refer to the Building the tutorials section for your platform Linux Mac OS X or Windows or use this specific command on Linux \ngcc basic tutorial c o basic tutorial pkg config cflags libs gstreamer \nIf you need help to run this code refer to the Running the tutorials section for your platform Linux Mac OS X or Windows. \nThis tutorial plays an audible tone through the audio card and opens a window with a waveform representation of the tone. The waveform should be a sinusoid but due to the refreshing of the window might not appear so. \nRequired libraries gstreamer \nAll the elements in the above picture are instantiated here \naudiotestsrc produces a synthetic tone. wavescope consumes an audio signal and renders a waveform as if it was an admittedly cheap oscilloscope. We have already worked with the autoaudiosink and autovideosink. \nThe conversion elements audioconvert audioresample and videoconvert are necessary to guarantee that the pipeline can be linked. Indeed the Capabilities of the audio and video sinks depend on the hardware and you do not know at design time if they will match the Caps produced by the audiotestsrc and wavescope. If the Caps matched though these elements act in pass through mode and do not modify the signal having negligible impact on performance. \nSmall adjustments for better demonstration The freq property of audiotestsrc controls the frequency of the wave Hz makes the wave appear almost stationary in the window and this style and shader for wavescope make the wave continuous. Use the gst inspect tool described in Basic tutorial GStreamer tools to learn all the properties of these elements. \nThis code block adds all elements to the pipeline and then links the ones that can be automatically linked the ones with Always Pads as the comment says \ngst_element_link_many can actually link elements with Request Pads. It internally requests the Pads so you do not have worry about the elements being linked having Always or Request Pads. Strange as it might seem this is actually inconvenient because you still need to release the requested Pads afterwards and if the Pad was requested automatically by gst_element_link_many it is easy to forget. Stay out of trouble by always requesting Request Pads manually as shown in the next code block. \nTo link Request Pads they need to be obtained by requesting them to the element. An element might be able to produce different kinds of Request Pads so when requesting them the desired Pad Template must be provided. Pad templates are obtained with gst_element_class_get_pad_template and are identified by their name. In the documentation for the tee element we see that it has two pad templates named sink for its sink Pads and src_ d for the Request Pads \nOnce we have the Pad template we request two Pads from the tee for the audio and video branches with gst_element_request_pad \nWe then obtain the Pads from the downstream elements to which these Request Pads need to be linked. These are normal Always Pads so we obtain them with gst_element_get_static_pad \nFinally we link the pads with gst_pad_link This is the function that gst_element_link and gst_element_link_many use internally. \nThe sink Pads we have obtained need to be released with gst_object_unref The Request Pads will be released when we no longer need them at the end of the program. \nWe then set the pipeline to playing as usual and wait until an error message or an EOS is produced. The only thing left to so is cleanup the requested Pads \ngst_element_release_request_pad releases the pad from the tee but it still needs to be unreferenced freed with gst_object_unref \nThis tutorial has shown \nHow to make parts of a pipeline run on a different thread by using queue elements. \nWhat is a Request Pad and how to link elements with request pads with gst_element_class_get_pad_template gst_element_request_pad gst_pad_link and gst_element_release_request_pad \nHow to have the same stream available in different branches by using tee elements. \nThe next tutorial builds on top of this one to show how data can be manually injected into and extracted from a running pipeline. \nIt has been a pleasure having you here and see you soon \n"});