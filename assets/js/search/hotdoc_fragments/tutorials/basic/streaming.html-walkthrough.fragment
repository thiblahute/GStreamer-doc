fragment_downloaded_cb({"url": "tutorials/basic/streaming.html#walkthrough", "fragment": "Walkthrough \nThe only special thing this tutorial does is react to certain messages therefore the initialization code is very simple and should be self explanative by now. The only new bit is the detection of live streams \nLive streams cannot be paused so they behave in PAUSED state as if they were in the PLAYING state. Setting live streams to PAUSED succeeds but returns GST_STATE_CHANGE_NO_PREROLL instead of GST_STATE_CHANGE_SUCCESS to indicate that this is a live stream. We are receiving the NO_PROROLL return code even though we are trying to set the pipeline to PLAYING because state changes happen progressively from NULL to READY to PAUSED and then to PLAYING \nWe care about live streams because we want to disable buffering for them so we take note of the result of gst_element_set_state in the is_live variable. \nLet s now review the interesting parts of the message parsing callback \nFirst if this is a live source ignore buffering messages. \nWe parse the buffering message with gst_message_parse_buffering to retrieve the buffering level. \nThen we print the buffering level on the console and set the pipeline to PAUSED if it is below Otherwise we set the pipeline to PLAYING. \nAt startup we will see the buffering level rise up to before playback starts which is what we wanted to achieve. If later on the network becomes slow or unresponsive and our buffer depletes we will receive new buffering messages with levels below so we will pause the pipeline again until enough buffer has been built up. \nFor the second network issue the loss of clock we simply set the pipeline to PAUSED and back to PLAYING so a new clock is selected waiting for new media chunks to be received if necessary. \n"});