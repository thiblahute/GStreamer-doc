fragment_downloaded_cb({"url": "tutorials/basic/short-cutting-the-pipeline.html#walkthrough", "fragment": "Walkthrough \nThe code to create the pipeline Lines to is an enlarged version of Basic tutorial Multithreading and Pad Availability. It involves instantiating all the elements link the elements with Always Pads and manually link the Request Pads of the tee element. \nRegarding the configuration of the appsrc and appsink elements \nThe first property that needs to be set on the appsrc is caps. It specifies the kind of data that the element is going to produce so GStreamer can check if linking with downstream elements is possible this is if the downstream elements will understand this kind of data This property must be a GstCaps object which is easily built from a string with gst_caps_from_string \nWe then connect to the need data and enough data signals. These are fired by appsrc when its internal queue of data is running low or almost full respectively. We will use these signals to start and stop respectively our signal generation process. \nRegarding the appsink configuration we connect to the new sample signal which is emitted every time the sink receives a buffer. Also the signal emission needs to be enabled through the emit signals property because by default it is disabled. \nStarting the pipeline waiting for messages and final cleanup is done as usual. Let s review the callbacks we have just registered \nThis function is called when the internal queue of appsrc is about to starve run out of data The only thing we do here is register a GLib idle function with g_idle_add that feeds data to appsrc until it is full again. A GLib idle function is a method that GLib will call from its main loop whenever it is idle this is when it has no higher priority tasks to perform. It requires a GLib GMainLoop to be instantiated and running obviously. \nThis is only one of the multiple approaches that appsrc allows. In particular buffers do not need to be fed into appsrc from the main thread using GLib and you do not need to use the need data and enough data signals to synchronize with appsrc although this is allegedly the most convenient \nWe take note of the sourceid that g_idle_add returns so we can disable it later. \nThis function is called when the internal queue of appsrc is full enough so we stop pushing data. Here we simply remove the idle function by using g_source_remove The idle function is implemented as a GSource \nThis is the function that feeds appsrc. It will be called by GLib at times and rates which are out of our control but we know that we will disable it when its job is done when the queue in appsrc is full \nIts first task is to create a new buffer with a given size in this example it is arbitrarily set to bytes with gst_buffer_new_and_alloc \nWe count the number of samples that we have generated so far with the CustomData.num_samples variable so we can time stamp this buffer using the GST_BUFFER_TIMESTAMP macro in GstBuffer. \nSince we are producing buffers of the same size their duration is the same and is set using the GST_BUFFER_DURATION in GstBuffer. \ngst_util_uint64_scale is a utility function that scales multiply and divide numbers which can be large without fear of overflows. \nThe bytes that for the buffer can be accessed with GST_BUFFER_DATA in GstBuffer Be careful not to write past the end of the buffer you allocated it so you know its size \nWe will skip over the waveform generation since it is outside the scope of this tutorial it is simply a funny way of generating a pretty psychedelic wave \nOnce we have the buffer ready we pass it to appsrc with the push buffer action signal see information box at the end of Playback tutorial Playbin usage and then gst_buffer_unref it since we no longer need it. \nFinally this is the function that gets called when the appsink receives a buffer. We use the pull sample action signal to retrieve the buffer and then just print some indicator on the screen. We can retrieve the data pointer using the GST_BUFFER_DATA macro and the data size using the GST_BUFFER_SIZE macro in GstBuffer. Remember that this buffer does not have to match the buffer that we produced in the push_data function any element in the path could have altered the buffers in any way Not in this example there is only a tee in the path between appsrc and appsink and it does not change the content of the buffers \nWe then gst_buffer_unref the buffer and this tutorial is done. \n"});