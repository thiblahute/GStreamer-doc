fragment_downloaded_cb({"url": "tutorials/basic/toolkit-integration.html#information", "fragment": "A GObject interface which GStreamer uses is a set of functions that an element can implement. If it does then it is said to support that particular interface. For example video sinks usually create their own windows to display video but if they are also capable of rendering to an external window they can choose to implement the GstVideoOverlay interface and provide functions to specify this external window. From the application developer point of view if a certain interface is supported you can use it and forget about which kind of element is implementing it. Moreover if you are using playbin it will automatically expose some of the interfaces supported by its internal elements You can use your interface functions directly on playbin without knowing who is implementing them \nAnother issue is that GUI toolkits usually only allow manipulation of the graphical widgets through the main or application thread whereas GStreamer usually spawns multiple threads to take care of different tasks. Calling GTK functions from within callbacks will usually fail because callbacks execute in the calling thread which does not need to be the main thread. This problem can be solved by posting a message on the GStreamer bus in the callback The messages will be received by the main thread which will then react accordingly. \nFinally so far we have registered a handle_message function that got called every time a message appeared on the bus which forced us to parse every message to see if it was of interest to us. In this tutorial a different method is used that registers a callback for each kind of message so there is less parsing and less code overall. \n"});