fragment_downloaded_cb({"url": "tutorials/basic/toolkit-integration.html#page-description", "fragment": "This tutorial shows how to integrate GStreamer in a Graphical User Interface GUI toolkit like GTK Basically GStreamer takes care of media playback while the GUI toolkit handles user interaction. The most interesting parts are those in which both libraries have to interact Instructing GStreamer to output video to a GTK window and forwarding user actions to GStreamer. \nIn particular you will learn \nHow to tell GStreamer to output video to a particular window instead of creating its own window \nHow to continuously refresh the GUI with information from GStreamer. \nHow to update the GUI from the multiple threads of GStreamer an operation forbidden on most GUI toolkits. \nA mechanism to subscribe only to the messages you are interested in instead of being notified of all of them. \nWe are going to build a media player using the GTK toolkit but the concepts apply to other toolkits like QT for example. A minimum knowledge of GTK will help understand this tutorial. \nThe main point is telling GStreamer to output the video to a window of our choice. The specific mechanism depends on the operating system or rather on the windowing system but GStreamer provides a layer of abstraction for the sake of platform independence. This independence comes through the GstVideoOverlay interface that allows the application to tell a video sink the handler of the window that should receive the rendering. \nGObject interfaces \nA GObject interface which GStreamer uses is a set of functions that an element can implement. If it does then it is said to support that particular interface. For example video sinks usually create their own windows to display video but if they are also capable of rendering to an external window they can choose to implement the GstVideoOverlay interface and provide functions to specify this external window. From the application developer point of view if a certain interface is supported you can use it and forget about which kind of element is implementing it. Moreover if you are using playbin it will automatically expose some of the interfaces supported by its internal elements You can use your interface functions directly on playbin without knowing who is implementing them \nAnother issue is that GUI toolkits usually only allow manipulation of the graphical widgets through the main or application thread whereas GStreamer usually spawns multiple threads to take care of different tasks. Calling GTK functions from within callbacks will usually fail because callbacks execute in the calling thread which does not need to be the main thread. This problem can be solved by posting a message on the GStreamer bus in the callback The messages will be received by the main thread which will then react accordingly. \nFinally so far we have registered a handle_message function that got called every time a message appeared on the bus which forced us to parse every message to see if it was of interest to us. In this tutorial a different method is used that registers a callback for each kind of message so there is less parsing and less code overall. \nLet s write a very simple media player based on playbin this time with a GUI \nCopy this code into a text file named basic tutorial c or find it in your GStreamer installation \nbasic tutorial c \nNeed help \nIf you need help to compile this code refer to the Building the tutorials section for your platform Linux Mac OS X or Windows or use this specific command on Linux \ngcc basic tutorial c o basic tutorial pkg config cflags libs gstreamer video gtk gstreamer \nIf you need help to run this code refer to the Running the tutorials section for your platform Linux Mac OS X or Windows. \nThis tutorial opens a GTK window and displays a movie with accompanying audio. The media is fetched from the Internet so the window might take a few seconds to appear depending on your connection speed. The Window has some GTK buttons to Pause Stop and Play the movie and a slider to show the current position of the stream which can be dragged to change it. Also information about the stream is shown on a column at the right edge of the window. \nBear in mind that there is no latency management buffering so on slow connections the movie might stop after a few seconds. See how Basic tutorial Streaming solves this issue. \nRequired libraries gstreamer video gtk gstreamer \nRegarding this tutorial s structure we are not going to use forward function definitions anymore Functions will be defined before they are used. Also for clarity of explanation the order in which the snippets of code are presented will not always match the program order. Use the line numbers to locate the snippets in the complete code. \nThe first thing worth noticing is that we are no longer completely platform independent. We need to include the appropriate GDK headers for the windowing system we are going to use. Fortunately there are not that many supported windowing systems so these three lines often suffice X11 for Linux Win32 for Windows and Quartz for Mac OSX. \nThis tutorial is composed mostly of callback functions which will be called from GStreamer or GTK so let s review the main function which registers all these callbacks. \nStandard GStreamer initialization and playbin pipeline creation along with GTK initialization. Not much new. \nWe are interested in being notified when new tags metadata appears on the stream. For simplicity we are going to handle all kinds of tags video audio and text from the same callback tags_cb. \nAll GTK widget creation and signal registration happens in this function. It contains only GTK related function calls so we will skip over its definition. The signals to which it registers convey user commands as shown below when reviewing the callbacks. \nIn Playback tutorial Playbin usage gst_bus_add_watch is used to register a function that receives every message posted to the GStreamer bus. We can achieve a finer granularity by using signals instead which allow us to register only to the messages we are interested in. By calling gst_bus_add_signal_watch we instruct the bus to emit a signal every time it receives a message. This signal has the name message detail where detail is the message that triggered the signal emission. For example when the bus receives the EOS message it emits a signal with the name message eos. \nThis tutorial is using the Signals s details to register only to the messages we care about. If we had registered to the message signal we would be notified of every single message just like gst_bus_add_watch would do. \nKeep in mind that in order for the bus watches to work be it a gst_bus_add_watch or a gst_bus_add_signal_watch there must be GLib Main Loop running. In this case it is hidden inside the GTK main loop. \nBefore transferring control to GTK we use g_timeout_add_seconds to register yet another callback this time with a timeout so it gets called every second. We are going to use it to refresh the GUI from the refresh_ui function. \nAfter this we are done with the setup and can start the GTK main loop. We will regain control from our callbacks when interesting things happen. Let s review the callbacks. Each callback has a different signature depending on who will call it. You can look up the signature the meaning of the parameters and the return value in the documentation of the signal. \nThe code comments talks by itself. At this point in the life cycle of the application we know the handle be it an X11 s XID a Window s HWND or a Quartz s NSView of the window where GStreamer should render the video. We simply retrieve it from the windowing system and pass it to playbin through the GstVideoOverlay interface using gst_video_overlay_set_window_handle playbin will locate the video sink and pass the handler to it so it does not create its own window and uses this one. \nNot much more to see here playbin and the GstVideoOverlay really simplify this process a lot \nThese three little callbacks are associated with the PLAY PAUSE and STOP buttons in the GUI. They simply set the pipeline to the corresponding state. Note that in the STOP state we set the pipeline to READY. We could have brought the pipeline all the way down to the NULL state but the transition would then be a little slower since some resources like the audio device would need to be released and re acquired. \ngtk_main_quit will eventually make the call to to gtk_main_run in main to terminate which in this case finishes the program. Here we call it when the main window is closed after stopping the pipeline just for the sake of tidiness \nWhen there is data flow in the PAUSED and PLAYING states the video sink takes care of refreshing the content of the video window. In the other cases however it will not so we have to do it. In this example we just fill the window with a black rectangle. \nThis is an example of how a complex GUI element like a seeker bar or slider that allows seeking can be very easily implemented thanks to GStreamer and GTK collaborating. If the slider has been dragged to a new position tell GStreamer to seek to that position with gst_element_seek_simple as seen in Basic tutorial Time management The slider has been setup so its value represents seconds. \nIt is worth mentioning that some performance and responsiveness can be gained by doing some throttling this is not responding to every single user request to seek. Since the seek operation is bound to take some time it is often nicer to wait half a second for example after a seek before allowing another one. Otherwise the application might look unresponsive if the user drags the slider frantically which would not allow any seek to complete before a new one is queued. \nThis function will move the slider to reflect the current position of the media. First off if we are not in the PLAYING state we have nothing to do here plus position and duration queries will normally fail \nWe recover the duration of the clip if we didn t know it so we can set the range for the slider. \nWe query the current pipeline position and set the position of the slider accordingly. This would trigger the emission of the value changed signal which we use to know when the user is dragging the slider. Since we do not want seeks happening unless the user requested them we disable the value changed signal emission during this operation with g_signal_handler_block and g_signal_handler_unblock \nReturning TRUE from this function will keep it called in the future. If we return FALSE the timer will be removed. \nThis is one of the key points of this tutorial. This function will be called when new tags are found in the media from a streaming thread this is from a thread other than the application or main thread. What we want to do here is to update a GTK widget to reflect this new information but GTK does not allow operating from threads other than the main one. \nThe solution is to make playbin post a message on the bus and return to the calling thread. When appropriate the main thread will pick up this message and update GTK. \ngst_element_post_message makes a GStreamer element post the given message to the bus. gst_message_new_application creates a new message of the APPLICATION type. GStreamer messages have different types and this particular type is reserved to the application it will go through the bus unaffected by GStreamer. The list of types can be found in the GstMessageType documentation. \nMessages can deliver additional information through their embedded GstStructure which is a very flexible data container. Here we create a new structure with gst_structure_new and name it tags changed to avoid confusion in case we wanted to send other application messages. \nLater once in the main thread the bus will receive this message and emit the message application signal which we have associated to the application_cb function \nOnce me made sure it is the tags changed message we call the analyze_streams function which is also used in Playback tutorial Playbin usage and is more detailed there. It basically recovers the tags from the stream and writes them in a text widget in the GUI. \nThe error_cb eos_cb and state_changed_cb are not really worth explaining since they do the same as in all previous tutorials but from their own function now. \nAnd this is it The amount of code in this tutorial might seem daunting but the required concepts are few and easy. If you have followed the previous tutorials and have a little knowledge of GTK you probably understood this one can now enjoy your very own media player \n\nIf this media player is not good enough for you try to change the text widget that displays the information about the streams into a proper list view or tree view Then when the user selects a different stream make GStreamer switch streams To switch streams you will need to read Playback tutorial Playbin usage. \nThis tutorial has shown \nHow to output the video to a particular window handle using gst_video_overlay_set_window_handle \nHow to refresh the GUI periodically by registering a timeout callback with g_timeout_add_seconds \nHow to convey information to the main thread by means of application messages through the bus with gst_element_post_message \nHow to be notified only of interesting messages by making the bus emit signals with gst_bus_add_signal_watch and discriminating among all message types using the signal details. \nThis allows you to build a somewhat complete media player with a proper Graphical User Interface. \nThe following basic tutorials keep focusing on other individual GStreamer topics \nIt has been a pleasure having you here and see you soon \n"});