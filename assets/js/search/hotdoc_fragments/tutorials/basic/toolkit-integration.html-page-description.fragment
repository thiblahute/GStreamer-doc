fragment_downloaded_cb({"url": "tutorials/basic/toolkit-integration.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"toolkit-integration.md\">\n        <h1 id=\"basic-tutorial-5-gui-toolkit-integration\">Basic tutorial 5: GUI toolkit integration</h1>\n<h2 id=\"goal\">Goal</h2>\n<p>This tutorial shows how to integrate GStreamer in a Graphical User\nInterface (GUI) toolkit like <a href=\"http://www.gtk.org\">GTK+</a>. Basically,\nGStreamer takes care of media playback while the GUI toolkit handles\nuser interaction. The most interesting parts are those in which both\nlibraries have to interact: Instructing GStreamer to output video to a\nGTK+ window and forwarding user actions to GStreamer.</p>\n<p>In particular, you will learn:</p>\n<ul>\n<li>\n<p>How to tell GStreamer to output video to a particular window\n(instead of creating its own window).</p>\n</li>\n<li>\n<p>How to continuously refresh the GUI with information from GStreamer.</p>\n</li>\n<li>\n<p>How to update the GUI from the multiple threads of GStreamer, an\noperation forbidden on most GUI toolkits.</p>\n</li>\n<li>\n<p>A mechanism to subscribe only to the messages you are interested in,\ninstead of being notified of all of them.</p>\n</li>\n</ul>\n<h2 id=\"introduction\">Introduction</h2>\n<p>We are going to build a media player using the\n<a href=\"http://www.gtk.org/\">GTK+</a> toolkit, but the concepts apply to other\ntoolkits like <a href=\"http://qt-project.org/\">QT</a>, for example. A minimum\nknowledge of <a href=\"http://www.gtk.org/\">GTK+</a> will help understand this\ntutorial.</p>\n<p>The main point is telling GStreamer to output the video to a window of\nour choice. The specific mechanism depends on the operating system (or\nrather, on the windowing system), but GStreamer provides a layer of\nabstraction for the sake of platform independence. This independence\ncomes through the <code>GstVideoOverlay</code> interface, that allows the application to\ntell a video sink the handler of the window that should receive the\nrendering.</p>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"Information\" id=\"information\">\n<strong>GObject interfaces</strong></p>\n<p>A GObject <em>interface</em> (which GStreamer uses) is a set of functions that an element can implement. If it does, then it is said to support that particular interface. For example, video sinks usually create their own windows to display video, but, if they are also capable of rendering to an external window, they can choose to implement the <code>GstVideoOverlay</code> interface and provide functions to specify this external window. From the application developer point of view, if a certain interface is supported, you can use it and forget about which kind of element is implementing it. Moreover, if you are using <code>playbin</code>, it will automatically expose some of the interfaces supported by its internal elements: You can use your interface functions directly on <code>playbin</code> without knowing who is implementing them!</p>\n</blockquote>\n<p>Another issue is that GUI toolkits usually only allow manipulation of\nthe graphical \u201cwidgets\u201d through the main (or application) thread,\nwhereas GStreamer usually spawns multiple threads to take care of\ndifferent tasks. Calling <a href=\"http://www.gtk.org/\">GTK+</a> functions from\nwithin callbacks will usually fail, because callbacks execute in the\ncalling thread, which does not need to be the main thread. This problem\ncan be solved by posting a message on the GStreamer bus in the callback:\nThe messages will be received by the main thread which will then react\naccordingly.</p>\n<p>Finally, so far we have registered a <code>handle_message</code> function that got\ncalled every time a message appeared on the bus, which forced us to\nparse every message to see if it was of interest to us. In this tutorial\na different method is used that registers a callback for each kind of\nmessage, so there is less parsing and less code overall.</p>\n<h2 id=\"a-media-player-in-gtk\">A media player in GTK+</h2>\n<p>Let's write a very simple media player based on playbin, this time,\nwith a GUI!</p>\n<p>Copy this code into a text file named <code>basic-tutorial-5.c</code> (or find it\nin the SDK installation).</p>\n<p><strong>basic-tutorial-5.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;string.h&gt;\n\n#include &lt;gtk/gtk.h&gt;\n#include &lt;gst/gst.h&gt;\n#include &lt;gst/video/videooverlay.h&gt;\n\n#include &lt;gdk/gdk.h&gt;\n#if defined (GDK_WINDOWING_X11)\n#include &lt;gdk/gdkx.h&gt;\n#elif defined (GDK_WINDOWING_WIN32)\n#include &lt;gdk/gdkwin32.h&gt;\n#elif defined (GDK_WINDOWING_QUARTZ)\n#include &lt;gdk/gdkquartz.h&gt;\n#endif\n\n/* Structure to contain all our information, so we can pass it around */\ntypedef struct _CustomData {\n  GstElement *playbin;           /* Our one and only pipeline */\n\n  GtkWidget *slider;              /* Slider widget to keep track of current position */\n  GtkWidget *streams_list;        /* Text widget to display info about the streams */\n  gulong slider_update_signal_id; /* Signal ID for the slider update signal */\n\n  GstState state;                 /* Current state of the pipeline */\n  gint64 duration;                /* Duration of the clip, in nanoseconds */\n} CustomData;\n\n/* This function is called when the GUI toolkit creates the physical window that will hold the video.\n * At this point we can retrieve its handler (which has a different meaning depending on the windowing system)\n * and pass it to GStreamer through the VideoOverlay interface. */\nstatic void realize_cb (GtkWidget *widget, CustomData *data) {\n  GdkWindow *window = gtk_widget_get_window (widget);\n  guintptr window_handle;\n\n  if (!gdk_window_ensure_native (window))\n    g_error (\"Couldn't create native window needed for GstVideoOverlay!\");\n\n  /* Retrieve window handler from GDK */\n#if defined (GDK_WINDOWING_WIN32)\n  window_handle = (guintptr)GDK_WINDOW_HWND (window);\n#elif defined (GDK_WINDOWING_QUARTZ)\n  window_handle = gdk_quartz_window_get_nsview (window);\n#elif defined (GDK_WINDOWING_X11)\n  window_handle = GDK_WINDOW_XID (window);\n#endif\n  /* Pass it to playbin, which implements VideoOverlay and will forward it to the video sink */\n  gst_video_overlay_set_window_handle (GST_VIDEO_OVERLAY (data-&gt;playbin), window_handle);\n}\n\n/* This function is called when the PLAY button is clicked */\nstatic void play_cb (GtkButton *button, CustomData *data) {\n  gst_element_set_state (data-&gt;playbin, GST_STATE_PLAYING);\n}\n\n/* This function is called when the PAUSE button is clicked */\nstatic void pause_cb (GtkButton *button, CustomData *data) {\n  gst_element_set_state (data-&gt;playbin, GST_STATE_PAUSED);\n}\n\n/* This function is called when the STOP button is clicked */\nstatic void stop_cb (GtkButton *button, CustomData *data) {\n  gst_element_set_state (data-&gt;playbin, GST_STATE_READY);\n}\n\n/* This function is called when the main window is closed */\nstatic void delete_event_cb (GtkWidget *widget, GdkEvent *event, CustomData *data) {\n  stop_cb (NULL, data);\n  gtk_main_quit ();\n}\n\n/* This function is called everytime the video window needs to be redrawn (due to damage/exposure,\n * rescaling, etc). GStreamer takes care of this in the PAUSED and PLAYING states, otherwise,\n * we simply draw a black rectangle to avoid garbage showing up. */\nstatic gboolean draw_cb (GtkWidget *widget, cairo_t *cr, CustomData *data) {\n  if (data-&gt;state &lt; GST_STATE_PAUSED) {\n    GtkAllocation allocation;\n\n    /* Cairo is a 2D graphics library which we use here to clean the video window.\n     * It is used by GStreamer for other reasons, so it will always be available to us. */\n    gtk_widget_get_allocation (widget, &amp;allocation);\n    cairo_set_source_rgb (cr, 0, 0, 0);\n    cairo_rectangle (cr, 0, 0, allocation.width, allocation.height);\n    cairo_fill (cr);\n  }\n\n  return FALSE;\n}\n\n/* This function is called when the slider changes its position. We perform a seek to the\n * new position here. */\nstatic void slider_cb (GtkRange *range, CustomData *data) {\n  gdouble value = gtk_range_get_value (GTK_RANGE (data-&gt;slider));\n  gst_element_seek_simple (data-&gt;playbin, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT,\n      (gint64)(value * GST_SECOND));\n}\n\n/* This creates all the GTK+ widgets that compose our application, and registers the callbacks */\nstatic void create_ui (CustomData *data) {\n  GtkWidget *main_window;  /* The uppermost window, containing all other windows */\n  GtkWidget *video_window; /* The drawing area where the video will be shown */\n  GtkWidget *main_box;     /* VBox to hold main_hbox and the controls */\n  GtkWidget *main_hbox;    /* HBox to hold the video_window and the stream info text widget */\n  GtkWidget *controls;     /* HBox to hold the buttons and the slider */\n  GtkWidget *play_button, *pause_button, *stop_button; /* Buttons */\n\n  main_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);\n  g_signal_connect (G_OBJECT (main_window), \"delete-event\", G_CALLBACK (delete_event_cb), data);\n\n  video_window = gtk_drawing_area_new ();\n  gtk_widget_set_double_buffered (video_window, FALSE);\n  g_signal_connect (video_window, \"realize\", G_CALLBACK (realize_cb), data);\n  g_signal_connect (video_window, \"draw\", G_CALLBACK (draw_cb), data);\n\n  play_button = gtk_button_new_from_stock (GTK_STOCK_MEDIA_PLAY);\n  g_signal_connect (G_OBJECT (play_button), \"clicked\", G_CALLBACK (play_cb), data);\n\n  pause_button = gtk_button_new_from_stock (GTK_STOCK_MEDIA_PAUSE);\n  g_signal_connect (G_OBJECT (pause_button), \"clicked\", G_CALLBACK (pause_cb), data);\n\n  stop_button = gtk_button_new_from_stock (GTK_STOCK_MEDIA_STOP);\n  g_signal_connect (G_OBJECT (stop_button), \"clicked\", G_CALLBACK (stop_cb), data);\n\n  data-&gt;slider = gtk_scale_new_with_range (GTK_ORIENTATION_HORIZONTAL, 0, 100, 1);\n  gtk_scale_set_draw_value (GTK_SCALE (data-&gt;slider), 0);\n  data-&gt;slider_update_signal_id = g_signal_connect (G_OBJECT (data-&gt;slider), \"value-changed\", G_CALLBACK (slider_cb), data);\n\n  data-&gt;streams_list = gtk_text_view_new ();\n  gtk_text_view_set_editable (GTK_TEXT_VIEW (data-&gt;streams_list), FALSE);\n\n  controls = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);\n  gtk_box_pack_start (GTK_BOX (controls), play_button, FALSE, FALSE, 2);\n  gtk_box_pack_start (GTK_BOX (controls), pause_button, FALSE, FALSE, 2);\n  gtk_box_pack_start (GTK_BOX (controls), stop_button, FALSE, FALSE, 2);\n  gtk_box_pack_start (GTK_BOX (controls), data-&gt;slider, TRUE, TRUE, 2);\n\n  main_hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);\n  gtk_box_pack_start (GTK_BOX (main_hbox), video_window, TRUE, TRUE, 0);\n  gtk_box_pack_start (GTK_BOX (main_hbox), data-&gt;streams_list, FALSE, FALSE, 2);\n\n  main_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);\n  gtk_box_pack_start (GTK_BOX (main_box), main_hbox, TRUE, TRUE, 0);\n  gtk_box_pack_start (GTK_BOX (main_box), controls, FALSE, FALSE, 0);\n  gtk_container_add (GTK_CONTAINER (main_window), main_box);\n  gtk_window_set_default_size (GTK_WINDOW (main_window), 640, 480);\n\n  gtk_widget_show_all (main_window);\n}\n\n/* This function is called periodically to refresh the GUI */\nstatic gboolean refresh_ui (CustomData *data) {\n  gint64 current = -1;\n\n  /* We do not want to update anything unless we are in the PAUSED or PLAYING states */\n  if (data-&gt;state &lt; GST_STATE_PAUSED)\n    return TRUE;\n\n  /* If we didn't know it yet, query the stream duration */\n  if (!GST_CLOCK_TIME_IS_VALID (data-&gt;duration)) {\n    if (!gst_element_query_duration (data-&gt;playbin, GST_FORMAT_TIME, &amp;data-&gt;duration)) {\n      g_printerr (\"Could not query current duration.\\n\");\n    } else {\n      /* Set the range of the slider to the clip duration, in SECONDS */\n      gtk_range_set_range (GTK_RANGE (data-&gt;slider), 0, (gdouble)data-&gt;duration / GST_SECOND);\n    }\n  }\n\n  if (gst_element_query_position (data-&gt;playbin, GST_FORMAT_TIME, &amp;current)) {\n    /* Block the \"value-changed\" signal, so the slider_cb function is not called\n     * (which would trigger a seek the user has not requested) */\n    g_signal_handler_block (data-&gt;slider, data-&gt;slider_update_signal_id);\n    /* Set the position of the slider to the current pipeline positoin, in SECONDS */\n    gtk_range_set_value (GTK_RANGE (data-&gt;slider), (gdouble)current / GST_SECOND);\n    /* Re-enable the signal */\n    g_signal_handler_unblock (data-&gt;slider, data-&gt;slider_update_signal_id);\n  }\n  return TRUE;\n}\n\n/* This function is called when new metadata is discovered in the stream */\nstatic void tags_cb (GstElement *playbin, gint stream, CustomData *data) {\n  /* We are possibly in a GStreamer working thread, so we notify the main\n   * thread of this event through a message in the bus */\n  gst_element_post_message (playbin,\n    gst_message_new_application (GST_OBJECT (playbin),\n      gst_structure_new_empty (\"tags-changed\")));\n}\n\n/* This function is called when an error message is posted on the bus */\nstatic void error_cb (GstBus *bus, GstMessage *msg, CustomData *data) {\n  GError *err;\n  gchar *debug_info;\n\n  /* Print error details on the screen */\n  gst_message_parse_error (msg, &amp;err, &amp;debug_info);\n  g_printerr (\"Error received from element %s: %s\\n\", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);\n  g_printerr (\"Debugging information: %s\\n\", debug_info ? debug_info : \"none\");\n  g_clear_error (&amp;err);\n  g_free (debug_info);\n\n  /* Set the pipeline to READY (which stops playback) */\n  gst_element_set_state (data-&gt;playbin, GST_STATE_READY);\n}\n\n/* This function is called when an End-Of-Stream message is posted on the bus.\n * We just set the pipeline to READY (which stops playback) */\nstatic void eos_cb (GstBus *bus, GstMessage *msg, CustomData *data) {\n  g_print (\"End-Of-Stream reached.\\n\");\n  gst_element_set_state (data-&gt;playbin, GST_STATE_READY);\n}\n\n/* This function is called when the pipeline changes states. We use it to\n * keep track of the current state. */\nstatic void state_changed_cb (GstBus *bus, GstMessage *msg, CustomData *data) {\n  GstState old_state, new_state, pending_state;\n  gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);\n  if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data-&gt;playbin)) {\n    data-&gt;state = new_state;\n    g_print (\"State set to %s\\n\", gst_element_state_get_name (new_state));\n    if (old_state == GST_STATE_READY &amp;&amp; new_state == GST_STATE_PAUSED) {\n      /* For extra responsiveness, we refresh the GUI as soon as we reach the PAUSED state */\n      refresh_ui (data);\n    }\n  }\n}\n\n/* Extract metadata from all the streams and write it to the text widget in the GUI */\nstatic void analyze_streams (CustomData *data) {\n  gint i;\n  GstTagList *tags;\n  gchar *str, *total_str;\n  guint rate;\n  gint n_video, n_audio, n_text;\n  GtkTextBuffer *text;\n\n  /* Clean current contents of the widget */\n  text = gtk_text_view_get_buffer (GTK_TEXT_VIEW (data-&gt;streams_list));\n  gtk_text_buffer_set_text (text, \"\", -1);\n\n  /* Read some properties */\n  g_object_get (data-&gt;playbin, \"n-video\", &amp;n_video, NULL);\n  g_object_get (data-&gt;playbin, \"n-audio\", &amp;n_audio, NULL);\n  g_object_get (data-&gt;playbin, \"n-text\", &amp;n_text, NULL);\n\n  for (i = 0; i &lt; n_video; i++) {\n    tags = NULL;\n    /* Retrieve the stream's video tags */\n    g_signal_emit_by_name (data-&gt;playbin, \"get-video-tags\", i, &amp;tags);\n    if (tags) {\n      total_str = g_strdup_printf (\"video stream %d:\\n\", i);\n      gtk_text_buffer_insert_at_cursor (text, total_str, -1);\n      g_free (total_str);\n      gst_tag_list_get_string (tags, GST_TAG_VIDEO_CODEC, &amp;str);\n      total_str = g_strdup_printf (\"  codec: %s\\n\", str ? str : \"unknown\");\n      gtk_text_buffer_insert_at_cursor (text, total_str, -1);\n      g_free (total_str);\n      g_free (str);\n      gst_tag_list_free (tags);\n    }\n  }\n\n  for (i = 0; i &lt; n_audio; i++) {\n    tags = NULL;\n    /* Retrieve the stream's audio tags */\n    g_signal_emit_by_name (data-&gt;playbin, \"get-audio-tags\", i, &amp;tags);\n    if (tags) {\n      total_str = g_strdup_printf (\"\\naudio stream %d:\\n\", i);\n      gtk_text_buffer_insert_at_cursor (text, total_str, -1);\n      g_free (total_str);\n      if (gst_tag_list_get_string (tags, GST_TAG_AUDIO_CODEC, &amp;str)) {\n        total_str = g_strdup_printf (\"  codec: %s\\n\", str);\n        gtk_text_buffer_insert_at_cursor (text, total_str, -1);\n        g_free (total_str);\n        g_free (str);\n      }\n      if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &amp;str)) {\n        total_str = g_strdup_printf (\"  language: %s\\n\", str);\n        gtk_text_buffer_insert_at_cursor (text, total_str, -1);\n        g_free (total_str);\n        g_free (str);\n      }\n      if (gst_tag_list_get_uint (tags, GST_TAG_BITRATE, &amp;rate)) {\n        total_str = g_strdup_printf (\"  bitrate: %d\\n\", rate);\n        gtk_text_buffer_insert_at_cursor (text, total_str, -1);\n        g_free (total_str);\n      }\n      gst_tag_list_free (tags);\n    }\n  }\n\n  for (i = 0; i &lt; n_text; i++) {\n    tags = NULL;\n    /* Retrieve the stream's subtitle tags */\n    g_signal_emit_by_name (data-&gt;playbin, \"get-text-tags\", i, &amp;tags);\n    if (tags) {\n      total_str = g_strdup_printf (\"\\nsubtitle stream %d:\\n\", i);\n      gtk_text_buffer_insert_at_cursor (text, total_str, -1);\n      g_free (total_str);\n      if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &amp;str)) {\n        total_str = g_strdup_printf (\"  language: %s\\n\", str);\n        gtk_text_buffer_insert_at_cursor (text, total_str, -1);\n        g_free (total_str);\n        g_free (str);\n      }\n      gst_tag_list_free (tags);\n    }\n  }\n}\n\n/* This function is called when an \"application\" message is posted on the bus.\n * Here we retrieve the message posted by the tags_cb callback */\nstatic void application_cb (GstBus *bus, GstMessage *msg, CustomData *data) {\n  if (g_strcmp0 (gst_structure_get_name (gst_message_get_structure (msg)), \"tags-changed\") == 0) {\n    /* If the message is the \"tags-changed\" (only one we are currently issuing), update\n     * the stream info GUI */\n    analyze_streams (data);\n  }\n}\n\nint main(int argc, char *argv[]) {\n  CustomData data;\n  GstStateChangeReturn ret;\n  GstBus *bus;\n\n  /* Initialize GTK */\n  gtk_init (&amp;argc, &amp;argv);\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* Initialize our data structure */\n  memset (&amp;data, 0, sizeof (data));\n  data.duration = GST_CLOCK_TIME_NONE;\n\n  /* Create the elements */\n  data.playbin = gst_element_factory_make (\"playbin\", \"playbin\");\n\n  if (!data.playbin) {\n    g_printerr (\"Not all elements could be created.\\n\");\n    return -1;\n  }\n\n  /* Set the URI to play */\n  g_object_set (data.playbin, \"uri\", \"https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm\", NULL);\n\n  /* Connect to interesting signals in playbin */\n  g_signal_connect (G_OBJECT (data.playbin), \"video-tags-changed\", (GCallback) tags_cb, &amp;data);\n  g_signal_connect (G_OBJECT (data.playbin), \"audio-tags-changed\", (GCallback) tags_cb, &amp;data);\n  g_signal_connect (G_OBJECT (data.playbin), \"text-tags-changed\", (GCallback) tags_cb, &amp;data);\n\n  /* Create the GUI */\n  create_ui (&amp;data);\n\n  /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */\n  bus = gst_element_get_bus (data.playbin);\n  gst_bus_add_signal_watch (bus);\n  g_signal_connect (G_OBJECT (bus), \"message::error\", (GCallback)error_cb, &amp;data);\n  g_signal_connect (G_OBJECT (bus), \"message::eos\", (GCallback)eos_cb, &amp;data);\n  g_signal_connect (G_OBJECT (bus), \"message::state-changed\", (GCallback)state_changed_cb, &amp;data);\n  g_signal_connect (G_OBJECT (bus), \"message::application\", (GCallback)application_cb, &amp;data);\n  gst_object_unref (bus);\n\n  /* Start playing */\n  ret = gst_element_set_state (data.playbin, GST_STATE_PLAYING);\n  if (ret == GST_STATE_CHANGE_FAILURE) {\n    g_printerr (\"Unable to set the pipeline to the playing state.\\n\");\n    gst_object_unref (data.playbin);\n    return -1;\n  }\n\n  /* Register a function that GLib will call every second */\n  g_timeout_add_seconds (1, (GSourceFunc)refresh_ui, &amp;data);\n\n  /* Start the GTK main loop. We will not regain control until gtk_main_quit is called. */\n  gtk_main ();\n\n  /* Free resources */\n  gst_element_set_state (data.playbin, GST_STATE_NULL);\n  gst_object_unref (data.playbin);\n  return 0;\n}\n</code></pre>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"Information\" id=\"information1\">\nNeed help?</p>\n<p>If you need help to compile this code, refer to the <strong>Building the tutorials</strong>  section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Build\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Build\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Build\">Windows</a>, or use this specific command on Linux:</p>\n<p><code>gcc basic-tutorial-5.c -o basic-tutorial-5 `pkg-config --cflags --libs gstreamer-interfaces-1.0 gtk+-3.0 gstreamer-1.0</code></p>\n<p>If you need help to run this code, refer to the <strong>Running the tutorials</strong> section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Run\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Run\">Mac OS X</a> or <a href=\"../../installing/on-windows.html#InstallingonWindows-Run\">Windows</a>.</p>\n<p>This tutorial opens a GTK+ window and displays a movie, with accompanying audio. The media is fetched from the Internet, so the window might take a few seconds to appear, depending on your connection speed. The Window has some GTK+ buttons to Pause, Stop and Play the movie, and a slider to show the current position of the stream, which can be dragged to change it. Also, information about the stream is shown on a column at the right edge of the window.</p>\n<p>Bear in mind that there is no latency management (buffering), so on slow connections, the movie might stop after a few seconds. See how <a href=\"streaming.html\">Basic tutorial 12: Streaming</a> solves this issue.</p>\n<p>Required libraries: <code>gstreamer-video-1.0 gtk+-3.0 gstreamer-1.0</code></p>\n</blockquote>\n<h2 id=\"walkthrough\">Walkthrough</h2>\n<p>Regarding this tutorial's structure, we are not going to use forward\nfunction definitions anymore: Functions will be defined before they are\nused. Also, for clarity of explanation, the order in which the snippets\nof code are presented will not always match the program order. Use the\nline numbers to locate the snippets in the complete code.</p>\n<pre><code class=\"language-c\">#include &lt;gdk/gdk.h&gt;\n#if defined (GDK_WINDOWING_X11)\n#include &lt;gdk/gdkx.h&gt;\n#elif defined (GDK_WINDOWING_WIN32)\n#include &lt;gdk/gdkwin32.h&gt;\n#elif defined (GDK_WINDOWING_QUARTZ)\n#include &lt;gdk/gdkquartzwindow.h&gt;\n#endif\n</code></pre>\n<p>The first thing worth noticing is that we are no longer completely\nplatform-independent. We need to include the appropriate GDK headers for\nthe windowing system we are going to use. Fortunately, there are not\nthat many supported windowing systems, so these three lines often\nsuffice: X11 for Linux, Win32 for Windows and Quartz for Mac OSX.</p>\n<p>This tutorial is composed mostly of callback functions, which will be\ncalled from GStreamer or GTK+, so let's review the <code>main</code> function,\nwhich registers all these callbacks.</p>\n<pre><code class=\"language-c\">int main(int argc, char *argv[]) {\n  CustomData data;\n  GstStateChangeReturn ret;\n  GstBus *bus;\n\n  /* Initialize GTK */\n  gtk_init (&amp;argc, &amp;argv);\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* Initialize our data structure */\n  memset (&amp;data, 0, sizeof (data));\n  data.duration = GST_CLOCK_TIME_NONE;\n\n  /* Create the elements */\n  data.playbin = gst_element_factory_make (\"playbin\", \"playbin\");\n\n  if (!data.playbin) {\n    g_printerr (\"Not all elements could be created.\\n\");\n    return -1;\n  }\n\n  /* Set the URI to play */\n  g_object_set (data.playbin, \"uri\", \"https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm\", NULL);\n</code></pre>\n<p>Standard GStreamer initialization and playbin pipeline creation, along\nwith GTK+ initialization. Not much new.</p>\n<pre><code class=\"language-c\">  /* Connect to interesting signals in playbin */\n  g_signal_connect (G_OBJECT (data.playbin), \"video-tags-changed\", (GCallback) tags_cb, &amp;data);\n  g_signal_connect (G_OBJECT (data.playbin), \"audio-tags-changed\", (GCallback) tags_cb, &amp;data);\n  g_signal_connect (G_OBJECT (data.playbin), \"text-tags-changed\", (GCallback) tags_cb, &amp;data);\n</code></pre>\n<p>We are interested in being notified when new tags (metadata) appears on\nthe stream. For simplicity, we are going to handle all kinds of tags\n(video, audio and text) from the same callback <code>tags_cb</code>.</p>\n<pre><code class=\"language-c\">/* Create the GUI */\ncreate_ui (&amp;data);\n</code></pre>\n<p>All GTK+ widget creation and signal registration happens in this\nfunction. It contains only GTK-related function calls, so we will skip\nover its definition. The signals to which it registers convey user\ncommands, as shown below when reviewing the\ncallbacks.</p>\n<pre><code class=\"language-c\">  /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */\n  bus = gst_element_get_bus (data.playbin);\n  gst_bus_add_signal_watch (bus);\n  g_signal_connect (G_OBJECT (bus), \"message::error\", (GCallback)error_cb, &amp;data);\n  g_signal_connect (G_OBJECT (bus), \"message::eos\", (GCallback)eos_cb, &amp;data);\n  g_signal_connect (G_OBJECT (bus), \"message::state-changed\", (GCallback)state_changed_cb, &amp;data);\n  g_signal_connect (G_OBJECT (bus), \"message::application\", (GCallback)application_cb, &amp;data);\n  gst_object_unref (bus);\n</code></pre>\n<p>In <a href=\"../playback/playbin-usage.html\">Playback tutorial 1: Playbin usage</a>, <code>gst_bus_add_watch()</code> is\nused to register a function that receives every message posted to the\nGStreamer bus. We can achieve a finer granularity by using signals\ninstead, which allow us to register only to the messages we are\ninterested in. By calling <code>gst_bus_add_signal_watch()</code> we instruct the\nbus to emit a signal every time it receives a message. This signal has\nthe name <code>message::detail</code> where <em><code>detail</code></em> is the message that\ntriggered the signal emission. For example, when the bus receives the\nEOS message, it emits a signal with the name <code>message::eos</code>.</p>\n<p>This tutorial is using the <code>Signals</code>'s details to register only to the\nmessages we care about. If we had registered to the <code>message</code> signal, we\nwould be notified of every single message, just like\n<code>gst_bus_add_watch()</code> would do.</p>\n<p>Keep in mind that, in order for the bus watches to work (be it a\n<code>gst_bus_add_watch()</code> or a <code>gst_bus_add_signal_watch()</code>), there must be\nGLib <code>Main Loop</code> running. In this case, it is hidden inside the\n<a href=\"http://www.gtk.org/\">GTK+</a> main loop.</p>\n<pre><code class=\"language-c\">/* Register a function that GLib will call every second */\ng_timeout_add_seconds (1, (GSourceFunc)refresh_ui, &amp;data);\n</code></pre>\n<p>Before transferring control to GTK+, we use <code>g_timeout_add_seconds ()</code> to register yet another callback, this time with a timeout, so it\ngets called every second. We are going to use it to refresh the GUI from\nthe <code>refresh_ui</code> function.</p>\n<p>After this, we are done with the setup and can start the GTK+ main loop.\nWe will regain control from our callbacks when interesting things\nhappen. Let's review the callbacks. Each callback has a different\nsignature, depending on who will call it. You can look up the signature\n(the meaning of the parameters and the return value) in the\ndocumentation of the signal.</p>\n<pre><code class=\"language-c\">/* This function is called when the GUI toolkit creates the physical window that will hold the video.\n * At this point we can retrieve its handler (which has a different meaning depending on the windowing system)\n * and pass it to GStreamer through the VideoOverlay interface. */\nstatic void realize_cb (GtkWidget *widget, CustomData *data) {\n  GdkWindow *window = gtk_widget_get_window (widget);\n  guintptr window_handle;\n\n  if (!gdk_window_ensure_native (window))\n    g_error (\"Couldn't create native window needed for GstVideoOverlay!\");\n\n  /* Retrieve window handler from GDK */\n#if defined (GDK_WINDOWING_WIN32)\n  window_handle = (guintptr)GDK_WINDOW_HWND (window);\n#elif defined (GDK_WINDOWING_QUARTZ)\n  window_handle = gdk_quartz_window_get_nsview (window);\n#elif defined (GDK_WINDOWING_X11)\n  window_handle = GDK_WINDOW_XID (window);\n#endif\n  /* Pass it to playbin, which implements VideoOverlay and will forward it to the video sink */\n  gst_video_overlay_set_window_handle (GST_VIDEO_OVERLAY (data-&gt;playbin), window_handle);\n}\n</code></pre>\n<p>The code comments talks by itself. At this point in the life cycle of\nthe application, we know the handle (be it an X11's <code>XID</code>, a Window's\n<code>HWND</code> or a Quartz's <code>NSView</code>) of the window where GStreamer should\nrender the video. We simply retrieve it from the windowing system and\npass it to <code>playbin</code> through the <code>GstVideoOverlay</code> interface using\n<code>gst_video_overlay_set_window_handle()</code>. <code>playbin</code> will locate the video\nsink and pass the handler to it, so it does not create its own window\nand uses this one.</p>\n<p>Not much more to see here; <code>playbin</code> and the <code>GstVideoOverlay</code> really simplify\nthis process a lot!</p>\n<pre><code class=\"language-c\">/* This function is called when the PLAY button is clicked */\nstatic void play_cb (GtkButton *button, CustomData *data) {\n  gst_element_set_state (data-&gt;playbin, GST_STATE_PLAYING);\n}\n\n/* This function is called when the PAUSE button is clicked */\nstatic void pause_cb (GtkButton *button, CustomData *data) {\n  gst_element_set_state (data-&gt;playbin, GST_STATE_PAUSED);\n}\n\n/* This function is called when the STOP button is clicked */\nstatic void stop_cb (GtkButton *button, CustomData *data) {\n  gst_element_set_state (data-&gt;playbin, GST_STATE_READY);\n}\n</code></pre>\n<p>These three little callbacks are associated with the PLAY, PAUSE and\nSTOP buttons in the GUI. They simply set the pipeline to the\ncorresponding state. Note that in the STOP state we set the pipeline to\n<code>READY</code>. We could have brought the pipeline all the way down to the\n<code>NULL</code> state, but, the transition would then be a little slower, since some\nresources (like the audio device) would need to be released and\nre-acquired.</p>\n<pre><code class=\"language-c\">/* This function is called when the main window is closed */\nstatic void delete_event_cb (GtkWidget *widget, GdkEvent *event, CustomData *data) {\n  stop_cb (NULL, data);\n  gtk_main_quit ();\n}\n</code></pre>\n<p>gtk_main_quit() will eventually make the call to to gtk_main_run()\nin <code>main</code> to terminate, which, in this case, finishes the program. Here,\nwe call it when the main window is closed, after stopping the pipeline\n(just for the sake of tidiness).</p>\n<pre><code class=\"language-c\">/* This function is called everytime the video window needs to be redrawn (due to damage/exposure,\n * rescaling, etc). GStreamer takes care of this in the PAUSED and PLAYING states, otherwise,\n * we simply draw a black rectangle to avoid garbage showing up. */\nstatic gboolean expose_cb (GtkWidget *widget, GdkEventExpose *event, CustomData *data) {\n  if (data-&gt;state &lt; GST_STATE_PAUSED) {\n    GtkAllocation allocation;\n    GdkWindow *window = gtk_widget_get_window (widget);\n    cairo_t *cr;\n\n    /* Cairo is a 2D graphics library which we use here to clean the video window.\n     * It is used by GStreamer for other reasons, so it will always be available to us. */\n    gtk_widget_get_allocation (widget, &amp;allocation);\n    cr = gdk_cairo_create (window);\n    cairo_set_source_rgb (cr, 0, 0, 0);\n    cairo_rectangle (cr, 0, 0, allocation.width, allocation.height);\n    cairo_fill (cr);\n  }\n\n  return FALSE;\n}\n</code></pre>\n<p>When there is data flow (in the <code>PAUSED</code> and <code>PLAYING</code> states) the video\nsink takes care of refreshing the content of the video window. In the\nother cases, however, it will not, so we have to do it. In this example,\nwe just fill the window with a black\nrectangle.</p>\n<pre><code class=\"language-c\">/* This function is called when the slider changes its position. We perform a seek to the\n * new position here. */\nstatic void slider_cb (GtkRange *range, CustomData *data) {\n  gdouble value = gtk_range_get_value (GTK_RANGE (data-&gt;slider));\n  gst_element_seek_simple (data-&gt;playbin, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT,\n      (gint64)(value * GST_SECOND));\n}\n</code></pre>\n<p>This is an example of how a complex GUI element like a seeker bar (or\nslider that allows seeking) can be very easily implemented thanks to\nGStreamer and GTK+ collaborating. If the slider has been dragged to a\nnew position, tell GStreamer to seek to that position\nwith <code>gst_element_seek_simple()</code> (as seen in <a href=\"time-management.html\">Basic tutorial 4: Time\nmanagement</a>). The\nslider has been setup so its value represents seconds.</p>\n<p>It is worth mentioning that some performance (and responsiveness) can be\ngained by doing some throttling, this is, not responding to every single\nuser request to seek. Since the seek operation is bound to take some\ntime, it is often nicer to wait half a second (for example) after a seek\nbefore allowing another one. Otherwise, the application might look\nunresponsive if the user drags the slider frantically, which would not\nallow any seek to complete before a new one is queued.</p>\n<pre><code class=\"language-c\">/* This function is called periodically to refresh the GUI */\nstatic gboolean refresh_ui (CustomData *data) {\n  gint64 current = -1;\n\n  /* We do not want to update anything unless we are in the PAUSED or PLAYING states */\n  if (data-&gt;state &lt; GST_STATE_PAUSED)\n    return TRUE;\n</code></pre>\n<p>This function will move the slider to reflect the current position of\nthe media. First off, if we are not in the <code>PLAYING</code> state, we have\nnothing to do here (plus, position and duration queries will normally\nfail).</p>\n<pre><code class=\"language-c\">/* If we didn't know it yet, query the stream duration */\nif (!GST_CLOCK_TIME_IS_VALID (data-&gt;duration)) {\n  if (!gst_element_query_duration (data-&gt;playbin, GST_FORMAT_TIME, &amp;data-&gt;duration)) {\n    g_printerr (\"Could not query current duration.\\n\");\n  } else {\n    /* Set the range of the slider to the clip duration, in SECONDS */\n    gtk_range_set_range (GTK_RANGE (data-&gt;slider), 0, (gdouble)data-&gt;duration / GST_SECOND);\n  }\n}\n</code></pre>\n<p>We recover the duration of the clip if we didn't know it, so we can set\nthe range for the slider.</p>\n<pre><code class=\"language-c\">if (gst_element_query_position (data-&gt;playbin, GST_FORMAT_TIME, &amp;current)) {\n  /* Block the \"value-changed\" signal, so the slider_cb function is not called\n   * (which would trigger a seek the user has not requested) */\n  g_signal_handler_block (data-&gt;slider, data-&gt;slider_update_signal_id);\n  /* Set the position of the slider to the current pipeline positoin, in SECONDS */\n  gtk_range_set_value (GTK_RANGE (data-&gt;slider), (gdouble)current / GST_SECOND);\n  /* Re-enable the signal */\n  g_signal_handler_unblock (data-&gt;slider, data-&gt;slider_update_signal_id);\n}\nreturn TRUE;\n</code></pre>\n<p>We query the current pipeline position, and set the position of the\nslider accordingly. This would trigger the emission of the\n<code>value-changed</code> signal, which we use to know when the user is dragging\nthe slider. Since we do not want seeks happening unless the user\nrequested them, we disable the <code>value-changed</code> signal emission during\nthis operation with <code>g_signal_handler_block()</code> and\n<code>g_signal_handler_unblock()</code>.</p>\n<p>Returning TRUE from this function will keep it called in the future. If\nwe return FALSE, the timer will be\nremoved.</p>\n<pre><code class=\"language-c\">/* This function is called when new metadata is discovered in the stream */\nstatic void tags_cb (GstElement *playbin, gint stream, CustomData *data) {\n  /* We are possibly in a GStreamer working thread, so we notify the main\n   * thread of this event through a message in the bus */\n  gst_element_post_message (playbin,\n    gst_message_new_application (GST_OBJECT (playbin),\n      gst_structure_new_empty (\"tags-changed\")));\n}\n</code></pre>\n<p>This is one of the key points of this tutorial. This function will be\ncalled when new tags are found in the media, <strong>from a streaming\nthread</strong>, this is, from a thread other than the application (or main)\nthread. What we want to do here is to update a GTK+ widget to reflect\nthis new information, but <strong>GTK+ does not allow operating from threads\nother than the main one</strong>.</p>\n<p>The solution is to make <code>playbin</code> post a message on the bus and return\nto the calling thread. When appropriate, the main thread will pick up\nthis message and update GTK.</p>\n<p><code>gst_element_post_message()</code> makes a GStreamer element post the given\nmessage to the bus. <code>gst_message_new_application()</code> creates a new\nmessage of the <code>APPLICATION</code> type. GStreamer messages have different\ntypes, and this particular type is reserved to the application: it will\ngo through the bus unaffected by GStreamer. The list of types can be\nfound in the <code>GstMessageType</code> documentation.</p>\n<p>Messages can deliver additional information through their embedded\n<code>GstStructure</code>, which is a very flexible data container. Here, we create\na new structure with <code>gst_structure_new</code>, and name it <code>tags-changed</code>, to\navoid confusion in case we wanted to send other application messages.</p>\n<p>Later, once in the main thread, the bus will receive this message and\nemit the <code>message::application</code> signal, which we have associated to the\n<code>application_cb</code> function:</p>\n<pre><code class=\"language-c\">/* This function is called when an \"application\" message is posted on the bus.\n * Here we retrieve the message posted by the tags_cb callback */\nstatic void application_cb (GstBus *bus, GstMessage *msg, CustomData *data) {\n  if (g_strcmp0 (gst_structure_get_name (gst_message_get_structure (msg)), \"tags-changed\") == 0) {\n    /* If the message is the \"tags-changed\" (only one we are currently issuing), update\n     * the stream info GUI */\n    analyze_streams (data);\n  }\n}\n</code></pre>\n<p>Once me made sure it is the <code>tags-changed</code> message, we call the\n<code>analyze_streams</code> function, which is also used in <a href=\"../playback/playbin-usage.html\">Playback tutorial 1: Playbin usage</a> and is\nmore detailed there. It basically recovers the tags from the stream and\nwrites them in a text widget in the GUI.</p>\n<p>The <code>error_cb</code>, <code>eos_cb</code> and <code>state_changed_cb</code> are not really worth\nexplaining, since they do the same as in all previous tutorials, but\nfrom their own function now.</p>\n<p>And this is it! The amount of code in this tutorial might seem daunting\nbut the required concepts are few and easy. If you have followed the\nprevious tutorials and have a little knowledge of GTK, you probably\nunderstood this one can now enjoy your very own media player!</p>\n<p><img src=\"images/tutorials/basic-tutorial-5.png\" alt=\"\"></p>\n<h2 id=\"exercise\">Exercise</h2>\n<p>If this media player is not good enough for you, try to change the text\nwidget that displays the information about the streams into a proper\nlist view (or tree view). Then, when the user selects a different\nstream, make GStreamer switch streams! To switch streams, you will need\nto read <a href=\"../playback/playbin-usage.html\">Playback tutorial 1: Playbin usage</a>.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial has shown:</p>\n<ul>\n<li>\n<p>How to output the video to a particular window handle\nusing <code>gst_video_overlay_set_window_handle()</code>.</p>\n</li>\n<li>\n<p>How to refresh the GUI periodically by registering a timeout\ncallback with <code>g_timeout_add_seconds ()</code>.</p>\n</li>\n<li>\n<p>How to convey information to the main thread by means of application\nmessages through the bus with <code>gst_element_post_message()</code>.</p>\n</li>\n<li>\n<p>How to be notified only of interesting messages by making the bus\nemit signals with <code>gst_bus_add_signal_watch()</code> and discriminating\namong all message types using the signal details.</p>\n</li>\n</ul>\n<p>This allows you to build a somewhat complete media player with a proper\nGraphical User Interface.</p>\n<p>The following basic tutorials keep focusing on other individual\nGStreamer topics</p>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n        \n\n    </div>\n\n\n        "});