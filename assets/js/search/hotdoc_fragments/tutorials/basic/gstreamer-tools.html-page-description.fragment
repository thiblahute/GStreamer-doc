fragment_downloaded_cb({"url": "tutorials/basic/gstreamer-tools.html#page-description", "fragment": "GStreamer comes with a set of tools which range from handy to absolutely essential. There is no code in this tutorial just sit back and relax and we will teach you \nThese tools are available in the bin directory of the GStreamer binaries. You need to move to this directory to execute them because it is not added to the system s PATH environment variable to avoid polluting it too much \nJust open a terminal or console window and go to the bin directory of your GStreamer installation Read again the Installing GStreamer section to find our where this is and you are ready to start typing the commands given in this tutorial. \n\nOn Linux you should use the GStreamer version installed with your distribution the tools should be installed with a package named gstreamer1 on Fedora style distributions or gstreamer1.0 tools on Debian Ubuntu style distributions. \nIn order to allow for multiple versions of GStreamer to coexists in the same system these tools are versioned this is a GStreamer version number is appended to their name. This version is based on GStreamer so the tools are called gst launch gst inspect and gst discoverer \nThis tool accepts a textual description of a pipeline instantiates it and sets it to the PLAYING state. It allows you to quickly check if a given pipeline works before going through the actual implementation using GStreamer API calls. \nBear in mind that it can only create simple pipelines. In particular it can only simulate the interaction of the pipeline with the application up to a certain level. In any case it is extremely handy to test pipelines quickly and is used by GStreamer developers around the world on a daily basis. \nPlease note that gst launch is primarily a debugging tool for developers. You should not build applications on top of it. Instead use the gst_parse_launch function of the GStreamer API as an easy way to construct pipelines from pipeline descriptions. \nAlthough the rules to construct pipeline descriptions are very simple the concatenation of multiple elements can quickly make such descriptions resemble black magic. Fear not for everyone learns the gst launch syntax eventually. \nThe command line for gst launch consists of a list of options followed by a PIPELINE DESCRIPTION. Some simplified instructions are given next se the complete documentation at the reference page for gst launch \nIn simple form a PIPELINE DESCRIPTION is a list of element types separated by exclamation marks Go ahead and type in the following command \nYou should see a windows with an animated video pattern. Use CTRL C on the terminal to stop the program. \nThis instantiates a new element of type videotestsrc an element which generates a sample video pattern an videoconvert an element which does raw video format conversion making sure other elements can understand each other and an autovideosink a window to which video is rendered Then GStreamer tries to link the output of each element to the input of the element appearing on its right in the description. If more than one input or output Pad is available the Pad Caps are used to find two compatible Pads. \nProperties may be appended to elements in the form property value multiple properties can be specified separated by spaces Use the gst inspect tool explained next to find out the available properties for an element. \nYou should see a static video pattern made of circles. \nElements can be named using the name property in this way complex pipelines involving branches can be created. Names allow linking to elements created previously in the description and are indispensable to use elements with multiple output pads like demuxers or tees for example. \nNamed elements are referred to using their name followed by a dot. \nYou should see two video windows showing the same sample video pattern. If you see only one try to move it since it is probably on top of the second window. \nThis example instantiates a videotestsrc linked to a videoconvert linked to a tee Remember from Basic tutorial Multithreading and Pad Availability that a tee copies to each of its output pads everything coming through its input pad The tee is named simply t using the name property and then linked to a queue and an autovideosink. The same tee is referred to using t. mind the dot and then linked to a second queue and a second autovideosink. \nTo learn why the queues are necessary read Basic tutorial Multithreading and Pad Availability. \nInstead of letting GStreamer choose which Pad to use when linking two elements you may want to specify the Pads directly. You can do this by adding a dot plus the Pad name after the name of the element it must be a named element Learn the names of the Pads of an element by using the gst inspect tool. \nThis is useful for example when you want to retrieve one particular stream out of a demuxer \nThis fetches a media file from the internet using souphttpsrc which is in webm format a special kind of Matroska container see Basic tutorial GStreamer concepts We then open the container using matroskademux. This media contains both audio and video so matroskademux will create two output Pads named video_00 and audio_00. We link video_00 to a matroskamux element to re pack the video stream into a new container and finally link it to a filesink which will write the stream into a file named sintel_video.mkv the location property specifies the name of the file \nAll in all we took a webm file stripped it of audio and generated a new matroska file with the video. If we wanted to keep only the audio \nThe vorbisparse element is required to extract some information from the stream and put it in the Pad Caps so the next element matroskamux knows how to deal with the stream. In the case of video this was not necessary because matroskademux already extracted this information and added it to the Caps. \nNote that in the above two examples no media has been decoded or played. We have just moved from one container to another demultiplexing and re multiplexing again \nWhen an element has more than one output pad it might happen that the link to the next element is ambiguous the next element may have more than one compatible input pad or its input pad may be compatible with the Pad Caps of all the output pads. In these cases GStreamer will link using the first pad that is available which pretty much amounts to saying that GStreamer will choose one output pad at random. \nConsider the following pipeline \nThis is the same media file and demuxer as in the previous example. The input Pad Caps of filesink are ANY meaning that it can accept any kind of media. Which one of the two output pads of matroskademux will be linked against the filesink video_00 or audio_00 You cannot know. \nYou can remove this ambiguity though by using named pads as in the previous sub section or by using Caps Filters \nA Caps Filter behaves like a pass through element which does nothing and only accepts media with the given Caps effectively resolving the ambiguity. In this example between matroskademux and matroskamux we added a video x vp8 Caps Filter to specify that we are interested in the output pad of matroskademux which can produce this kind of video. \nTo find out the Caps an element accepts and produces use the gst inspect tool. To find out the Caps contained in a particular file use the gst discoverer tool. To find out the Caps an element is producing for a particular pipeline run gst launch as usual with the v option to print Caps information. \nPlay a media file using playbin as in Basic tutorial Hello world \nA fully operation playback pipeline with audio and video more or less the same pipeline that playbin will create internally \nA transcoding pipeline which opens the webm container and decodes both streams via uridecodebin then re encodes the audio and video branches with a different codec and puts them back together in an Ogg container just for the sake of it \nA rescaling pipeline. The videoscale element performs a rescaling operation whenever the frame size is different in the input and the output caps. The output caps are set by the Caps Filter to x200. \nThis short description of gst launch should be enough to get you started. Remember that you have the complete documentation available here. \nThis tool has three modes of operation \nLet s see an example of the third mode \nThe most relevant sections are \nFor more information you can check the documentation page of gst inspect \nThis tool is a wrapper around the GstDiscoverer object shown in Basic tutorial Media information gathering. It accepts a URI from the command line and prints all information regarding the media that GStreamer can extract. It is useful to find out what container and codecs have been used to produce the media and therefore what elements you need to put in a pipeline to play it. \nUse gst discoverer help to obtain the list of available options which basically control the amount of verbosity of the output. \nLet s see an example \nThis tutorial has shown \nIt has been a pleasure having you here and see you soon \n"});