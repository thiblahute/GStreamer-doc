fragment_downloaded_cb({"url": "tutorials/basic/hello-world.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"hello-world.md\">\n        <h1 id=\"basic-tutorial-1-hello-world\">Basic tutorial 1: Hello world!</h1>\n<h2 id=\"goal\">Goal</h2>\n<p>Nothing better to get a first impression about a software library than\nto print \u201cHello World\u201d on the screen!</p>\n<p>But since we are dealing with multimedia frameworks, we are going to\nplay a video instead.</p>\n<p>Do not be scared by the amount of code below: there are only 4 lines\nwhich do <em>real</em> work. The rest is cleanup code, and, in C, this is\nalways a bit verbose.</p>\n<p>Without further ado, get ready for your first GStreamer application...</p>\n<h2 id=\"hello-world\">Hello world</h2>\n<p>Copy this code into a text file named <code>basic-tutorial-1.c</code> (or find it\nin the SDK installation).</p>\n<p><strong>basic-tutorial-1.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n\nint main(int argc, char *argv[]) {\n  GstElement *pipeline;\n  GstBus *bus;\n  GstMessage *msg;\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* Build the pipeline */\n  pipeline = gst_parse_launch (\"playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm\", NULL);\n\n  /* Start playing */\n  gst_element_set_state (pipeline, GST_STATE_PLAYING);\n\n  /* Wait until error or EOS */\n  bus = gst_element_get_bus (pipeline);\n  msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS);\n\n  /* Free resources */\n  if (msg != NULL)\n    gst_message_unref (msg);\n  gst_object_unref (bus);\n  gst_element_set_state (pipeline, GST_STATE_NULL);\n  gst_object_unref (pipeline);\n  return 0;\n}\n\n</code></pre>\n<p>Compile it as described in <a href=\"../../installing/on-linux.html\">Installing on Linux</a>, <a href=\"../../installing/on-mac-osx.html\">Installing on Mac OS\nX</a> or <a href=\"../../installing/on-windows.html\">Installing on Windows</a>. If you get compilation errors,\ndouble-check the instructions given in those sections.</p>\n<p>If everything built fine, fire up the executable! You should see a\nwindow pop up, containing a video being played straight from the\nInternet, along with audio. Congratulations!</p>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"Information\" id=\"information\"> Need help?</p>\n<p>If you need help to compile this code, refer to the <strong>Building the\ntutorials</strong> section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Build\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Build\">Mac OS X</a> or\n<a href=\"../../installing/on-windows.html#InstallingonWindows-Build\">Windows</a>, or use this specific command on Linux:</p>\n<p><code>gcc basic-tutorial-1.c -o basic-tutorial-1 `pkg-config --cflags --libs gstreamer-1.0`</code></p>\n<p>If you need help to run this code, refer to the <strong>Running the\ntutorials</strong> section for your platform: <a href=\"../../installing/on-linux.html#InstallingonLinux-Run\">Linux</a>, <a href=\"../../installing/on-mac-osx.html#InstallingonMacOSX-Run\">Mac OS X</a> or\n<a href=\"../../installing/on-windows.html#InstallingonWindows-Run\">Windows</a>.</p>\n<p>This tutorial opens a window and displays a movie, with accompanying\naudio. The media is fetched from the Internet, so the window might\ntake a few seconds to appear, depending on your connection speed.\nAlso, there is no latency management (buffering), so on slow\nconnections, the movie might stop after a few seconds. See how <a href=\"streaming.html\">Basic\ntutorial 12: Streaming</a> solves this issue.</p>\n<p>Required libraries: <code>gstreamer-1.0</code></p>\n</blockquote>\n<h2 id=\"walkthrough\">Walkthrough</h2>\n<p>Let's review these lines of code and see what they do:</p>\n<pre><code class=\"language-c\">    /* Initialize GStreamer */\n    gst_init (&amp;argc, &amp;argv);\n</code></pre>\n<p>This must always be your first GStreamer command. Among other things,\n<code>gst_init()</code>:</p>\n<ul>\n<li>\n<p>Initializes all internal structures</p>\n</li>\n<li>\n<p>Checks what plug-ins are available</p>\n</li>\n<li>\n<p>Executes any command-line option intended for GStreamer</p>\n</li>\n</ul>\n<p>If you always pass your command-line parameters\n<code>argc</code> and <code>argv</code> to <code>gst_init()</code> your application will automatically\nbenefit from the GStreamer standard command-line options (more on this\nin <a href=\"gstreamer-tools.html\">Basic tutorial 10: GStreamer tools</a>)</p>\n<pre><code class=\"language-c\">    /* Build the pipeline */\n    pipeline = gst_parse_launch (\"playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm\", NULL);\n</code></pre>\n<p>This line is the heart of this tutorial, and exemplifies <strong>two</strong> key\npoints: <code>gst_parse_launch()</code> and <code>playbin</code>.</p>\n<h3 id=\"gst_parse_launch\">gst_parse_launch</h3>\n<p>GStreamer is a framework designed to handle multimedia flows. Media\ntravels from the \u201csource\u201d elements (the producers), down to the \u201csink\u201d\nelements (the consumers), passing through a series of intermediate\nelements performing all kinds of tasks. The set of all the\ninterconnected elements is called a \u201cpipeline\u201d.</p>\n<p>In GStreamer you usually build the pipeline by manually assembling the\nindividual elements, but, when the pipeline is easy enough, and you do\nnot need any advanced features, you can take the shortcut:\n<code>gst_parse_launch()</code>.</p>\n<p>This function takes a textual representation of a pipeline and turns it\ninto an actual pipeline, which is very handy. In fact, this function is\nso handy there is a tool built completely around it which you will get\nvery acquainted with (see <a href=\"gstreamer-tools.html\">Basic tutorial 10: GStreamer tools</a> to learn about <code>gst-launch-1.0</code> and the\n<code>gst-launch-1.0</code> syntax).</p>\n<h3 id=\"playbin\">playbin</h3>\n<p>So, what kind of pipeline are we asking <code>gst_parse_launch()</code>to build for\nus? Here enters the second key point: We are building a pipeline\ncomposed of a single element called <code>playbin</code>.</p>\n<p><code>playbin</code> is a special element which acts as a source and as a sink, and\nis a whole pipeline. Internally, it creates and connects all the\nnecessary elements to play your media, so you do not have to worry about\nit.</p>\n<p>It does not allow the control granularity that a manual pipeline does,\nbut, still, it permits enough customization to suffice for a wide range\nof applications. Including this tutorial.</p>\n<p>In this example, we are only passing one parameter to <code>playbin</code>, which\nis the URI of the media we want to play. Try changing it to something\nelse! Whether it is an <code>http://</code> or <code>file://</code> URI, <code>playbin</code> will\ninstantiate the appropriate GStreamer source transparently!</p>\n<p>If you mistype the URI, or the file does not exist, or you are missing a\nplug-in, GStreamer provides several notification mechanisms, but the\nonly thing we are doing in this example is exiting on error, so do not\nexpect much feedback.</p>\n<pre><code class=\"language-c\">    /* Start playing */\n    gst_element_set_state (pipeline, GST_STATE_PLAYING);\n</code></pre>\n<p>This line highlights another interesting concept: the state. Every\nGStreamer element has an associated state, which you can more or less\nthink of as the Play/Pause button in your regular DVD player. For now,\nsuffice to say that playback will not start unless you set the pipeline\nto the PLAYING state.</p>\n<p>In this line, <code>gst_element_set_state()</code> is setting <code>pipeline</code> (our only\nelement, remember) to the PLAYING state, thus initiating playback.</p>\n<pre><code>\n``` c\n    /* Wait until error or EOS */\n    bus = gst_element_get_bus (pipeline);\n    gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS);\n</code></pre>\n<p>These lines will wait until an error occurs or the end of the stream is\nfound. <code>gst_element_get_bus()</code> retrieves the pipeline's bus, and\n<code>gst_bus_timed_pop_filtered()</code> will block until you receive either an\nERROR or an EOS (End-Of-Stream) through that bus. Do not worry much\nabout this line, the GStreamer bus is explained in <a href=\"concepts.html\">Basic tutorial 2:\nGStreamer concepts</a>.</p>\n<p>And that's it! From this point onwards, GStreamer takes care of\neverything. Execution will end when the media reaches its end (EOS) or\nan error is encountered (try closing the video window, or unplugging the\nnetwork cable). The application can always be stopped by pressing\ncontrol-C in the console.</p>\n<h3 id=\"cleanup\">Cleanup</h3>\n<p>Before terminating the application, though, there is a couple of things\nwe need to do to tidy up correctly after ourselves.</p>\n<pre><code class=\"language-c\">    /* Free resources */\n    if (msg != NULL)\n      gst_message_unref (msg);\n    gst_object_unref (bus);\n    gst_element_set_state (pipeline, GST_STATE_NULL);\n    gst_object_unref (pipeline);\n</code></pre>\n<p>Always read the documentation of the functions you use, to know if you\nshould free the objects they return after using them.</p>\n<p>In this case, <code>gst_bus_timed_pop_filtered()</code> returned a message which\nneeds to be freed with <code>gst_message_unref()</code> (more about messages in\n<a href=\"concepts.html\">Basic tutorial 2: GStreamer concepts</a>).</p>\n<p><code>gst_element_get_bus()</code> added a reference to the bus that must be freed\nwith <code>gst_object_unref()</code>. Setting the pipeline to the NULL state will\nmake sure it frees any resources it has allocated (More about states in\n<a href=\"dynamic-pipelines.html\">Basic tutorial 3: Dynamic pipelines</a>). Finally, unreferencing the\npipeline will destroy it, and all its contents.</p>\n<hr>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>And so ends your first tutorial with GStreamer. We hope its brevity\nserves as an example of how powerful this framework is!</p>\n<p>Let's recap a bit. Today we have learned:</p>\n<ul>\n<li>\n<p>How to initialize GStreamer using <code>gst_init()</code>.</p>\n</li>\n<li>\n<p>How to quickly build a pipeline from a textual description using\n<code>gst_parse_launch()</code>.</p>\n</li>\n<li>\n<p>How to create an automatic playback pipeline using <code>playbin</code>.</p>\n</li>\n<li>\n<p>How to signal GStreamer to start playback using\n<code>gst_element_set_state()</code>.</p>\n</li>\n<li>\n<p>How to sit back and relax, while GStreamer takes care of everything,\nusing <code>gst_element_get_bus()</code> and <code>gst_bus_timed_pop_filtered()</code>.</p>\n</li>\n</ul>\n<p>The next tutorial will keep introducing more basic GStreamer elements,\nand show you how to build a pipeline manually.</p>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n        \n\n    </div>\n\n\n        "});