fragment_downloaded_cb({"url": "tutorials/basic/short-cutting-the-pipeline.html#page-description", "fragment": "Pipelines constructed with GStreamer do not need to be completely closed. Data can be injected into the pipeline and extracted from it at any time in a variety of ways. This tutorial shows \nHow to inject external data into a general GStreamer pipeline. \nHow to extract data from a general GStreamer pipeline. \nHow to access and manipulate this data. \nPlayback tutorial Short cutting the pipeline explains how to achieve the same goals in a playbin based pipeline. \nApplications can interact with the data flowing through a GStreamer pipeline in several ways. This tutorial describes the easiest one since it uses elements that have been created for this sole purpose. \nThe element used to inject application data into a GStreamer pipeline is appsrc and its counterpart used to extract GStreamer data back to the application is appsink. To avoid confusing the names think of it from GStreamer s point of view appsrc is just a regular source that provides data magically fallen from the sky provided by the application actually appsink is a regular sink where the data flowing through a GStreamer pipeline goes to die it is recovered by the application actually \nappsrc and appsink are so versatile that they offer their own API see their documentation which can be accessed by linking against the gstreamer app library. In this tutorial however we will use a simpler approach and control them through signals. \nappsrc can work in a variety of modes in pull mode it requests data from the application every time it needs it. In push mode the application pushes data at its own pace. Furthermore in push mode the application can choose to be blocked in the push function when enough data has already been provided or it can listen to the enough data and need data signals to control flow. This example implements the latter approach. Information regarding the other methods can be found in the appsrc documentation. \nData travels through a GStreamer pipeline in chunks called buffers. Since this example produces and consumes data we need to know about GstBuffers. \nSource Pads produce buffers that are consumed by Sink Pads GStreamer takes these buffers and passes them from element to element. \nA buffer simply represents a unit of data do not assume that all buffers will have the same size or represent the same amount of time. Neither should you assume that if a single buffer enters an element a single buffer will come out. Elements are free to do with the received buffers as they please. GstBuffers may also contain more than one actual memory buffer. Actual memory buffers are abstracted away using GstMemory objects and a GstBuffer can contain multiple GstMemory objects. \nEvery buffer has attached time stamps and duration that describe in which moment the content of the buffer should be decoded rendered or displayed. Time stamping is a very complex and delicate subject but this simplified vision should suffice for now. \nAs an example a filesrc a GStreamer element that reads files produces buffers with the ANY caps and no time stamping information. After demuxing see Basic tutorial Dynamic pipelines buffers can have some specific caps for example video x h264 After decoding each buffer will contain a single video frame with raw caps for example video x raw yuv and very precise time stamps indicating when should that frame be displayed. \nThis tutorial expands Basic tutorial Multithreading and Pad Availability in two ways firstly the audiotestsrc is replaced by an appsrc that will generate the audio data. Secondly a new branch is added to the tee so data going into the audio sink and the wave display is also replicated into an appsink. The appsink uploads the information back into the application which then just notifies the user that data has been received but it could obviously perform more complex tasks. \n\nCopy this code into a text file named basic tutorial c or find it in your GStreamer installation \nNeed help \nIf you need help to compile this code refer to the Building the tutorials section for your platform Linux Mac OS X or Windows or use this specific command on Linux \ngcc basic tutorial c o basic tutorial pkg config cflags libs gstreamer gstreamer audio \nIf you need help to run this code refer to the Running the tutorials section for your platform Linux Mac OS X or Windows. \nThis tutorial plays an audible tone for varying frequency through the audio card and opens a window with a waveform representation of the tone. The waveform should be a sinusoid but due to the refreshing of the window might not appear so. \nRequired libraries gstreamer \nThe code to create the pipeline Lines to is an enlarged version of Basic tutorial Multithreading and Pad Availability. It involves instantiating all the elements link the elements with Always Pads and manually link the Request Pads of the tee element. \nRegarding the configuration of the appsrc and appsink elements \nThe first property that needs to be set on the appsrc is caps. It specifies the kind of data that the element is going to produce so GStreamer can check if linking with downstream elements is possible this is if the downstream elements will understand this kind of data This property must be a GstCaps object which is easily built from a string with gst_caps_from_string \nWe then connect to the need data and enough data signals. These are fired by appsrc when its internal queue of data is running low or almost full respectively. We will use these signals to start and stop respectively our signal generation process. \nRegarding the appsink configuration we connect to the new sample signal which is emitted every time the sink receives a buffer. Also the signal emission needs to be enabled through the emit signals property because by default it is disabled. \nStarting the pipeline waiting for messages and final cleanup is done as usual. Let s review the callbacks we have just registered \nThis function is called when the internal queue of appsrc is about to starve run out of data The only thing we do here is register a GLib idle function with g_idle_add that feeds data to appsrc until it is full again. A GLib idle function is a method that GLib will call from its main loop whenever it is idle this is when it has no higher priority tasks to perform. It requires a GLib GMainLoop to be instantiated and running obviously. \nThis is only one of the multiple approaches that appsrc allows. In particular buffers do not need to be fed into appsrc from the main thread using GLib and you do not need to use the need data and enough data signals to synchronize with appsrc although this is allegedly the most convenient \nWe take note of the sourceid that g_idle_add returns so we can disable it later. \nThis function is called when the internal queue of appsrc is full enough so we stop pushing data. Here we simply remove the idle function by using g_source_remove The idle function is implemented as a GSource \nThis is the function that feeds appsrc. It will be called by GLib at times and rates which are out of our control but we know that we will disable it when its job is done when the queue in appsrc is full \nIts first task is to create a new buffer with a given size in this example it is arbitrarily set to bytes with gst_buffer_new_and_alloc \nWe count the number of samples that we have generated so far with the CustomData.num_samples variable so we can time stamp this buffer using the GST_BUFFER_TIMESTAMP macro in GstBuffer. \nSince we are producing buffers of the same size their duration is the same and is set using the GST_BUFFER_DURATION in GstBuffer. \ngst_util_uint64_scale is a utility function that scales multiply and divide numbers which can be large without fear of overflows. \nThe bytes that for the buffer can be accessed with GST_BUFFER_DATA in GstBuffer Be careful not to write past the end of the buffer you allocated it so you know its size \nWe will skip over the waveform generation since it is outside the scope of this tutorial it is simply a funny way of generating a pretty psychedelic wave \nOnce we have the buffer ready we pass it to appsrc with the push buffer action signal see information box at the end of Playback tutorial Playbin usage and then gst_buffer_unref it since we no longer need it. \nFinally this is the function that gets called when the appsink receives a buffer. We use the pull sample action signal to retrieve the buffer and then just print some indicator on the screen. We can retrieve the data pointer using the GST_BUFFER_DATA macro and the data size using the GST_BUFFER_SIZE macro in GstBuffer. Remember that this buffer does not have to match the buffer that we produced in the push_data function any element in the path could have altered the buffers in any way Not in this example there is only a tee in the path between appsrc and appsink and it does not change the content of the buffers \nWe then gst_buffer_unref the buffer and this tutorial is done. \nThis tutorial has shown how applications can \nIn a playbin based pipeline the same goals are achieved in a slightly different way. Playback tutorial Short cutting the pipeline shows how to do it. \nIt has been a pleasure having you here and see you soon \n"});