fragment_downloaded_cb({"url": "tutorials/basic/toolkit-integration.html#walkthrough", "fragment": "Walkthrough \nRegarding this tutorial s structure we are not going to use forward function definitions anymore Functions will be defined before they are used. Also for clarity of explanation the order in which the snippets of code are presented will not always match the program order. Use the line numbers to locate the snippets in the complete code. \nThe first thing worth noticing is that we are no longer completely platform independent. We need to include the appropriate GDK headers for the windowing system we are going to use. Fortunately there are not that many supported windowing systems so these three lines often suffice X11 for Linux Win32 for Windows and Quartz for Mac OSX. \nThis tutorial is composed mostly of callback functions which will be called from GStreamer or GTK so let s review the main function which registers all these callbacks. \nStandard GStreamer initialization and playbin pipeline creation along with GTK initialization. Not much new. \nWe are interested in being notified when new tags metadata appears on the stream. For simplicity we are going to handle all kinds of tags video audio and text from the same callback tags_cb. \nAll GTK widget creation and signal registration happens in this function. It contains only GTK related function calls so we will skip over its definition. The signals to which it registers convey user commands as shown below when reviewing the callbacks. \nIn Playback tutorial Playbin usage gst_bus_add_watch is used to register a function that receives every message posted to the GStreamer bus. We can achieve a finer granularity by using signals instead which allow us to register only to the messages we are interested in. By calling gst_bus_add_signal_watch we instruct the bus to emit a signal every time it receives a message. This signal has the name message detail where detail is the message that triggered the signal emission. For example when the bus receives the EOS message it emits a signal with the name message eos. \nThis tutorial is using the Signals s details to register only to the messages we care about. If we had registered to the message signal we would be notified of every single message just like gst_bus_add_watch would do. \nKeep in mind that in order for the bus watches to work be it a gst_bus_add_watch or a gst_bus_add_signal_watch there must be GLib Main Loop running. In this case it is hidden inside the GTK main loop. \nBefore transferring control to GTK we use g_timeout_add_seconds to register yet another callback this time with a timeout so it gets called every second. We are going to use it to refresh the GUI from the refresh_ui function. \nAfter this we are done with the setup and can start the GTK main loop. We will regain control from our callbacks when interesting things happen. Let s review the callbacks. Each callback has a different signature depending on who will call it. You can look up the signature the meaning of the parameters and the return value in the documentation of the signal. \nThe code comments talks by itself. At this point in the life cycle of the application we know the handle be it an X11 s XID a Window s HWND or a Quartz s NSView of the window where GStreamer should render the video. We simply retrieve it from the windowing system and pass it to playbin through the GstVideoOverlay interface using gst_video_overlay_set_window_handle playbin will locate the video sink and pass the handler to it so it does not create its own window and uses this one. \nNot much more to see here playbin and the GstVideoOverlay really simplify this process a lot \nThese three little callbacks are associated with the PLAY PAUSE and STOP buttons in the GUI. They simply set the pipeline to the corresponding state. Note that in the STOP state we set the pipeline to READY. We could have brought the pipeline all the way down to the NULL state but the transition would then be a little slower since some resources like the audio device would need to be released and re acquired. \ngtk_main_quit will eventually make the call to to gtk_main_run in main to terminate which in this case finishes the program. Here we call it when the main window is closed after stopping the pipeline just for the sake of tidiness \nWhen there is data flow in the PAUSED and PLAYING states the video sink takes care of refreshing the content of the video window. In the other cases however it will not so we have to do it. In this example we just fill the window with a black rectangle. \nThis is an example of how a complex GUI element like a seeker bar or slider that allows seeking can be very easily implemented thanks to GStreamer and GTK collaborating. If the slider has been dragged to a new position tell GStreamer to seek to that position with gst_element_seek_simple as seen in Basic tutorial Time management The slider has been setup so its value represents seconds. \nIt is worth mentioning that some performance and responsiveness can be gained by doing some throttling this is not responding to every single user request to seek. Since the seek operation is bound to take some time it is often nicer to wait half a second for example after a seek before allowing another one. Otherwise the application might look unresponsive if the user drags the slider frantically which would not allow any seek to complete before a new one is queued. \nThis function will move the slider to reflect the current position of the media. First off if we are not in the PLAYING state we have nothing to do here plus position and duration queries will normally fail \nWe recover the duration of the clip if we didn t know it so we can set the range for the slider. \nWe query the current pipeline position and set the position of the slider accordingly. This would trigger the emission of the value changed signal which we use to know when the user is dragging the slider. Since we do not want seeks happening unless the user requested them we disable the value changed signal emission during this operation with g_signal_handler_block and g_signal_handler_unblock \nReturning TRUE from this function will keep it called in the future. If we return FALSE the timer will be removed. \nThis is one of the key points of this tutorial. This function will be called when new tags are found in the media from a streaming thread this is from a thread other than the application or main thread. What we want to do here is to update a GTK widget to reflect this new information but GTK does not allow operating from threads other than the main one. \nThe solution is to make playbin post a message on the bus and return to the calling thread. When appropriate the main thread will pick up this message and update GTK. \ngst_element_post_message makes a GStreamer element post the given message to the bus. gst_message_new_application creates a new message of the APPLICATION type. GStreamer messages have different types and this particular type is reserved to the application it will go through the bus unaffected by GStreamer. The list of types can be found in the GstMessageType documentation. \nMessages can deliver additional information through their embedded GstStructure which is a very flexible data container. Here we create a new structure with gst_structure_new and name it tags changed to avoid confusion in case we wanted to send other application messages. \nLater once in the main thread the bus will receive this message and emit the message application signal which we have associated to the application_cb function \nOnce me made sure it is the tags changed message we call the analyze_streams function which is also used in Playback tutorial Playbin usage and is more detailed there. It basically recovers the tags from the stream and writes them in a text widget in the GUI. \nThe error_cb eos_cb and state_changed_cb are not really worth explaining since they do the same as in all previous tutorials but from their own function now. \nAnd this is it The amount of code in this tutorial might seem daunting but the required concepts are few and easy. If you have followed the previous tutorials and have a little knowledge of GTK you probably understood this one can now enjoy your very own media player \n\n"});