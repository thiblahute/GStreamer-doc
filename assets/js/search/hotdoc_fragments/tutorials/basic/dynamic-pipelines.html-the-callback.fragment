fragment_downloaded_cb({"url": "tutorials/basic/dynamic-pipelines.html#the-callback", "fragment": "The callback \nWhen our source element finally has enough information to start producing data it will create source pads and trigger the pad added signal. At this point our callback will be called \nsrc is the GstElement which triggered the signal. In this example it can only be the uridecodebin since it is the only signal to which we have attached. The first parameter of a signal handler is always the object that has triggered it. \nnew_pad is the GstPad that has just been added to the src element. This is usually the pad to which we want to link. \ndata is the pointer we provided when attaching to the signal. In this example we use it to pass the CustomData pointer. \nFrom CustomData we extract the converter element and then retrieve its sink pad using gst_element_get_static_pad This is the pad to which we want to link new_pad. In the previous tutorial we linked element against element and let GStreamer choose the appropriate pads. Now we are going to link the pads directly. \nuridecodebin can create as many pads as it sees fit and for each one this callback will be called. These lines of code will prevent us from trying to link to a new pad once we are already linked. \nNow we will check the type of data this new pad is going to output because we are only interested in pads producing audio. We have previously created a piece of pipeline which deals with audio an audioconvert linked with an autoaudiosink and we will not be able to link it to a pad producing video for example. \ngst_pad_query_caps retrieves the capabilities of the pad this is the kind of data it supports wrapped in a GstCaps structure. A pad can offer many capabilities and hence GstCaps can contain many GstStructure each representing a different capability. \nSince in this case we know that the pad we want only had one capability audio we retrieve the first GstStructure with gst_caps_get_structure \nFinally with gst_structure_get_name we recover the name of the structure which contains the main description of the format its media type actually \nIf the name is not audio x raw this is not a decoded audio pad and we are not interested in it. \nOtherwise attempt the link \ngst_pad_link tries to link two pads. As it was the case with gst_element_link the link must be specified from source to sink and both pads must be owned by elements residing in the same bin or pipeline \nAnd we are done When a pad of the right kind appears it will be linked to the rest of the audio processing pipeline and execution will continue until ERROR or EOS. However we will squeeze a bit more content from this tutorial by also introducing the concept of State. \n"});