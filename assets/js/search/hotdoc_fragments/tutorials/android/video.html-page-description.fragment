fragment_downloaded_cb({"url": "tutorials/android/video.html#page-description", "fragment": "\nExcept for Basic tutorial GUI toolkit integration which embedded a video window on a GTK application all tutorials so far relied on GStreamer video sinks to create a window to display their contents. The video sink on Android is not capable of creating its own window so a drawing surface always needs to be provided. This tutorial shows \nSince Android does not provide a windowing system a GStreamer video sink cannot create pop up windows as it would do on a Desktop platform. Fortunately the VideoOverlay interface allows providing video sinks with an already created window onto which they can draw as we have seen in Basic tutorial GUI toolkit integration. \nIn this tutorial a SurfaceView widget actually a subclass of it is placed on the main layout. When Android informs the application that a surface has been created for this widget we pass it to the C code which stores it. The check_initialization_complete method explained in the previous tutorial is extended so that GStreamer is not considered initialized until a main loop is running and a drawing surface has been received. \nsrc org freedesktop gstreamer tutorials tutorial_3 Tutorial3.java \nThis tutorial continues where the previous one left adding a video surface to the layout and changing the GStreamer pipeline to produce video instead of audio. Only the parts of the code that are new will be discussed. \nTwo new entry points to the C code are defined nativeSurfaceInit and nativeSurfaceFinalize which we will call when the video surface becomes available and when it is about to be destroyed respectively. \nIn onCreate we retrieve the SurfaceView and then register ourselves to receive notifications about the surface state through the SurfaceHolder interface. This is why we declared this Activity as implementing the SurfaceHolder.Callback interface in line \nThis interface is composed of the three methods above which get called when the geometry of the surface changes when the surface is created and when it is about to be destroyed. surfaceChanged always gets called at least once right after surfaceCreated so we will use it to notify GStreamer about the new surface. We use surfaceDestroyed to tell GStreamer to stop using this surface. \nLet s review the C code to see what these functions do. \njni tutorial c \nFirst our CustomData structure is augmented to keep a pointer to the video sink element and the native window handle \nThe check_initialization_complete method is also augmented so that it requires a native window before considering GStreamer to be initialized \nAlso once the pipeline has been built and a native window has been received we inform the video sink of the window handle to use via the gst_video_overlay_set_window_handle method. \nThe GStreamer pipeline for this tutorial involves a videotestsrc a warptv psychedelic distorter effect check out other cool video effects in the GSTREAMER_PLUGINS_EFFECTS package and an autovideosink which will instantiate the adequate video sink for the platform \nHere things start to get more interesting \nWe start by setting the pipeline to the READY state. No data flow occurs yet but the autovideosink will instantiate the actual sink so we can ask for it immediately. \nThe gst_bin_get_by_interface method will examine the whole pipeline and return a pointer to an element which supports the requested interface. We are asking for the VideoOverlay interface explained in Basic tutorial GUI toolkit integration which controls how to perform rendering into foreign non GStreamer windows. The internal video sink instantiated by autovideosink is the only element in this pipeline implementing it so it will be returned. \nNow we will implement the two native functions called by the Java code when the drawing surface becomes available or is about to be destroyed \nThis method is responsible for providing the video sink with the window handle coming from the Java code. We are passed a Surface object and we use ANativeWindow_fromSurface to obtain the underlying native window pointer. There is no official online documentation for the NDK but fortunately the header files are well commented. Native window management functions can be found in ANDROID_NDK_ROOT platforms android arch arm usr include android native_window.h and native_window_jni.h \nIf we had already stored a native window the one we just received can either be a new one or just an update of the one we have. If the pointers are the same we assume the geometry of the surface has changed and simply instruct the video sink to redraw itself via the gst_video_overlay_expose method. The video sink will recover the new size from the surface itself so we do not need to bother about it here. We need to call gst_video_overlay_expose twice because of the way the surface changes propagate down the OpenGL ES EGL pipeline The only video sink available for Android in GStreamer uses OpenGL ES By the time we call the first expose the surface that the sink will pick up still contains the old size. \nOn the other hand if the pointers are different we mark GStreamer as not being initialized. Next time we call check_initialization_complete the video sink will be informed of the new window handle. \nWe finally store the new window handle and call check_initialization_complete to inform the Java code that everything is set up if that is the case. \nThe complementary function gst_native_surface_finalize is called when a surface is about to be destroyed and should not be used anymore. Here we simply instruct the video sink to stop using the window handle and set the pipeline to READY so no rendering occurs. We release the window pointer we had stored with ANativeWindow_release and mark GStreamer as not being initialized anymore. \nAnd this is all there is to it regarding the main code. Only a couple of details remain the subclass we made for SurfaceView and the Android.mk file. \nBy default SurfaceView does not have any particular size so it expands to use all the space the layout can give it. While this might be convenient sometimes it does not allow a great deal of control. In particular when the surface does not have the same aspect ratio as the media the sink will add black borders the known letterbox or pillarbox effect which is an unnecessary work and a waste of battery \nThe subclass of SurfaceView presented here overrides the onMeasure method to report the actual media size so the surface can adapt to any layout while preserving the media aspect ratio. \nSince in this tutorial the media size is known beforehand it is hardcoded in the GStreamerSurfaceView class for simplicity. The next tutorial shows how it can be recovered at runtime and passed onto the surface. \nsrc org freedesktop gstreamer tutorials tutorial_3 GStreamerSurfaceView.java \njni Android.mk \nWorth mentioning is the landroid library being used to allow interaction with the native windows and the different plugin packages GSTREAMER_PLUGINS_SYS for the system dependent video sink and GSTREAMER_PLUGINS_EFFECTS for the warptv element. This tutorial requires the gstreamer video library to use the VideoOverlay interface and the video helper methods. \nThis tutorial has shown \nThe following tutorial plays an actual clip and adds a few more controls to this tutorial in order to build a simple media player. \nIt has been a pleasure having you here and see you soon \n"});