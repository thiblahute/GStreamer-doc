fragment_downloaded_cb({"url": "tutorials/android/a-running-pipeline.html#introduction", "fragment": "Introduction \nWhen using a Graphical User Interface UI if the application waits for GStreamer calls to complete the user experience will suffer. The usual approach with the GTK toolkit for example is to relinquish control to a GLib GMainLoop and let it control the events coming from the UI or GStreamer. \nThis approach can be very cumbersome when GStreamer and the Android UI communicate through the JNI interface so we take a cleaner route We use a GLib main loop and move it to its own thread so it does not block the application. This simplifies the GStreamer Android integration and we only need to worry about a few inter process synchronization bits which are detailed in this tutorial. \nAdditionally this tutorial shows how to obtain from any thread the JNI Environment pointer required to make JNI calls. This is necessary for example to call Java code from callbacks in threads spawned deep within GStreamer which never received this pointer directly. \nFinally this tutorial explains how to call Java methods from native C code which involves locating the desired method s ID in the class. These IDs never change so they are cached as global variables in the C code and obtained in the static initializer of the class. \nThe code below builds a pipeline with an audiotestsrc and an autoaudiosink it plays an audible tone Two buttons in the UI allow setting the pipeline to PLAYING or PAUSED. A TextView in the UI shows messages sent from the C code for errors and state changes \n"});