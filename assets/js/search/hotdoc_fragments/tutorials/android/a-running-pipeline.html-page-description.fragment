fragment_downloaded_cb({"url": "tutorials/android/a-running-pipeline.html#page-description", "fragment": "Android tutorial A running pipeline \nA pipeline on Android Java code \ngst_native_init nativeInit from Java \ngst_native_finalize nativeFinalize from Java \ngst_native_play and gst_native_pause nativePlay and nativePause from Java \nA pipeline on Android Android.mk \nsrc org freedesktop gstreamer tutorials tutorial_2 Tutorial2.java \nAs usual the first bit that gets executed is the static initializer of the class \nAs explained in the previous tutorial the two native libraries are loaded and their JNI_OnLoad methods are executed. Here we also call the native method nativeClassInit previously declared with the native keyword in line We will later see what its purpose is \nIn the onCreate method GStreamer is initialized as in the previous tutorial with GStreamer.init this and then the layout is inflated and listeners are setup for the two UI buttons \nEach button instructs the native code to set the pipeline to the desired state and also remembers this state in the is_playing_desired variable. This is required so when the application is restarted for example due to an orientation change it can set the pipeline again to the desired state. This approach is easier and safer than tracking the actual pipeline state because orientation changes can happen before the pipeline has moved to the desired state for example. \nRestore the previous playing state if any from savedInstanceState. We will first build the GStreamer pipeline below and only when the native code reports itself as initialized we will use is_playing_desired. \nAs will be shown in the C code nativeInit creates a dedicated thread a GStreamer pipeline a GLib main loop and right before calling g_main_loop_run and going to sleep it warns the Java code that the native code is initialized and ready to accept commands. \nThis finishes the onCreate method and the Java initialization. The UI buttons are disabled so nothing will happen until native code is ready and onGStreamerInitialized is called \nThis is called by the native code when its main loop is finally running. We first retrieve the desired playing state from is_playing_desired and then set that state \nHere comes the first caveat when re enabling the UI buttons \nThis method is being called from the thread that the native code created to run its main loop and is not allowed to issue UI altering commands Only the UI thread can do that. The solution is easy though Android Activities have a handy runOnUiThread method which lets bits of code to be executed from the correct thread. A Runnable instance has to be constructed and any parameter can be passed either by sub classing Runnable and adding a dedicated constructor or by using the final modifier as shown in the above snippet. \nThe same problem exists when the native code wants to output a string in our TextView using the setMessage method it has to be done from the UI thread. The solution is the same \nFinally a few remaining bits \nThis method stores the currently desired playing state when Android is about to shut us down so next time it restarts after an orientation change for example it can restore the same state. \nAnd this is called before Android destroys our application. We call the nativeFinalize method to exit the main loop destroy its thread and all allocated resources. \nThis concludes the UI part of the tutorial. \nThis method is called at the end of Java s onCreate \nIt first allocates memory for the CustomData structure and passes the pointer to the Java class with SET_CUSTOM_DATA so it is remembered. \nA pointer to the application class the Tutorial2 class is also kept in CustomData a Global Reference is used so its methods can be called later. \nFinally a thread is created and it starts running the app_function method. \nThis method is called from Java in onDestroy when the activity is about to be destroyed. Here we \nThese two simple methods retrieve CustomData from the passed in object with GET_CUSTOM_DATA and set the pipeline found inside CustomData to the desired state returning immediately. \nFinally let s see how the GStreamer callbacks are handled \njni Android.mk \nNotice how the required GSTREAMER_PLUGINS are now GSTREAMER_PLUGINS_CORE For the test source and converter elements and GSTREAMER_PLUGINS_SYS for the audio sink \nAnd this is it This has been a rather long tutorial but we covered a lot of territory. Building on top of this one the following ones are shorter and focus only on the new topics. \n"});