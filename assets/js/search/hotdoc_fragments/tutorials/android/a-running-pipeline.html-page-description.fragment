fragment_downloaded_cb({"url": "tutorials/android/a-running-pipeline.html#page-description", "fragment": "\nThe tutorials seen in the Basic and Playback sections are intended for Desktop platforms and therefore their main thread is allowed to block using gst_bus_pop_filtered or relinquish control to a GLib main loop. On Android this would lead to the application being tagged as non responsive and probably closed. \nThis tutorial shows how to overcome this problem. In particular we will learn \nWhen using a Graphical User Interface UI if the application waits for GStreamer calls to complete the user experience will suffer. The usual approach with the GTK toolkit for example is to relinquish control to a GLib GMainLoop and let it control the events coming from the UI or GStreamer. \nThis approach can be very cumbersome when GStreamer and the Android UI communicate through the JNI interface so we take a cleaner route We use a GLib main loop and move it to its own thread so it does not block the application. This simplifies the GStreamer Android integration and we only need to worry about a few inter process synchronization bits which are detailed in this tutorial. \nAdditionally this tutorial shows how to obtain from any thread the JNI Environment pointer required to make JNI calls. This is necessary for example to call Java code from callbacks in threads spawned deep within GStreamer which never received this pointer directly. \nFinally this tutorial explains how to call Java methods from native C code which involves locating the desired method s ID in the class. These IDs never change so they are cached as global variables in the C code and obtained in the static initializer of the class. \nThe code below builds a pipeline with an audiotestsrc and an autoaudiosink it plays an audible tone Two buttons in the UI allow setting the pipeline to PLAYING or PAUSED. A TextView in the UI shows messages sent from the C code for errors and state changes \nsrc org freedesktop gstreamer tutorials tutorial_2 Tutorial2.java \nAs usual the first bit that gets executed is the static initializer of the class \nAs explained in the previous tutorial the two native libraries are loaded and their JNI_OnLoad methods are executed. Here we also call the native method nativeClassInit previously declared with the native keyword in line We will later see what its purpose is \nIn the onCreate method GStreamer is initialized as in the previous tutorial with GStreamer.init this and then the layout is inflated and listeners are setup for the two UI buttons \nEach button instructs the native code to set the pipeline to the desired state and also remembers this state in the is_playing_desired variable. This is required so when the application is restarted for example due to an orientation change it can set the pipeline again to the desired state. This approach is easier and safer than tracking the actual pipeline state because orientation changes can happen before the pipeline has moved to the desired state for example. \nRestore the previous playing state if any from savedInstanceState. We will first build the GStreamer pipeline below and only when the native code reports itself as initialized we will use is_playing_desired. \nAs will be shown in the C code nativeInit creates a dedicated thread a GStreamer pipeline a GLib main loop and right before calling g_main_loop_run and going to sleep it warns the Java code that the native code is initialized and ready to accept commands. \nThis finishes the onCreate method and the Java initialization. The UI buttons are disabled so nothing will happen until native code is ready and onGStreamerInitialized is called \nThis is called by the native code when its main loop is finally running. We first retrieve the desired playing state from is_playing_desired and then set that state \nHere comes the first caveat when re enabling the UI buttons \nThis method is being called from the thread that the native code created to run its main loop and is not allowed to issue UI altering commands Only the UI thread can do that. The solution is easy though Android Activities have a handy runOnUiThread method which lets bits of code to be executed from the correct thread. A Runnable instance has to be constructed and any parameter can be passed either by sub classing Runnable and adding a dedicated constructor or by using the final modifier as shown in the above snippet. \nThe same problem exists when the native code wants to output a string in our TextView using the setMessage method it has to be done from the UI thread. The solution is the same \nFinally a few remaining bits \nThis method stores the currently desired playing state when Android is about to shut us down so next time it restarts after an orientation change for example it can restore the same state. \nAnd this is called before Android destroys our application. We call the nativeFinalize method to exit the main loop destroy its thread and all allocated resources. \nThis concludes the UI part of the tutorial. \njni tutorial c \nLet s start with the CustomData structure. We have seen it in most of the basic tutorials and it is used to hold all our information in one place so we can easily pass it around to callbacks \nWe will see the meaning of each member as we go. What is interesting now is that CustomData belongs to the application so a pointer is kept in the Tutorial2 Java class in the private long native_custom_data attribute. Java only holds this pointer for us it is completely handled in C code. \nFrom C this pointer can be set and retrieved with the SetLongField and GetLongField JNI functions but two convenience macros have been defined SET_CUSTOM_DATA and GET_CUSTOM_DATA. These macros are handy because the long type used in Java is always bits wide but the pointer used in C can be either or bits wide. The macros take care of the conversion without warnings. \nThe JNI_OnLoad function is almost the same as the previous tutorial. It registers the list of native methods which is longer in this tutorial It also uses pthread_key_create to be able to store per thread information which is crucial to properly manage the JNI Environment as shown later. \nThis method is called from the static initializer of the Java class which is passed as a parameter since this is called from a static method it receives a class object instead of an instance object In order for C code to be able to call a Java method it needs to know the method s MethodID. This ID is obtained from the method s name and signature and can be cached. The purpose of the gst_native_class_init function is to obtain the IDs of all the methods and fields that the C code will need. If some ID cannot be retrieved the calling Java class does not offer the expected interface and execution should halt which is not currently done for simplicity \nLet s review now the first native method which can be directly called from Java \nThis method is called at the end of Java s onCreate \nIt first allocates memory for the CustomData structure and passes the pointer to the Java class with SET_CUSTOM_DATA so it is remembered. \nA pointer to the application class the Tutorial2 class is also kept in CustomData a Global Reference is used so its methods can be called later. \nFinally a thread is created and it starts running the app_function method. \nIt first creates a GLib context so all GSource are kept in the same place. This also helps cleaning after GSources created by other libraries which might not have been properly disposed of. A new context is created with g_main_context_new and then it is made the default one for the thread with g_main_context_push_thread_default \nIt then creates a pipeline the easy way with gst parse launch In this case it is simply an audiotestsrc which produces a continuous tone and an autoaudiosink with accompanying adapter elements. \nThese lines create a bus signal watch and connect to some interesting signals just like we have been doing in the basic tutorials. The creation of the watch is done step by step instead of using gst_bus_add_signal_watch to exemplify how to use a custom GLib context. \nFinally the main loop is created and set to run. When it exits because somebody else calls g_main_loop_quit the main loop is disposed of. Before entering the main loop though check_initialization_complete is called. This method checks if all conditions are met to consider the native code ready to accept commands. Since having a running main loop is one of the conditions check_initialization_complete is called here. This method is reviewed below. \nOnce the main loop has quit all resources are freed in lines to \nThis method does not do much in this tutorial but it will also be used in the next ones with progressively more complex functionality. Its purpose is to check if the native code is ready to accept commands and if so notify the UI code. \nIn tutorial the only conditions are the code is not already initialized and the main loop is running. If these two are met the Java onGStreamerInitialized method is called via the CallVoidMethod JNI call. \nHere comes a tricky bit. JNI calls require a JNI Environment which is different for every thread. C methods called from Java receive a JNIEnv pointer as a parameter but this is not the situation with check_initialization_complete Here we are in a thread which has never been called from Java so we have no JNIEnv. We need to use the JavaVM pointer passed to us in the JNI_OnLoad method and shared among all threads to attach this thread to the Java Virtual Machine and obtain a JNIEnv. This JNIEnv is stored in the Thread Local Storage TLS using the pthread key we created in JNI_OnLoad so we do not need to attach the thread anymore. \nThis behavior is implemented in the get_jni_env method used for example in check_initialization_complete as we have just seen. Let s see how it works step by step \nIt first retrieves the current JNIEnv from the TLS using pthread_getspecific and the key we obtained from pthread_key_create If it returns NULL we never attached this thread so we do now with attach_current_thread and then store the new JNIEnv into the TLS with pthread_setspecific \nThis method is simply a convenience wrapper around AttachCurrentThread to deal with its parameters. \nThis method is called by the pthreads library when a TLS key is deleted meaning that the thread is about to be destroyed. We simply detach the thread from the JavaVM with DetachCurrentThread \nLet s now review the rest of the native methods accessible from Java \nThis method is called from Java in onDestroy when the activity is about to be destroyed. Here we \nThese two simple methods retrieve CustomData from the passed in object with GET_CUSTOM_DATA and set the pipeline found inside CustomData to the desired state returning immediately. \nFinally let s see how the GStreamer callbacks are handled \nThis tutorial does not do much in these callbacks. They simply parse the error or state changed message and display a message in the UI using the set_ui_message method \nThis is the other method besides check_initialization_complete that needs to call a Java function from a thread which never received an JNIEnv pointer directly. Notice how all the complexities of attaching the thread to the JavaVM and storing the JNI environment in the TLS are hidden in the simple call to get_jni_env \nThe desired message received in ASCII or modified UTF8 is converted to UTF16 as required by Java using the NewStringUTF JNI call. \nThe setMessage Java method is called via the JNI CallVoidMethod using the global reference to the class we are keeping in CustomData data app and the set_message_method_id we cached in gst_native_class_init \nWe check for exceptions with the JNI ExceptionCheck method and free the UTF16 message with DeleteLocalRef \njni Android.mk \nNotice how the required GSTREAMER_PLUGINS are now GSTREAMER_PLUGINS_CORE For the test source and converter elements and GSTREAMER_PLUGINS_SYS for the audio sink \nAnd this is it This has been a rather long tutorial but we covered a lot of territory. Building on top of this one the following ones are shorter and focus only on the new topics. \nThis tutorial has shown \nMost of the methods introduced in this tutorial like get_jni_env check_initialization_complete app_function and the API methods gst_native_init gst_native_finalize and gst_native_class_init will continue to be used in the following tutorials with minimal modifications so better get used to them \nAs usual it has been a pleasure having you here and see you soon \n"});