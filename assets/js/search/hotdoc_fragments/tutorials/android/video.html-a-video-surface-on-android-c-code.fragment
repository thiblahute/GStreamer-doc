fragment_downloaded_cb({"url": "tutorials/android/video.html#a-video-surface-on-android-c-code", "fragment": "A video surface on Android C code \njni tutorial c \nFirst our CustomData structure is augmented to keep a pointer to the video sink element and the native window handle \nThe check_initialization_complete method is also augmented so that it requires a native window before considering GStreamer to be initialized \nAlso once the pipeline has been built and a native window has been received we inform the video sink of the window handle to use via the gst_video_overlay_set_window_handle method. \nThe GStreamer pipeline for this tutorial involves a videotestsrc a warptv psychedelic distorter effect check out other cool video effects in the GSTREAMER_PLUGINS_EFFECTS package and an autovideosink which will instantiate the adequate video sink for the platform \nHere things start to get more interesting \nWe start by setting the pipeline to the READY state. No data flow occurs yet but the autovideosink will instantiate the actual sink so we can ask for it immediately. \nThe gst_bin_get_by_interface method will examine the whole pipeline and return a pointer to an element which supports the requested interface. We are asking for the VideoOverlay interface explained in Basic tutorial GUI toolkit integration which controls how to perform rendering into foreign non GStreamer windows. The internal video sink instantiated by autovideosink is the only element in this pipeline implementing it so it will be returned. \nNow we will implement the two native functions called by the Java code when the drawing surface becomes available or is about to be destroyed \nThis method is responsible for providing the video sink with the window handle coming from the Java code. We are passed a Surface object and we use ANativeWindow_fromSurface to obtain the underlying native window pointer. There is no official online documentation for the NDK but fortunately the header files are well commented. Native window management functions can be found in ANDROID_NDK_ROOT platforms android arch arm usr include android native_window.h and native_window_jni.h \nIf we had already stored a native window the one we just received can either be a new one or just an update of the one we have. If the pointers are the same we assume the geometry of the surface has changed and simply instruct the video sink to redraw itself via the gst_video_overlay_expose method. The video sink will recover the new size from the surface itself so we do not need to bother about it here. We need to call gst_video_overlay_expose twice because of the way the surface changes propagate down the OpenGL ES EGL pipeline The only video sink available for Android in GStreamer uses OpenGL ES By the time we call the first expose the surface that the sink will pick up still contains the old size. \nOn the other hand if the pointers are different we mark GStreamer as not being initialized. Next time we call check_initialization_complete the video sink will be informed of the new window handle. \nWe finally store the new window handle and call check_initialization_complete to inform the Java code that everything is set up if that is the case. \nThe complementary function gst_native_surface_finalize is called when a surface is about to be destroyed and should not be used anymore. Here we simply instruct the video sink to stop using the window handle and set the pipeline to READY so no rendering occurs. We release the window pointer we had stored with ANativeWindow_release and mark GStreamer as not being initialized anymore. \nAnd this is all there is to it regarding the main code. Only a couple of details remain the subclass we made for SurfaceView and the Android.mk file. \n"});