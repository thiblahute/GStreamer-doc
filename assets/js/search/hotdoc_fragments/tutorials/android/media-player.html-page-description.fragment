fragment_downloaded_cb({"url": "tutorials/android/media-player.html#page-description", "fragment": "\nEnough testing with synthetic images and audio tones This tutorial finally plays actual media streamed directly from the Internet in your Android device. It shows \nIt also uses the knowledge gathered in the Basic tutorials regarding \nFrom the previous tutorials we already have almost all necessary pieces to build a media player. The most complex part is assembling a pipeline which retrieves decodes and displays the media but we already know that the playbin element can take care of all that for us. We only need to replace the manual pipeline we used in Android tutorial Video with a single element playbin pipeline and we are good to go \nHowever we can do better than. We will add a Seek Bar with a moving thumb that will advance as our current position in the media advances. We will also allow the user to drag the thumb to jump or seek to a different position. \nAnd finally we will make the video surface adapt to the media size so the video sink is not forced to draw black borders around the clip. This also allows the Android layout to adapt more nicely to the actual media content. You can still force the video surface to have a specific size if you really want to. \nsrc com gst_sdk_tutorials tutorial_4 Tutorial4.java \nThe C code provides the nativeSetUri method so we can indicate the URI of the media to play. Since playbin will be taking care of retrieving the media we can use local or remote URIs indistinctly file or http for example From Java though we want to keep track of whether the file is local or remote because we will not offer the same functionalities. We keep track of this in the is_local_media variable and update it every time we change the media URI \nWe call setMediaUri in the onGStreamerInitialized callback once the pipeline is ready to accept commands. \nEvery time the size of the media changes which could happen mid stream for some kind of streams or when it is first detected C code calls our onMediaSizeChanged callback \nHere we simply pass the new size onto the GStreamerSurfaceView in charge of displaying the media and ask the Android layout to be recalculated. Eventually the onMeasure method in GStreamerSurfaceView will be called and the new size will be taken into account. As we have already seen in Android tutorial A running pipeline methods which change the UI must be called from the main thread and we are now in a callback from some GStreamer internal thread. Hence the usage of runOnUiThread \nBasic tutorial GUI toolkit integration has already shown how to implement a Seek Bar using the GTK toolkit. The implementation on Android is very similar. \nThe Seek Bar accomplishes to functions First it moves on its own to reflect the current playback position in the media. Second it can be dragged by the user to seek to a different position. \nTo realize the first function C code will periodically call our setCurrentPosition method so we can update the position of the thumb in the Seek Bar. Again we do so from the UI thread using RunOnUiThread \nTo the left of the Seek Bar refer to the screenshot at the top of this page there is a TextView widget which we will use to display the current position and duration in HH mm ss HH mm ss textual format. The updateTimeWidget method takes care of it and must be called every time the Seek Bar is updated \nTo perform the second function of the Seek Bar allowing the user to seek by dragging the thumb we implement the OnSeekBarChangeListener interface in the Activity \nAnd we register the Activity as the listener for the Seek Bar s events in the onCreate method \nWe will now be notified of three events When the user starts dragging the thumb every time the thumb moves and when the thumb is released by the user \nonStartTrackingTouch is called when the user starts dragging and the only thing we do is pause the pipeline. If the user is searching for a particular scene we do not want it to keep moving. \nonProgressChanged is called every time the thumb moves be it because the user dragged it or because we called setProgress on the Seek Bar. We discard the latter case with the handy fromUser parameter. \nAs the comment says if this is a local media we allow scrub seeking this is we jump to the indicated position as soon as the thumb moves. Otherwise the seek will be performed when the thumb is released and the only thing we do here is update the textual time widget. \nFinally onStopTrackingTouch is called when the thumb is released. We simply perform the seek operation if the file was non local and restore the pipeline to the desired playing state. \nThis concludes the User interface part of this tutorial. Let s review now the under the hood C code that allows this to work. \njni tutorial c \nJava code will call gst_native_set_uri whenever it wants to change the playing URI in this tutorial the URI never changes but it could \nWe first need to convert between the UTF16 encoding used by Java and the Modified UTF8 used by GStreamer with GetStringUTFChars and ReleaseStringUTFChars \nplaybin will only care about URI changes in the READY to PAUSED state change because the new URI might need a completely different playback pipeline think about switching from a local Matroska file to a remote OGG file this would require at least different source and demuxing elements Thus before passing the new URI to playbin we set its state to READY if we were in PAUSED or PLAYING \nplaybin s URI is exposed as a common GObject property so we simply set it with g_object_set \nWe then reset the clip duration so it is re queried later and bring the pipeline to the playing state it had before. In this last step we also take note of whether the new URI corresponds to a live source or not. Live sources must not use buffering otherwise latency is introduced which is inacceptable for them so we keep track of this information in the is_live variable. \nSome codecs allow the media size width and height of the video to change during playback. For simplicity this tutorial assumes that they do not. Therefore in the READY to PAUSED state change once the Caps of the decoded media are known we inspect them in check_media_size \nWe first retrieve the video sink element from the pipeline using the video sink property of playbin and then its sink Pad. The negotiated Caps of this Pad which we recover using gst_pad_get_negotiated_caps are the Caps of the decoded media. \nThe helper functions gst_video_format_parse_caps and gst_video_parse_caps_pixel_aspect_ratio turn the Caps into manageable integers which we pass to Java through its onMediaSizeChanged callback. \nTo keep the UI updated a GLib timer is installed in the app_function that fires times per second or every ms right before entering the main loop \nThen in the refresh_ui method \nIf it is unknown the clip duration is retrieved as explained in Basic tutorial Time management. The current position is retrieved next and the UI is informed of both through its setCurrentPosition callback. \nBear in mind that all time related measures returned by GStreamer are in nanoseconds whereas for simplicity we decided to make the UI code work in milliseconds. \nThe Java UI code already takes care of most of the complexity of seeking by dragging the thumb of the Seek Bar. From C code we just need to honor the calls to nativeSetPosition and instruct the pipeline to jump to the indicated position. \nThere are though a couple of caveats. Firstly seeks are only possible when the pipeline is in the PAUSED or PLAYING state and we might receive seek requests before that happens. Secondly dragging the Seek Bar can generate a very high number of seek requests in a short period of time which is visually useless and will impair responsiveness. Let s see how to overcome these problems. \nIn gst_native_set_position \nIf we are already in the correct state for seeking execute it right away otherwise store the desired position in the desired_position variable. Then in the state_changed_cb callback \nOnce the pipeline moves from the READY to the PAUSED state we check if there is a pending seek operation and execute it. The desired_position variable is reset inside execute_seek \nA seek is potentially a lengthy operation. The demuxer the element typically in charge of seeking needs to estimate the appropriate byte offset inside the media file that corresponds to the time position to jump to. Then it needs to start decoding from that point until the desired position is reached. If the initial estimate is accurate this will not take long but on some container formats or when indexing information is missing it can take up to several seconds. \nIf a demuxer is in the process of performing a seek and receives a second one it is up to it to finish the first one start the second one or abort both which is a bad thing. A simple method to avoid this issue is throttling which means that we will only allow one seek every half a second for example after performing a seek only the last seek request received during the next ms is stored and will be honored once this period elapses. \nTo achieve this all seek requests are routed through the execute_seek method \nThe time at which the last seek was performed is stored in the last_seek_time variable. This is wall clock time not to be confused with the stream time carried in the media time stamps and is obtained with gst_util_get_timestamp \nIf enough time has passed since the last seek operation the new one is directly executed and last_seek_time is updated. Otherwise the new seek is scheduled for later. If there is no previously scheduled seek a one shot timer is setup to trigger ms after the last seek operation. If another seek was already scheduled its desired position is simply updated with the new one. \nThe one shot timer calls delayed_seek_cb which simply calls execute_seek again. \nIdeally execute_seek will now find that enough time has indeed passed since the last seek and the scheduled one will proceed. It might happen though that after ms of the previous seek and before the timer wakes up yet another seek comes through and is executed. delayed_seek_cb needs to check for this condition to avoid performing two very close seeks and therefore calls execute_seek instead of performing it itself. \nThis is not a complete solution the scheduled seek will still be executed even though a more recent seek has already been executed that should have cancelled it. However it is a good tradeoff between functionality and simplicity. \nBasic tutorial Streaming has already shown how to adapt to the variable nature of the network bandwidth by using buffering. The same procedure is used here by listening to the buffering messages \nAnd pausing the pipeline until buffering is complete unless this is a live source \ntarget_state is the state in which we have been instructed to set the pipeline which might be different to the current state because buffering forces us to go to PAUSED. Once buffering is complete we set the pipeline to the target_state. \nThe only line worth mentioning in the makefile is GSTREAMER_PLUGINS \njni Android.mk \nIn which all plugins required for playback are loaded because it is not known at build time what would be needed for an unspecified URI again in this tutorial the URI does not change but it will in the next one \nThis tutorial has shown how to embed a playbin pipeline into an Android application. This effectively turns such application into a basic media player capable of streaming and decoding all the formats GStreamer understands. More particularly it has shown \nThe next tutorial adds the missing bits to turn the application built here into an acceptable Android media player. \nAs usual it has been a pleasure having you here and see you soon \n"});