fragment_downloaded_cb({"url": "tutorials/android/media-player.html#seek-throttling", "fragment": "Seek throttling \nA seek is potentially a lengthy operation. The demuxer the element typically in charge of seeking needs to estimate the appropriate byte offset inside the media file that corresponds to the time position to jump to. Then it needs to start decoding from that point until the desired position is reached. If the initial estimate is accurate this will not take long but on some container formats or when indexing information is missing it can take up to several seconds. \nIf a demuxer is in the process of performing a seek and receives a second one it is up to it to finish the first one start the second one or abort both which is a bad thing. A simple method to avoid this issue is throttling which means that we will only allow one seek every half a second for example after performing a seek only the last seek request received during the next ms is stored and will be honored once this period elapses. \nTo achieve this all seek requests are routed through the execute_seek method \nThe time at which the last seek was performed is stored in the last_seek_time variable. This is wall clock time not to be confused with the stream time carried in the media time stamps and is obtained with gst_util_get_timestamp \nIf enough time has passed since the last seek operation the new one is directly executed and last_seek_time is updated. Otherwise the new seek is scheduled for later. If there is no previously scheduled seek a one shot timer is setup to trigger ms after the last seek operation. If another seek was already scheduled its desired position is simply updated with the new one. \nThe one shot timer calls delayed_seek_cb which simply calls execute_seek again. \nIdeally execute_seek will now find that enough time has indeed passed since the last seek and the scheduled one will proceed. It might happen though that after ms of the previous seek and before the timer wakes up yet another seek comes through and is executed. delayed_seek_cb needs to check for this condition to avoid performing two very close seeks and therefore calls execute_seek instead of performing it itself. \n"});