fragment_downloaded_cb({"url": "tutorials/playback/subtitle-management.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"subtitle-management.md\">\n<h1 id=\"playback-tutorial-2-subtitle-management\">Playback tutorial 2: Subtitle management</h1>\n<h2 id=\"goal\">Goal</h2>\n<p>This tutorial is very similar to the previous one, but instead of\nswitching among different audio streams, we will use subtitle streams.\nThis will allow us to learn:</p>\n<ul>\n<li>\n<p>How to choose the subtitle stream</p>\n</li>\n<li>\n<p>How to add external subtitles</p>\n</li>\n<li>\n<p>How to customize the font used for the subtitles</p>\n</li>\n</ul>\n<h2 id=\"introduction\">Introduction</h2>\n<p>We already know (from the previous tutorial) that container files can\nhold multiple audio and video streams, and that we can very easily\nchoose among them by changing the <code>current-audio</code> or\n<code>current-video</code> <code>playbin</code> property. Switching subtitles is just as\neasy.</p>\n<p>It is worth noting that, just like it happens with audio and video,\n<code>playbin</code> takes care of choosing the right decoder for the subtitles,\nand that the plugin structure of GStreamer allows adding support for new\nformats as easily as copying a file. Everything is invisible to the\napplication developer.</p>\n<p>Besides subtitles embedded in the container, <code>playbin</code> offers the\npossibility to add an extra subtitle stream from an external URI.</p>\n<p>This tutorial opens a file which already contains 5 subtitle streams,\nand adds another one from another file (for the Greek language).</p>\n<h2 id=\"the-multilingual-player-with-subtitles\">The multilingual player with subtitles</h2>\n<p>Copy this code into a text file named <code>playback-tutorial-2.c</code> (or find\nit in the GStreamer installation).</p>\n<p><strong>playback-tutorial-2.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;gst/gst.h&gt;\n\n/* Structure to contain all our information, so we can pass it around */\ntypedef struct _CustomData {\n  GstElement *playbin;  /* Our one and only element */\n\n  gint n_video;          /* Number of embedded video streams */\n  gint n_audio;          /* Number of embedded audio streams */\n  gint n_text;           /* Number of embedded subtitle streams */\n\n  gint current_video;    /* Currently playing video stream */\n  gint current_audio;    /* Currently playing audio stream */\n  gint current_text;     /* Currently playing subtitle stream */\n\n  GMainLoop *main_loop;  /* GLib's Main Loop */\n} CustomData;\n\n/* playbin flags */\ntypedef enum {\n  GST_PLAY_FLAG_VIDEO         = (1 &lt;&lt; 0), /* We want video output */\n  GST_PLAY_FLAG_AUDIO         = (1 &lt;&lt; 1), /* We want audio output */\n  GST_PLAY_FLAG_TEXT          = (1 &lt;&lt; 2)  /* We want subtitle output */\n} GstPlayFlags;\n\n/* Forward definition for the message and keyboard processing functions */\nstatic gboolean handle_message (GstBus *bus, GstMessage *msg, CustomData *data);\nstatic gboolean handle_keyboard (GIOChannel *source, GIOCondition cond, CustomData *data);\n\nint main(int argc, char *argv[]) {\n  CustomData data;\n  GstBus *bus;\n  GstStateChangeReturn ret;\n  gint flags;\n  GIOChannel *io_stdin;\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* Create the elements */\n  data.playbin = gst_element_factory_make (\"playbin\", \"playbin\");\n\n  if (!data.playbin) {\n    g_printerr (\"Not all elements could be created.\\n\");\n    return -1;\n  }\n\n  /* Set the URI to play */\n  g_object_set (data.playbin, \"uri\", \"https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.ogv\", NULL);\n\n  /* Set the subtitle URI to play and some font description */\n  g_object_set (data.playbin, \"suburi\", \"https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer_gr.srt\", NULL);\n  g_object_set (data.playbin, \"subtitle-font-desc\", \"Sans, 18\", NULL);\n\n  /* Set flags to show Audio, Video and Subtitles */\n  g_object_get (data.playbin, \"flags\", &amp;flags, NULL);\n  flags |= GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_TEXT;\n  g_object_set (data.playbin, \"flags\", flags, NULL);\n\n  /* Add a bus watch, so we get notified when a message arrives */\n  bus = gst_element_get_bus (data.playbin);\n  gst_bus_add_watch (bus, (GstBusFunc)handle_message, &amp;data);\n\n  /* Add a keyboard watch so we get notified of keystrokes */\n#ifdef G_OS_WIN32\n  io_stdin = g_io_channel_win32_new_fd (fileno (stdin));\n#else\n  io_stdin = g_io_channel_unix_new (fileno (stdin));\n#endif\n  g_io_add_watch (io_stdin, G_IO_IN, (GIOFunc)handle_keyboard, &amp;data);\n\n  /* Start playing */\n  ret = gst_element_set_state (data.playbin, GST_STATE_PLAYING);\n  if (ret == GST_STATE_CHANGE_FAILURE) {\n    g_printerr (\"Unable to set the pipeline to the playing state.\\n\");\n    gst_object_unref (data.playbin);\n    return -1;\n  }\n\n  /* Create a GLib Main Loop and set it to run */\n  data.main_loop = g_main_loop_new (NULL, FALSE);\n  g_main_loop_run (data.main_loop);\n\n  /* Free resources */\n  g_main_loop_unref (data.main_loop);\n  g_io_channel_unref (io_stdin);\n  gst_object_unref (bus);\n  gst_element_set_state (data.playbin, GST_STATE_NULL);\n  gst_object_unref (data.playbin);\n  return 0;\n}\n\n/* Extract some metadata from the streams and print it on the screen */\nstatic void analyze_streams (CustomData *data) {\n  gint i;\n  GstTagList *tags;\n  gchar *str;\n  guint rate;\n\n  /* Read some properties */\n  g_object_get (data-&gt;playbin, \"n-video\", &amp;data-&gt;n_video, NULL);\n  g_object_get (data-&gt;playbin, \"n-audio\", &amp;data-&gt;n_audio, NULL);\n  g_object_get (data-&gt;playbin, \"n-text\", &amp;data-&gt;n_text, NULL);\n\n  g_print (\"%d video stream(s), %d audio stream(s), %d text stream(s)\\n\",\n    data-&gt;n_video, data-&gt;n_audio, data-&gt;n_text);\n\n  g_print (\"\\n\");\n  for (i = 0; i &lt; data-&gt;n_video; i++) {\n    tags = NULL;\n    /* Retrieve the stream's video tags */\n    g_signal_emit_by_name (data-&gt;playbin, \"get-video-tags\", i, &amp;tags);\n    if (tags) {\n      g_print (\"video stream %d:\\n\", i);\n      gst_tag_list_get_string (tags, GST_TAG_VIDEO_CODEC, &amp;str);\n      g_print (\"  codec: %s\\n\", str ? str : \"unknown\");\n      g_free (str);\n      gst_tag_list_free (tags);\n    }\n  }\n\n  g_print (\"\\n\");\n  for (i = 0; i &lt; data-&gt;n_audio; i++) {\n    tags = NULL;\n    /* Retrieve the stream's audio tags */\n    g_signal_emit_by_name (data-&gt;playbin, \"get-audio-tags\", i, &amp;tags);\n    if (tags) {\n      g_print (\"audio stream %d:\\n\", i);\n      if (gst_tag_list_get_string (tags, GST_TAG_AUDIO_CODEC, &amp;str)) {\n        g_print (\"  codec: %s\\n\", str);\n        g_free (str);\n      }\n      if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &amp;str)) {\n        g_print (\"  language: %s\\n\", str);\n        g_free (str);\n      }\n      if (gst_tag_list_get_uint (tags, GST_TAG_BITRATE, &amp;rate)) {\n        g_print (\"  bitrate: %d\\n\", rate);\n      }\n      gst_tag_list_free (tags);\n    }\n  }\n\n  g_print (\"\\n\");\n  for (i = 0; i &lt; data-&gt;n_text; i++) {\n    tags = NULL;\n    /* Retrieve the stream's subtitle tags */\n    g_print (\"subtitle stream %d:\\n\", i);\n    g_signal_emit_by_name (data-&gt;playbin, \"get-text-tags\", i, &amp;tags);\n    if (tags) {\n      if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &amp;str)) {\n        g_print (\"  language: %s\\n\", str);\n        g_free (str);\n      }\n      gst_tag_list_free (tags);\n    } else {\n      g_print (\"  no tags found\\n\");\n    }\n  }\n\n  g_object_get (data-&gt;playbin, \"current-video\", &amp;data-&gt;current_video, NULL);\n  g_object_get (data-&gt;playbin, \"current-audio\", &amp;data-&gt;current_audio, NULL);\n  g_object_get (data-&gt;playbin, \"current-text\", &amp;data-&gt;current_text, NULL);\n\n  g_print (\"\\n\");\n  g_print (\"Currently playing video stream %d, audio stream %d and subtitle stream %d\\n\",\n      data-&gt;current_video, data-&gt;current_audio, data-&gt;current_text);\n  g_print (\"Type any number and hit ENTER to select a different subtitle stream\\n\");\n}\n\n/* Process messages from GStreamer */\nstatic gboolean handle_message (GstBus *bus, GstMessage *msg, CustomData *data) {\n  GError *err;\n  gchar *debug_info;\n\n  switch (GST_MESSAGE_TYPE (msg)) {\n    case GST_MESSAGE_ERROR:\n      gst_message_parse_error (msg, &amp;err, &amp;debug_info);\n      g_printerr (\"Error received from element %s: %s\\n\", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);\n      g_printerr (\"Debugging information: %s\\n\", debug_info ? debug_info : \"none\");\n      g_clear_error (&amp;err);\n      g_free (debug_info);\n      g_main_loop_quit (data-&gt;main_loop);\n      break;\n    case GST_MESSAGE_EOS:\n      g_print (\"End-Of-Stream reached.\\n\");\n      g_main_loop_quit (data-&gt;main_loop);\n      break;\n    case GST_MESSAGE_STATE_CHANGED: {\n      GstState old_state, new_state, pending_state;\n      gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);\n      if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data-&gt;playbin)) {\n        if (new_state == GST_STATE_PLAYING) {\n          /* Once we are in the playing state, analyze the streams */\n          analyze_streams (data);\n        }\n      }\n    } break;\n  }\n\n  /* We want to keep receiving messages */\n  return TRUE;\n}\n\n/* Process keyboard input */\nstatic gboolean handle_keyboard (GIOChannel *source, GIOCondition cond, CustomData *data) {\n  gchar *str = NULL;\n\n  if (g_io_channel_read_line (source, &amp;str, NULL, NULL, NULL) == G_IO_STATUS_NORMAL) {\n    int index = atoi (str);\n    if (index &lt; 0 || index &gt;= data-&gt;n_text) {\n      g_printerr (\"Index out of bounds\\n\");\n    } else {\n      /* If the input was a valid subtitle stream index, set the current subtitle stream */\n      g_print (\"Setting current subtitle stream to %d\\n\", index);\n      g_object_set (data-&gt;playbin, \"current-text\", index, NULL);\n    }\n  }\n  g_free (str);\n  return TRUE;\n}\n</code></pre>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"information\" id=\"information\"> Need help?</p>\n<p>If you need help to compile this code, refer to the <strong>Building the\ntutorials</strong> section for your platform: [Linux], [Mac OS X] or\n[Windows], or use this specific command on Linux:</p>\n<p><code>gcc playback-tutorial-2.c -o playback-tutorial-2 `pkg-config --cflags --libs gstreamer-1.0`</code></p>\n<p>If you need help to run this code, refer to the <strong>Running the\ntutorials</strong> section for your platform: [Linux][1], [Mac OS X][2] or\n[Windows][3].</p>\n<p>This tutorial opens a window and displays a movie, with accompanying\naudio. The media is fetched from the Internet, so the window might\ntake a few seconds to appear, depending on your connection\nspeed. The number of subtitle streams is shown in the terminal, and\nthe user can switch from one to another by entering a number and\npressing enter. A small delay is to be\nexpected. <em>Please read the note at the bottom of this\npage.</em> Bear in mind that\nthere is no latency management (buffering), so on slow connections,\nthe movie might stop after a few seconds. See how\n<a href=\"../basic/streaming.html\">Basic tutorial 12: Streaming</a> solves this issue.</p>\n<p>Required libraries: <code>gstreamer-1.0</code></p>\n</blockquote>\n<h2 id=\"walkthrough\">Walkthrough</h2>\n<p>This tutorial is copied from\n<a href=\"playbin-usage.html\">Playback tutorial 1: Playbin usage</a> with some changes, so let's\nreview only the changes.</p>\n<pre><code class=\"language-c\">/* Set the subtitle URI to play and some font description */\ng_object_set (data.playbin, \"suburi\", \"https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer_gr.srt\", NULL);\ng_object_set (data.playbin, \"subtitle-font-desc\", \"Sans, 18\", NULL);\n</code></pre>\n<p>After setting the media URI, we set the <code>suburi</code> property, which points\n<code>playbin</code> to a file containing a subtitle stream. In this case, the\nmedia file already contains multiple subtitle streams, so the one\nprovided in the <code>suburi</code> is added to the list, and will be the currently\nselected one.</p>\n<p>Note that metadata concerning a subtitle stream (like its language)\nresides in the container file, therefore, subtitles not embedded in a\ncontainer will not have metadata. When running this tutorial you will\nfind that the first subtitle stream does not have a language tag.</p>\n<p>The <code>subtitle-font-desc</code> property allows specifying the font to render\nthe subtitles. Since <a href=\"http://www.pango.org/\">Pango</a> is the library used\nto render fonts, you can check its documentation to see how this font\nshould be specified, in particular, the\n<a href=\"http://developer.gnome.org/pango/stable/pango-Fonts.html#pango-font-description-from-string\">pango-font-description-from-string</a> function.</p>\n<p>In a nutshell, the format of the string representation is <code>[FAMILY-LIST] [STYLE-OPTIONS] [SIZE]</code> where <code>FAMILY-LIST</code> is a comma separated list of\nfamilies optionally terminated by a comma, <code>STYLE_OPTIONS</code> is a\nwhitespace separated list of words where each word describes one of\nstyle, variant, weight, or stretch, and <code>SIZE</code> is an decimal number\n(size in points). For example the following are all valid string\nrepresentations:</p>\n<ul>\n<li>sans bold 12</li>\n<li>serif, monospace bold italic condensed 16</li>\n<li>normal 10</li>\n</ul>\n<p>The commonly available font families are: Normal, Sans, Serif and\nMonospace.</p>\n<p>The available styles are: Normal (the font is upright), Oblique (the\nfont is slanted, but in a roman style), Italic (the font is slanted in\nan italic style).</p>\n<p>The available weights are: Ultra-Light, Light, Normal, Bold, Ultra-Bold,\nHeavy.</p>\n<p>The available variants are: Normal, Small_Caps (A font with the lower\ncase characters replaced by smaller variants of the capital characters)</p>\n<p>The available stretch styles\nare: Ultra-Condensed, Extra-Condensed, Condensed, Semi-Condensed, Normal, Semi-Expanded, Expanded,\nExtra-Expanded, Ultra-Expanded</p>\n<pre><code class=\"language-c\">/* Set flags to show Audio, Video and Subtitles */\ng_object_get (data.playbin, \"flags\", &amp;flags, NULL);\nflags |= GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_TEXT;\ng_object_set (data.playbin, \"flags\", flags, NULL);\n</code></pre>\n<p>We set the <code>flags</code> property to allow Audio, Video and Text (Subtitles).</p>\n<p>The rest of the tutorial is the same as <a href=\"playbin-usage.html\">Playback tutorial 1: Playbin usage</a>, except\nthat the keyboard input changes the <code>current-text</code> property instead of\nthe <code>current-audio</code>. As before, keep in mind that stream changes are not\nimmediate, since there is a lot of information flowing through the\npipeline that needs to reach the end of it before the new stream shows\nup.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial showed how to handle subtitles from <code>playbin</code>, whether\nthey are embedded in the container or in a different file:</p>\n<ul>\n<li>\n<p>Subtitles are chosen using the <code>current-tex</code>t and <code>n-tex</code>t\nproperties of <code>playbin</code>.</p>\n</li>\n<li>\n<p>External subtitle files can be selected using the <code>suburi</code> property.</p>\n</li>\n<li>\n<p>Subtitle appearance can be customized with the\n<code>subtitle-font-desc</code> property.</p>\n</li>\n</ul>\n<p>The next playback tutorial shows how to change the playback speed.</p>\n<p>Remember that attached to this page you should find the complete source\ncode of the tutorial and any accessory files needed to build it.\nIt has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n\t"});