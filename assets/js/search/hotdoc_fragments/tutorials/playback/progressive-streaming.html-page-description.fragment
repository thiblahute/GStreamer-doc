fragment_downloaded_cb({"url": "tutorials/playback/progressive-streaming.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"progressive-streaming.md\">\n<h1 id=\"playback-tutorial-4-progressive-streaming\">Playback tutorial 4: Progressive streaming</h1>\n<h2 id=\"goal\">Goal</h2>\n<p><a href=\"../basic/streaming.html\">Basic tutorial 12: Streaming</a> showed how to\nenhance the user experience in poor network conditions, by taking\nbuffering into account. This tutorial further expands\n<a href=\"../basic/streaming.html\">Basic tutorial 12: Streaming</a> by enabling\nthe local storage of the streamed media, and describes the advantages of\nthis technique. In particular, it shows:</p>\n<ul>\n<li>How to enable progressive downloading</li>\n<li>How to know what has been downloaded</li>\n<li>How to know where it has been downloaded</li>\n<li>How to limit the amount of downloaded data that is kept</li>\n</ul>\n<h2 id=\"introduction\">Introduction</h2>\n<p>When streaming, data is fetched from the network and a small buffer of\nfuture-data is kept to ensure smooth playback (see\n<a href=\"../basic/streaming.html\">Basic tutorial 12: Streaming</a>). However, data\nis discarded as soon as it is displayed or rendered (there is no\npast-data buffer). This means, that if a user wants to jump back and\ncontinue playback from a point in the past, data needs to be\nre-downloaded.</p>\n<p>Media players tailored for streaming, like YouTube, usually keep all\ndownloaded data stored locally for this contingency. A graphical widget\nis also normally used to show how much of the file has already been\ndownloaded.</p>\n<p><code>playbin</code> offers similar functionalities through the <code>DOWNLOAD</code> flag\nwhich stores the media in a local temporary file for faster playback of\nalready-downloaded chunks.</p>\n<p>This code also shows how to use the Buffering Query, which allows\nknowing what parts of the file are available.</p>\n<h2 id=\"a-networkresilient-example-with-local-storage\">A network-resilient example with local storage</h2>\n<p>Copy this code into a text file named <code>playback-tutorial-4.c</code>.</p>\n<p><strong>playback-tutorial-4.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n#include &lt;string.h&gt;\n\n#define GRAPH_LENGTH 78\n\n/* playbin flags */\ntypedef enum {\n  GST_PLAY_FLAG_DOWNLOAD      = (1 &lt;&lt; 7) /* Enable progressive download (on selected formats) */\n} GstPlayFlags;\n\ntypedef struct _CustomData {\n  gboolean is_live;\n  GstElement *pipeline;\n  GMainLoop *loop;\n  gint buffering_level;\n} CustomData;\n\nstatic void got_location (GstObject *gstobject, GstObject *prop_object, GParamSpec *prop, gpointer data) {\n  gchar *location;\n  g_object_get (G_OBJECT (prop_object), \"temp-location\", &amp;location, NULL);\n  g_print (\"Temporary file: %s\\n\", location);\n  g_free (location);\n  /* Uncomment this line to keep the temporary file after the program exits */\n  /* g_object_set (G_OBJECT (prop_object), \"temp-remove\", FALSE, NULL); */\n}\n\nstatic void cb_message (GstBus *bus, GstMessage *msg, CustomData *data) {\n\n  switch (GST_MESSAGE_TYPE (msg)) {\n    case GST_MESSAGE_ERROR: {\n      GError *err;\n      gchar *debug;\n\n      gst_message_parse_error (msg, &amp;err, &amp;debug);\n      g_print (\"Error: %s\\n\", err-&gt;message);\n      g_error_free (err);\n      g_free (debug);\n\n      gst_element_set_state (data-&gt;pipeline, GST_STATE_READY);\n      g_main_loop_quit (data-&gt;loop);\n      break;\n    }\n    case GST_MESSAGE_EOS:\n      /* end-of-stream */\n      gst_element_set_state (data-&gt;pipeline, GST_STATE_READY);\n      g_main_loop_quit (data-&gt;loop);\n      break;\n    case GST_MESSAGE_BUFFERING:\n      /* If the stream is live, we do not care about buffering. */\n      if (data-&gt;is_live) break;\n\n      gst_message_parse_buffering (msg, &amp;data-&gt;buffering_level);\n\n      /* Wait until buffering is complete before start/resume playing */\n      if (data-&gt;buffering_level &lt; 100)\n        gst_element_set_state (data-&gt;pipeline, GST_STATE_PAUSED);\n      else\n        gst_element_set_state (data-&gt;pipeline, GST_STATE_PLAYING);\n      break;\n    case GST_MESSAGE_CLOCK_LOST:\n      /* Get a new clock */\n      gst_element_set_state (data-&gt;pipeline, GST_STATE_PAUSED);\n      gst_element_set_state (data-&gt;pipeline, GST_STATE_PLAYING);\n      break;\n    default:\n      /* Unhandled message */\n      break;\n    }\n}\n\nstatic gboolean refresh_ui (CustomData *data) {\n  GstQuery *query;\n  gboolean result;\n\n  query = gst_query_new_buffering (GST_FORMAT_PERCENT);\n  result = gst_element_query (data-&gt;pipeline, query);\n  if (result) {\n    gint n_ranges, range, i;\n    gchar graph[GRAPH_LENGTH + 1];\n    gint64 position = 0, duration = 0;\n\n    memset (graph, ' ', GRAPH_LENGTH);\n    graph[GRAPH_LENGTH] = '\\0';\n\n    n_ranges = gst_query_get_n_buffering_ranges (query);\n    for (range = 0; range &lt; n_ranges; range++) {\n      gint64 start, stop;\n      gst_query_parse_nth_buffering_range (query, range, &amp;start, &amp;stop);\n      start = start * GRAPH_LENGTH / (stop - start);\n      stop = stop * GRAPH_LENGTH / (stop - start);\n      for (i = (gint)start; i &lt; stop; i++)\n        graph [i] = '-';\n    }\n    if (gst_element_query_position (data-&gt;pipeline, GST_TIME_FORMAT, &amp;position) &amp;&amp;\n        GST_CLOCK_TIME_IS_VALID (position) &amp;&amp;\n        gst_element_query_duration (data-&gt;pipeline, GST_TIME_FORMAT, &amp;duration) &amp;&amp;\n        GST_CLOCK_TIME_IS_VALID (duration)) {\n      i = (gint)(GRAPH_LENGTH * (double)position / (double)(duration + 1));\n      graph [i] = data-&gt;buffering_level &lt; 100 ? 'X' : '&gt;';\n    }\n    g_print (\"[%s]\", graph);\n    if (data-&gt;buffering_level &lt; 100) {\n      g_print (\" Buffering: %3d%%\", data-&gt;buffering_level);\n    } else {\n      g_print (\"                \");\n    }\n    g_print (\"\\r\");\n  }\n\n  return TRUE;\n\n}\n\nint main(int argc, char *argv[]) {\n  GstElement *pipeline;\n  GstBus *bus;\n  GstStateChangeReturn ret;\n  GMainLoop *main_loop;\n  CustomData data;\n  guint flags;\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* Initialize our data structure */\n  memset (&amp;data, 0, sizeof (data));\n  data.buffering_level = 100;\n\n  /* Build the pipeline */\n  pipeline = gst_parse_launch (\"playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm\", NULL);\n  bus = gst_element_get_bus (pipeline);\n\n  /* Set the download flag */\n  g_object_get (pipeline, \"flags\", &amp;flags, NULL);\n  flags |= GST_PLAY_FLAG_DOWNLOAD;\n  g_object_set (pipeline, \"flags\", flags, NULL);\n\n  /* Uncomment this line to limit the amount of downloaded data */\n  /* g_object_set (pipeline, \"ring-buffer-max-size\", (guint64)4000000, NULL); */\n\n  /* Start playing */\n  ret = gst_element_set_state (pipeline, GST_STATE_PLAYING);\n  if (ret == GST_STATE_CHANGE_FAILURE) {\n    g_printerr (\"Unable to set the pipeline to the playing state.\\n\");\n    gst_object_unref (pipeline);\n    return -1;\n  } else if (ret == GST_STATE_CHANGE_NO_PREROLL) {\n    data.is_live = TRUE;\n  }\n\n  main_loop = g_main_loop_new (NULL, FALSE);\n  data.loop = main_loop;\n  data.pipeline = pipeline;\n\n  gst_bus_add_signal_watch (bus);\n  g_signal_connect (bus, \"message\", G_CALLBACK (cb_message), &amp;data);\n  g_signal_connect (pipeline, \"deep-notify::temp-location\", G_CALLBACK (got_location), NULL);\n\n  /* Register a function that GLib will call every second */\n  g_timeout_add_seconds (1, (GSourceFunc)refresh_ui, &amp;data);\n\n  g_main_loop_run (main_loop);\n\n  /* Free resources */\n  g_main_loop_unref (main_loop);\n  gst_object_unref (bus);\n  gst_element_set_state (pipeline, GST_STATE_NULL);\n  gst_object_unref (pipeline);\n  g_print (\"\\n\");\n  return 0;\n}\n</code></pre>\n<blockquote>\n<p><img src=\"images/icons/emoticons/information.png\" alt=\"information\" id=\"information\"> If you need help to compile this code, refer to the\n<strong>Building the tutorials</strong> section for your platform: <a href=\"../../installing/on-mac-osx.html\">Mac</a> or\n<a href=\"../../installing/on-windows.html\">Windows</a> or use this specific command on Linux:</p>\n<p><code>gcc playback-tutorial-4.c -o playback-tutorial-4 `pkg-config --cflags --libs gstreamer-1.0`</code></p>\n<p>If you need help to run this code, refer to the <strong>Running the\ntutorials</strong> section for your platform: <a href=\"../../installing/on-mac-osx.html#building-the-tutorials\">Mac OS X</a>, <a href=\"../../installing/on-windows.html#running-the-tutorials\">Windows</a>, for\n<a href=\"../../installing/for-ios-development.html#building-the-tutorials\">iOS</a> or for <a href=\"../../installing/for-android-development.html#building-the-tutorials\">android</a>.</p>\n<p>This tutorial opens a window and displays a movie, with accompanying\naudio. The media is fetched from the Internet, so the window might\ntake a few seconds to appear, depending on your connection\nspeed. In the console window, you should see a message indicating\nwhere the media is being stored, and a text graph representing the\ndownloaded portions and the current position. A buffering message\nappears whenever buffering is required, which might never happen is\nyour network connection is fast enough</p>\n<p>Required libraries: <code>gstreamer-1.0</code></p>\n</blockquote>\n<h2 id=\"walkthrough\">Walkthrough</h2>\n<p>This code is based on that of <a href=\"../basic/streaming.html\">Basic tutorial 12: Streaming</a>. Let\u2019s review\nonly the differences.</p>\n<h3 id=\"setup\">Setup</h3>\n<pre><code class=\"language-c\">/* Set the download flag */\ng_object_get (pipeline, \"flags\", &amp;flags, NULL);\nflags |= GST_PLAY_FLAG_DOWNLOAD;\ng_object_set (pipeline, \"flags\", flags, NULL);\n</code></pre>\n<p>By setting this flag, <code>playbin</code> instructs its internal queue (a\n<code>queue2</code> element, actually) to store all downloaded\ndata.</p>\n<pre><code class=\"language-c\">g_signal_connect (pipeline, \"deep-notify::temp-location\", G_CALLBACK (got_location), NULL);\n</code></pre>\n<p><code>deep-notify</code> signals are emitted by <code>GstObject</code> elements (like\n<code>playbin</code>) when the properties of any of their children elements\nchange. In this case we want to know when the <code>temp-location</code> property\nchanges, indicating that the <code>queue2</code> has decided where to store the\ndownloaded\ndata.</p>\n<pre><code class=\"language-c\">static void got_location (GstObject *gstobject, GstObject *prop_object, GParamSpec *prop, gpointer data) {\n  gchar *location;\n  g_object_get (G_OBJECT (prop_object), \"temp-location\", &amp;location, NULL);\n  g_print (\"Temporary file: %s\\n\", location);\n  g_free (location);\n  /* Uncomment this line to keep the temporary file after the program exits */\n  /* g_object_set (G_OBJECT (prop_object), \"temp-remove\", FALSE, NULL); */\n}\n</code></pre>\n<p>The <code>temp-location</code> property is read from the element that triggered the\nsignal (the <code>queue2</code>) and printed on screen.</p>\n<p>When the pipeline state changes from <code>PAUSED</code> to <code>READY</code>, this file is\nremoved. As the comment reads, you can keep it by setting the\n<code>temp-remove</code> property of the <code>queue2</code> to <code>FALSE</code>.</p>\n<blockquote>\n<p><img src=\"images/icons/emoticons/warning.png\" alt=\"warning\" id=\"warning\">\nOn Windows this file is usually created inside the <code>Temporary Internet Files</code> folder, which might hide it from Windows Explorer. If you cannot find the downloaded files, try to use the console.</p>\n</blockquote>\n<h3 id=\"user-interface\">User Interface</h3>\n<p>In <code>main</code> we also install a timer which we use to refresh the UI every\nsecond.</p>\n<pre><code class=\"language-c\">/* Register a function that GLib will call every second */\ng_timeout_add_seconds (1, (GSourceFunc)refresh_ui, &amp;data);\n</code></pre>\n<p>The <code>refresh_ui</code> method queries the pipeline to find out which parts of\nthe file have been downloaded and what the currently playing position\nis. It builds a graph to display this information (sort of a text-mode\nuser interface) and prints it on screen, overwriting the previous one so\nit looks like it is animated:</p>\n<pre><code>[----&gt;-------                ]\n</code></pre>\n<p>The dashes \u2018<code>-</code>\u2019 indicate the downloaded parts, and the greater-than\nsign \u2018<code>&gt;</code>\u2019 shows the current position (turning into an \u2018<code>X</code>\u2019 when the\npipeline is paused). Keep in mind that if your network is fast enough,\nyou will not see the download bar (the dashes) advance at all; it will\nbe completely full from the beginning.</p>\n<pre><code class=\"language-c\">static gboolean refresh_ui (CustomData *data) {\n  GstQuery *query;\n  gboolean result;\n  query = gst_query_new_buffering (GST_FORMAT_PERCENT);\n  result = gst_element_query (data-&gt;pipeline, query);\n</code></pre>\n<p>The first thing we do in <code>refresh_ui</code> is construct a new Buffering\n<code>GstQuery</code> with <code>gst_query_new_buffering()</code> and pass it to the pipeline\n(<code>playbin</code>) with <code>gst_element_query()</code>. In <a href=\"../basic/time-management.html\">Basic tutorial 4: Time management</a> we have\nalready seen how to perform simple queries like Position and Duration\nusing specific methods. More complex queries, like Buffering, need to\nuse the more general <code>gst_element_query()</code>.</p>\n<p>The Buffering query can be made in different <code>GstFormat</code> (TIME, BYTES,\nPERCENTAGE and a few more). Not all elements can answer the query in all\nthe formats, so you need to check which ones are supported in your\nparticular pipeline. If <code>gst_element_query()</code> returns <code>TRUE</code>, the query\nsucceeded. The answer to the query is contained in the same\n<code>GstQuery</code> structure we created, and can be retrieved using multiple\nparse methods:</p>\n<pre><code class=\"language-c\">n_ranges = gst_query_get_n_buffering_ranges (query);\nfor (range = 0; range &lt; n_ranges; range++) {\n  gint64 start, stop;\n  gst_query_parse_nth_buffering_range (query, range, &amp;start, &amp;stop);\n  start = start * GRAPH_LENGTH / (stop - start);\n  stop = stop * GRAPH_LENGTH / (stop - start);\n  for (i = (gint)start; i &lt; stop; i++)\n    graph [i] = '-';\n}\n</code></pre>\n<p>Data does not need to be downloaded in consecutive pieces from the\nbeginning of the file: Seeking, for example, might force to start\ndownloading from a new position and leave a downloaded chunk behind.\nTherefore, <code>gst_query_get_n_buffering_ranges()</code> returns the number of\nchunks, or <em>ranges</em> of downloaded data, and then, the position and size\nof each range is retrieved with <code>gst_query_parse_nth_buffering_range()</code>.</p>\n<p>The format of the returned values (start and stop position for each\nrange) depends on what we requested in the\n<code>gst_query_new_buffering()</code> call. In this case, PERCENTAGE. These\nvalues are used to generate the graph.</p>\n<pre><code class=\"language-c\">if (gst_element_query_position (data-&gt;pipeline, &amp;format, &amp;position) &amp;&amp;\n    GST_CLOCK_TIME_IS_VALID (position) &amp;&amp;\n    gst_element_query_duration (data-&gt;pipeline, &amp;format, &amp;duration) &amp;&amp;\n    GST_CLOCK_TIME_IS_VALID (duration)) {\n  i = (gint)(GRAPH_LENGTH * (double)position / (double)(duration + 1));\n  graph [i] = data-&gt;buffering_level &lt; 100 ? 'X' : '&gt;';\n}\n</code></pre>\n<p>Next, the current position is queried. It could be queried in the\nPERCENT format, so code similar to the one used for the ranges is used,\nbut currently this format is not well supported for position queries.\nInstead, we use the TIME format and also query the duration to obtain a\npercentage.</p>\n<p>The current position is indicated with either a \u2018<code>&gt;</code>\u2019 or an \u2018<code>X</code>\u2019\ndepending on the buffering level. If it is below 100%, the code in the\n<code>cb_message</code> method will have set the pipeline to <code>PAUSED</code>, so we print\nan \u2018<code>X</code>\u2019. If the buffering level is 100% the pipeline is in the\n<code>PLAYING</code> state and we print a \u2018<code>&gt;</code>\u2019.</p>\n<pre><code class=\"language-c\">if (data-&gt;buffering_level &lt; 100) {\n  g_print (\" Buffering: %3d%%\", data-&gt;buffering_level);\n} else {\n  g_print (\"                \");\n}\n</code></pre>\n<p>Finally, if the buffering level is below 100%, we report this\ninformation (and delete it otherwise).</p>\n<h3 id=\"limiting-the-size-of-the-downloaded-file\">Limiting the size of the downloaded file</h3>\n<pre><code class=\"language-c\">/* Uncomment this line to limit the amount of downloaded data */\n/* g_object_set (pipeline, \"ring-buffer-max-size\", (guint64)4000000, NULL); */\n</code></pre>\n<p>Uncomment line 139 to see how this can be achieved. This reduces the\nsize of the temporary file, by overwriting already played regions.\nObserve the download bar to see which regions are kept available in the\nfile.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial has shown:</p>\n<ul>\n<li>How to enable progressive downloading with the\n<code>GST_PLAY_FLAG_DOWNLOAD</code> <code>playbin</code> flag</li>\n<li>How to know what has been downloaded using a Buffering <code>GstQuery</code></li>\n<li>How to know where it has been downloaded with the\n<code>deep-notify::temp-location</code> signal</li>\n<li>How to limit the size of the temporary file with\nthe <code>ring-buffer-max-size</code> property of <code>playbin</code>.</li>\n</ul>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n        "});