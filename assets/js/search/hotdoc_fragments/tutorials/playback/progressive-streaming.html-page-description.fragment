fragment_downloaded_cb({"url": "tutorials/playback/progressive-streaming.html#page-description", "fragment": "Basic tutorial Streaming showed how to enhance the user experience in poor network conditions by taking buffering into account. This tutorial further expands Basic tutorial Streaming by enabling the local storage of the streamed media and describes the advantages of this technique. In particular it shows \nWhen streaming data is fetched from the network and a small buffer of future data is kept to ensure smooth playback see Basic tutorial Streaming However data is discarded as soon as it is displayed or rendered there is no past data buffer This means that if a user wants to jump back and continue playback from a point in the past data needs to be re downloaded. \nMedia players tailored for streaming like YouTube usually keep all downloaded data stored locally for this contingency. A graphical widget is also normally used to show how much of the file has already been downloaded. \nplaybin offers similar functionalities through the DOWNLOAD flag which stores the media in a local temporary file for faster playback of already downloaded chunks. \nThis code also shows how to use the Buffering Query which allows knowing what parts of the file are available. \nCopy this code into a text file named playback tutorial c. \nplayback tutorial c \nIf you need help to compile this code refer to the Building the tutorials section for your platform Mac or Windows or use this specific command on Linux \ngcc playback tutorial c o playback tutorial pkg config cflags libs gstreamer \nIf you need help to run this code refer to the Running the tutorials section for your platform Mac OS X Windows for iOS or for android. \nThis tutorial opens a window and displays a movie with accompanying audio. The media is fetched from the Internet so the window might take a few seconds to appear depending on your connection speed. In the console window you should see a message indicating where the media is being stored and a text graph representing the downloaded portions and the current position. A buffering message appears whenever buffering is required which might never happen is your network connection is fast enough \nRequired libraries gstreamer \nThis code is based on that of Basic tutorial Streaming. Let s review only the differences. \nBy setting this flag playbin instructs its internal queue a queue2 element actually to store all downloaded data. \ndeep notify signals are emitted by GstObject elements like playbin when the properties of any of their children elements change. In this case we want to know when the temp location property changes indicating that the queue2 has decided where to store the downloaded data. \nThe temp location property is read from the element that triggered the signal the queue2 and printed on screen. \nWhen the pipeline state changes from PAUSED to READY this file is removed. As the comment reads you can keep it by setting the temp remove property of the queue2 to FALSE. \nOn Windows this file is usually created inside the Temporary Internet Files folder which might hide it from Windows Explorer. If you cannot find the downloaded files try to use the console. \nIn main we also install a timer which we use to refresh the UI every second. \nThe refresh_ui method queries the pipeline to find out which parts of the file have been downloaded and what the currently playing position is. It builds a graph to display this information sort of a text mode user interface and prints it on screen overwriting the previous one so it looks like it is animated \nThe dashes indicate the downloaded parts and the greater than sign shows the current position turning into an X when the pipeline is paused Keep in mind that if your network is fast enough you will not see the download bar the dashes advance at all it will be completely full from the beginning. \nThe first thing we do in refresh_ui is construct a new Buffering GstQuery with gst_query_new_buffering and pass it to the pipeline playbin with gst_element_query In Basic tutorial Time management we have already seen how to perform simple queries like Position and Duration using specific methods. More complex queries like Buffering need to use the more general gst_element_query \nThe Buffering query can be made in different GstFormat TIME BYTES PERCENTAGE and a few more Not all elements can answer the query in all the formats so you need to check which ones are supported in your particular pipeline. If gst_element_query returns TRUE the query succeeded. The answer to the query is contained in the same GstQuery structure we created and can be retrieved using multiple parse methods \nData does not need to be downloaded in consecutive pieces from the beginning of the file Seeking for example might force to start downloading from a new position and leave a downloaded chunk behind. Therefore gst_query_get_n_buffering_ranges returns the number of chunks or ranges of downloaded data and then the position and size of each range is retrieved with gst_query_parse_nth_buffering_range \nThe format of the returned values start and stop position for each range depends on what we requested in the gst_query_new_buffering call. In this case PERCENTAGE. These values are used to generate the graph. \nNext the current position is queried. It could be queried in the PERCENT format so code similar to the one used for the ranges is used but currently this format is not well supported for position queries. Instead we use the TIME format and also query the duration to obtain a percentage. \nThe current position is indicated with either a or an X depending on the buffering level. If it is below the code in the cb_message method will have set the pipeline to PAUSED so we print an X If the buffering level is the pipeline is in the PLAYING state and we print a \nFinally if the buffering level is below we report this information and delete it otherwise \nUncomment line to see how this can be achieved. This reduces the size of the temporary file by overwriting already played regions. Observe the download bar to see which regions are kept available in the file. \nThis tutorial has shown \nIt has been a pleasure having you here and see you soon \n"});