fragment_downloaded_cb({"url": "tutorials/playback/playbin-usage.html#walkthrough", "fragment": "Walkthrough \nWe start as usual putting all our variables in a structure so we can pass it around to functions. For this tutorial we need the amount of streams of each type and the currently playing one. Also we are going to use a different mechanism to wait for messages that allows interactivity so we need a GLib s main loop object. \nLater we are going to set some of playbin s flags. We would like to have a handy enum that allows manipulating these flags easily but since playbin is a plug in and not a part of the GStreamer core this enum is not available to us. The trick is simply to declare this enum in our code as it appears in the playbin documentation GstPlayFlags. GObject allows introspection so the possible values for these flags can be retrieved at runtime without using this trick but in a far more cumbersome way. \nForward declarations for the two callbacks we will be using. handle_message for the GStreamer messages as we have already seen and handle_keyboard for key strokes since this tutorial is introducing a limited amount of interactivity. \nWe skip over the creation of the pipeline the instantiation of playbin and pointing it to our test media through the uri property. playbin is in itself a pipeline and in this case it is the only element in the pipeline so we skip completely the creation of the pipeline and use directly the playbin element. \nWe focus on some of the other properties of playbin though \nplaybin s behavior can be changed through its flags property which can have any combination of GstPlayFlags. The most interesting values are \nIn our case for demonstration purposes we are enabling audio and video and disabling subtitles leaving the rest of flags to their default values this is why we read the current value of the flags with g_object_get before overwriting it with g_object_set \nThis property is not really useful in this example. connection speed informs playbin of the maximum speed of our network connection so in case multiple versions of the requested media are available in the server playbin chooses the most appropriate. This is mostly used in combination with streaming protocols like mms or rtsp. \nWe have set all these properties one by one but we could have all of them with a single call to g_object_set \nThis is why g_object_set requires a NULL as the last parameter. \nThese lines connect a callback function to the standard input the keyboard The mechanism shown here is specific to GLib and not really related to GStreamer so there is no point in going into much depth. Applications normally have their own way of handling user input and GStreamer has little to do with it besides the Navigation interface discussed briefly in Tutorial DVD playback \nTo allow interactivity we will no longer poll the GStreamer bus manually. Instead we create a GMainLoop GLib main loop and set it running with g_main_loop_run This function blocks and will not return until g_main_loop_quit is issued. In the meantime it will call the callbacks we have registered at the appropriate times handle_message when a message appears on the bus and handle_keyboard when the user presses any key. \nThere is nothing new in handle_message except that when the pipeline moves to the PLAYING state it will call the analyze_streams function \nAs the comment says this function just gathers information from the media and prints it on the screen. The number of video audio and subtitle streams is directly available through the n video n audio and n text properties. \nNow for each stream we want to retrieve its metadata. Metadata is stored as tags in a GstTagList structure which is a list of data pieces identified by a name. The GstTagList associated with a stream can be recovered with g_signal_emit_by_name and then individual tags are extracted with the gst_tag_list_get_ functions like gst_tag_list_get_string for example. \nThis rather unintuitive way of retrieving the tag list is called an Action Signal. Action signals are emitted by the application to a specific element which then performs an action and returns a result. They behave like a dynamic function call in which methods of a class are identified by their name the signal s name instead of their memory address. These signals are listed In the documentation along with the regular signals and are tagged Action See playbin for example. \n"});