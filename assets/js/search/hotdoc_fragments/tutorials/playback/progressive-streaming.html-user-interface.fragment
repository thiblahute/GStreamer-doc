fragment_downloaded_cb({"url": "tutorials/playback/progressive-streaming.html#user-interface", "fragment": "User Interface \nIn main we also install a timer which we use to refresh the UI every second. \nThe refresh_ui method queries the pipeline to find out which parts of the file have been downloaded and what the currently playing position is. It builds a graph to display this information sort of a text mode user interface and prints it on screen overwriting the previous one so it looks like it is animated \nThe dashes indicate the downloaded parts and the greater than sign shows the current position turning into an X when the pipeline is paused Keep in mind that if your network is fast enough you will not see the download bar the dashes advance at all it will be completely full from the beginning. \nThe first thing we do in refresh_ui is construct a new Buffering GstQuery with gst_query_new_buffering and pass it to the pipeline playbin with gst_element_query In Basic tutorial Time management we have already seen how to perform simple queries like Position and Duration using specific methods. More complex queries like Buffering need to use the more general gst_element_query \nThe Buffering query can be made in different GstFormat TIME BYTES PERCENTAGE and a few more Not all elements can answer the query in all the formats so you need to check which ones are supported in your particular pipeline. If gst_element_query returns TRUE the query succeeded. The answer to the query is contained in the same GstQuery structure we created and can be retrieved using multiple parse methods \nData does not need to be downloaded in consecutive pieces from the beginning of the file Seeking for example might force to start downloading from a new position and leave a downloaded chunk behind. Therefore gst_query_get_n_buffering_ranges returns the number of chunks or ranges of downloaded data and then the position and size of each range is retrieved with gst_query_parse_nth_buffering_range \nThe format of the returned values start and stop position for each range depends on what we requested in the gst_query_new_buffering call. In this case PERCENTAGE. These values are used to generate the graph. \nNext the current position is queried. It could be queried in the PERCENT format so code similar to the one used for the ranges is used but currently this format is not well supported for position queries. Instead we use the TIME format and also query the duration to obtain a percentage. \nThe current position is indicated with either a or an X depending on the buffering level. If it is below the code in the cb_message method will have set the pipeline to PAUSED so we print an X If the buffering level is the pipeline is in the PLAYING state and we print a \nFinally if the buffering level is below we report this information and delete it otherwise \n"});