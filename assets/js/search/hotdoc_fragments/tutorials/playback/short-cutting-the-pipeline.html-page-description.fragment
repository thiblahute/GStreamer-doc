fragment_downloaded_cb({"url": "tutorials/playback/short-cutting-the-pipeline.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"short-cutting-the-pipeline.md\">\n<h1 id=\"playback-tutorial-3-shortcutting-the-pipeline\">Playback tutorial 3: Short-cutting the pipeline</h1>\n<h2 id=\"goal\">Goal</h2>\n<p><a href=\"../basic/short-cutting-the-pipeline.html\">Basic tutorial 8: Short-cutting the pipeline</a> showed\nhow an application can manually extract or inject data into a pipeline\nby using two special elements called <code>appsrc</code> and <code>appsink</code>.\n<code>playbin</code> allows using these elements too, but the method to connect\nthem is different. To connect an <code>appsink</code> to <code>playbin</code> see <a href=\"custom-playbin-sinks.html\">Playback tutorial 7: Custom playbin sinks</a>.\nThis tutorial shows:</p>\n<ul>\n<li>How to connect <code>appsrc</code> with <code>playbin</code></li>\n<li>How to configure the <code>appsrc</code></li>\n</ul>\n<h2 id=\"a-playbin-waveform-generator\">A playbin waveform generator</h2>\n<p>Copy this code into a text file named <code>playback-tutorial-3.c</code>.</p>\n<p><strong>playback-tutorial-3.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;gst/gst.h&gt;\n#include &lt;gst/audio/audio.h&gt;\n#include &lt;string.h&gt;\n\n#define CHUNK_SIZE 1024   /* Amount of bytes we are sending in each buffer */\n#define SAMPLE_RATE 44100 /* Samples per second we are sending */\n\n/* Structure to contain all our information, so we can pass it to callbacks */\ntypedef struct _CustomData {\n  GstElement *pipeline;\n  GstElement *app_source;\n\n  guint64 num_samples;   /* Number of samples generated so far (for timestamp generation) */\n  gfloat a, b, c, d;     /* For waveform generation */\n\n  guint sourceid;        /* To control the GSource */\n\n  GMainLoop *main_loop;  /* GLib's Main Loop */\n} CustomData;\n\n/* This method is called by the idle GSource in the mainloop, to feed CHUNK_SIZE bytes into appsrc.\n * The ide handler is added to the mainloop when appsrc requests us to start sending data (need-data signal)\n * and is removed when appsrc has enough data (enough-data signal).\n */\nstatic gboolean push_data (CustomData *data) {\n  GstBuffer *buffer;\n  GstFlowReturn ret;\n  int i;\n  GstMapInfo map;\n  gint16 *raw;\n  gint num_samples = CHUNK_SIZE / 2; /* Because each sample is 16 bits */\n  gfloat freq;\n\n  /* Create a new empty buffer */\n  buffer = gst_buffer_new_and_alloc (CHUNK_SIZE);\n\n  /* Set its timestamp and duration */\n  GST_BUFFER_TIMESTAMP (buffer) = gst_util_uint64_scale (data-&gt;num_samples, GST_SECOND, SAMPLE_RATE);\n  GST_BUFFER_DURATION (buffer) = gst_util_uint64_scale (CHUNK_SIZE, GST_SECOND, SAMPLE_RATE);\n\n  /* Generate some psychodelic waveforms */\n  gst_buffer_map (buffer, &amp;map, GST_MAP_WRITE);\n  raw = (gint16 *)map.data;\n  data-&gt;c += data-&gt;d;\n  data-&gt;d -= data-&gt;c / 1000;\n  freq = 1100 + 1000 * data-&gt;d;\n  for (i = 0; i &lt; num_samples; i++) {\n    data-&gt;a += data-&gt;b;\n    data-&gt;b -= data-&gt;a / freq;\n    raw[i] = (gint16)(500 * data-&gt;a);\n  }\n  gst_buffer_unmap (buffer, &amp;map);\n  data-&gt;num_samples += num_samples;\n\n  /* Push the buffer into the appsrc */\n  g_signal_emit_by_name (data-&gt;app_source, \"push-buffer\", buffer, &amp;ret);\n\n  /* Free the buffer now that we are done with it */\n  gst_buffer_unref (buffer);\n\n  if (ret != GST_FLOW_OK) {\n    /* We got some error, stop sending data */\n    return FALSE;\n  }\n\n  return TRUE;\n}\n\n/* This signal callback triggers when appsrc needs data. Here, we add an idle handler\n * to the mainloop to start pushing data into the appsrc */\nstatic void start_feed (GstElement *source, guint size, CustomData *data) {\n  if (data-&gt;sourceid == 0) {\n    g_print (\"Start feeding\\n\");\n    data-&gt;sourceid = g_idle_add ((GSourceFunc) push_data, data);\n  }\n}\n\n/* This callback triggers when appsrc has enough data and we can stop sending.\n * We remove the idle handler from the mainloop */\nstatic void stop_feed (GstElement *source, CustomData *data) {\n  if (data-&gt;sourceid != 0) {\n    g_print (\"Stop feeding\\n\");\n    g_source_remove (data-&gt;sourceid);\n    data-&gt;sourceid = 0;\n  }\n}\n\n/* This function is called when an error message is posted on the bus */\nstatic void error_cb (GstBus *bus, GstMessage *msg, CustomData *data) {\n  GError *err;\n  gchar *debug_info;\n\n  /* Print error details on the screen */\n  gst_message_parse_error (msg, &amp;err, &amp;debug_info);\n  g_printerr (\"Error received from element %s: %s\\n\", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);\n  g_printerr (\"Debugging information: %s\\n\", debug_info ? debug_info : \"none\");\n  g_clear_error (&amp;err);\n  g_free (debug_info);\n\n  g_main_loop_quit (data-&gt;main_loop);\n}\n\n/* This function is called when playbin has created the appsrc element, so we have\n * a chance to configure it. */\nstatic void source_setup (GstElement *pipeline, GstElement *source, CustomData *data) {\n  GstAudioInfo info;\n  GstCaps *audio_caps;\n\n  g_print (\"Source has been created. Configuring.\\n\");\n  data-&gt;app_source = source;\n\n  /* Configure appsrc */\n  gst_audio_info_set_format (&amp;info, GST_AUDIO_FORMAT_S16, SAMPLE_RATE, 1, NULL);\n  audio_caps = gst_audio_info_to_caps (&amp;info);\n  g_object_set (source, \"caps\", audio_caps, \"format\", GST_FORMAT_TIME, NULL);\n  g_signal_connect (source, \"need-data\", G_CALLBACK (start_feed), data);\n  g_signal_connect (source, \"enough-data\", G_CALLBACK (stop_feed), data);\n  gst_caps_unref (audio_caps);\n  g_free (audio_caps_text);\n}\n\nint main(int argc, char *argv[]) {\n  CustomData data;\n  GstBus *bus;\n\n  /* Initialize cumstom data structure */\n  memset (&amp;data, 0, sizeof (data));\n  data.b = 1; /* For waveform generation */\n  data.d = 1;\n\n  /* Initialize GStreamer */\n  gst_init (&amp;argc, &amp;argv);\n\n  /* Create the playbin element */\n  data.pipeline = gst_parse_launch (\"playbin uri=appsrc://\", NULL);\n  g_signal_connect (data.pipeline, \"source-setup\", G_CALLBACK (source_setup), &amp;data);\n\n  /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */\n  bus = gst_element_get_bus (data.pipeline);\n  gst_bus_add_signal_watch (bus);\n  g_signal_connect (G_OBJECT (bus), \"message::error\", (GCallback)error_cb, &amp;data);\n  gst_object_unref (bus);\n\n  /* Start playing the pipeline */\n  gst_element_set_state (data.pipeline, GST_STATE_PLAYING);\n\n  /* Create a GLib Main Loop and set it to run */\n  data.main_loop = g_main_loop_new (NULL, FALSE);\n  g_main_loop_run (data.main_loop);\n\n  /* Free resources */\n  gst_element_set_state (data.pipeline, GST_STATE_NULL);\n  gst_object_unref (data.pipeline);\n  return 0;\n}\n</code></pre>\n<p>To use an <code>appsrc</code> as the source for the pipeline, simply instantiate a\n<code>playbin</code> and set its URI to <code>appsrc://</code></p>\n<pre><code class=\"language-c\">/* Create the playbin element */\ndata.pipeline = gst_parse_launch (\"playbin uri=appsrc://\", NULL);\n</code></pre>\n<p><code>playbin</code> will create an internal <code>appsrc</code> element and fire the\n<code>source-setup</code> signal to allow the application to configure\nit:</p>\n<pre><code class=\"language-c\">g_signal_connect (data.pipeline, \"source-setup\", G_CALLBACK (source_setup), &amp;data);\n</code></pre>\n<p>In particular, it is important to set the caps property of <code>appsrc</code>,\nsince, once the signal handler returns, <code>playbin</code> will instantiate the\nnext element in the pipeline according to these\ncaps:</p>\n<pre><code class=\"language-c\">/* This function is called when playbin has created the appsrc element, so we have\n * a chance to configure it. */\nstatic void source_setup (GstElement *pipeline, GstElement *source, CustomData *data) {\n  GstAudioInfo info;\n  GstCaps *audio_caps;\n\n  g_print (\"Source has been created. Configuring.\\n\");\n  data-&gt;app_source = source;\n\n  /* Configure appsrc */\n  gst_audio_info_set_format (&amp;info, GST_AUDIO_FORMAT_S16, SAMPLE_RATE, 1, NULL);\n  audio_caps = gst_audio_info_to_caps (&amp;info);\n  g_object_set (source, \"caps\", audio_caps, \"format\", GST_FORMAT_TIME, NULL);\n  g_signal_connect (source, \"need-data\", G_CALLBACK (start_feed), data);\n  g_signal_connect (source, \"enough-data\", G_CALLBACK (stop_feed), data);\n  gst_caps_unref (audio_caps);\n  g_free (audio_caps_text);\n}\n</code></pre>\n<p>The configuration of the <code>appsrc</code> is exactly the same as in\n<a href=\"../basic/short-cutting-the-pipeline.html\">Basic tutorial 8: Short-cutting the pipeline</a>:\nthe caps are set to <code>audio/x-raw</code>, and two callbacks are registered,\nso the element can tell the application when it needs to start and stop\npushing data. See <a href=\"../basic/short-cutting-the-pipeline.html\">Basic tutorial 8: Short-cutting the pipeline</a>\nfor more details.</p>\n<p>From this point onwards, <code>playbin</code> takes care of the rest of the\npipeline, and the application only needs to worry about generating more\ndata when told so.</p>\n<p>To learn how data can be extracted from <code>playbin</code> using the\n<code>appsink</code> element, see <a href=\"custom-playbin-sinks.html\">Playback tutorial 7: Custom playbin sinks</a>.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial applies the concepts shown in\n<a href=\"../basic/short-cutting-the-pipeline.html\">Basic tutorial 8: Short-cutting the pipeline</a> to\n<code>playbin</code>. In particular, it has shown:</p>\n<ul>\n<li>How to connect <code>appsrc</code> with <code>playbin</code> using the special\nURI <code>appsrc://</code></li>\n<li>How to configure the <code>appsrc</code> using the <code>source-setup</code> signal</li>\n</ul>\n<p>It has been a pleasure having you here, and see you soon!</p>\n\n</div>\n\n\n        "});