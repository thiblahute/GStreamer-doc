fragment_downloaded_cb({"url": "design/events.html#flush_startstop", "fragment": "FLUSH_START STOP \nA flush event is sent both downstream and upstream to clear any pending data from the pipeline. This might be needed to make the graph more responsive when the normal dataflow gets interrupted by for example a seek event. \nFlushing happens in two stages. \na source element sends the FLUSH_START event to the downstream peer element. The downstream element starts rejecting buffers from the upstream elements. It sends the flush event further downstream and discards any buffers it is holding as well as return from the chain function as soon as possible. This makes sure that all upstream elements get unblocked. This event is not synchronized with the STREAM_LOCK and can be done in the application thread. \na source element sends the FLUSH_STOP event to indicate that the downstream element can accept buffers again. The downstream element sends the flush event to its peer elements. After this step dataflow continues. The FLUSH_STOP call is synchronized with the STREAM_LOCK so any data used by the chain function can safely freed here if needed. Any pending EOS events should be discarded too. \nAfter the flush completes the second stage data is flowing again in the pipeline and all buffers are more recent than those before the flush. \nFor elements that use the pullrange function they send both flush events to the upstream pads in the same way to make sure that the pullrange function unlocks and any pending buffers are cleared in the upstream elements. \nA FLUSH_START may instruct the pipeline to distribute a new base_time to elements so that the running_time is reset to see clocks and synchronisation \n"});