fragment_downloaded_cb({"url": "design/latency.html#example-1", "fragment": "Example \nAn audio capture playback pipeline. \nNULL READY \nREADY PAUSED \nSince the source is a live source it will only produce data in the PLAYING state. To note this fact it returns NO_PREROLL from the state change function. \nThis sink returns ASYNC because it can only complete the state change to PAUSED when it receives the first buffer. \nAt this point the pipeline is not processing data and the clock is not running. Unless a new action is performed on the pipeline this situation will never change. \nPAUSED PLAYING asrc clock selected because it is the most upstream clock provider. asink can only provide a clock when it received the first buffer and configured the device with the samplerate in the caps. \nsink PAUSED PLAYING sets pending state to PLAYING returns ASYNC because it is not prerolled. The sink will commit state to PLAYING when it prerolls. \nsrc PAUSED PLAYING starts pushing buffers. \nsince the sink is still performing a state change from READY PAUSED it remains ASYNC. The pending state will be set to PLAYING. \nThe clock starts running as soon as all the elements have been set to PLAYING. \nthe source is a live source with a latency. Since it is synchronized with the clock it will produce a buffer with timestamp and duration D after time D ie. it will only be able to produce the last sample of the buffer with timestamp D at time D. This latency depends on the size of the buffer. \nthe sink will receive the buffer with timestamp at time D. At this point the buffer is too late already and might be dropped. This state of constantly dropping data will not change unless a constant latency correction is added to the incoming buffer timestamps. \nThe problem is due to the fact that the sink is set to pending PLAYING without being prerolled which only happens in live pipelines. \n"});