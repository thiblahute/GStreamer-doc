fragment_downloaded_cb({"url": "design/probes.html#page-description", "fragment": "Probes are callbacks that can be installed by the application and will notify the application about the states of the dataflow. \nApplications should be able to monitor and control the dataflow on pads. We identify the following types \nbe notified when the pad is becomes idle and make sure the pad stays idle. This is essential to be able to implement dynamic relinking of elements without breaking the dataflow. \nbe notified when data events or queries are pushed or sent on a pad. It should also be possible to inspect and modify the data. \nbe able to drop pass and block on data based on the result of the callback. \nbe able to drop pass data on blocking pads based on methods performed by the application thread. \nThe function gst_pad_add_probe is used to add a probe to a pad. It accepts a probe type mask and a callback. \nThe function returns a gulong that uniquely identifies the probe and that can be used to remove the probe with gst_pad_remove_probe \nThe mask parameter is a bitwise or of the following flags \nWhen adding a probe with the IDLE or BLOCK flag the probe will become a blocking probe see below Otherwise the probe will be a DATA probe. \nThe datatype and scheduling selector flags are used to select what kind of datatypes and scheduling modes should be allowed in the callback. \nThe blocking flags must match the triggered probe exactly. \nThe probe callback is defined as \nA probe info structure is passed as an argument and its type is guaranteed to match the mask that was used to register the callback. The data item in the info contains type specific data which is usually the data item that is blocked or NULL when no data item is present. \nThe probe can return any of the following return values \nGST_PAD_PROBE_OK is the normal return value. _DROP will drop the item that is currently being probed. GST_PAD_PROBE_REMOVE remove the currently executing probe from the list of probes. \nGST_PAD_PROBE_PASS is relevant for blocking probes and will temporarily unblock the pad and let the item trough it will then block again on the next item. \nBlocking probes are probes with BLOCK or IDLE flags set. They will always block the dataflow and trigger the callback according to the following rules \nWhen the IDLE flag is set the probe callback is called as soon as no data is flowing over the pad. If at the time of probe registration the pad is idle the callback will be called immediately from the current thread. Otherwise the callback will be called as soon as the pad becomes idle in the streaming thread. \nThe IDLE probe is useful to perform dynamic linking it allows to wait for for a safe moment when an unlink link operation can be done. Since the probe is a blocking probe it will also make sure that the pad stays idle until the probe is removed. \nWhen the BLOCK flag is set the probe callback will be called when new data arrives on the pad and right before the pad goes into the blocking state. This callback is thus only called when there is new data on the pad. \nThe blocking probe is removed with gst_pad_remove_probe or when the probe callback return GST_PAD_PROBE_REMOVE. In both cases and if this was the last blocking probe on the pad the pad is unblocked and dataflow can continue. \nNon blocking probes or DATA probes are probes triggered when data is flowing over the pad. The are called after the blocking probes are run and always with data. \nPush probes have the GST_PAD_PROBE_TYPE_PUSH flag set in the callbacks. \nIn push based scheduling the blocking probe is called first with the data item. Then the data probes are called before the peer pad chain or event function is called. \nThe data probes are called before the peer pad is checked. This allows for linking the pad in either the BLOCK or DATA probes on the pad. \nBefore the peerpad chain or event function is called the peer pad block and data probes are called. \nFinally the IDLE probe is called on the pad after the data was sent to the peer pad. \nThe push dataflow probe behavior is the same for buffers and bidirectional events. \nPull probes have the GST_PAD_PROBE_TYPE_PULL flag set in the callbacks. \nThe gst_pad_pull_range call will first trigger the BLOCK probes without a DATA item. This allows the pad to be linked before the peer pad is resolved. It also allows the callback to set a data item in the probe info. \nAfter the blocking probe and the getrange function is called on the peer pad and there is a data item the DATA probes are called. \nWhen control returns to the sinkpad the IDLE callbacks are called. The IDLE callback is called without a data item so that it will also be called when there was an error. \nIf there is a valid DATA item the DATA probes are called for the item. \nQuery probes have the GST_PAD_PROBE_TYPE_QUERY_ flag set in the callbacks. \nFor queries the PUSH ProbeType is set when the query is traveling to the object that will answer the query and the PULL type is set when the query contains the answer. \nThe purpose is to create the pipeline dynamically up to the decoders but not yet connect them to a sink and without losing any data. \nTo do this the source pads of the decoders is blocked so that no events or buffers can escape and we don t interrupt the stream. \nWhen all of the dynamic pad are created no more pads emitted by the branching point ie the demuxer or the queues filled and the pads are blocked blocked callback received the pipeline is completely prerolled. \nIt should then be possible to perform the following actions on the prerolled pipeline \nquery duration position \nperform a flushing seek to preroll a new position \nconnect other elements and unblock the blocked pads. \nThe purpose is to replace element2 with element4 in the PLAYING pipeline. \nThe same flow can be used to replace an element in a PAUSED pipeline. Of course in a PAUSED pipeline there might not be dataflow so the block might not immediately happen. \n"});