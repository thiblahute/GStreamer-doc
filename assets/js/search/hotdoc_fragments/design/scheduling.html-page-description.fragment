fragment_downloaded_cb({"url": "design/scheduling.html#page-description", "fragment": "The scheduling in GStreamer is based on pads actively pushing producing data or pulling consuming data from other pads. \nA pad can produce data and push it to the next pad. A pad that behaves this way exposes a loop function that will be repeatedly called until it returns false. This loop function is allowed to block whenever it wants. When the pad is deactivated the loop function should unblock though. \nA pad operating in the push mode can only produce data to a pad that exposes a chain function. This chain function will be called with the buffer produced by the pushing pad. \nThis method of producing data is called the streaming mode since the producer produces a constant stream of data. \nPads that operate in pulling mode can only pull data from a pad that exposes the pull_range function. In this case the sink pad exposes a loop function that will be called repeatedly until the task is stopped. \nAfter pulling data from the peer pad the loop function will typically call the push function to push the result to the peer sinkpad. \nWhen a pad is activated the _activate function is called. The pad can then choose to activate itself in push or pull mode depending on upstream capabilities. \nThe GStreamer core will by default activate pads in push mode when there is no activate function for the pad. \nThe chain function will be called when a upstream element performs a _push on the pad. The upstream element can be another chain based element or a pushing source. \nThe getrange function is called when a peer pad performs a _pull_range on the pad. This downstream pad can be a pulling element or another _pull_range based element. \nA sinkpad can ask the upstream srcpad for its scheduling attributes. It does this with the SCHEDULING query. \nout modes G_TYPE_ARRAY default NULL an array of GST_TYPE_PAD_MODE enums. Contains all the supported scheduling modes. \nout flags GST_TYPE_SCHEDULING_FLAGS default \n_SEEKABLE the offset of a pull operation can be specified if this flag is false the offset should be \n_SEQUENTIAL suggest sequential access to the data. If _SEEKABLE is specified seeks are allowed but should be avoided. This is common for network streams. \n_BANDWIDTH_LIMITED suggest the element supports buffering data for downstream to cope with bandwidth limitations. If this flag is on the downstream element might ask for more data than necessary for normal playback. This use case is interesting for on disk buffering scenarios for instance. Seek operations might be slow as well so downstream elements should take this into consideration. \nout minsize G_TYPE_INT default the suggested minimum size of pull requests \nout maxsize G_TYPE_INT default unlimited the suggested maximum size of pull requests \nout align G_TYPE_INT default the suggested alignment for the pull requests. \nElements with multiple sinks can either expose a loop function on each of the pads to actively pull_range data or they can expose a chain function on each pad. \nImplementing a chain function is usually easy and allows for all possible scheduling methods. \nIf the chain based sink wants to wait for one of the pads to receive a buffer just implement the action to perform in the chain function. Be aware that the action could be performed in different threads and possibly simultaneously so grab the STREAM_LOCK. \nIf the chain based sink pads all require one buffer before the element can operate on the data collect all the buffers in the chain function and perform the action when all chainpads received the buffer. \nIn this case you probably also don t want to accept more data on a pad that has a buffer queued. This can easily be done with the following code snippet \nInside the braces below the pads is stated what function the pad support \nFollowing scheduling decisions are made based on the scheduling methods exposed by the pads \ng l sinkpad will pull data from src \nl c srcpad actively pushes data to sinkpad \nc srcpad will push data to sinkpad. \nnot schedulable. \nl not schedulable. \ng not schedulable. \ng c not schedulable. \nl not schedulable. \nl l not schedulable \ng impossible \ng g impossible. \nl g impossible \nc impossible \nc g impossible \nc l impossible \nc c impossible \nWhen activating the pads \naudiosink has a chain function and the peer pad has no loop function no scheduling is done. \nmp3decoder and filesrc expose an l c connection a thread is created to call the srcpad loop function. \nfakesink has a chain function and the peer pad has no loop function no scheduling is done. \navidemuxer and filesrc expose an g l connection a thread is created to call the sinkpad loop function. \nfakesink has a chain function and the peer pad has no loop function no scheduling is done. \navidemuxer and identity expose no schedulable connection so this pipeline is not schedulable. \nfakesink has a chain function and the peer pad has no loop function no scheduling is done. \navidemuxer and identity expose an g l connection a thread is created to call the sinkpad loop function. \nidentity knows the srcpad is getrange based and uses the thread from avidemux to getrange data from filesrc. \nfakesink has a chain function and the peer pad has no loop function no scheduling is done. \noggdemuxer and identity expose an l c connection oggdemux has to operate in chain mode. \nidentity chan only work chain based and so filesrc creates a thread to push data to it. \n"});