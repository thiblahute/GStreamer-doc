fragment_downloaded_cb({"url": "design/MT-refcounting.html#mutable-substructures", "fragment": "Mutable substructures \nSpecial techniques are necessary to ensure the consistency of compound shared objects. As mentioned above shared objects need to have a reference count of if they are to be modified. Implicit in this assumption is that all parts of the shared object belong only to the object. For example a GstStructure in one GstCaps object should not belong to any other GstCaps object. This condition suggests a parent child relationship structures can only be added to parent object if they do not already have a parent object. \nIn addition these substructures must not be modified while more than one code segment has a reference on the parent object. For example if the user creates a GstStructure adds it to a GstCaps and the GstCaps is then referenced by other code segments the GstStructure should then become immutable so that changes to that data structure do not affect other parts of the code. This means that the child is only mutable when the parent s reference count is as well as when the child structure has no parent. \nThe general solution to this problem is to include a field in child structures pointing to the parent s atomic reference count. When set to NULL this indicates that the child has no parent. Otherwise procedures that modify the child structure must check if the parent s refcount is and otherwise must cause an error to be signaled. \nNote that this is an internal implementation detail application or plugin code that calls _get_writable on an object is guaranteed to receive an object of refcount which must then be writable. The only trick is that a pointer to a child structure of an object is only valid while the calling code has a reference on the parent object because the parent is the owner of the child. \n"});