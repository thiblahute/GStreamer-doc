fragment_downloaded_cb({"url": "design/audiosinks.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"audiosinks.md\">\n        <h2 id=\"audiosink-design\">Audiosink design</h2>\n<h3 id=\"requirements\">Requirements</h3>\n<ul>\n<li>\n<p>must operate chain based. Most simple playback pipelines will push\naudio from the decoders into the audio sink.</p>\n</li>\n<li>\n<p>must operate getrange based Most professional audio applications\nwill operate in a mode where the audio sink pulls samples from the\npipeline. This is typically done in a callback from the audiosink\nrequesting N samples. The callback is either scheduled from a thread\nor from an interrupt from the audio hardware device.</p>\n</li>\n<li>\n<p>Exact sample accurate clocks. the audiosink must be able to provide\na clock that is sample accurate even if samples are dropped or when\ndiscontinuities are found in the stream.</p>\n</li>\n<li>\n<p>Exact timing of playback. The audiosink must be able to play samples\nat their exact times.</p>\n</li>\n<li>\n<p>use DMA access when possible. When the hardware can do DMA we should\nuse it. This should also work over bufferpools to avoid data copying\nto/from kernel space.</p>\n</li>\n</ul>\n<h3 id=\"design\">Design</h3>\n<p>The design is based on a set of base classes and the concept of a\nringbuffer of samples.</p>\n<pre><code>+-----------+   - provide preroll, rendering, timing\n+ basesink  +   - caps nego\n+-----+-----+\n      |\n+-----V----------+   - manages ringbuffer\n+ audiobasesink  +   - manages scheduling (push/pull)\n+-----+----------+   - manages clock/query/seek\n      |              - manages scheduling of samples in the ringbuffer\n      |              - manages caps parsing\n      |\n+-----V------+   - default ringbuffer implementation with a GThread\n+ audiosink  +   - subclasses provide open/read/close methods\n+------------+\n</code></pre>\n<p>The ringbuffer is a contiguous piece of memory divided into segtotal\npieces of segments. Each segment has segsize bytes.</p>\n<pre><code>      play position \n        v          \n+---+---+---+-------------------------------------+----------+\n+ 0 | 1 | 2 | ....                                | segtotal |\n+---+---+---+-------------------------------------+----------+\n&lt;---&gt;\n  segsize bytes = N samples * bytes_per_sample.\n</code></pre>\n<p>The ringbuffer has a play position, which is expressed in segments. The\nplay position is where the device is currently reading samples from the\nbuffer.</p>\n<p>The ringbuffer can be put to the PLAYING or STOPPED state.</p>\n<p>In the STOPPED state no samples are played to the device and the play\npointer does not advance.</p>\n<p>In the PLAYING state samples are written to the device and the\nringbuffer should call a configurable callback after each segment is\nwritten to the device. In this state the play pointer is advanced after\neach segment is written.</p>\n<p>A write operation to the ringbuffer will put new samples in the\nringbuffer. If there is not enough space in the ringbuffer, the write\noperation will block. The playback of the buffer never stops, even if\nthe buffer is empty. When the buffer is empty, silence is played by the\ndevice.</p>\n<p>The ringbuffer is implemented with lockfree atomic operations,\nespecially on the reading side so that low-latency operations are\npossible.</p>\n<p>Whenever new samples are to be put into the ringbuffer, the position of\nthe read pointer is taken. The required write position is taken and the\ndiff is made between the required and actual position. If the difference\nis &lt;0, the sample is too late. If the difference is bigger than\nsegtotal, the writing part has to wait for the play pointer to advance.</p>\n<h3 id=\"scheduling\">Scheduling</h3>\n<h4 id=\"chain-based-mode\">chain based mode</h4>\n<p>In chain based mode, bytes are written into the ringbuffer. This\noperation will eventually block when the ringbuffer is filled.</p>\n<p>When no samples arrive in time, the ringbuffer will play silence. Each\nbuffer that arrives will be placed into the ringbuffer at the correct\ntimes. This means that dropping samples or inserting silence is done\nautomatically and very accurate and independend of the play pointer.</p>\n<p>In this mode, the ringbuffer is usually kept as full as possible. When\nusing a small buffer (small segsize and segtotal), the latency for audio\nto start from the sink to when it is played can be kept low but at least\none context switch has to be made between read and write.</p>\n<h4 id=\"getrange-based-mode\">getrange based mode</h4>\n<p>In getrange based mode, the audiobasesink will use the callback\nfunction of the ringbuffer to get a segsize samples from the peer\nelement. These samples will then be placed in the ringbuffer at the\nnext play position. It is assumed that the getrange function returns\nfast enough to fill the ringbuffer before the play pointer reaches\nthe write pointer.</p>\n<p>In this mode, the ringbuffer is usually kept as empty as possible.\nThere is no context switch needed between the elements that create\nthe samples and the actual writing of the samples to the device.</p>\n<h4 id=\"dma-mode\">DMA mode</h4>\n<p>Elements that can do DMA based access to the audio device have to\nsubclass from the GstAudioBaseSink class and wrap the DMA ringbuffer\nin a subclass of GstRingBuffer.</p>\n<p>The ringbuffer subclass should trigger a callback after writing or\nplaying each sample to the device. This callback can be triggered\nfrom a thread or from a signal from the audio device.</p>\n<h3 id=\"clocks\">Clocks</h3>\n<p>The GstAudioBaseSink class will use the ringbuffer to act as a clock\nprovider. It can do this by using the play pointer and the delay to\ncalculate the clock time.</p>\n\n        \n\n    </div>\n\n\n        "});