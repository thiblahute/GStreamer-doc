fragment_downloaded_cb({"url": "design/bufferpool.html#page-description", "fragment": "videotestsrc queue myvideosink \nmyvideodecoder queue fakesink \nmyvideodecoder queue myvideosink \nmyvideodecoder videoscale myvideosink \nIn this second use case we have a videosink that can at most allocate video buffers. \nAgain videotestsrc will have to negotiate a bufferpool with the peer element. For this it will perform the ALLOCATION query which queue will proxy to its downstream peer element. \nThe bufferpool returned from myvideosink will have a max_buffers set to queue and videotestsrc can operate with this upper limit because none of those elements require more than that amount of buffers for temporary storage. \nMyvideosink s bufferpool will then be configured with the size of the buffers for the negotiated format and according to the padding and alignment rules. When videotestsrc sets the pool to active the video buffers will be preallocated in the pool. \nvideotestsrc acquires a buffer from the configured pool on its srcpad and pushes this into the queue. When videotestsrc has acquired and pushed frames the next call to gst_buffer_pool_acquire_buffer will block assuming the GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT is not specified \nWhen the queue has pushed out a buffer and the sink has rendered it the refcount of the buffer reaches and the buffer is recycled in the pool. This will wake up the videotestsrc that was blocked waiting for more buffers and will make it produce the next buffer. \nIn this setup there are at most buffers active in the pipeline and the videotestsrc is rate limited by the rate at which buffers are recycled in the bufferpool. \nWhen shutting down videotestsrc will first set the bufferpool on the srcpad to inactive. This causes any pending blocked acquire to return with a FLUSHING result and causes the streaming thread to pause. \nIn this case the myvideodecoder requires buffers to be aligned to bytes and padded with bytes. The pipeline starts out with the decoder linked to a fakesink but we will then dynamically change the sink to one that can provide a bufferpool. \nWhen myvideodecoder negotiates the size with the downstream fakesink element it will receive a NULL bufferpool because fakesink does not provide a bufferpool. It will then select its own custom bufferpool to start the data transfer. \nAt some point we block the queue srcpad unlink the queue from the fakesink link a new sink and set the new sink to the PLAYING state. Linking the new sink would automatically send a RECONFIGURE event upstream and through queue inform myvideodecoder that it should renegotiate its bufferpool because downstream has been reconfigured. \nBefore pushing the next buffer myvideodecoder has to renegotiate a new bufferpool. To do this it performs the usual bufferpool negotiation algorithm. If it can obtain and configure a new bufferpool from downstream it sets its own old pool to inactive and unrefs it. This will eventually drain and unref the old bufferpool. \nThe new bufferpool is set as the new bufferpool for the srcpad and sinkpad of the queue and set to the active state. \nmyvideodecoder has negotiated a bufferpool with the downstream myvideosink to handle buffers of size x240. It has now detected a change in the video format and needs to renegotiate to a resolution of x480. This requires it to negotiate a new bufferpool with a larger buffer size. \nWhen myvideodecoder needs to get the bigger buffer it starts the negotiation of a new bufferpool. It queries a bufferpool from downstream reconfigures it with the new configuration which includes the bigger buffer size and sets the bufferpool to active. The old pool is inactivated and unreffed which causes the old format to drain. \nIt then uses the new bufferpool for allocating new buffers of the new dimension. \nIf at some point the decoder wants to switch to a lower resolution again it can choose to use the current pool which has buffers that are larger than the required size or it can choose to renegotiate a new bufferpool. \nmyvideosink is providing a bufferpool for upstream elements and wants to change the resolution. \nmyvideosink sends a RECONFIGURE event upstream to notify upstream that a new format is desirable. Upstream elements try to negotiate a new format and bufferpool before pushing out a new buffer. The old bufferpools are drained in the regular way. \n"});