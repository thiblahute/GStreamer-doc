fragment_downloaded_cb({"url": "design/miniobject.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"miniobject.md\">\n        <h1 id=\"gstminiobject\">GstMiniObject</h1>\n<p>This document describes the design of the <code>GstMiniObject</code> base class.</p>\n<p>The <code>GstMiniObject</code> abstract base class is used to construct lightweight,\nrefcounted and boxed types that are frequently created and destroyed.</p>\n<h2 id=\"requirements\">Requirements</h2>\n<ul>\n<li>Be lightweight</li>\n<li>Refcounted</li>\n<li>I must be possible to control access to the object, ie. when the\nobject is readable and writable.</li>\n<li>Subclasses must be able to use their own allocator for the memory.</li>\n</ul>\n<h2 id=\"usage\">Usage</h2>\n<p>Users of the <code>GstMiniObject</code> infrastructure will need to define a\nstructure that includes the <code>GstMiniObject</code> structure as the first field.</p>\n<pre><code class=\"language-c\">struct {\n  GstMiniObject mini_object;\n\n  /* my fields */\n  ...\n} MyObject\n</code></pre>\n<p>The subclass should then implement a constructor method where it\nallocates the memory for its structure and initializes the miniobject\nstructure with <code>gst_mini_object_init()</code>. Copy and Free functions are\nprovided to the <code>gst_mini_object_init()</code> function.</p>\n<pre><code class=\"language-c\">MyObject *\nmy_object_new()\n{\n  MyObject *res = g_slice_new (MyObject);\n\n  gst_mini_object_init (GST_MINI_OBJECT_CAST (res), 0,\n        MY_TYPE_OBJECT,\n        (GstMiniObjectCopyFunction) _my_object_copy,\n        (GstMiniObjectDisposeFunction) NULL,\n        (GstMiniObjectFreeFunction) _my_object_free);\n\n    /* other init */\n    .....\n\n  return res;\n}\n</code></pre>\n<p>The Free function is responsible for freeing the allocated memory for\nthe structure.</p>\n<pre><code class=\"language-c\">static void\n_my_object_free (MyObject *obj)\n{\n  /* other cleanup */\n  ...\n\n  g_slice_free (MyObject, obj);\n}\n</code></pre>\n<h2 id=\"lifecycle\">Lifecycle</h2>\n<p><code>GstMiniObject</code> is refcounted. When a <code>GstMiniObject</code> is first created, it\nhas a refcount of 1.</p>\n<p>Each variable holding a reference to a <code>GstMiniObject</code> is responsible for\nupdating the refcount. This includes incrementing the refcount with\n<code>gst_mini_object_ref()</code> when a reference is kept to a miniobject or\n<code>gst_mini_object_unref()</code> when a reference is released.</p>\n<p>When the refcount reaches 0, and thus no objects hold a reference to the\nminiobject anymore, we can free the miniobject.</p>\n<p>When freeing the miniobject, first the <code>GstMiniObjectDisposeFunction</code> is\ncalled. This function is allowed to revive the object again by\nincrementing the refcount, in which case it should return FALSE from the\ndispose function. The dispose function is used by <code>GstBuffer</code> to revive\nthe buffer back into the <code>GstBufferPool</code> when needed.</p>\n<p>When the dispose function returns TRUE, the <code>GstMiniObjectFreeFunction</code>\nwill be called and the miniobject will be freed.</p>\n<h2 id=\"copy\">Copy</h2>\n<p>A miniobject can be copied with <code>gst_mini_object_copy()</code>. This function\nwill call the custom copy function that was provided when registering\nthe new <code>GstMiniObject</code> subclass.</p>\n<p>The copy function should try to preserve as much info from the original\nobject as possible.</p>\n<p>The new copy should be writable.</p>\n<h2 id=\"access-management\">Access management</h2>\n<p><code>GstMiniObject</code> can be shared between multiple threads. It is important\nthat when a thread writes to a <code>GstMiniObject</code> that the other threads\ndon\u2019t not see the changes.</p>\n<p>To avoid exposing changes from one thread to another thread, the\nminiobjects are managed in a Copy-On-Write way. A copy is only made when\nit is known that the object is shared between multiple objects or\nthreads.</p>\n<p>There are 2 methods implemented for controlling access to the miniobject.</p>\n<ul>\n<li>\n<p>A first method relies on the refcount of the object to control\nwritability. Objects using this method have the <code>LOCKABLE</code> flag unset.</p>\n</li>\n<li>\n<p>A second method relies on a separate counter for controlling the\naccess to the object. Objects using this method have the LOCKABLE\nflag set.\nYou can check if an object is writable with <code>gst_mini_object_is_writable()</code> and\nyou can make any miniobject writable with <code>gst_mini_object_make_writable()</code>.\nThis will create a writable copy when the object was not writable.</p>\n</li>\n</ul>\n<h3 id=\"nonlockable-gstminiobjects\">non-LOCKABLE GstMiniObjects</h3>\n<p>These <code>GstMiniObjects</code> have the <code>LOCKABLE</code> flag unset. They use the refcount\nvalue to control writability of the object.</p>\n<p>When the refcount of the miniobject is &gt; 1, the objects it referenced by at\nleast 2 objects and is thus considered unwritable. A copy must be made before a\nmodification to the object can be done.</p>\n<p>Using the refcount to control writability is problematic for many language\nbindings that can keep additional references to the objects. This method is\nmainly for historical reasons until all users of the miniobjects are\nconverted to use the <code>LOCKABLE</code> flag.</p>\n<h3 id=\"lockable-gstminiobjects\">LOCKABLE GstMiniObjects</h3>\n<p>These <code>GstMiniObjects</code> have the <code>LOCKABLE</code> flag set. They use a separate counter\nfor controlling writability and access to the object.</p>\n<p>It consists of 2 components:</p>\n<h4 id=\"exclusive-counter\">exclusive counter</h4>\n<p>Each object that wants to keep a reference to a <code>GstMiniObject</code> and doesn't\nwant to see the changes from other owners of the same <code>GstMiniObject</code> needs to\nlock the <code>GstMiniObject</code> in <code>EXCLUSIVE</code> mode, which will increase the exclusive\ncounter.</p>\n<p>The exclusive counter counts the amount of objects that share this\n<code>GstMiniObject</code>. The counter is initially 0, meaning that the object is not\nshared with any object.</p>\n<p>When a reference to a <code>GstMiniObject</code> release, both the ref count and the\nexclusive counter will be decreased with <code>gst_mini_object_unref()</code> and\n<code>gst_mini_object_unlock()</code> respectively.</p>\n<h4 id=\"locking\">locking</h4>\n<p>All read and write access must be performed between a <code>gst_mini_object_lock()</code>\nand <code>gst_mini_object_unlock()</code> pair with the requested access method.</p>\n<p>A <code>gst_mini_object_lock()</code> can fail when a <code>WRITE</code> lock is requested and the\nexclusive counter is &gt; 1. Indeed a <code>GstMiniObject</code> object with an exclusive\ncounter &gt; 1 is locked <code>EXCLUSIVELY</code> by at least 2 objects and is therefore not\nwritable.</p>\n<p>Once the <code>GstMiniObject</code> is locked with a certain access mode, it can be\nrecursively locked with the same or narrower access mode. For example, first\nlocking the <code>GstMiniObject</code> in <code>READWRITE</code> mode allows you to recusively lock\nthe <code>GstMiniObject</code> in <code>READWRITE</code>, <code>READ</code> and <code>WRITE</code> mode. Memory locked in\n<code>READ</code> mode cannot be locked recursively in <code>WRITE</code> or <code>READWRITE</code> mode.</p>\n<p>Note that multiple threads can <code>READ</code>-lock the <code>GstMiniObject</code> concurrently but\ncannot lock the object in <code>WRITE</code> mode because the exclusive counter must\nbe &gt; 1.</p>\n<p>All calls to <code>gst_mini_object_lock()</code> need to be paired with one\n<code>gst_mini_object_unlock()</code> call with the same access mode. When the last\nrefcount of the object is removed, there should be no more outstanding locks.</p>\n<p>Note that a shared counter of both 0 and 1 leaves the <code>GstMiniObject</code> writable.\nThe reason is to make it easy to create and pass ownership of the\n<code>GstMiniObject</code> to another object while keeping it writable. When the\n<code>GstMiniObject</code> is created with a shared count of 0, it is writable. When the\n<code>GstMiniObject</code> is then added to another object, the shared count is incremented\nto 1 and the <code>GstMiniObject</code> remains writable. The 0 share counter has a similar\npurpose as the floating reference in <code>GObject</code>.</p>\n<h2 id=\"weak-references\">Weak references</h2>\n<p><code>GstMiniObject</code> has support for weak references. A callback will be called\nwhen the object is freed for all registered weak references.</p>\n<h2 id=\"qdata\">QData</h2>\n<p>Extra data can be associated with a <code>GstMiniObject</code> by using the <code>QData</code>\nAPI.</p>\n\n        \n\n    </div>\n\n\n        "});