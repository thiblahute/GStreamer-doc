fragment_downloaded_cb({"url": "design/miniobject.html#page-description", "fragment": "This document describes the design of the GstMiniObject base class. \nThe GstMiniObject abstract base class is used to construct lightweight refcounted and boxed types that are frequently created and destroyed. \nUsers of the GstMiniObject infrastructure will need to define a structure that includes the GstMiniObject structure as the first field. \nThe subclass should then implement a constructor method where it allocates the memory for its structure and initializes the miniobject structure with gst_mini_object_init Copy and Free functions are provided to the gst_mini_object_init function. \nThe Free function is responsible for freeing the allocated memory for the structure. \nGstMiniObject is refcounted. When a GstMiniObject is first created it has a refcount of \nEach variable holding a reference to a GstMiniObject is responsible for updating the refcount. This includes incrementing the refcount with gst_mini_object_ref when a reference is kept to a miniobject or gst_mini_object_unref when a reference is released. \nWhen the refcount reaches and thus no objects hold a reference to the miniobject anymore we can free the miniobject. \nWhen freeing the miniobject first the GstMiniObjectDisposeFunction is called. This function is allowed to revive the object again by incrementing the refcount in which case it should return FALSE from the dispose function. The dispose function is used by GstBuffer to revive the buffer back into the GstBufferPool when needed. \nWhen the dispose function returns TRUE the GstMiniObjectFreeFunction will be called and the miniobject will be freed. \nA miniobject can be copied with gst_mini_object_copy This function will call the custom copy function that was provided when registering the new GstMiniObject subclass. \nThe copy function should try to preserve as much info from the original object as possible. \nThe new copy should be writable. \nGstMiniObject can be shared between multiple threads. It is important that when a thread writes to a GstMiniObject that the other threads don t not see the changes. \nTo avoid exposing changes from one thread to another thread the miniobjects are managed in a Copy On Write way. A copy is only made when it is known that the object is shared between multiple objects or threads. \nThere are methods implemented for controlling access to the miniobject. \nA first method relies on the refcount of the object to control writability. Objects using this method have the LOCKABLE flag unset. \nA second method relies on a separate counter for controlling the access to the object. Objects using this method have the LOCKABLE flag set. You can check if an object is writable with gst_mini_object_is_writable and you can make any miniobject writable with gst_mini_object_make_writable This will create a writable copy when the object was not writable. \nThese GstMiniObjects have the LOCKABLE flag unset. They use the refcount value to control writability of the object. \nWhen the refcount of the miniobject is the objects it referenced by at least objects and is thus considered unwritable. A copy must be made before a modification to the object can be done. \nUsing the refcount to control writability is problematic for many language bindings that can keep additional references to the objects. This method is mainly for historical reasons until all users of the miniobjects are converted to use the LOCKABLE flag. \nThese GstMiniObjects have the LOCKABLE flag set. They use a separate counter for controlling writability and access to the object. \nIt consists of components \nEach object that wants to keep a reference to a GstMiniObject and doesn t want to see the changes from other owners of the same GstMiniObject needs to lock the GstMiniObject in EXCLUSIVE mode which will increase the exclusive counter. \nThe exclusive counter counts the amount of objects that share this GstMiniObject. The counter is initially meaning that the object is not shared with any object. \nWhen a reference to a GstMiniObject release both the ref count and the exclusive counter will be decreased with gst_mini_object_unref and gst_mini_object_unlock respectively. \nAll read and write access must be performed between a gst_mini_object_lock and gst_mini_object_unlock pair with the requested access method. \nA gst_mini_object_lock can fail when a WRITE lock is requested and the exclusive counter is Indeed a GstMiniObject object with an exclusive counter is locked EXCLUSIVELY by at least objects and is therefore not writable. \nOnce the GstMiniObject is locked with a certain access mode it can be recursively locked with the same or narrower access mode. For example first locking the GstMiniObject in READWRITE mode allows you to recusively lock the GstMiniObject in READWRITE READ and WRITE mode. Memory locked in READ mode cannot be locked recursively in WRITE or READWRITE mode. \nNote that multiple threads can READ lock the GstMiniObject concurrently but cannot lock the object in WRITE mode because the exclusive counter must be \nAll calls to gst_mini_object_lock need to be paired with one gst_mini_object_unlock call with the same access mode. When the last refcount of the object is removed there should be no more outstanding locks. \nNote that a shared counter of both and leaves the GstMiniObject writable. The reason is to make it easy to create and pass ownership of the GstMiniObject to another object while keeping it writable. When the GstMiniObject is created with a shared count of it is writable. When the GstMiniObject is then added to another object the shared count is incremented to and the GstMiniObject remains writable. The share counter has a similar purpose as the floating reference in GObject. \nGstMiniObject has support for weak references. A callback will be called when the object is freed for all registered weak references. \nExtra data can be associated with a GstMiniObject by using the QData API. \n"});