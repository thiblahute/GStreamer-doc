fragment_downloaded_cb({"url": "design/events.html#seek", "fragment": "SEEK \nA seek event is issued by the application to configure the playback range of a stream. It is called form the application thread and travels upstream. \nThe seek event contains the new start and stop position of playback after the seek is performed. Optionally the stop position can be left at to continue playback to the end of the stream. The seek event also contains the new playback rate of the stream is normal playback double speed and negative values mean backwards playback. \nA seek usually flushes the graph to minimize latency after the seek. This behaviour is triggered by using the SEEK_FLUSH flag on the seek event. \nThe seek event usually starts from the sink elements and travels upstream from element to element until it reaches an element that can perform the seek. No intermediate element is allowed to assume that a seek to this location will happen. It is allowed to modify the start and stop times if it needs to do so. this is typically the case if a seek is requested for a non time position. \nThe actual seek is performed in the application thread so that success or failure can be reported as a return value of the seek event. It is therefore important that before executing the seek the element acquires the STREAM_LOCK so that the streaming thread and the seek get serialized. \nThe general flow of executing the seek with FLUSH is as follows \nunblock the streaming threads they could be blocked in a chain function. This is done by sending a FLUSH_START on all srcpads or by pausing the streaming task depending on the seek FLUSH flag. The flush will make sure that all downstream elements unlock and that control will return to this element chain loop function. We cannot lock the STREAM_LOCK before doing this since it might cause a deadlock. \nacquire the STREAM_LOCK. This will work since the chain loop function was unlocked paused in step \nperform the seek. since the STREAM_LOCK is held the streaming thread will wait for the seek to complete. Most likely the stream thread will pause because the peer elements are flushing. \nsend a FLUSH_STOP event to all peer elements to allow streaming again. \ncreate a SEGMENT event to signal the new buffer timestamp base time. This event must be queued to be sent by the streaming thread. \nstart stopped tasks and unlock the STREAM_LOCK dataflow will continue now from the new position. \nMore information about the different seek types can be found in seeking. \n"});