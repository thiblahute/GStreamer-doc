fragment_downloaded_cb({"url": "design/bufferpool.html#-myvideodecoder-queue-fakesink", "fragment": "myvideodecoder queue fakesink \nIn this case the myvideodecoder requires buffers to be aligned to bytes and padded with bytes. The pipeline starts out with the decoder linked to a fakesink but we will then dynamically change the sink to one that can provide a bufferpool. \nWhen myvideodecoder negotiates the size with the downstream fakesink element it will receive a NULL bufferpool because fakesink does not provide a bufferpool. It will then select its own custom bufferpool to start the data transfer. \nAt some point we block the queue srcpad unlink the queue from the fakesink link a new sink and set the new sink to the PLAYING state. Linking the new sink would automatically send a RECONFIGURE event upstream and through queue inform myvideodecoder that it should renegotiate its bufferpool because downstream has been reconfigured. \nBefore pushing the next buffer myvideodecoder has to renegotiate a new bufferpool. To do this it performs the usual bufferpool negotiation algorithm. If it can obtain and configure a new bufferpool from downstream it sets its own old pool to inactive and unrefs it. This will eventually drain and unref the old bufferpool. \nThe new bufferpool is set as the new bufferpool for the srcpad and sinkpad of the queue and set to the active state. \n"});