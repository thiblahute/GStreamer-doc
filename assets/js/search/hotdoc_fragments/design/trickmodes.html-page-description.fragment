fragment_downloaded_cb({"url": "design/trickmodes.html#page-description", "fragment": "GStreamer provides API for performing various trickmode playback. This includes \nserver side trickmodes \nclient side fast slow forward playback \nclient side fast slow backwards playback \nServer side trickmodes mean that a source network source can provide a stream with different playback speed and direction. The client does not have to perform any special algorithms to decode this stream. \nClient side trickmodes mean that the decoding client GStreamer performs the needed algorithms to change the direction and speed of the media file. \nSeeking can both be done in a playback pipeline and a transcoding pipeline. \nConsider a typical playback pipeline \nThe pipeline is initially configured to play back at speed starting from position and stopping at the total duration of the file. \nWhen performing a seek the following steps have to be taken by the application \nThe seek event contains \nvarious GstSeekFlags flags describing \nwhere to seek to KEY_UNIT \nhow accurate the seek should be ACCURATE \nhow to perform the seek FLUSH \nwhat to do when the stop position is reached SEGMENT \nextra playback options SKIP \na format to seek in this can be time bytes units frames samples \na playback rate is normal playback speed positive values bigger than mean fast playback. negative values mean reverse playback. A playback speed of is not allowed but is equivalent to PAUSING the pipeline \na start position this value has to be between and the total duration of the file. It can also be relative to the previously configured start value. \na stop position this value has to be between and the total duration. It can also be relative to the previously configured stop value. \nSee also gst_event_new_seek \nSend the new seek event to the pipeline with gst_element_send_event \nBy default the pipeline will send the event to all sink elements. By default an element will forward the event upstream on all sinkpads. Elements can modify the format of the seek event. The most common format is GST_FORMAT_TIME. \nOne element will actually perform the seek this is usually the demuxer or source element. For more information on how to perform the different seek types see seeking. \nFor client side trickmode a SEGMENT event will be sent downstream with the new rate and start stop positions. All elements prepare themselves to handle the rate see below The applied rate of the SEGMENT event will be set to to indicate that no rate adjustment has been done. \nfor server side trick mode a SEGMENT event is sent downstream with a rate of and the start stop positions. The elements will configure themselves for normal playback speed since the server will perform the rate conversions. The applied rate will be set to the rate that will be applied by the server. This is done to insure that the position reporting performed in the sink is aware of the trick mode. \nWhen the seek succeeds the _send_event function will return TRUE. \nThe source element operates in push mode. It can reopen a server connection requesting a new byte or time position and a new playback speed. The capabilities can be queried from the server when the connection is opened. \nWe assume the source element is derived from the GstPushSrc base class. The base source should be configured with \nThe do_seek method will be called on the GstPushSrc subclass with the seek information passed in the GstSegment argument. \nThe rate value in the segment should be used to reopen the connection to the server requesting data at the new speed and possibly a new playback position. \nWhen the server connection was successfully reopened set the rate of the segment to so that the client side trickmode is not enabled. The applied rate in the segment is set to the rate transformation done by the server. \nAlternatively a combination of client side and serverside trickmode can be used for example if the server does not support certain rates the client can perform rate conversion for the remainder. \nAfter performing the seek the source will inform the downstream elements of the new segment that is to be played back. Since the segment will have a rate of no client side trick modes are enabled. The segment will have an applied rate different from to indicate that the media contains data with non standard playback speed or direction. \nThe seek happens as stated above. a SEGMENT event is sent downstream with a rate different from Plugins receiving the SEGMENT can decide to perform the rate conversion of the media data retimestamp video frames resample audio \nIf a plugin decides to resample or retimestamp it should modify the SEGMENT with a rate of and update the applied rate so that downstream elements don t resample again but are aware that the media has been modified. \nThe GStreamer base audio and video sinks will resample automatically if they receive a SEGMENT event with a rate different from The position reporting in the base audio and video sinks will also depend on the applied rate of the segment information. \nWhen the SKIP flag is set frames can be dropped in the elements. If S is the speedup factor a good algorithm for implementing frame skipping is to send audio in chunks of Nms usually ms is good and then skip S Nns of audio data. For the video we send only the keyframes in the S Nns interval. In this case the demuxer would scale the timestamps and would set an applied rate of S. \nFor backwards playback the following rules apply \nthe rate in the SEGMENT is less than \nthe SEGMENT start position is less than the stop position playback will however happen from stop to start in reverse. \nthe time member in the SEGMENT is set to the stream time of the start position. \nFor plugins the following rules apply \nA source plugin sends data in chunks starting from the last chunk of the file. The actual bytes are not reversed. Each chunk that is not forward continuous with the previous chunk is marked with a DISCONT flag. \nA demuxer accumulates the chunks. As soon as a keyframe is found everything starting from the keyframe up to the accumulated data is sent downstream. Timestamps on the buffers are set starting from the stop position to start effectively going backwards. Chunks are marked with DISCONT when they are not forward continuous with the previous buffer. \nA video decoder decodes and accumulates all decoded frames. If a buffer with a DISCONT SEGMENT or EOS is received all accumulated frames are sent downsteam in reverse. \nAn audio decoder decodes and accumulates all decoded audio. If a buffer with a DISCONT SEGMENT or EOS is received all accumulated audio is sent downstream in reverse order. Some audio codecs need the previous data buffer to decode the current one in that case the previous DISCONT buffer needs to be combined with the last non DISCONT buffer to generate the last bit of output. \nA sink reverses for audio and retimestamps audio video the buffers before playing them back. Retimestamping occurs relative to the stop position making the timestamps increase again and suitable for synchronizing against the clock. Audio sinks also have to perform simple resampling before playing the samples. \nfor transcoding audio and video resamplers can be used to reverse resample and retimestamp the buffers. Any rate adjustments performed on the media must be added to the applied_rate and subtracted from the rate members in the SEGMENT event. \nIn SKIP mode the same algorithm as for forward SKIP mode can be used. \nThe clock running_time keeps running forward. \nbackwards playback potentially uses a lot of memory as frames and undecoded data gets buffered. \n"});