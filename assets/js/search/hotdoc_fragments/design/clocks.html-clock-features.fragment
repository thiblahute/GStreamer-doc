fragment_downloaded_cb({"url": "design/clocks.html#clock-features", "fragment": "Clock features \nThe clock supports periodic and single shot clock notifications both synchronous and asynchronous. \nOne first needs to create a GstClockID for the periodic or single shot notification using _clock_new_single_shot_id or _clock_new_periodic_id \nTo perform a blocking wait for the specific time of the GstClockID use the gst_clock_id_wait To receive a callback when the specific time is reached in the clock use gstclock_id_wait_async Both these calls can be interrupted with the gst_clock_id_unschedule call. If the blocking wait is unscheduled a value of GST_CLOCK_UNSCHEDULED is returned. \nThe async callbacks can happen from any thread either provided by the core or from a streaming thread. The application should be prepared for this. \nA GstClockID that has been unscheduled cannot be used again for any wait operation. \nIt is possible to perform a blocking wait on the same ID from multiple threads. However registering the same ID for multiple async notifications is not possible the callback will only be called once. \nNone of the wait operations unref the GstClockID the owner is responsible for unreffing the ids itself. This holds true for both periodic and single shot notifications. The reason being that the owner of the ClockID has to keep a handle to the ID to unblock the wait on FLUSHING events or state changes and if we unref it automatically the handle might be invalid. \nThese clock operations do not operate on the stream time so the callbacks will also occur when not in PLAYING state as if the clock just keeps on running. Some clocks however do not progress when the element that provided the clock is not PLAYING. \n"});