fragment_downloaded_cb({"url": "design/element-transform.html#transform-elements", "fragment": "Transform elements \nTransform elements transform input buffers to output buffers based on the sink and source caps. \nAn important requirement for a transform is that the output caps are completely defined by the input caps and vice versa. This means that a typical decoder element can NOT be implemented with a transform element this is because the output caps like width and height of the decompressed video frame for example are encoded in the stream and thus not defined by the input caps. \nTypical transform elements include \naudio convertors audioconvert audioresample \nvideo convertors colorspace videoscale \nfilters capsfilter volume colorbalance \nThe implementation of the transform element has to take care of the following things \nefficient negotiation both up and downstream \nefficient buffer alloc and other buffer management \nSome transform elements can operate in different modes \npassthrough no changes are done on the input buffers \nin place changes made directly to the incoming buffers without requiring a copy or new buffer allocation \nmetadata changes only \nDepending on the mode of operation the buffer allocation strategy might change. \nThe transform element should at any point be able to renegotiate sink and src caps as well as change the operation mode. \nIn addition the transform element will typically take care of the following things as well \nflushing seeking \nstate changes \ntimestamping this is typically done by copying the input timestamps to the output buffers but subclasses should be able to override this. \nQoS avoiding calls to the subclass transform function \nhandle scheduling issues such as push and pull based operation. \nIn the next sections we will describe the behaviour of the transform element in each of the above use cases. We focus mostly on the buffer allocation strategies and caps negotiation. \n"});