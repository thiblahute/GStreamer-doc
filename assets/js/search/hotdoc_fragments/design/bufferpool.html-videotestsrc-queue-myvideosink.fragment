fragment_downloaded_cb({"url": "design/bufferpool.html#videotestsrc-queue-myvideosink", "fragment": "videotestsrc queue myvideosink \nIn this second use case we have a videosink that can at most allocate video buffers. \nAgain videotestsrc will have to negotiate a bufferpool with the peer element. For this it will perform the ALLOCATION query which queue will proxy to its downstream peer element. \nThe bufferpool returned from myvideosink will have a max_buffers set to queue and videotestsrc can operate with this upper limit because none of those elements require more than that amount of buffers for temporary storage. \nMyvideosink s bufferpool will then be configured with the size of the buffers for the negotiated format and according to the padding and alignment rules. When videotestsrc sets the pool to active the video buffers will be preallocated in the pool. \nvideotestsrc acquires a buffer from the configured pool on its srcpad and pushes this into the queue. When videotestsrc has acquired and pushed frames the next call to gst_buffer_pool_acquire_buffer will block assuming the GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT is not specified \nWhen the queue has pushed out a buffer and the sink has rendered it the refcount of the buffer reaches and the buffer is recycled in the pool. This will wake up the videotestsrc that was blocked waiting for more buffers and will make it produce the next buffer. \nIn this setup there are at most buffers active in the pipeline and the videotestsrc is rate limited by the rate at which buffers are recycled in the bufferpool. \nWhen shutting down videotestsrc will first set the bufferpool on the srcpad to inactive. This causes any pending blocked acquire to return with a FLUSHING result and causes the streaming thread to pause. \n"});