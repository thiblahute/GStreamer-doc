fragment_downloaded_cb({"url": "design/relations.html#using-the-parentchild-relationship", "fragment": "using the parent child relationship \nsince the initial floating reference to the child object became invalid after giving it to the parent any reference to a child has at least a refcount \nthis means that unreffing a child object cannot decrease the refcount to In fact only the parent can destroy and dispose the child object. \ngiven a reference to the child object the parent pointer is only valid when holding the child LOCK. Indeed after unlocking the child LOCK the parent can unparent the child or the parent could even become disposed. To avoid the parent dispose problem when obtaining the parent pointer if should be reffed before releasing the child LOCK. \ngetting a reference to a child \na reference to a child can be obtained by reffing it before adding it to the parent or by querying the parent. \nwhen requesting a child from the parent a reference is held to the parent so it cannot be disposed. The parent will use its internal data structures to locate the child element and will return a reference to it with an incremented refcount. The requester should _unref the child after usage. \ndestroying the parent child relationship \nonly the parent can actively destroy the parent child relationship this typically happens when a method is called on the parent to release ownership of the child. \na child shall never remove itself from the parent. \nsince calling a method on the parent with the child as an argument requires the caller to obtain a valid reference to the child the child refcount is at least \nthe parent will perform the folowing actions \nThe _unparent method performs the following actions \nSince the _unparent method unrefs the child object it is possible that the child pointer is invalid after this function. If the parent wants to perform other actions on the child such as signal emission it should _ref the child first. \n"});