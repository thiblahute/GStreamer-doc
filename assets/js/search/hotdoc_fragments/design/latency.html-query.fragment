fragment_downloaded_cb({"url": "design/latency.html#query", "fragment": "Query \nThe pipeline latency is queried with the LATENCY query. \nlive G_TYPE_BOOLEAN default FALSE if a live element is found upstream \nmin latency G_TYPE_UINT64 default must not be NONE the minimum latency in the pipeline meaning the minimum time downstream elements synchronizing to the clock have to wait until they can be sure all data for the current running time has been received. \nElements answering the latency query and introducing latency must set this to the maximum time for which they will delay data while considering upstream s minimum latency. As such from an element s perspective this is not its own minimum latency but its own maximum latency. Considering upstream s minimum latency generally means that the element s own value is added to upstream s value as this will give the overall minimum latency of all elements from the source to the current element \nElements answering the latency query should set this to the maximum time for which they can buffer upstream data without blocking or dropping further data. For an element this value will generally be its own minimum latency but might be bigger than that if it can buffer more data. As such queue elements can be used to increase the maximum latency. \nThe value set in the query should again consider upstream s maximum latency \nIf the element has multiple sinkpads the minimum upstream latency is the maximum of all live upstream minimum latencies. \nIf the current element has leaky buffering i.e. it drops data by itself when its internal buffer is full it should take the minimum of its own maximum latency and upstream s. Examples for such elements are audio sinks and sources with an internal ringbuffer leaky queues and in general live sources with a limited amount of internal buffers that can be used. \nNote many GStreamer base classes allow subclasses to set a minimum and maximum latency and handle the query themselves. These base classes assume non leaky i.e. blocking buffering for the maximum latency. The base class default query handler needs to be overridden to correctly handle leaky buffering. \nIf the element has multiple sinkpads the maximum upstream latency is the minimum of all live upstream maximum latencies. \n"});