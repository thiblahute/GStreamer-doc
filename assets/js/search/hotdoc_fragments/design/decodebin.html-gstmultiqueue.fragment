fragment_downloaded_cb({"url": "design/decodebin.html#gstmultiqueue", "fragment": "GstMultiQueue \nMultiple input output data queue. \nmultiqueue achieves the same functionality as queue with a few differences \nMultiple streams handling. \nThe element handles queueing data on more than one stream at once. To achieve such a feature it has request sink pads sink_ u and sometimes src pads src_ u \nWhen requesting a given sinkpad the associated srcpad for that stream will be created. Ex requesting sink_1 will generate src_1. \nNon starvation on multiple streams. \nIf more than one stream is used with the element the streams queues will be dynamically grown up to a limit in order to ensure that no stream is risking data starvation. This guarantees that at any given time there are at least N bytes queued and available for each individual stream. \nIf an EOS event comes through a srcpad the associated queue should be considered as not empty in the queue size growing algorithm. \nNon linked srcpads graceful handling. \nA GstTask is started for all srcpads when going to GST_STATE_PAUSED. \nThe task are blocking against a GCondition which will be fired in two different cases \nWhen the associated queue has received a buffer. \nWhen the associated queue was previously declared as not linked and the first buffer of the queue is scheduled to be pushed synchronously in relation to the order in which it arrived globally in the element see Synchronous data pushing below \nWhen woken up by the GCondition the GstTask will try to push the next GstBuffer GstEvent on the queue. If pushing returns GST_FLOW_NOT_LINKED the associated queue is marked as not linked. If pushing succeeds the queue will no longer be marked as not linked. \nIf pushing on all srcpads returns a GstFlowReturn different from GST_FLOW_OK then all the srcpads tasks are stopped and subsequent pushes on sinkpads will return GST_FLOW_NOT_LINKED. \nSynchronous data pushing for non linked pads. \nIn order to better support dynamic switching between streams the multiqueue unlike the current GStreamer queue continues to push buffers on non linked pads rather than shutting down. \nIn addition to prevent a non linked stream from very quickly consuming all available buffers and thus racing ahead of the other streams the element must ensure that buffers and inlined events for a non linked stream are pushed in the same order as they were received relative to the other streams controlled by the element. This means that a buffer cannot be pushed to a non linked pad any sooner than buffers in any other stream which were received before it. \n"});