fragment_downloaded_cb({"url": "design/progress.html#page-description", "fragment": "To give the application more information of what is going on \nTo make the state changes non blocking and cancellable. \nRTSP client but also HTTP MMS \nWhen there are well defined progress information codes applications can let the user know about the status of the progress. We anticipate to have at least DNS resolving and server connections and requests be well defined. \nCurrently state changes such as going to the READY or PAUSED state often do blocking calls such as resolving DNS or connecting to a remote server. These operations often block the main thread and are often not cancellable causing application lockups. \nWe would like to make the state change function instead start a separate thread that performs the blocking operations in a cancellable way. When going back to the NULL state all pending operations would be canceled immediately. \nFor downward state changes we want to let the application implement its own timeout mechanism. For example when stopping an RTSP stream the clients needs to send a TEARDOWN request to the server. This can however take an unlimited amount of time in case of network problems. We want to give the application an opportunity to wait and timeout for the completion of the async operation before setting the element to the final NULL state. \nProgress updates are very similar to buffering messages in the same way that the application can decide to wait for the completion of the buffering process before performing the next state change. It might make sense to implement buffering with the progress messages in the future. \nWhen the client goes from the READY to the PAUSED state it opens a socket performs a DNS lookup retrieves the SDP and negotiates the streams. All these operations currently block the state change function for an indefinite amount of time and while they are blocking cannot be canceled. \nInstead a thread would be started to perform these operations asynchronously and the state change would complete with the usual NO_PREROLL return value. Before starting the thread a PROGRESS message would be posted to mark the start of the async operation. \nAs the DNS lookup completes and the connection is established PROGRESS messages are posted on the bus to inform the application of the progress. When something fails an error is posted and a PROGRESS CANCELED message is posted. The application can then stop the pipeline. \nIf there are no errors and the setup of the streams completed successfully a PROGRESS COMPLETED is posted on the bus. The thread then goes to sleep and the asynchronous operation completed. \nThe RTSP protocol requires to send a TEARDOWN request to the server before closing the connection and destroying the socket. A state change to the READY state will issue the TEARDOWN request in the background and notify the application of this pending request with a PROGRESS message. \nThe application might want to only go to the NULL state after it got confirmation that the TEARDOWN request completed or it might choose to go to NULL after a timeout. It might also be possible that the application just want to close the socket as fast as possible without waiting for completion of the TEARDOWN request. \n"});