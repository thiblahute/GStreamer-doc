fragment_downloaded_cb({"url": "design/progress.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"progress.md\">\n<h1 id=\"progress-reporting\">Progress Reporting</h1>\n<p>This document describes the design and use cases for the progress\nreporting messages.</p>\n<p>PROGRESS messages are posted on the bus to inform the application about\nthe progress of asynchronous operations in the pipeline. This should not\nbe confused with asynchronous state changes.</p>\n<p>We accommodate for the following requirements:</p>\n<ul>\n<li>\n<p>Application is informed when an async operation starts and\ncompletes.</p>\n</li>\n<li>\n<p>It should be possible for the application to generically detect\ncommon operations and incorporate their progress into the GUI.</p>\n</li>\n<li>\n<p>Applications can cancel pending operations by doing regular state\nchanges.</p>\n</li>\n<li>\n<p>Applications should be able to wait for completion of async\noperations.</p>\n</li>\n</ul>\n<p>We allow for the following scenarios:</p>\n<ul>\n<li>\n<p>Elements want to inform the application about asynchronous DNS\nlookups and pending network requests. This includes starting and\ncompleting the lookup.</p>\n</li>\n<li>\n<p>Elements opening devices and resources asynchronously.</p>\n</li>\n<li>\n<p>Applications having more freedom to implement timeout and\ncancelation of operations that currently block the state changes or\nhappen invisibly behind the scenes.</p>\n</li>\n</ul>\n<h2 id=\"rationale\">Rationale</h2>\n<p>The main reason for adding these extra progress notifications is\ntwofold:</p>\n<h3 id=\"to-give-the-application-more-information-of-what-is-going-on\">To give the application more information of what is going on</h3>\n<p>When there are well defined progress information codes, applications\ncan let the user know about the status of the progress. We anticipate to\nhave at least DNS resolving and server connections and requests be well\ndefined.</p>\n<h3 id=\"to-make-the-state-changes-nonblocking-and-cancellable\">To make the state changes non-blocking and cancellable.</h3>\n<p>Currently state changes such as going to the READY or PAUSED state often do\nblocking calls such as resolving DNS or connecting to a remote server. These\noperations often block the main thread and are often not cancellable, causing\napplication lockups.</p>\n<p>We would like to make the state change function, instead, start a separate\nthread that performs the blocking operations in a cancellable way. When going\nback to the NULL state, all pending operations would be canceled immediately.</p>\n<p>For downward state changes, we want to let the application implement its own\ntimeout mechanism. For example: when stopping an RTSP stream, the clients\nneeds to send a TEARDOWN request to the server. This can however take an\nunlimited amount of time in case of network problems. We want to give the\napplication an opportunity to wait (and timeout) for the completion of the\nasync operation before setting the element to the final NULL state.</p>\n<p>Progress updates are very similar to buffering messages in the same way\nthat the application can decide to wait for the completion of the\nbuffering process before performing the next state change. It might make\nsense to implement buffering with the progress messages in the future.</p>\n<h2 id=\"async-state-changes\">Async state changes</h2>\n<p>GStreamer currently has a <code>GST_STATE_CHANGE_ASYNC</code> return value to note\nto the application that a state change is happening asynchronously.</p>\n<p>The main purpose of this return value is to make the pipeline wait for\npreroll and delay a future (upwards) state changes until the sinks are\nprerolled.</p>\n<p>In the case of async operations on source, this will automatically force\nsinks to stay async because they will not preroll before the source can\nproduce data.</p>\n<p>The fact that other asynchronous operations happen behind the scenes is\nirrelevant for the prerolling process so it is not implemented with the\nASYNC state change return value in order to not complicate the state\nchanges and mix concepts.</p>\n<h2 id=\"use-cases\">Use cases</h2>\n<h3 id=\"rtsp-client-but-also-http-mms-\">RTSP client (but also HTTP, MMS, \u2026)</h3>\n<p>When the client goes from the READY to the PAUSED state, it opens a socket,\nperforms a DNS lookup, retrieves the SDP and negotiates the streams. All these\noperations currently block the state change function for an indefinite amount\nof time and while they are blocking cannot be canceled.</p>\n<p>Instead, a thread would be started to perform these operations asynchronously\nand the state change would complete with the usual <code>NO_PREROLL</code> return value.\nBefore starting the thread a PROGRESS message would be posted to mark the\nstart of the async operation.</p>\n<p>As the DNS lookup completes and the connection is established, PROGRESS\nmessages are posted on the bus to inform the application of the progress. When\nsomething fails, an error is posted and a PROGRESS CANCELED message is posted.\nThe application can then stop the pipeline.</p>\n<p>If there are no errors and the setup of the streams completed successfully, a\nPROGRESS COMPLETED is posted on the bus. The thread then goes to sleep and the\nasynchronous operation completed.</p>\n<p>The RTSP protocol requires to send a TEARDOWN request to the server\nbefore closing the connection and destroying the socket. A state change to the\nREADY state will issue the TEARDOWN request in the background and notify the\napplication of this pending request with a PROGRESS message.</p>\n<p>The application might want to only go to the NULL state after it got confirmation\nthat the TEARDOWN request completed or it might choose to go to NULL after a\ntimeout. It might also be possible that the application just want to close the\nsocket as fast as possible without waiting for completion of the TEARDOWN request.</p>\n<h3 id=\"network-performance-measuring\">Network performance measuring</h3>\n<p>DNS lookup and connection times can be measured by calculating the elapsed\ntime between the various PROGRESS messages.</p>\n<h2 id=\"messages\">Messages</h2>\n<p>A new <code>PROGRESS</code> message will be created.</p>\n<p>The following fields will be contained in the message:</p>\n<ul>\n<li>\n<p><strong><code>type</code></strong>, <code>GST_TYPE_PROGRESS_TYPE</code>: A set of types to define the type of progress</p>\n<ul>\n<li><code>GST_PROGRESS_TYPE_START</code>: A new task is started in the background</li>\n<li><code>GST_PROGRESS_TYPE_CONTINUE</code>: The previous tasks completed and a new one\ncontinues. This is done so that the application can follow a set of\ncontinuous tasks and react to COMPLETE only when the element completely\nfinished.</li>\n<li><code>GST_PROGRESS_TYPE_CANCELED</code>: A task is canceled by the user.</li>\n<li><code>GST_PROGRESS_TYPE_ERROR</code>: A task stopped because of an error. In case of\nan error, an error message will have been posted before.</li>\n<li><code>GST_PROGRESS_TYPE_COMPLETE</code>: A task completed successfully.</li>\n</ul>\n</li>\n<li>\n<p><strong><code>code</code></strong>, <code>G_TYPE_STRING</code>: A generic extensible string that can be used to\nprogrammatically determine the action that is in progress. Some standard\npredefined codes will be defined.</p>\n</li>\n<li>\n<p><strong><code>text</code></strong>, <code>G_TYPE_STRING</code>: A user visible string detailing the action.</p>\n</li>\n<li>\n<p><strong><code>percent</code></strong>, <code>G_TYPE_INT</code>: between 0 and 100 Progress of the action as\na percentage, the following values are allowed:</p>\n<ul>\n<li><code>GST_PROGRESS_TYPE_START</code> always has a 0% value.</li>\n<li><code>GST_PROGRESS_TYPE_CONTINUE</code> have a value between 0 and 100</li>\n<li><code>GST_PROGRESS_TYPE_CANCELED</code>, <code>GST_PROGRESS_TYPE_ERROR</code> and\n<code>GST_PROGRESS_TYPE_COMPLETE</code> always have a 100% value.</li>\n</ul>\n</li>\n<li>\n<p><strong><code>timeout</code></strong>, <code>G_TYPE_INT</code> in milliseconds: The timeout of the async\noperation. -1 if unknown/unlimited.. This field can be interesting to the\napplication when it wants to display some sort of progress indication.</p>\n</li>\n<li>\n<p>\u2026.</p>\n</li>\n</ul>\n<p>Depending on the code, more fields can be put here.</p>\n<h2 id=\"implementation\">Implementation</h2>\n<p>Elements should not do blocking operations from the state change\nfunction. Instead, elements should post an appropriate progress message\nwith the right code and of type <code>GST_PROGRESS_TYPE_START</code> and then\nstart a thread to perform the blocking calls in a cancellable manner.</p>\n<p>It is highly recommended to only start async operations from the READY\nto PAUSED state and onwards and not from the NULL to READY state. The\nreason for this is that streaming threads are usually started in the\nREADY to PAUSED state and that the current NULL to READY state change is\nused to perform a blocking check for the presence of devices.</p>\n<p>The progress message needs to be posted from the state change function\nso that the application can immediately take appropriate action after\nsetting the state.</p>\n<p>The threads will usually perform many blocking calls with different\ncodes in a row, a client might first do a DNS query and then continue\nwith establishing a connection to the server. For this purpose the\n<code>GST_PROGRESS_TYPE_CONTINUE</code> must be used.</p>\n<p>Usually, the thread used to perform the blocking operations can be used\nto implement the streaming threads when needed.</p>\n<p>Upon downward state changes, operations that are busy in the thread are\ncanceled and <code>GST_PROGRESS_TYPE_CANCELED</code> is posted.</p>\n<p>The application can know about pending tasks because they received the\n<code>GST_PROGRESS_TYPE_START</code> messages that didn\u2019t complete with a\n<code>GST_PROGRESS_TYPE_COMPLETE</code> message, got canceled with a\n<code>GST_PROGRESS_TYPE_CANCELED</code> or errored with\n<code>GST_PROGRESS_TYPE_ERROR.</code> Applications should be able to choose if\nthey wait for the pending operation or cancel them.</p>\n<p>If an async operation fails, an error message is posted first before the\n<code>GST_PROGRESS_TYPE_ERROR</code> progress message.</p>\n<h2 id=\"categories\">Categories</h2>\n<p>We want to propose some standard codes here:</p>\n<ul>\n<li>\n<p>\"open\" : A resource is being opened</p>\n</li>\n<li>\n<p>\"close\" : A resource is being closed</p>\n</li>\n<li>\n<p>\"name-lookup\" : A DNS lookup.</p>\n</li>\n<li>\n<p>\"connect\" : A socket connection is established</p>\n</li>\n<li>\n<p>\"disconnect\" : a socket connection is closed</p>\n</li>\n<li>\n<p>\"request\" : A request is sent to a server and we are waiting for a reply.\nThis message is posted right before the request is sent and completed when the\nreply has arrived completely. * \"mount\" : A volume is being mounted</p>\n</li>\n<li>\n<p>\"unmount\" : A volume is being unmounted</p>\n</li>\n</ul>\n<p>More codes can be posted by elements and can be made official later.</p>\n\n</div>\n\n\n        "});