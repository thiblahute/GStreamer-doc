fragment_downloaded_cb({"url": "design/meta.html#page-description", "fragment": "This document describes the design for arbitrary per buffer metadata. \nBuffer metadata typically describes the low level properties of the buffer content. These properties are commonly not negotiated with caps but they are negotiated in the bufferpools. \nSome examples of metadata \ninterlacing information \nvideo alignment cropping panning information \nextra container information such as granulepos \nextra global buffer properties \nIt must be fast \nallocation free low fragmentation \naccess to the metadata fields preferably not much slower than directly accessing a C structure field \nIt must be extensible. Elements should be able to add new arbitrary metadata without requiring much effort. Also new metadata fields should not break API or ABI. \nIt plays nice with subbuffers. When a subbuffer is created the various buffer metadata should be copied updated correctly. \nWe should be able to negotiate metadata between elements \nVideo planes Video data is sometimes allocated in non contiguous planes for the Y and the UV data. We need to be able to specify the data on a buffer using multiple pointers in memory. We also need to be able to specify the stride for these planes. \nExtra buffer data Some elements might need to store extra data for a buffer. This is typically done when the resources are allocated from another subsystem such as OMX or X11. \nProcessing information Pan and crop information can be added to the buffer data when the downstream element can understand and use this metadata. An imagesink can for example use the pan and cropping information when blitting the image on the screen with little overhead. \nA GstMeta is a structure as follows \nThe purpose of this structure is to serve as a common header for all metadata information that we can attach to a buffer. Specific metadata such as timing metadata will have this structure as the first field. For example \nOr another example for the video memory regions that consists of both fields and methods. \nGstMeta derived structures define the API of the metadata. The API can consist of fields and or methods. It is possible to have different implementations for the same GstMeta structure. \nThe implementation of the GstMeta API would typically add more fields to the public structure that allow it to implement the API. \nGstMetaInfo will point to more information about the metadata and looks like this \nThe api member will contain a GType of the metadata API. A repository of registered MetaInfo will be maintained by the core. We will register some common metadata structures in core and some media specific info for audio video text in base. Plugins can register additional custom metadata. \nFor each implementation of api there will thus be a unique GstMetaInfo. In the case of metadata with a well defined API the implementation specific init function will setup the methods in the metadata structure. A unique GType will be made for each implementation and stored in the type field. \nAlong with the metadata description we will have functions to initialize free and or refcount a specific GstMeta instance. We also have the possibility to add a custom transform function that can be used to modify the metadata when a transformation happens. \nThere are no explicit methods to serialize and deserialize the metadata. Since each type has a GType we can reuse the GValue transform functions for this. \nThe purpose of the separate MetaInfo is to not have to carry the free init functions in each buffer instance but to define them globally. We still want quick access to the info so we need to make the buffer metadata point to the info. \nTechnically we could also specify the field and types in the MetaInfo and provide a generic API to retrieve the metadata fields without the need for a header file. We will not do this yet. \nAllocation of the GstBuffer structure will result in the allocation of a memory region of a customizable size bytes Only the first sizeof GstBuffer bytes of this region will initially be used. The remaining bytes will be part of the free metadata region of the buffer. Different implementations are possible and are invisible in the API or ABI. \nThe complete buffer with metadata could for example look as follows \nBuffers are created using the normal gst_buffer_new functions. The standard fields are initialized as usual. A memory area that is bigger than the structure size is allocated for the buffer metadata. \nAfter creating a buffer the application can set caps and add metadata information. \nTo add or retrieve metadata a handle to a GstMetaInfo structure needs to be obtained. This defines the implementation and API of the metadata. Usually a handle to this info structure can be obtained by calling a public _get_info method from a shared library for shared metadata \nThe following defines can usually be found in the shared h file. \nAdding metadata to a buffer can be done with the gst_buffer_add_meta call. This function will create new metadata based on the implementation specified by the GstMetaInfo. It is also possible to pass a generic pointer to the add_meta function that can contain parameters to initialize the new metadata fields. \nRetrieving the metadata on a buffer can be done with the gst_buffer_meta_get method. This function retrieves an existing metadata conforming to the API specified in the given info. When no such metadata exists the function will return NULL. \nOnce a reference to the info has been obtained the associated metadata can be added or modified on a buffer. \nOther convenience macros can be made to simplify the above code \nThis makes the code look like this \nTo iterate the different metainfo structures one can use the gst_buffer_meta_get_next methods. \nWe initially allocate a reasonable sized GstBuffer structure say bytes \nSince the complete buffer structure including a large area for metadata is allocated in one go we can reduce the number of memory allocations while still providing dynamic metadata. \nWhen adding metadata we need to call the init function of the associated metadata info structure. Since adding the metadata requires the caller to pass a handle to the info this operation does not require table lookups. \nPer metadata memory initialisation is needed because not all metadata is initialized in the same way. We need to for example set the timestamps to NONE in the MetaTiming structures. \nThe init free functions can also be used to implement refcounting for a metadata structure. This can be useful when a structure is shared between buffers. \nWhen the free_size of the GstBuffer is exhausted we will allocate new memory for each newly added Meta and use the next pointers to point to this. It is expected that this does not occur often and we might be able to optimize this transparently in the future. \nWhen a GstBuffer is freed we potentially might have to call a custom free function on the metadata info. In the case of the Memory metadata we need to call the associated free function to free the memory. \nWhen freeing a GstBuffer the custom buffer free function will iterate all of the metadata in the buffer and call the associated free functions in the MetaInfo associated with the entries. Usually this function will be NULL. \nWhen a buffer should be sent over the wire or be serialized in GDP we need a way to perform custom serialization and deserialization on the metadata. For this we can use the GValue transform functions. \nAfter certain transformations the metadata on a buffer might not be relevant anymore. \nConsider for example metadata that lists certain regions of interest on the video data. If the video is scaled or rotated the coordinates might not make sense anymore. A transform element should be able to adjust or remove the associated metadata when it becomes invalid. \nWe can make the transform element aware of the metadata so that it can adjust or remove in an intelligent way. Since we allow arbitrary metadata we can t do this for all metadata and thus we need some other way. \nOne proposition is to tag the metadata type with keywords that specify what it functionally refers too. We could for example tag the metadata for the regions of interest with a tag that notes that the metadata refers to absolute pixel positions. A transform could then know that the metadata is not valid anymore when the position of the pixels changed due to rotation flipping scaling and so on \nSubbuffers are implemented with a generic copy. Parameters to the copy are the offset and size. This allows each metadata structure to implement the actions needed to update the metadata of the subbuffer. \nIt might not make sense for some metadata to work with subbuffers. For example when we take a subbuffer of a buffer with a video frame the GstMetaVideo simply becomes invalid and is removed from the new subbuffer. \nThe difference between GstCaps used in negotiation and the metadata is not clearly defined. \nWe would like to think of the GstCaps containing the information needed to functionally negotiate the format between two elements. The Metadata should then only contain variables that can change between each buffer. \nFor example for video we would have width height framerate in the caps but then have the more technical details such as stride data pointers pan crop zoom etc in the metadata. \nA scheme like this would still allow us to functionally specify the desired video resolution while the implementation details would be inside the metadata. \nqdata on a miniobject is element private and is not visible to other element. Therefore qdata never contains essential information that describes the buffer content. \nWe need to make sure that elements exchange metadata that they both understand This is particularly important when the metadata describes the data layout in memory such as strides \nThe ALLOCATION query is used to let upstream know what metadata we can support. \nIt is also possible to have a bufferpool add certain metadata to the buffers from the pool. This feature is activated by enabling a buffer option when configuring the pool. \nSome structures that we need to be able to add to buffers. \nSome of these overlap we need to find a minimal set of metadata structures that allows us to define all use cases. \n"});