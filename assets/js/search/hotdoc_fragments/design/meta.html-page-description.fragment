fragment_downloaded_cb({"url": "design/meta.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"meta.md\">\n<h1 id=\"gstmeta\">GstMeta</h1>\n<p>This document describes the design for arbitrary per-buffer metadata.</p>\n<p>Buffer metadata typically describes the low level properties of the\nbuffer content. These properties are commonly not negotiated with caps\nbut they are negotiated in the bufferpools.</p>\n<p>Some examples of metadata:</p>\n<ul>\n<li>\n<p>interlacing information</p>\n</li>\n<li>\n<p>video alignment, cropping, panning information</p>\n</li>\n<li>\n<p>extra container information such as granulepos, \u2026</p>\n</li>\n<li>\n<p>extra global buffer properties</p>\n</li>\n</ul>\n<h2 id=\"requirements\">Requirements</h2>\n<ul>\n<li>\n<p>It must be fast</p>\n<ul>\n<li>\n<p>allocation, free, low fragmentation</p>\n</li>\n<li>\n<p>access to the metadata fields, preferably not much slower than\ndirectly accessing a C structure field</p>\n</li>\n</ul>\n</li>\n<li>\n<p>It must be extensible. Elements should be able to add new arbitrary\nmetadata without requiring much effort. Also new metadata fields\nshould not break API or ABI.</p>\n</li>\n<li>\n<p>It plays nice with subbuffers. When a subbuffer is created, the\nvarious buffer metadata should be copied/updated correctly.</p>\n</li>\n<li>\n<p>We should be able to negotiate metadata between elements</p>\n</li>\n</ul>\n<h2 id=\"use-cases\">Use cases</h2>\n<ul>\n<li>\n<p><strong>Video planes</strong>: Video data is sometimes allocated in non-contiguous planes\nfor the Y and the UV data. We need to be able to specify the data on a buffer\nusing multiple pointers in memory. We also need to be able to specify the\nstride for these planes.</p>\n</li>\n<li>\n<p><strong>Extra buffer data</strong>: Some elements might need to store extra data for\na buffer. This is typically done when the resources are allocated from another\nsubsystem such as OMX or X11.</p>\n</li>\n<li>\n<p><strong>Processing information</strong>: Pan and crop information can be added to the\nbuffer data when the downstream element can understand and use this metadata.\nAn imagesink can, for example, use the pan and cropping information when\nblitting the image on the screen with little overhead.</p>\n</li>\n</ul>\n<h2 id=\"gstmeta1\">GstMeta</h2>\n<p>A <code>GstMeta</code> is a structure as follows:</p>\n<pre><code class=\"language-c\">struct _GstMeta {\n  GstMetaFlags       flags;\n  const GstMetaInfo *info;    /* tag and info for the meta item */\n};\n</code></pre>\n<p>The purpose of this structure is to serve as a common header for all\nmetadata information that we can attach to a buffer. Specific metadata,\nsuch as timing metadata, will have this structure as the first field.\nFor example:</p>\n<pre><code class=\"language-c\">struct _GstMetaTiming {\n  GstMeta        meta;        /* common meta header */\n\n  GstClockTime   dts;         /* decoding timestamp */\n  GstClockTime   pts;         /* presentation timestamp */\n  GstClockTime   duration;    /* duration of the data */\n  GstClockTime   clock_rate;  /* clock rate for the above values */\n};\n</code></pre>\n<p>Or another example for the video memory regions that consists of both\nfields and methods.</p>\n<pre><code class=\"language-c\">#define GST_VIDEO_MAX_PLANES 4\n\nstruct GstMetaVideo {\n  GstMeta       meta;\n\n  GstBuffer         *buffer;\n\n  GstVideoFlags      flags;\n  GstVideoFormat     format;\n  guint              id\n  guint              width;\n  guint              height;\n\n  guint              n_planes;\n  gsize              offset[GST_VIDEO_MAX_PLANES];   /* offset in the buffer memory region of the\n                                                    * first pixel. */\n  gint               stride[GST_VIDEO_MAX_PLANES];   /* stride of the image lines. Can be negative when\n                                                    * the image is upside-down */\n\n  gpointer (*map)    (GstMetaVideo *meta, guint plane, gpointer * data, gint *stride,\n                      GstMapFlags flags);\n  gboolean (*unmap)  (GstMetaVideo *meta, guint plane, gpointer data);\n};\n\ngpointer gst_meta_video_map   (GstMetaVideo *meta, guint plane, gpointer * data,\n                               gint *stride, GstMapflags flags);\ngboolean gst_meta_video_unmap (GstMetaVideo *meta, guint plane, gpointer data);\n</code></pre>\n<p><code>GstMeta</code> derived structures define the API of the metadata. The API can\nconsist of fields and/or methods. It is possible to have different\nimplementations for the same <code>GstMeta</code> structure.</p>\n<p>The implementation of the <code>GstMeta</code> API would typically add more fields to\nthe public structure that allow it to implement the API.</p>\n<p><code>GstMetaInfo</code> will point to more information about the metadata and looks\nlike this:</p>\n<pre><code class=\"language-c\">struct _GstMetaInfo {\n  GType                      api;       /* api type */\n  GType                      type;      /* implementation type */\n  gsize                      size;      /* size of the structure */\n\n  GstMetaInitFunction        init_func;\n  GstMetaFreeFunction        free_func;\n  GstMetaTransformFunction   transform_func;\n};\n</code></pre>\n<p>The <code>api</code> member will contain a <code>GType</code> of the metadata API. A repository of\nregistered <code>MetaInfo</code> will be maintained by the core. We will register some\ncommon metadata structures in core and some media specific info for\naudio/video/text in -base. Plugins can register additional custom metadata.</p>\n<p>For each implementation of api, there will thus be a unique <code>GstMetaInfo</code>.\nIn the case of metadata with a well defined API, the implementation\nspecific init function will setup the methods in the metadata structure.\nA unique <code>GType</code> will be made for each implementation and stored in the\ntype field.</p>\n<p>Along with the metadata description we will have functions to\ninitialize/free (and/or refcount) a specific <code>GstMeta</code> instance. We also\nhave the possibility to add a custom transform function that can be used\nto modify the metadata when a transformation happens.</p>\n<p>There are no explicit methods to serialize and deserialize the metadata.\nSince each type has a <code>GType</code>, we can reuse the <code>GValue</code> transform functions\nfor this.</p>\n<p>The purpose of the separate <code>MetaInfo</code> is to not have to carry the\nfree/init functions in each buffer instance but to define them globally.\nWe still want quick access to the info so we need to make the buffer\nmetadata point to the info.</p>\n<p>Technically we could also specify the field and types in the <code>MetaInfo</code>\nand provide a generic API to retrieve the metadata fields without the\nneed for a header file. We will not do this yet.</p>\n<p>Allocation of the <code>GstBuffer</code> structure will result in the allocation of a\nmemory region of a customizable size (512 bytes). Only the first <code>sizeof (GstBuffer)</code> bytes of this region will initially be used. The remaining\nbytes will be part of the free metadata region of the buffer. Different\nimplementations are possible and are invisible in the API or ABI.</p>\n<p>The complete buffer with metadata could, for example, look as follows:</p>\n<pre><code>                         +----------------------------------+\nGstMiniObject            |  GType (GstBuffer)               |\n                         |  refcount, flags, copy/disp/free |\n                         +----------------------------------+\nGstBuffer                |  pool,pts,dts,duration,offsets   |\n                         |  &lt;private data&gt;                  |\n                         +..................................+\n                         |  next                           ---+\n                      +- |  info                           ------&gt; GstMetaInfo\nGstMetaTiming         |  |                                  | |\n                      |  |  dts                             | |\n                      |  |  pts                             | |\n                      |  |  duration                        | |\n                      +- |  clock_rate                      | |\n                         +  . . . . . . . . . . . . . . . . + |\n                         |  next                           &lt;--+\nGstMetaVideo       +- +- |  info                           ------&gt; GstMetaInfo\n                   |  |  |                                  | |\n                   |  |  |  flags                           | |\n                   |  |  |  n_planes                        | |\n                   |  |  |  planes[]                        | |\n                   |  |  |  map                             | |\n                   |  |  |  unmap                           | |\n                   +- |  |                                  | |\n                      |  |  private fields                  | |\nGstMetaVideoImpl      |  |  ...                             | |\n                      |  |  ...                             | |\n                      +- |                                  | |\n                         +  . . . . . . . . . . . . . . . . + .\n                         .                                    .\n</code></pre>\n<h2 id=\"api-examples\">API examples</h2>\n<p>Buffers are created using the normal <code>gst_buffer_new()</code> functions. The\nstandard fields are initialized as usual. A memory area that is bigger\nthan the structure size is allocated for the buffer metadata.</p>\n<pre><code class=\"language-c\">gst_buffer_new ();\n</code></pre>\n<p>After creating a buffer, the application can set caps and add metadata\ninformation.</p>\n<p>To add or retrieve metadata, a handle to a <code>GstMetaInfo</code> structure needs\nto be obtained. This defines the implementation and API of the metadata.\nUsually, a handle to this info structure can be obtained by calling a\npublic <code>_get_info()</code> method from a shared library (for shared metadata).</p>\n<p>The following defines can usually be found in the shared .h file.</p>\n<pre><code class=\"language-c\">GstMetaInfo * gst_meta_timing_get_info();\n#define GST_META_TIMING_INFO  (gst_meta_timing_get_info())\n</code></pre>\n<p>Adding metadata to a buffer can be done with the\n<code>gst_buffer_add_meta()</code> call. This function will create new metadata\nbased on the implementation specified by the <code>GstMetaInfo</code>. It is also\npossible to pass a generic pointer to the <code>add_meta()</code> function that can\ncontain parameters to initialize the new metadata fields.</p>\n<p>Retrieving the metadata on a buffer can be done with the\n<code>gst_buffer_meta_get()</code> method. This function retrieves an existing\nmetadata conforming to the API specified in the given info. When no such\nmetadata exists, the function will return NULL.</p>\n<pre><code class=\"language-c\">GstMetaTiming *timing;\n\ntiming = gst_buffer_get_meta (buffer, GST_META_TIMING_INFO);\n</code></pre>\n<p>Once a reference to the info has been obtained, the associated metadata\ncan be added or modified on a buffer.</p>\n<pre><code class=\"language-c\">timing-&gt;timestamp = 0;\ntiming-&gt;duration = 20 * GST_MSECOND;\n</code></pre>\n<p>Other convenience macros can be made to simplify the above code:</p>\n<pre><code class=\"language-c\">#define gst_buffer_get_meta_timing(b) \\\n   ((GstMetaTiming *) gst_buffer_get_meta ((b), GST_META_TIMING_INFO)\n</code></pre>\n<p>This makes the code look like this:</p>\n<pre><code class=\"language-c\">GstMetaTiming *timing;\n\ntiming = gst_buffer_get_meta_timing (buffer);\ntiming-&gt;timestamp = 0;\ntiming-&gt;duration = 20 * GST_MSECOND;\n</code></pre>\n<p>To iterate the different metainfo structures, one can use the\n<code>gst_buffer_meta_get_next()</code> methods.</p>\n<pre><code class=\"language-c\">GstMeta *current = NULL;\n\n/* passing NULL gives the first entry */\ncurrent = gst_buffer_meta_get_next (buffer, current);\n\n/* passing a GstMeta returns the next */\ncurrent = gst_buffer_meta_get_next (buffer, current);\n</code></pre>\n<h2 id=\"memory-management\">Memory management</h2>\n<h3 id=\"allocation\">allocation</h3>\n<p>We initially allocate a reasonable sized <code>GstBuffer</code> structure (say 512 bytes).</p>\n<p>Since the complete buffer structure, including a large area for metadata, is\nallocated in one go, we can reduce the number of memory allocations while still\nproviding dynamic metadata.</p>\n<p>When adding metadata, we need to call the init function of the associated\nmetadata info structure. Since adding the metadata requires the caller to pass\na handle to the info, this operation does not require table lookups.</p>\n<p>Per-metadata memory initialisation is needed because not all metadata is\ninitialized in the same way. We need to, for example, set the timestamps to\nNONE in the MetaTiming structures.</p>\n<p>The init/free functions can also be used to implement refcounting for a metadata\nstructure. This can be useful when a structure is shared between buffers.</p>\n<p>When the <code>free_size</code> of the <code>GstBuffer</code> is exhausted, we will allocate new\nmemory for each newly added Meta and use the next pointers to point to this. It\nis expected that this does not occur often and we might be able to optimize\nthis transparently in the future.</p>\n<h3 id=\"free\">free</h3>\n<p>When a <code>GstBuffer</code> is freed, we potentially might have to call a custom <code>free()</code>\nfunction on the metadata info. In the case of the Memory metadata, we need to\ncall the associated <code>free()</code> function to free the memory.</p>\n<p>When freeing a <code>GstBuffer</code>, the custom buffer free function will iterate all of\nthe metadata in the buffer and call the associated free functions in the\n<code>MetaInfo</code> associated with the entries. Usually, this function will be NULL.</p>\n<h2 id=\"serialization\">Serialization</h2>\n<p>When a buffer should be sent over the wire or be serialized in GDP, we\nneed a way to perform custom serialization and deserialization on the\nmetadata. For this we can use the <code>GValue</code> transform functions.</p>\n<h2 id=\"transformations\">Transformations</h2>\n<p>After certain transformations, the metadata on a buffer might not be\nrelevant anymore.</p>\n<p>Consider, for example, metadata that lists certain regions of interest\non the video data. If the video is scaled or rotated, the coordinates\nmight not make sense anymore. A transform element should be able to\nadjust or remove the associated metadata when it becomes invalid.</p>\n<p>We can make the transform element aware of the metadata so that it can\nadjust or remove in an intelligent way. Since we allow arbitrary\nmetadata, we can\u2019t do this for all metadata and thus we need some other\nway.</p>\n<p>One proposition is to tag the metadata type with keywords that specify\nwhat it functionally refers too. We could, for example, tag the metadata\nfor the regions of interest with a tag that notes that the metadata\nrefers to absolute pixel positions. A transform could then know that the\nmetadata is not valid anymore when the position of the pixels changed\n(due to rotation, flipping, scaling and so on).</p>\n<h2 id=\"subbuffers\">Subbuffers</h2>\n<p>Subbuffers are implemented with a generic copy. Parameters to the copy\nare the offset and size. This allows each metadata structure to\nimplement the actions needed to update the metadata of the subbuffer.</p>\n<p>It might not make sense for some metadata to work with subbuffers. For\nexample when we take a subbuffer of a buffer with a video frame, the\n<code>GstMetaVideo</code> simply becomes invalid and is removed from the new\nsubbuffer.</p>\n<h2 id=\"relationship-with-gstcaps\">Relationship with GstCaps</h2>\n<p>The difference between <code>GstCaps</code>, used in negotiation, and the metadata is\nnot clearly defined.</p>\n<p>We would like to think of the <code>GstCaps</code> containing the information needed\nto functionally negotiate the format between two elements. The Metadata\nshould then only contain variables that can change between each buffer.</p>\n<p>For example, for video we would have width/height/framerate in the caps\nbut then have the more technical details, such as stride, data pointers,\npan/crop/zoom etc in the metadata.</p>\n<p>A scheme like this would still allow us to functionally specify the\ndesired video resolution while the implementation details would be\ninside the metadata.</p>\n<h2 id=\"relationship-with-gstminiobject-qdata\">Relationship with GstMiniObject qdata</h2>\n<p>qdata on a miniobject is element private and is not visible to other\nelement. Therefore qdata never contains essential information that\ndescribes the buffer content.</p>\n<h2 id=\"compatibility\">Compatibility</h2>\n<p>We need to make sure that elements exchange metadata that they both\nunderstand, This is particularly important when the metadata describes\nthe data layout in memory (such as strides).</p>\n<p>The <code>ALLOCATION</code> query is used to let upstream know what metadata we can\nsupport.</p>\n<p>It is also possible to have a bufferpool add certain metadata to the\nbuffers from the pool. This feature is activated by enabling a buffer\noption when configuring the pool.</p>\n<h2 id=\"notes\">Notes</h2>\n<p>Some structures that we need to be able to add to buffers.</p>\n<ul>\n<li>Clean Aperture</li>\n<li>Arbitrary Matrix Transform</li>\n<li>Aspect ratio</li>\n<li>Pan/crop/zoom</li>\n<li>Video strides</li>\n</ul>\n<p>Some of these overlap, we need to find a minimal set of metadata\nstructures that allows us to define all use cases.</p>\n\n</div>\n\n\n        "});