fragment_downloaded_cb({"url": "design/stream-selection.html#page-description", "fragment": "Exposing collections of streams \nChanging the active selection from the application \nElements that create new streams such as demuxers or can create new streams like the HLS DASH alternative streams can list the streams they can make available with the GstStreamCollection object. \nOther elements that might generate GstStreamCollections are the DVD VM which handles internal switching of tracks or parsebin and decodebin3 when it aggregates and presents multiple internal stream sources as a single configurable collection. \nThe GstStreamCollection object is a flat listing of GstStream objects. \nThe various properties of a GstStreamCollection are \nAn element will inform outside components about that collection via \nApplications and container bin elements can listen and collect the various stream collections to know the full range of streams available within a bin pipeline. \nOnce posted on the bus a GstStreamCollection is immutable. It is updated by subsequent messages with a matching identifier. \nIf the element that provided the collection goes away there is no way to know that the streams are no longer valid without having the user app track that element The exception to that is if the bin containing that element such as parsebin or decodebin3 informs that the next collection is a replacement of the former one. \nThe mutual exclusion and relationship lists use stream ids rather than GstStream references in order to avoid circular referencing problems. \nThe user wants to change the audio track. The application received the GST_MESSAGE_STREAM_COLLECTION containing the list of available streams. For clarity we will assume those stream ids are video main audio english and audio french \nThe user prefers to use the french soundtrack which it knows based on the language tag contained in the GstStream objects \nThe application will create and send a GST_EVENT_SELECT_STREAM event containing the list of streams video main audio french \nThat event gets sent on the pipeline the sinks send it upstream and eventually reach decodebin. \nDecodebin compares \nDecodebin determines that no change is required for video main but sees that it needs to deactivate audio english and activate audio french \nIt unlinks the multiqueue source pad connected to the audiodec. Then it queries audiodec using the GST_QUERY_ACCEPT_CAPS whether it can accept as is the caps from the audio french stream. \nThe newly selected stream gets decoded and output through the same pad as the previous audio stream. \nNote The default behaviour would be to only expose one stream of each type. But nothing prevents decodebin from outputting more less of each type if the GST_EVENT_SELECT_STREAM event specifies that. This allows covering more use case than the simple playback one. Such examples could be \n"});