fragment_downloaded_cb({"url": "design/stream-selection.html#page-description", "fragment": "History \nThis document describes the events and objects involved in stream selection in GStreamer pipelines elements and applications \nThis new API is intended to address the use cases described in this section \nAs a user app I want an overview and control of the media streams that can be configured within a pipeline for processing even when some streams are mutually exclusive or logical constructs only. \nThe user app can disable entirely streams it s not interested in so they don t occupy memory or processing power discarded as early as possible in the pipeline. The user app can also re enable them at a later time. \nIf the set of possible stream configurations is changing the user app should be aware of the pending change and be able to make configuration choices for the new set of streams as well as possibly still reconfiguring the old set \nElements that have some other internal mechanism for triggering stream selections DVD or maybe some scripted playback playlist should be able to trigger selection of some particular stream. \nIndicate known relationships between streams for example that separate video feeds represent the views of a stereoscopic view or that certain streams are mutually exclusive. \nNote the streams that are available are not automatically the ones active or present in the pipeline as pads. Think HLS DASH alternate streams. \nPlaying an MPEG TS multi program stream we want to tell the app that there are multiple programs that could be extracted from the incoming feed. Further we want to provide a mechanism for the app to select which program s to decode and once that is known to further tell the app which elementary streams are then available within those program s so the app user can choose which audio track s to decode and or use. \nA new PMT arrives for an MPEG TS stream due to a codec or channel change. The pipeline will need to reconfigure to play the desired streams from new program. Equally there may be multiple seconds of content buffered from the old program and it should still be possible to switch for example subtitle tracks responsively in the draining out data as well as selecting which subs track to play from the new feed. This same scenario applies when doing gapless transition to a new source file URL except that likely the element providing the list of streams also changes as a new demuxer is installed. \nWhen playing a multi angle DVD the DVD Virtual Machine needs to extract angle from the data for presentation. It can publish the available angles as logical streams even though only one stream can be chosen. \nWhen playing a DVD the user can make stream selections from the DVD menu to choose audio or sub picture tracks or the DVD VM can trigger automatic selections. In addition the player UI should be able to show which audio subtitle tracks are available and allow direct selection in a GUI the same as for normal files with subtitle tracks in them. \nPlaying a SCHC DTV feed where one view is MPEG and the other is H.264 and they should be combined for D presentation or not bother decoding stream if displaying D. bug https bugzilla.gnome.org show_bug.cgi id \nFIXME need some use cases indicating what alternate streams in HLS might require what are the possibilities \nStream selection in GStreamer is implemented in several parts \nAPI \nGstStream objects are a high level convenience object containing information regarding a possible data stream that can be exposed by GStreamer elements. \nThey are mostly the aggregation of information present in other GStreamer components STREAM_START CAPS TAGS events but are not tied to the presence of a GstPad and for some use cases provide information that the existing components don t provide. \nThe various properties of a GstStream object are \nGstStream objects can be subclassed so that they can be re used by elements already using the notion of stream which is common for example in demuxers \nElements that create GstStream should also set it on the GST_EVENT_STREAM_START event of the relevant pad. This helps downstream elements to have all information in one location. \nAPI \nElements that create new streams such as demuxers or can create new streams like the HLS DASH alternative streams can list the streams they can make available with the GstStreamCollection object. \nOther elements that might generate GstStreamCollections are the DVD VM which handles internal switching of tracks or parsebin and decodebin3 when it aggregates and presents multiple internal stream sources as a single configurable collection. \nThe GstStreamCollection object is a flat listing of GstStream objects. \nThe various properties of a GstStreamCollection are \nAn element will inform outside components about that collection via \nApplications and container bin elements can listen and collect the various stream collections to know the full range of streams available within a bin pipeline. \nOnce posted on the bus a GstStreamCollection is immutable. It is updated by subsequent messages with a matching identifier. \nIf the element that provided the collection goes away there is no way to know that the streams are no longer valid without having the user app track that element The exception to that is if the bin containing that element such as parsebin or decodebin3 informs that the next collection is a replacement of the former one. \nThe mutual exclusion and relationship lists use stream ids rather than GstStream references in order to avoid circular referencing problems. \nWhen a demuxer knows the list of streams it can expose it creates a new GstStream for each stream it can provide with the appropriate information stream id flag tags caps \nThe demuxer then creates a GstStreamCollection object in which it will put the list of GstStream it can expose. That collection is then both posted on the bus via a GST_MESSAGE_COLLECTION and on each pad via a GST_EVENT_STREAM_COLLECTION \nThat new collection must be posted on the bus before the changes are made available. i.e. before pads corresponding to that selection are added removed. \nIn order to be backwards compatible and support elements that don t create streams collection yet the new parsebin element used by decodebin3 will automatically create those if not provided. \nApplications can know what streams are available by listening to the GST_MESSAGE_STREAM_COLLECTION messages posted on the bus. \nThe application can list the available streams per type such as all the audio streams or all the video streams by iterating the streams available in the collection by GST_STREAM_TYPE. \nThe application will also be able to use these stream information to decide which streams should be activated or not see the stream selection event below \nNot all demuxers will create the various GstStream and GstStreamCollection objects. In order to remain backwards compatible a parent bin parsebin in decodebin3 will create the GstStream and GstStreamCollection based on the pads being added removed from an element. \nThis allows providing stream listing selection for any demuxer like element even if it doesn t implement the GstStreamCollection usage. \nAPI \nStream selection events are generated by the application and sent into the pipeline to configure the streams. \nThe event carries \nThere are two use cases where an application needs to specify in a generic fashion which streams it wants in output \nFrom the point of view of the application those two use cases are treated identically. The streams are all available through the GstStreamCollection posted on the bus and it will select a subset. \nThe application can select the streams it wants by creating a GST_EVENT_SELECT_STREAMS event with the list of stream id of the streams it wants. That event is then sent on the pipeline eventually traveling all the way upstream from each sink. \nIn some cases selecting one stream may trigger the availability of other dependent streams resulting in new GstStreamCollection messages. This can happen in the case where choosing a different DVB channel would create a new single program collection. \nElements that receive the GST_EVENT_SELECT_STREAMS event and that can activate deactivate streams need to look at the list of stream id contained in the event and decide if they need to do some action. \nIn the standard demuxer case demuxing and exposing all streams there is nothing to do by default. \nIn decodebin3 activating or deactivating streams is taken care of by linking only the streams present in the event to decoders and output ghostpad. \nIn the case of elements that can expose alternate streams that are not present in the pipeline as pads they will take the appropriate action to add remove those streams. \nContainers that receive the event should pass it to any elements with no downstream peers so that streams can be configured during pre roll before a pipeline is completely linked down to sinks. \nThis is an example of how decodebin3 works by using the above mentioned objects events messages. \nFor clarity completeness we will consider a MPEG TS stream that has multiple audio streams. Furthermore that stream might have changes at some point switching video codec or adding removing audio streams \ndecodebin3 is different compared to decodebin2 in the sense that by default \nThe multiqueue element is still used and takes in all elementary non decoded streams. If parsers are needed present they are placed before the multiqueue. This is needed in order for multiqueue to work only with packetized and properly timestamped streams. \nNote that the whole typefinding of streams and optional depayloading demuxing and parsing are done in a new parsebin element. \nJust like the current implementation demuxers will expose all streams present within a program as source pads. They will connect to parsers and multiqueue. \nInitial setup. video stream audio streams. \nWhen parsing the initial PAT PMT the demuxer will \nparsebin will add all relevant parsers and expose those streams. \nDecodebin will be able to correlate based on STREAM_START event stream id what pad corresponds to which stream. It links each stream from parsebin to multiqueue. \nDecodebin knows all the streams that will be available. Since by default it is configured to only expose a stream of each type it will pick a stream of each for which it will complete the auto plugging finding a decoder and then exposing that stream as a source ghostpad. \nNote If the demuxer doesn t create post the GstStreamCollection parsebin will create it on itself as explained in section above. \nThe user wants to change the audio track. The application received the GST_MESSAGE_STREAM_COLLECTION containing the list of available streams. For clarity we will assume those stream ids are video main audio english and audio french \nThe user prefers to use the french soundtrack which it knows based on the language tag contained in the GstStream objects \nThe application will create and send a GST_EVENT_SELECT_STREAM event containing the list of streams video main audio french \nThat event gets sent on the pipeline the sinks send it upstream and eventually reach decodebin. \nDecodebin compares \nDecodebin determines that no change is required for video main but sees that it needs to deactivate audio english and activate audio french \nIt unlinks the multiqueue source pad connected to the audiodec. Then it queries audiodec using the GST_QUERY_ACCEPT_CAPS whether it can accept as is the caps from the audio french stream. \nThe newly selected stream gets decoded and output through the same pad as the previous audio stream. \nNote The default behaviour would be to only expose one stream of each type. But nothing prevents decodebin from outputting more less of each type if the GST_EVENT_SELECT_STREAM event specifies that. This allows covering more use case than the simple playback one. Such examples could be \nAt some point in time a PMT change happens. Let s assume a change in video codec and or PID. \nThe demuxer creates a new GstStream for the changed new stream creates a new GstStreamCollection for the updated PMT and posts it. \nDecodebin sees the new GstStreamCollection message. \nThe demuxer and parsebin then adds and removes pads. \nEventually the stream that switched will be decoded and output through the same pad as the previous video stream in a gapless fashion. \nThere is a main multi bitrate or not stream with audio and video interleaved in MPEG TS. The manifest also indicates the presence of alternate language audio only streams. HLS would expose one collection containing \nThe user might want to use the korean audio track instead of the default english one. \nAssuming the case of a MPEG TS stream which contains multiple programs. There would be three levels of collection \nInitially tsdemux exposes the first program present default \nAt some point the user wants to switch to ITV of which we do not know the topology at this point in time. A SELECT_STREAMS event is sent with ITV in it and the pointer to the Collection1. \nFinal state \nAdd missing implementation \nAdd flags to GstStreamCollection \nAdd mutual exclusion and relationship API to GstStreamCollection \nAdd helper API to figure out whether a collection is a replacement of another or a completely new one. This will require a more generic system to know whether a certain stream id is a replacement of another or not. \nIs a FLUSHING flag for stream selection required or not This would make the handler of the SELECT_STREAMS event send FLUSH START STOP before switching to the other streams. This is tricky when dealing where situations where we keep some streams and only switch some others. Do we flush all streams Do we only flush the new streams potentially resulting in delay to fully switch Furthermore due to efficient buffering in decodebin3 the switching time has been minimized extensively to the point where flushing might not bring a noticeable improvement. \nStore the stream collection in bins pipelines A Bin Pipeline could store all active collection internally so that it could be queried later on. This could be useful to then get on any pipeline at any point in time the full list of collections available without having to listen to all COLLECTION messages on the bus. This would require fixing the is a collection a replacement or not issue first. \nWhen switching to new collections should decodebin3 make any effort to map corresponding streams from the old to new PMT that is try and stick to the english language audio track for example Alternatively rely on the app to do such smarts with stream select messages \n"});