fragment_downloaded_cb({"url": "design/memory.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"memory.md\">\n<h1 id=\"gstmemory\">GstMemory</h1>\n<p>This document describes the design of the memory objects.</p>\n<p><code>GstMemory</code> objects are usually added to <code>GstBuffer</code> objects and contain the\nmultimedia data passed around in the pipeline.</p>\n<pre><code class=\"language-c\">struct GstMemory {\n  GstMiniObject   mini_object;\n\n  GstAllocator   *allocator;\n\n  GstMemory      *parent;\n  gsize           maxsize;\n  gsize           align;\n  gsize           offset;\n  gsize           size;\n};\n</code></pre>\n<h2 id=\"requirements\">Requirements</h2>\n<ul>\n<li>It must be possible to have different memory allocators</li>\n<li>It must be possible to efficiently share memory objects, copy, span and trim.</li>\n</ul>\n<h2 id=\"memory-layout\">Memory layout</h2>\n<p>A <code>GstMemory</code> has a pointer to a memory region of <code>maxsize</code>. The accessible part\nof this managed region is defined by an <code>offset</code> relative to the start of the\nregion and a <code>size</code>. This means that the managed region can be larger than what\nis visible to the user of the <code>GstMemory</code> API.</p>\n<pre><code>           memory\nGstMemory  -&gt;*----------------------------------------------------*\n             ^----------------------------------------------------^\n                               maxsize\n                  ^--------------------------------------^\n                 offset            size\n</code></pre>\n<p>The current properties of the accessible memory can be retrieved with:</p>\n<pre><code class=\"language-c\">gsize gst_memory_get_sizes (GstMemory *mem, gsize *offset, gsize *maxsize);\n</code></pre>\n<p>The offset and size can be changed with:</p>\n<pre><code class=\"language-c\">void  gst_memory_resize (GstMemory *mem, gssize offset, gsize size);\n</code></pre>\n<h2 id=\"allocators\">Allocators</h2>\n<p><code>GstMemory</code> objects are created by allocators. Allocators are a subclass\nof <code>GstObject</code> and can be subclassed to make custom allocators.</p>\n<pre><code class=\"language-c\">struct _GstAllocator {\n  GstObject                 object;\n\n  const gchar               *mem_type;\n\n  GstMemoryMapFunction       mem_map;\n  GstMemoryUnmapFunction     mem_unmap;\n  GstMemoryCopyFunction      mem_copy;\n  GstMemoryShareFunction     mem_share;\n  GstMemoryIsSpanFunction    mem_is_span;\n\n  GstMemoryMapFullFunction   mem_map_full;\n  GstMemoryUnmapFullFunction mem_unmap_full;\n};\n</code></pre>\n<p>The allocator class has 2 virtual methods. One to create a <code>GstMemory</code>,\nanother to free it.</p>\n<pre><code class=\"language-c\">struct _GstAllocatorClass {\n  GstObjectClass object_class;\n\n  GstMemory *  (*alloc)      (GstAllocator *allocator, gsize size,\n                              GstAllocationParams *params);\n  void         (*free)       (GstAllocator *allocator, GstMemory *memory);\n};\n</code></pre>\n<p>Allocators are refcounted. It is also possible to register the allocator to the\nGStreamer system. This way, the allocator can be retrieved by name.</p>\n<p>After an allocator is created, new <code>GstMemory</code> can be created with</p>\n<pre><code class=\"language-c\">GstMemory * gst_allocator_alloc (const GstAllocator * allocator,\n                                 gsize size, GstAllocationParams *params);\n</code></pre>\n<p><code>GstAllocationParams</code> contain extra info such as flags, alignment, prefix and\npadding.</p>\n<p>The <code>GstMemory</code> object is a refcounted object that must be freed with\n<code>gst_memory_unref()</code>.</p>\n<p>The <code>GstMemory</code> keeps a ref to the allocator that allocated it. Inside the\nallocator are the most common <code>GstMemory</code> operations listed. Custom\n<code>GstAllocator</code> implementations must implement the various operations on\nthe memory they allocate.</p>\n<p>It is also possible to create a new <code>GstMemory</code> object that wraps existing\nmemory with:</p>\n<pre><code class=\"language-c\">GstMemory * gst_memory_new_wrapped  (GstMemoryFlags flags,\n                                     gpointer data, gsize maxsize,\n                                     gsize offset, gsize size,\n                                     gpointer user_data,\n                                     GDestroyNotify notify);\n</code></pre>\n<h2 id=\"lifecycle\">Lifecycle</h2>\n<p><code>GstMemory</code> extends from <code>GstMiniObject</code> and therefore uses its lifecycle\nmanagement (See <a href=\"miniobject.html\">miniobject</a>).</p>\n<h2 id=\"data-access\">Data Access</h2>\n<p>Access to the memory region is always controlled with a map and unmap method\ncall. This allows the implementation to monitor the access patterns or set up\nthe required memory mappings when needed.</p>\n<p>The access of the memory object is controlled with the locking mechanism on\n<code>GstMiniObject</code> (See <a href=\"miniobject.html\">miniobject</a>).</p>\n<p>Mapping a memory region requires the caller to specify the access method: READ\nand/or WRITE. Mapping a memory region will first try to get a lock on the\nmemory in the requested access mode. This means that the map operation can\nfail when WRITE access is requested on a non-writable memory object (it has\nan exclusive counter &gt; 1, the memory is already locked in an incompatible\naccess mode or the memory is marked readonly).</p>\n<p>After the data has been accessed in the object, the <code>unmap()</code> call must be\nperformed, which will unlock the memory again.</p>\n<p>It is allowed to recursively map multiple times with the same or narrower\naccess modes. For each of the <code>map()</code> calls, a corresponding <code>unmap()</code> call\nneeds to be made. WRITE-only memory cannot be mapped in READ mode and\nREAD-only memory cannot be mapped in WRITE mode.</p>\n<p>The memory pointer returned from the <code>map()</code> call is guaranteed to remain\nvalid in the requested mapping mode until the corresponding <code>unmap()</code> call is\nperformed on the pointer.</p>\n<p>When multiple <code>map()</code> operations are nested and return the same pointer, the\npointer is valid until the last <code>unmap()</code> call is done.</p>\n<p>When the final reference on a memory object is dropped, all outstanding\nmappings should have been unmapped.</p>\n<p>Resizing a <code>GstMemory</code> does not influence any current mappings in any way.</p>\n<h2 id=\"copy\">Copy</h2>\n<p>A <code>GstMemory</code> copy can be made with the <code>gst_memory_copy()</code> call. Normally,\nallocators will implement a custom version of this function to make a copy of\nthe same kind of memory as the original one. This is what the fallback version\nof the copy function does, albeit slower than what a custom implementation\ncould do.</p>\n<p>The copy operation is only required to copy the visible range of the memory\nblock.</p>\n<h2 id=\"share\">Share</h2>\n<p>A memory region can be shared between <code>GstMemory</code> objects with the\n<code>gst_memory_share()</code> operation.</p>\n\n</div>\n\n\n        "});