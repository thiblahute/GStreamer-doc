fragment_downloaded_cb({"url": "design/memory.html#page-description", "fragment": "This document describes the design of the memory objects. \nGstMemory objects are usually added to GstBuffer objects and contain the multimedia data passed around in the pipeline. \nA GstMemory has a pointer to a memory region of maxsize. The accessible part of this managed region is defined by an offset relative to the start of the region and a size. This means that the managed region can be larger than what is visible to the user of the GstMemory API. \nThe current properties of the accessible memory can be retrieved with \nThe offset and size can be changed with \nGstMemory objects are created by allocators. Allocators are a subclass of GstObject and can be subclassed to make custom allocators. \nThe allocator class has virtual methods. One to create a GstMemory another to free it. \nAllocators are refcounted. It is also possible to register the allocator to the GStreamer system. This way the allocator can be retrieved by name. \nAfter an allocator is created new GstMemory can be created with \nGstAllocationParams contain extra info such as flags alignment prefix and padding. \nThe GstMemory object is a refcounted object that must be freed with gst_memory_unref \nThe GstMemory keeps a ref to the allocator that allocated it. Inside the allocator are the most common GstMemory operations listed. Custom GstAllocator implementations must implement the various operations on the memory they allocate. \nIt is also possible to create a new GstMemory object that wraps existing memory with \nGstMemory extends from GstMiniObject and therefore uses its lifecycle management See miniobject \nAccess to the memory region is always controlled with a map and unmap method call. This allows the implementation to monitor the access patterns or set up the required memory mappings when needed. \nThe access of the memory object is controlled with the locking mechanism on GstMiniObject See miniobject \nMapping a memory region requires the caller to specify the access method READ and or WRITE. Mapping a memory region will first try to get a lock on the memory in the requested access mode. This means that the map operation can fail when WRITE access is requested on a non writable memory object it has an exclusive counter the memory is already locked in an incompatible access mode or the memory is marked readonly \nAfter the data has been accessed in the object the unmap call must be performed which will unlock the memory again. \nIt is allowed to recursively map multiple times with the same or narrower access modes. For each of the map calls a corresponding unmap call needs to be made. WRITE only memory cannot be mapped in READ mode and READ only memory cannot be mapped in WRITE mode. \nThe memory pointer returned from the map call is guaranteed to remain valid in the requested mapping mode until the corresponding unmap call is performed on the pointer. \nWhen multiple map operations are nested and return the same pointer the pointer is valid until the last unmap call is done. \nWhen the final reference on a memory object is dropped all outstanding mappings should have been unmapped. \nResizing a GstMemory does not influence any current mappings in any way. \nA GstMemory copy can be made with the gst_memory_copy call. Normally allocators will implement a custom version of this function to make a copy of the same kind of memory as the original one. This is what the fallback version of the copy function does albeit slower than what a custom implementation could do. \nThe copy operation is only required to copy the visible range of the memory block. \nA memory region can be shared between GstMemory objects with the gst_memory_share operation. \n"});