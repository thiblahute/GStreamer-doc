fragment_downloaded_cb({"url": "design/caps.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"caps.md\">\n        <h1 id=\"caps\">Caps</h1>\n<p>Caps are lightweight refcounted objects describing media types. They are\ncomposed of an array of <code>GstStructure</code> plus, optionally, a\n<code>GstCapsFeatures</code> set for the <code>GstStructure</code>.</p>\n<p>Caps are exposed on <code>GstPadTemplates</code> to describe all possible types a\ngiven pad can handle. They are also stored in the registry along with a\ndescription of the element.</p>\n<p>Caps are exposed on the element pads via <code>CAPS</code> and <code>ACCEPT_CAPS</code> queries.</p>\n<p>This function describes the possible types that the pad can handle or\nproduce (<a href=\"negotiation.html\">negotiation</a>).</p>\n<p>Various methods exist to work with the media types such as subtracting\nor intersecting.</p>\n<h2 id=\"operations\">Operations</h2>\n<h3 id=\"fixating\">Fixating</h3>\n<p>Caps are fixed if they only contain a single structure and this\nstructure is fixed. A structure is fixed if none of its fields\nis of an unfixed type, for example a range, list or array.</p>\n<p>For fixating caps only the first structure is kept, as the order in\nwhich they appear is meant to express their precedence.\nAfterwards, each unfixed field of this structure is set to\nthe value that makes most sense for the media format by the element or\npad implementation and then every remaining unfixed field is set to an\narbitrary value that is a subset of the unfixed field\u2019s values.</p>\n<p>EMPTY caps are fixed caps and ANY caps are not. Caps with ANY caps\nfeatures are not fixed.</p>\n<h3 id=\"subset\">Subset</h3>\n<p>One caps \"A\" is a subset of another caps \"B\" if for each structure in\n\"A\" there exists a structure in \"B\" that is a superset of the structure\nin \"A\".</p>\n<p>A structure \"a\" is the subset of a structure \"b\" if it has the same\nstructure name, the same caps features and each field in \"b\" either does not\nexist in \"a\", or the value of the field in \"a\" is a subset of the value of the\nfield in \"b\". \"a\" must not have additional fields that are not in \"b\". Fields\nthat are in \"b\" but not in \"a\" (aka, an empty field) are always a subset.\nThis is different to the intuitive mathematical definition as an empty field\nis defined to contain all possible values. This means that the empty field is\nalways a superset of any other field.</p>\n<p><code>EMPTY</code> caps are a subset of every other caps. Every caps are a subset of\n<code>ANY</code> caps.</p>\n<h3 id=\"equality\">Equality</h3>\n<p>Caps \"A\" and \"B\" are equal if \"A\" is a subset of \"B\" and \"B\" is a subset\nof \"A\". This means that both caps are expressing the same possibilities\nbut their structures can still be different if they contain unfixed\nfields.</p>\n<h3 id=\"intersection\">Intersection</h3>\n<p>The intersection of caps \"A\" and caps \"B\" are the caps that contain the\nintersection of all their structures with each other.</p>\n<p>The intersection of structure \"a\" and structure \"b\" is empty if their\nstructure name or their caps features are not equal, or if \"a\" and \"b\"\ncontain the same field but the intersection of both field values is\nempty. If one structure contains a field that is not existing in the\nother structure it will be copied over to the intersection with the same\nvalue.</p>\n<p>The intersection with <code>ANY</code> caps is always the other caps and the\nintersection with <code>EMPTY</code> caps is always <code>EMPTY</code>.</p>\n<h3 id=\"union\">Union</h3>\n<p>The union of caps \"A\" and caps \"B\" are the caps that contain the union\nof all their structures with each other.</p>\n<p>The union of structure \"a\" and structure \"b\" are the two structures \"a\"\nand \"b\" if the structure names or caps features are not equal.\nOtherwise, the union is the structure that contains the union of each\nfields value. If a field is only in one of the two structures it is not\ncontained in the union.</p>\n<p>The union with ANY caps is always ANY and the union with EMPTY caps is\nalways the other caps.</p>\n<h3 id=\"subtraction\">Subtraction</h3>\n<p>The subtraction of caps \"A\" from caps \"B\" is the most generic subset of\n\"B\" that has an empty intersection with \"A\" but only contains structures\nwith names and caps features that are existing in \"B\".</p>\n<h2 id=\"basic-rules\">Basic Rules</h2>\n<h3 id=\"semantics-of-caps-and-their-usage\">Semantics of caps and their usage</h3>\n<p>A caps can contain multiple structures, in which case any of the\nstructures would be acceptable. The structures are in the preferred\norder of the creator of the caps, with the preferred structure being\nfirst and during negotiation of caps this order should be considered to\nselect the most optimal structure.</p>\n<p>Each of these structures has a name that specifies the media type, e.g.\n\"video/x-theora\" to specify Theora video. Additional fields in the\nstructure add additional constraints and/or information about the media\ntype, like the width and height of a video frame, or the codec profile\nthat is used. These fields can be non-fixed (e.g. ranges) for non-fixed\ncaps but must be fixated to a fixed value during negotiation. If a field\nis included in the caps returned by a pad via the <code>CAPS</code> query, it imposes\nan additional constraint during negotiation. The caps in the end must\nhave this field with a value that is a subset of the non-fixed value.\nAdditional fields that are added in the negotiated caps give additional\ninformation about the media but are treated as optional. Information\nthat can change for every buffer and is not relevant during negotiation\nmust not be stored inside the caps.</p>\n<p>For each of the structures in caps it is possible to store caps\nfeatures. The caps features are expressing additional requirements for a\nspecific structure, and only structures with the same name <em>and</em> equal\ncaps features are considered compatible. Caps features can be used to\nrequire a specific memory representation or a specific meta to be set on\nbuffers, for example a pad could require for a specific structure that\nit is passed <code>EGLImage</code> memory or buffers with the video meta. If no caps\nfeatures are provided for a structure, it is assumed that system memory\nis required unless later negotiation steps (e.g. the <code>ALLOCATION</code> query)\ndetect that something else can be used. The special <code>ANY</code> caps features\ncan be used to specify that any caps feature would be accepted, for\nexample if the buffer memory is not touched at all.</p>\n<h3 id=\"compatibility-of-caps\">Compatibility of caps</h3>\n<p>Pads can be linked when the caps of both pads are compatible. This is\nthe case when their intersection is not empty.</p>\n<p>For checking if a pad actually supports a fixed caps an intersection is\nnot enough. Instead the fixed caps must be at least a subset of the\npad\u2019s caps but pads can introduce additional constraints which would\nbe checked in the <code>ACCEPT_CAPS</code> query handler.</p>\n<p>Data flow can only happen after pads have decided on common fixed caps.\nThese caps are distributed to both pads with the <code>CAPS</code> event.</p>\n\n        \n\n    </div>\n\n\n        "});