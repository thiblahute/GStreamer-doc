fragment_downloaded_cb({"url": "design/overview.html#pipeline-states", "fragment": "Pipeline states \nWhen all the pads are linked and signals have been connected the pipeline can be put in the PAUSED state to start dataflow. \nWhen a bin and hence a pipeline performs a state change it will change the state of all its children. The pipeline will change the state of its children from the sink elements to the source elements this to make sure that no upstream element produces data to an element that is not yet ready to accept it. \nIn the mp3 playback pipeline the state of the elements is changed in the order alsasink mp3dec filesrc. \nAll intermediate states are traversed for each element resulting in the following chain of state changes \nalsasink to READY the audio device is probed \nmp3dec to READY nothing happens \nfilesrc to READY the file is probed \nalsasink to PAUSED the audio device is opened. alsasink is a sink and returns ASYNC because it did not receive data yet \nmp3dec to PAUSED the decoding library is initialized \nfilesrc to PAUSED the file is opened and a thread is started to push data to mp3dec \nAt this point data flows from filesrc to mp3dec and alsasink. Since mp3dec is PAUSED it accepts the data from filesrc on the sinkpad and starts decoding the compressed data to raw audio samples. \nThe mp3 decoder figures out the samplerate the number of channels and other audio properties of the raw audio samples and sends out a caps event with the media type. \nAlsasink then receives the caps event inspects the caps and reconfigures itself to process the media type. \nmp3dec then puts the decoded samples into a Buffer and pushes this buffer to the next element. \nAlsasink receives the buffer with samples. Since it received the first buffer of samples it completes the state change to the PAUSED state. At this point the pipeline is prerolled and all elements have samples. Alsasink is now also capable of providing a clock to the pipeline. \nSince alsasink is now in the PAUSED state it blocks while receiving the first buffer. This effectively blocks both mp3dec and filesrc in their gst_pad_push \nSince all elements now return SUCCESS from the gst_element_get_state function the pipeline can be put in the PLAYING state. \nBefore going to PLAYING the pipeline select a clock and samples the current time of the clock. This is the base_time. It then distributes this time to all elements. Elements can then synchronize against the clock using the buffer running_time base_time See also synchronisation \nThe following chain of state changes then takes place \nalsasink to PLAYING the samples are played to the audio device \nmp3dec to PLAYING nothing happens \nfilesrc to PLAYING nothing happens \n"});