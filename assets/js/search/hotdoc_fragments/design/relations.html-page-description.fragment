fragment_downloaded_cb({"url": "design/relations.html#page-description", "fragment": "establishing the parent child relationship \nusing the parent child relationship \nestablishing the single reffed relationship \nusing the single reffed relationship \ndestroying the single reffed relationship \nestablishing the unreffed relationship \nusing the unreffed relationship \ndestroying the unreffed relationship \nThe application then calls a method on the parent object to take ownership of the child object. The parent performs the following actions \nthe _set_parent method performs the following actions \nThe function atomically checks if the child has no parent yet and will set the parent if not. It will also sink the child meaning all floating references to the child are invalid now as it takes over the refcount of the object. \nVisually \nafter _set_parent returns TRUE \nafter parent updates ref_pointer to child. \nonly one parent is able to _sink the same object because the _set_parent method is atomic. \nsince only one parent is able to _set_parent the object only one will add a reference to the object. \nsince the parent can hold multiple references to children we don t need to lock the parent when locking the child. Many threads can call _set_parent on the children with the same parent the parent can then add all those to its lists. \nNote that the signal is emitted before the parent has added the element to its internal data structures. This is not a problem since the parent usually has his own signal to inform the app that the child was reffed. One possible solution would be to update the internal structure first and then perform a rollback if the _set_parent failed. This is not a good solution as iterators might grab the half added child too soon. \nsince the initial floating reference to the child object became invalid after giving it to the parent any reference to a child has at least a refcount \nthis means that unreffing a child object cannot decrease the refcount to In fact only the parent can destroy and dispose the child object. \ngiven a reference to the child object the parent pointer is only valid when holding the child LOCK. Indeed after unlocking the child LOCK the parent can unparent the child or the parent could even become disposed. To avoid the parent dispose problem when obtaining the parent pointer if should be reffed before releasing the child LOCK. \ngetting a reference to a child \na reference to a child can be obtained by reffing it before adding it to the parent or by querying the parent. \nwhen requesting a child from the parent a reference is held to the parent so it cannot be disposed. The parent will use its internal data structures to locate the child element and will return a reference to it with an incremented refcount. The requester should _unref the child after usage. \ndestroying the parent child relationship \nonly the parent can actively destroy the parent child relationship this typically happens when a method is called on the parent to release ownership of the child. \na child shall never remove itself from the parent. \nsince calling a method on the parent with the child as an argument requires the caller to obtain a valid reference to the child the child refcount is at least \nthe parent will perform the folowing actions \nThe _unparent method performs the following actions \nSince the _unparent method unrefs the child object it is possible that the child pointer is invalid after this function. If the parent wants to perform other actions on the child such as signal emission it should _ref the child first. \nThe second object is attached to the first one using a method on the first object. The second object is reffed and a pointer is updated in the first object using the following algorithm \nAfter releasing the lock on the first object is is not sure that object2 is still reffed from object1. \nThe only way to access object2 is by holding a ref to it or by getting the reference from object1. Reading the object pointed to by object1 can be done like this \nDepending on the type of the object modifications can be done either with copy on write or directly into the object. \nCopy on write can practically only be done like this \nThe folowing algorithm removes the single reffed link between object1 and object2. \nWhich yields the following initial state again \nSince we need to take two locks the order in which these locks are taken is very important or we might cause deadlocks. This lock order must be defined for all unreffed relations. In these examples we always lock object1 first and then object2. \nReading requires taking one of the locks and reading the corresponing object. Again we need to ref the object before releasing the lock. \nBecause of the lock order we need to be careful when destroying this relation. \nWhen only a reference to object1 is held \nWhen only a reference to object2 is held we need to get a handle to the other object fist so that we can lock it first. There is a window where we need to release all locks and the relation could be invalid. To solve this we check the relation after grabbing both locks and retry if the relation changed. \n"});