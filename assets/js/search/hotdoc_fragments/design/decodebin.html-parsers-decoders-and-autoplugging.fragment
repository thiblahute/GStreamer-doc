fragment_downloaded_cb({"url": "design/decodebin.html#parsers-decoders-and-autoplugging", "fragment": "Parsers decoders and auto plugging \nThis section has DRAFT status. \nSome media formats come in different flavours or stream formats These formats differ in the way the setup data and media data is signalled and or packaged. An example for this is H.264 video where there is a bytestream format with codec setup data signalled inline and units prefixed by a sync code and packet length information and a raw format where codec setup data is signalled out of band via the caps and the chunking is implicit in the way the buffers were muxed into a container to mention just two of the possible variants. \nEspecially on embedded platforms it is common that decoders can only handle one particular stream format and not all of them. \nWhere there are multiple stream formats parsers are usually expected to be able to convert between the different formats. This will if implemented correctly work as expected in a static pipeline such as \nwhere the parser can query the decoder s capabilities even before processing the first piece of data and configure itself to convert accordingly if conversion is needed at all. \nIn an auto plugging context this is not so straight forward though because elements are plugged incrementally and not before the previous element has processed some data and decided what it will output exactly unless the template caps are completely fixed then it can continue right away this is not always the case here though see below A parser will thus have to decide on some output format so auto plugging can continue. It doesn t know anything about the available decoders and their capabilities though so it s possible that it will choose a format that is not supported by any of the available decoders or by the preferred decoder. \nIf the parser had sufficiently concise but fixed source pad template caps decodebin could continue to plug a decoder right away allowing the parser to configure itself in the same way as it would with a static pipeline. This is not an option unfortunately because often the parser needs to process some data to determine e.g. the format s profile or other stream properties resolution sample rate channel configuration etc. and there may be different decoders for different profiles e.g. DSP codec for baseline profile and software fallback for main high profile or a DSP codec only supporting certain resolutions with a software fallback for unusual resolutions So if decodebin just plugged the most highest ranking decoder that decoder might not be be able to handle the actual stream later on which would yield an error this is a data flow error then which would be hard to intercept and avoid in decodebin In other words we can t solve this issue by plugging a decoder right away with the parser. \nSo decodebin needs to communicate to the parser the set of available decoder caps which would contain the relevant capabilities restrictions such as supported profiles resolutions etc. after the usual autoplug signal filtering sorting of course. \nThis is done by plugging a capsfilter element right after the parser and constructing set of filter caps from the list of available decoders one appends at the end just the name s of the caps structures from the parser pad template caps to function as an ANY other caps equivalent This let the parser negotiate to a supported stream format in the same way as with the static pipeline mentioned above but of course incur some overhead through the additional capsfilter element. \n"});