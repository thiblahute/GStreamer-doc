fragment_downloaded_cb({"url": "design/missing-plugins.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"missing-plugins.md\">\n<h1 id=\"what-to-do-when-a-plugin-is-missing\">What to do when a plugin is missing</h1>\n<p>The mechanism and API described in this document requires GStreamer core\nand gst-plugins-base versions &gt;= 0.10.12. Further information on some\naspects of this document can be found in the libgstbaseutils API\nreference.</p>\n<p>We only discuss playback pipelines for now.</p>\n<p>A three step process:</p>\n<h1 id=\"gstreamer-level\">GStreamer level</h1>\n<p>Elements will use a \"missing-plugin\" element message to report\nmissing plugins, with the following fields set:</p>\n<ul>\n<li>\n<p><strong><code>type</code></strong>: (string) { \"urisource\", \"urisink\", \"decoder\", \"encoder\",\n\"element\" } (we do not distinguish between demuxer/decoders/parsers etc.)</p>\n</li>\n<li>\n<p><strong><code>detail</code></strong>: (string) or (caps) depending on the type { ANY } ex: \"mms,\n\"mmsh\", \"audio/x-mp3,rate=48000,\u2026\"</p>\n</li>\n<li>\n<p><strong><code>name</code></strong>: (string) { ANY } ex: \"MMS protocol handler\",..</p>\n</li>\n</ul>\n<h3 id=\"missing-uri-handler\">missing uri handler</h3>\n<p>ex. mms://foo.bar/file.asf</p>\n<p>When no protocol handler is installed for mms://, the application will not be\nable to instantiate an element for that uri (<code>gst_element_make_from_uri()</code>\nreturns NULL).</p>\n<p>Playbin will post a <code>missing-plugin</code> element message with the type set to\n\"urisource\", detail set to \"mms\". Optionally the friendly name can be filled\nin as well.</p>\n<h3 id=\"missing-typefind-function\">missing typefind function</h3>\n<p>We don't recognize the type of the file, this should normally not happen\nbecause all the typefinders are in the basic GStreamer installation.\nThere is not much useful information we can give about how to resolve this\nissue. It is possible to use the first N bytes of the data to determine the\ntype (and needed plugin) on the server. We don't explore this option in this\ndocument yet, but the proposal is flexible enough to accommodate this in the\nfuture should the need arise.</p>\n<h3 id=\"missing-demuxer\">missing demuxer</h3>\n<p>Typically after running typefind on the data we determine the type of the\nfile. If there is no plugin found for the type, a <code>missing-plugin</code> element\nmessage is posted by decodebin with the following fields: Type set to\n\"decoder\", detail set to the caps for witch no plugin was found. Optionally\nthe friendly name can be filled in as well.</p>\n<h3 id=\"missing-decoder\">missing decoder</h3>\n<p>The demuxer will dynamically create new pads with specific caps while it\nfigures out the contents of the container format. Decodebin tries to find the\ndecoders for these formats in the registry. If there is no decoder found, a\n<code>missing-plugin</code> element message is posted by decodebin with the following\nfields: Type set to \"decoder\", detail set to the caps for which no plugin\nwas found. Optionally the friendly name can be filled in as well. There is\nno distinction made between the missing demuxer and decoder at the\napplication level.</p>\n<h3 id=\"missing-element\">missing element</h3>\n<p>Decodebin and playbin will create a set of helper elements when they set up\ntheir decoding pipeline. These elements are typically colorspace, sample rate,\naudio sinks,... Their presence on the system is required for the functionality\nof decodebin. It is typically a package dependency error if they are not\npresent but in case of a corrupted system the following <code>missing-plugin</code>\nelement message will be emitted: type set to \"element\", detail set to the\nelement factory name and the friendly name optionally set to a description\nof the element's functionality in the decoding pipeline.</p>\n<p>Except for reporting the missing plugins, no further policy is enforced at the\nGStreamer level. It is up to the application to decide whether a missing\nplugin constitutes a problem or not.</p>\n<h2 id=\"application-level\">Application level</h2>\n<p>The application's job is to listen for the <code>missing-plugin</code> element messages\nand to decide on a policy to handle them. Following cases exist:</p>\n<h3 id=\"partially-missing-plugins\">partially missing plugins</h3>\n<p>The application will be able to complete a state change to PAUSED but there\nwill be a <code>missing-plugin</code> element message on the <code>GstBus</code>.</p>\n<p>This means that it will be possible to play back part of the media file but not\nall of it.</p>\n<p>For example: suppose we have an .avi file with mp3 audio and divx video. If we\nhave the mp3 audio decoder but not the divx video decoder, it will be possible\nto play only the audio part but not the video part. For an audio playback\napplication, this is not a problem but a video player might want to decide on:</p>\n<ul>\n<li>require the use to install the additionally required plugins.</li>\n<li>inform the user that only the audio will be played back</li>\n<li>ask the user if it should download the additional codec or only play\nthe audio part.</li>\n<li>\u2026</li>\n</ul>\n<h3 id=\"completely-unplayable-stream\">completely unplayable stream</h3>\n<p>The application will receive an ERROR message from GStreamer informing it that\nplayback stopped (before it could reach PAUSED). This happens because none of\nthe streams is connected to a decoder. The error code and domain should be one\nof the following in this case:</p>\n<ul>\n<li><code>GST_CORE_ERROR_MISSING_PLUGIN</code> (domain: <code>GST_CORE_ERROR</code>)</li>\n<li><code>GST_STREAM_ERROR_CODEC_NOT_FOUND</code> (domain: <code>GST_STREAM_ERROR</code>)</li>\n</ul>\n<p>The application can then see that there are a set of <code>missing-plugin</code> element\nmessages on the <code>GstBus</code> and can decide to trigger the download procedure. It\ndoes that as described in the following section.</p>\n<p><code>missing-plugin</code> element messages can be identified using the function\n<code>gst_is_missing_plugin_message()</code>.</p>\n<h2 id=\"plugin-download-stage\">Plugin download stage</h2>\n<p>At this point the application has</p>\n<ul>\n<li>collected one or more <code>missing-plugin</code> element messages</li>\n<li>made a decision that additional plugins should be installed</li>\n</ul>\n<p>It will call a GStreamer utility function to convert each <code>missing-plugin</code>\nmessage into an identifier string describing the missing capability. This is\ndone using the function <code>gst_missing_plugin_message_get_installer_detail()</code>.</p>\n<p>The application will then pass these strings to <code>gst_install_plugins_async()</code>\nor <code>gst_install_plugins_sync()</code> to initiate the download. See the API\ndocumentation there (<code>libgstbaseutils</code>, part of <code>gst-plugins-base</code>) for more\ndetails.</p>\n<p>When new plugins have been installed, the application will have to initiate\na re-scan of the GStreamer plugin registry using <code>gst_update_registry()</code>.</p>\n<h3 id=\"format-of-the-utf8-string-id-passed-to-the-external-installer-system\">Format of the (UTF-8) string ID passed to the external installer system</h3>\n<p>The string is made up of several fields, separated by '|' characters.\nThe fields are:</p>\n<ul>\n<li>\n<p>plugin system identifier, ie. \"gstreamer\" This identifier determines\nthe format of the rest of the detail string. Automatic plugin\ninstallers should not process detail strings with unknown\nidentifiers. This allows other plugin-based libraries to use the\nsame mechanism for their automatic plugin installation needs, or for\nthe format to be changed should it turn out to be insufficient.</p>\n</li>\n<li>\n<p>plugin system version, e.g. \"1.0\" This is required so that when\nthere is a GStreamer-2.0 or GStreamer-3.0 at some point in future,\nthe different major versions can still co-exist and use the same\nplugin install mechanism in the same way.</p>\n</li>\n<li>\n<p>application identifier, e.g. \"totem\" This may also be in the form of\n\"pid/12345\" if the program name can\u2019t be obtained for some reason.</p>\n</li>\n<li>\n<p>human-readable localised description of the required component, e.g.\n\"Vorbis audio decoder\"</p>\n</li>\n<li>\n<p>identifier string for the required component, e.g.</p>\n</li>\n<li>\n<p>urisource-(<code>PROTOCOL_REQUIRED</code>) e.g. <code>urisource-http</code> or <code>urisource-mms</code></p>\n</li>\n<li>\n<p>element-(<code>ELEMENT_REQUIRED</code>), e.g. <code>element-videoconvert</code></p>\n</li>\n<li>\n<p>decoder-(<code>CAPS_REQUIRED</code>) e.g. <code>decoder-audio/x-vorbis</code> or\n<code>decoder-application/ogg</code> or <code>decoder-audio/mpeg, mpegversion=(int)4</code> or\n<code>decoder-video/mpeg, systemstream=(boolean)true, mpegversion=(int)2</code></p>\n</li>\n<li>\n<p>encoder-(<code>CAPS_REQUIRED</code>) e.g. <code>encoder-audio/x-vorbis</code></p>\n</li>\n<li>\n<p>optional further fields not yet specified</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>An entire ID string might then look like this, for example:\n<code>gstreamer|0.10|totem|Vorbis audio decoder|decoder-audio/x-vorbis</code></p>\n</li>\n<li>\n<p>Plugin installers parsing this ID string should expect further fields also\nseparated by '|' symbols and either ignore them, warn the user, or error\nout when encountering them.</p>\n</li>\n<li>\n<p>The human-readable description string is provided by the libgstbaseutils\nlibrary that can be found in gst-plugins-base versions &gt;= 0.10.12 and can\nalso be used by demuxers to find out the codec names for taglists from given\ncaps in a unified and consistent way.</p>\n</li>\n<li>\n<p>Applications can create these detail strings using the function\n<code>gst_missing_plugin_message_get_installer_detail()</code> on a given missing-plugin\nmessage.</p>\n</li>\n</ul>\n<h3 id=\"using-missingplugin-messages-for-error-reporting\">Using missing-plugin messages for error reporting:</h3>\n<p>Missing-plugin messages are also useful for error reporting purposes, either in\nthe case where the application does not support libgimme-codec, or the external\ninstaller is not available or not able to install the required plugins.</p>\n<p>When creating error messages, applications may use the function\n<code>gst_missing_plugin_message_get_description()</code> to obtain a possibly translated\ndescription from each missing-plugin message (e.g. \"Matroska demuxer\" or\n\"Theora video depayloader\"). This can be used to report to the user exactly\nwhat it is that is missing.</p>\n<h2 id=\"notes-for-packagers\">Notes for packagers</h2>\n<p>An easy way to introspect plugin .so files is:</p>\n<pre><code>$ gst-inspect --print-plugin-auto-install-info /path/to/libgstfoo.so\n</code></pre>\n<p>The output will be something like:</p>\n<pre><code>decoder-audio/x-vorbis\nelement-vorbisdec\nelement-vorbisenc\nelement-vorbisparse\nelement-vorbistag\nencoder-audio/x-vorbis\n</code></pre>\n<p>BUT could also be like this (from the faad element in this case):</p>\n<pre><code>decoder-audio/mpeg, mpegversion=(int){ 2, 4 }\n</code></pre>\n<p>NOTE that this does not exactly match the caps string that the installer\nwill get from the application. The application will always ever ask for\none of</p>\n<pre><code>decoder-audio/mpeg, mpegversion=(int)2\ndecoder-audio/mpeg, mpegversion=(int)4\n</code></pre>\n<p>When introspecting, keep in mind that there are GStreamer plugins\nthat in turn load external plugins. Examples of these are pitfdll,\nladspa, or the GStreamer libvisual plugin. Those plugins will only\nannounce elements for the currently installed external plugins at\nthe time of introspection! With the exception of pitfdll, this is\nnot really relevant to the playback case, but may become an issue in\nfuture when applications like buzztard, jokosher or pitivi start\nrequestion elements by name, for example ladspa effect elements or\nso.</p>\n<p>This case could be handled if those wrapper plugins would also provide a\n<code>gst-install-xxx-plugins-helper</code>, where xxx={ladspa|visual|...}. Thus if the\ndistro specific <code>gst-install-plugins-helper</code> can't resolve a request for e.g.\n<code>element-bml-sonicverb</code> it can forward the request to\n<code>gst-install-bml-plugins-helper</code> (bml is the buzz machine loader).</p>\n<h2 id=\"further-references\">Further references:</h2>\n<p><a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-base-libs/html/gstreamer-base-utils.html\">http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-base-libs/html/gstreamer-base-utils.html</a></p>\n\n</div>\n\n\n\t"});