fragment_downloaded_cb({"url": "design/element-source.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"element-source.md\">\n        <h1 id=\"source-elements\">Source elements</h1>\n<p>A source element is an element that provides data to the pipeline. It\ndoes typically not have any sink (input) pads.</p>\n<p>Typical source elements include:</p>\n<ul>\n<li>\n<p>file readers</p>\n</li>\n<li>\n<p>network elements (live or not)</p>\n</li>\n<li>\n<p>capture elements (video/audio/\u2026)</p>\n</li>\n<li>\n<p>generators (signals/video/audio/\u2026)</p>\n</li>\n</ul>\n<h2 id=\"live-sources\">Live sources</h2>\n<p>A source is said to be a live source when it has the following property:</p>\n<ul>\n<li>temporarily stopping reading from the source causes data to be lost.</li>\n</ul>\n<p>In general when this property holds, the source also produces data at a\nfixed rate. Most sources have a limit on the rate at which they can\ndeliver data, which might be faster or slower than the consumption rate.\nThis property however does not make them a live source.</p>\n<p>Let\u2019s look at some example sources.</p>\n<ul>\n<li>\n<p>file readers: you can PAUSE without losing data. There is however a\nlimit to how fast you can read from this source. This limit is\nusually much higher than the consumption rate. In some cases it\nmight be slower (an NFS share, for example) in which case you might\nneed to use some buffering (see <a href=\"buffering.html\">buffering</a>).</p>\n</li>\n<li>\n<p>HTTP network element: you can PAUSE without data loss. Depending on\nthe available network bandwidth, consumption rate might be higher\nthan production rate in which case buffering should be used (see\n<a href=\"buffering.html\">buffering</a>).</p>\n</li>\n<li>\n<p>audio source: pausing the audio capture will lead to lost data. this\nsource is therefore definitely live. In addition, an audio source\nwill produce data at a fixed rate (the samplerate). Also depending\non the buffersize, this source will introduce a latency (see\n<a href=\"latency.html\">latency</a>).</p>\n</li>\n<li>\n<p>udp network source: Pausing the receiving part will lead to lost\ndata. This source is therefore a live source. Also in a typical case\nthe udp packets will be received at a certain rate, which might be\ndifficult to guess because of network jitter. This source does not\nnecessarily introduce latency on its own.</p>\n</li>\n<li>\n<p>dvb source: PAUSING this element will lead to data loss, it\u2019s a live\nsource similar to a UDP source.</p>\n</li>\n</ul>\n<h2 id=\"source-types\">Source types</h2>\n<p>A source element can operate in three ways:</p>\n<ul>\n<li>\n<p>it is fully seekable, this means that random access can be performed\non it in an efficient way. (a file reader,\u2026). This also typically\nmeans that the source is not live.</p>\n</li>\n<li>\n<p>data can be obtained from it with a variable size. This means that\nthe source can give N bytes of data. An example is an audio source.\nA video source always provides the same amount of data (one video\nframe). Note that this is not a fully seekable source.</p>\n</li>\n<li>\n<p>it is a live source, see above.</p>\n</li>\n</ul>\n<p>When writing a source, one has to look at how the source can operate to\ndecide on the scheduling methods to implement on the source.</p>\n<ul>\n<li>\n<p>fully seekable sources implement a getrange function on the source\npad.</p>\n</li>\n<li>\n<p>sources that can give N bytes but cannot do seeking also implement a\ngetrange function but state that they cannot do random access.</p>\n</li>\n<li>\n<p>sources that are purely live sources implement a task to push out\ndata.</p>\n</li>\n</ul>\n<p>Any source that has a getrange function must also implement a push based\nscheduling mode. In this mode the source starts a task that gets N bytes\nand pushes them out. Whenever possible, the peer element will select the\ngetrange based scheduling method of the source, though.</p>\n<p>A source with a getrange function must activate itself in the pad\nactivate function. This is needed because the downstream peer element\nwill decide and activate the source element in its state change function\nbefore the source\u2019s state change function is called.</p>\n<h2 id=\"source-base-classes\">Source base classes</h2>\n<p><code>GstBaseSrc</code>:</p>\n<p>This base class provides an implementation of a random access source and\nis very well suited for file reader like sources.</p>\n<p><code>GstPushSrc</code>:</p>\n<p>Base class for block-based sources. This class is mostly useful for\nelements that cannot do random access, or at least very slowly. The\nsource usually prefers to push out a fixed size buffer.</p>\n<p>Classes extending this base class will usually be scheduled in a push\nbased mode. If the peer accepts to operate without offsets and within\nthe limits of the allowed block size, this class can operate in getrange\nbased mode automatically.</p>\n<p>The subclass should extend the methods from the baseclass in addition to\nthe create method. If the source is seekable, it needs to override\n<code>GstBaseSrc::event()</code> in addition to <code>GstBaseSrc::is_seekable()</code> in order\nto retrieve the seek offset, which is the offset of the next buffer to\nbe requested.</p>\n<p>Flushing, scheduling and sync is all handled by this base class.</p>\n<h2 id=\"timestamps\">Timestamps</h2>\n<p>A non-live source should timestamp the buffers it produces starting from</p>\n<ol start=\"0\">\n<li>If it is not possible to timestamp every buffer (filesrc), the source\nis allowed to only timestamp the first buffer (as 0).</li>\n</ol>\n<p>Live sources only produce data in the PLAYING state, when the clock is\nrunning. They should timestamp each buffer they produce with the current\n<code>running_time</code> of the pipeline, which is expressed as:</p>\n<pre><code>absolute_time - base_time\n</code></pre>\n<p>With <code>absolute_time</code> being the time obtained from the global pipeline with\n<code>gst_clock_get_time()</code> and <code>base_time</code> being the time of that clock when\nthe pipeline was last set to PLAYING.</p>\n\n        \n\n    </div>\n\n\n        "});