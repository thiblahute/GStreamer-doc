fragment_downloaded_cb({"url": "design/keyframe-force.html#downstream", "fragment": "Downstream \nThe implementation would consist of generating a GST_EVENT_CUSTOM_DOWNSTREAM event that marks the keyframe boundary. This event is inserted into the pipeline by the application upon a certain trigger. In the above use case this trigger would be given by the element that detects the pattern in the form of an element message. \nThe custom event would travel further downstream to instruct encoder muxer and sink about the possible switch. \nThe information passed in the event consists of \nGstForceKeyUnit \ntimestamp G_TYPE_UINT64 the timestamp of the buffer that triggered the event. \nstream time G_TYPE_UINT64 the stream position that triggered the event. \nrunning time G_TYPE_UINT64 the running time of the stream when the event was triggered. \nall headers G_TYPE_BOOLEAN Send all headers including those in the caps or those sent at the start of the stream. \noptional other data fields. \nNote that this event is purely informational no element is required to perform an action but it should forward the event downstream just like any other event it does not handle. \nElements understanding the event should behave as follows \nThe video encoder receives the event before the next frame. Upon reception of the event it schedules to encode the next frame as a keyframe. Before pushing out the encoded keyframe it must push the GstForceKeyUnit event downstream. \nThe muxer receives the GstForceKeyUnit event and flushes out its current state preparing to produce data that can be used as a keyunit. Before pushing out the new data it pushes the GstForceKeyUnit event downstream. \nThe application receives the GstForceKeyUnit on a sink padprobe of the sink and reconfigures the sink to make it perform new actions after receiving the next buffer. \n"});