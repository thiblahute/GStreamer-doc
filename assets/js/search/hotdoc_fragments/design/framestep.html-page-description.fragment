fragment_downloaded_cb({"url": "design/framestep.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"framestep.md\">\n<h1 id=\"frame-step\">Frame step</h1>\n<p>This document outlines the details of the frame stepping functionality\nin GStreamer.</p>\n<p>The stepping functionality operates on the current playback segment,\nposition and rate as it was configured with a regular seek event. In\ncontrast to the seek event, it operates very closely to the sink and\nthus has a very low latency and is not slowed down by queues and does\nnot actually perform any seeking logic. For this reason we want to\ninclude a new API instead of reusing the seek API.</p>\n<p>The following requirements are needed:</p>\n<ul>\n<li>\n<p>The ability to walk forwards and backwards in the stream.</p>\n</li>\n<li>\n<p>Arbitrary increments in any supported format (time, frames, bytes \u2026)</p>\n</li>\n<li>\n<p>High speed, minimal overhead. This mechanism is not more expensive\nthan simple playback.</p>\n</li>\n<li>\n<p>switching between forwards and backwards stepping should be fast.</p>\n</li>\n<li>\n<p>Maintain synchronisation between streams.</p>\n</li>\n<li>\n<p>Get feedback of the amount of skipped data.</p>\n</li>\n<li>\n<p>Ability to play a certain amount of data at an arbitrary speed.</p>\n</li>\n</ul>\n<p>We want a system where we can step frames in <code>PAUSED</code> as well as play\nshort segments of data in <code>PLAYING</code>.</p>\n<h2 id=\"use-cases\">Use Cases</h2>\n<h3 id=\"video-only-pipeline-in-paused\">video only pipeline in PAUSED</h3>\n<pre><code>.-----.    .-------.              .------.    .-------.\n| src |    | demux |    .-----.   | vdec |    | vsink |\n|    src-&gt;sink    src1-&gt;|queue|-&gt;sink   src-&gt;sink     |\n'-----'    '-------'    '-----'   '------'    '-------'\n</code></pre>\n<ul>\n<li>\n<p>app sets the pipeline to <code>PAUSED</code> to block on the preroll picture</p>\n</li>\n<li>\n<p>app seeks to required position in the stream. This can be done\nwith a positive or negative rate depending on the required frame\nstepping direction.</p>\n</li>\n<li>\n<p>app steps frames (in <code>GST_FORMAT_DEFAULT</code> or <code>GST_FORMAT_BUFFER)</code>. The\npipeline loses its <code>PAUSED</code> state until the required number of frames have been\nskipped, it then prerolls again. This skipping is purely done in the sink.</p>\n</li>\n<li>\n<p>sink posts <code>STEP_DONE</code> with amount of frames stepped and\ncorresponding time interval.</p>\n</li>\n</ul>\n<h3 id=\"audiovideo-pipeline-in-paused\">audio/video pipeline in PAUSED</h3>\n<pre><code>.-----.    .-------.              .------.    .-------.\n| src |    | demux |    .-----.   | vdec |    | vsink |\n|    src-&gt;sink    src1-&gt;|queue|-&gt;sink   src-&gt;sink     |\n'-----'    |       |    '-----'   '------'    '-------'\n           |       |              .------.    .-------.\n           |       |    .-----.   | adec |    | asink |\n           |      src2-&gt;|queue|-&gt;sink   src-&gt;sink     |\n           '-------'    '-----'   '------'    '-------'\n</code></pre>\n<ul>\n<li>\n<p>app sets the pipeline to <code>PAUSED</code> to block on the preroll picture</p>\n</li>\n<li>\n<p>app seeks to required position in the stream. This can be done\nwith a positive or negative rate depending on the required frame\nstepping direction.</p>\n</li>\n<li>\n<p>app steps frames (in <code>GST_FORMAT_DEFAULT</code> or <code>GST_FORMAT_BUFFER</code>) or an\namount of time on the video sink. The pipeline loses its <code>PAUSED</code> state until\nthe required number of frames have been skipped, it then prerolls again. This\nskipping is purely done in the sink.</p>\n</li>\n<li>\n<p>sink posts <code>STEP_DONE</code> with amount of frames stepped and\ncorresponding time interval.</p>\n</li>\n<li>\n<p>the app skips the same amount of time on the audiosink to align\nthe streams again. When huge amount of video frames are skipped,\nthere needs to be enough queueing in the pipeline to compensate\nfor the accumulated audio.</p>\n</li>\n</ul>\n<h3 id=\"audiovideo-pipeline-in-playing\">audio/video pipeline in PLAYING</h3>\n<ul>\n<li>\n<p>app sets the pipeline to <code>PAUSED</code> to block on the preroll picture</p>\n</li>\n<li>\n<p>app seeks to required position in the stream. This can be done\nwith a positive or negative rate depending on the required frame\nstepping direction.</p>\n</li>\n<li>\n<p>app configures frames steps (in <code>GST_FORMAT_DEFAULT</code> or\n<code>GST_FORMAT_BUFFER</code> or an amount of time on the sink. The step event has\na flag indicating live stepping so that the stepping will only happens in\nPLAYING.</p>\n</li>\n<li>\n<p>app sets pipeline to PLAYING. The pipeline continues PLAYING\nuntil it consumed the amount of time.</p>\n</li>\n<li>\n<p>sink posts <code>STEP_DONE</code> with amount of frames stepped and\ncorresponding time interval. The sink will then wait for another\nstep event. Since the <code>STEP_DONE</code> message was emitted by the sink\nwhen it handed off the buffer to the device, there is usually\nsufficient time to queue a new STEP event so that one can\nseamlessly continue stepping.</p>\n</li>\n</ul>\n<h2 id=\"events\">events</h2>\n<p>A new <code>GST_EVENT_STEP</code> event is introduced to start the step operation.\nThe step event is created with the following fields in the structure:</p>\n<ul>\n<li>\n<p><strong><code>format</code></strong> <code>GST_TYPE_FORMAT</code>: The format of the step units</p>\n</li>\n<li>\n<p><strong><code>amount</code></strong> <code>G_TYPE_UINT64</code>: The amount of units to step. A 0 amount\nimmediately completes and can be used to cancel the current step and resume\nnormal non-stepping behaviour to the end of the segment. A -1 amount steps\nuntil the end of the segment.</p>\n</li>\n<li>\n<p><strong><code>rate</code></strong> <code>G_TYPE_DOUBLE</code>: The rate at which the frames should be stepped in\nPLAYING mode. 1.0 is the normal playback speed and direction of the segment,\n2.0 is double speed. A speed of 0.0 is not allowed. When performing a flushing\nstep, the speed is not relevant. Note that we don't allow negative rates here,\nuse a seek with a negative rate first to reverse the playback direction.</p>\n</li>\n<li>\n<p><strong><code>flush</code></strong> <code>G_TYPE_BOOLEAN</code>: when flushing is TRUE, the step is performed\nimmediately:</p>\n<ul>\n<li>\n<p>In the <code>PAUSED</code> state the pipeline loses the <code>PAUSED</code> state, the\nrequested amount of data is skipped and the pipeline prerolls again\nwhen a non-intermediate step completes. When the pipeline was\nstepping while the event is sent, the current step operation is\nupdated with the new amount and format. The sink will do a best\neffort to comply with the new amount.</p>\n</li>\n<li>\n<p>In the PLAYING state, the pipeline loses the <code>PLAYING</code> state, the\nrequested amount of data is skipped (not rendered) from the previous\nSTEP request or from the position of the last <code>PAUSED</code> if no previous\nSTEP operation was performed. The pipeline goes back to the <code>PLAYING</code>\nstate when a non-intermediate step completes.</p>\n</li>\n<li>\n<p>When flushing is FALSE, the step will be performed later.</p>\n</li>\n<li>\n<p>In the <code>PAUSED</code> state the step will be done when going to <code>PLAYING</code>. Any\nprevious step operation will be overridden with the new <code>STEP</code> event.</p>\n</li>\n<li>\n<p>In the <code>PLAYING</code> state the step operation will be performed after the\ncurrent step operation completes. If there was no previous step\noperation, the step operation will be performed from the position of\nthe last <code>PAUSED</code> state.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong><code>intermediate</code></strong> <code>G_TYPE_BOOLEAN</code>: Signal that this step operation is an\nintermediate step, part of a series of step operations. It is mostly\ninteresting for stepping in the <code>PAUSED</code> state because the sink will only perform\na preroll after a non-intermediate step operation completes. Intermediate steps\nare useful to flush out data from other sinks in order to not cause excessive\nqueueing. In the PLAYING state the intermediate flag has no visual effect. In\nall states, the intermediate flag is passed to the corresponding\n<code>GST_MESSAGE_STEP_DONE</code>.</p>\n</li>\n</ul>\n<p>The application will create a STEP event to start or stop the stepping\noperation. Both stepping in <code>PAUSED</code> and <code>PLAYING</code> can be performed by means\nof the flush flag.</p>\n<p>The event is usually sent to the pipeline, which will typically\ndistribute the event to all of its sinks. For some use cases, like frame\nstepping on video frames only, the event should only be sent to the\nvideo sink and upon reception of the <code>STEP_DONE</code> message, one can step\nthe other sinks to align the streams again.</p>\n<p>For large stepping amounts, there needs to be enough queueing in front\nof all the sinks. If large steps need to be performed, they can be split\nup into smaller step operations using the \"intermediate\" flag on the\nstep.</p>\n<p>Since the step event does not update the <code>base_time</code> of any of the\nelements, the sinks should keep track of the amount of stepped data in\norder to remain synchronized against the clock.</p>\n<h2 id=\"messages\">messages</h2>\n<p>A <code>GST_MESSAGE_STEP_START</code> is created. It contains the following\nfields.</p>\n<ul>\n<li>\n<p><strong><code>active</code></strong>: If the step was queued or activated.</p>\n</li>\n<li>\n<p><strong><code>format</code></strong> <code>GST_TYPE_FORMAT</code>: The format of the step units that queued/activated.</p>\n</li>\n<li>\n<p><strong><code>amount</code></strong> <code>G_TYPE_UINT64</code>: The amount of units that were queued/activated.</p>\n</li>\n<li>\n<p><strong><code>rate</code></strong> <code>G_TYPE_DOUBLE</code>: The rate and direction at which the frames were queued/activated.</p>\n</li>\n<li>\n<p><strong><code>flush</code></strong> <code>G_TYPE_BOOLEAN</code>: If the queued/activated frames will be flushed.</p>\n</li>\n<li>\n<p><strong><code>intermediate</code></strong> <code>G_TYPE_BOOLEAN</code>: If this is an intermediate step operation\nthat queued/activated.</p>\n</li>\n</ul>\n<p>The <code>STEP_START</code> message is emitted 2 times:</p>\n<ul>\n<li>\n<p>first when an element received the STEP event and queued it. The\n\"active\" field will be FALSE in this case.</p>\n</li>\n<li>\n<p>second when the step operation started in the streaming thread. The\n\"active\" field is TRUE in this case. After this message is emitted,\nthe application can queue a new step operation.</p>\n</li>\n</ul>\n<p>The purpose of this message is to find out how many elements participate\nin the step operation and to queue new step operations at the earliest\npossible moment.</p>\n<p>A new <code>GST_MESSAGE_STEP_DONE</code> message is created. It contains the\nfollowing fields:</p>\n<ul>\n<li><strong><code>format</code></strong> <code>GST_TYPE_FORMAT</code>: The format of the step units that completed.</li>\n<li><strong><code>amount</code></strong> <code>G_TYPE_UINT64</code>: The amount of units that were stepped.</li>\n<li><strong><code>rate</code></strong> <code>G_TYPE_DOUBLE</code>: The rate and direction at which the frames were stepped.</li>\n<li><strong><code>flush</code></strong> <code>G_TYPE_BOOLEAN</code>: If the stepped frames were flushed.</li>\n<li><strong><code>intermediate</code></strong> <code>G_TYPE_BOOLEAN</code>: If this is an intermediate step operation that completed.</li>\n<li><strong><code>duration</code></strong> <code>G_TYPE_UINT64</code>: The total duration of the stepped units in <code>GST_FORMAT_TIME</code>.</li>\n<li><strong><code>eos</code></strong> <code>G_TYPE_BOOLEAN</code>: The step ended because of EOS.</li>\n</ul>\n<p>The message is emitted by the element that performs the step operation.\nThe purpose is to return the duration in <code>GST_FORMAT_TIME</code> of the\nstepped media. This especially interesting to align other stream in case\nof stepping frames on the video sink element.</p>\n<h2 id=\"direction-switch\">Direction switch</h2>\n<p>When quickly switching between a forwards and a backwards step of, for\nexample, one video frame, we need either:</p>\n<ol>\n<li>issue a new seek to change the direction from the current position.</li>\n<li>cache a certain number of stepped frames and walk the cache.</li>\n</ol>\n<p>option 1) might be very slow. For option 2) we would ideally like to\noffload this caching functionality to a separate element, which means\nthat we need to forward the STEP event upstream. It\u2019s unclear how this\ncould work in a generic way. What is a demuxer supposed to do when it\nreceived a step event? a flushing seek to what stream position?</p>\n\n</div>\n\n\n        "});