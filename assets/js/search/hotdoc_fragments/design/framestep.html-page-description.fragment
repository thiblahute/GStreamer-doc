fragment_downloaded_cb({"url": "design/framestep.html#page-description", "fragment": "This document outlines the details of the frame stepping functionality in GStreamer. \nThe stepping functionality operates on the current playback segment position and rate as it was configured with a regular seek event. In contrast to the seek event it operates very closely to the sink and thus has a very low latency and is not slowed down by queues and does not actually perform any seeking logic. For this reason we want to include a new API instead of reusing the seek API. \nThe following requirements are needed \nThe ability to walk forwards and backwards in the stream. \nArbitrary increments in any supported format time frames bytes \nHigh speed minimal overhead. This mechanism is not more expensive than simple playback. \nswitching between forwards and backwards stepping should be fast. \nMaintain synchronisation between streams. \nGet feedback of the amount of skipped data. \nAbility to play a certain amount of data at an arbitrary speed. \nWe want a system where we can step frames in PAUSED as well as play short segments of data in PLAYING. \napp sets the pipeline to PAUSED to block on the preroll picture \napp seeks to required position in the stream. This can be done with a positive or negative rate depending on the required frame stepping direction. \napp steps frames in GST_FORMAT_DEFAULT or GST_FORMAT_BUFFER The pipeline loses its PAUSED state until the required number of frames have been skipped it then prerolls again. This skipping is purely done in the sink. \nsink posts STEP_DONE with amount of frames stepped and corresponding time interval. \napp sets the pipeline to PAUSED to block on the preroll picture \napp seeks to required position in the stream. This can be done with a positive or negative rate depending on the required frame stepping direction. \napp steps frames in GST_FORMAT_DEFAULT or GST_FORMAT_BUFFER or an amount of time on the video sink. The pipeline loses its PAUSED state until the required number of frames have been skipped it then prerolls again. This skipping is purely done in the sink. \nsink posts STEP_DONE with amount of frames stepped and corresponding time interval. \nthe app skips the same amount of time on the audiosink to align the streams again. When huge amount of video frames are skipped there needs to be enough queueing in the pipeline to compensate for the accumulated audio. \napp sets the pipeline to PAUSED to block on the preroll picture \napp seeks to required position in the stream. This can be done with a positive or negative rate depending on the required frame stepping direction. \napp configures frames steps in GST_FORMAT_DEFAULT or GST_FORMAT_BUFFER or an amount of time on the sink. The step event has a flag indicating live stepping so that the stepping will only happens in PLAYING. \napp sets pipeline to PLAYING. The pipeline continues PLAYING until it consumed the amount of time. \nsink posts STEP_DONE with amount of frames stepped and corresponding time interval. The sink will then wait for another step event. Since the STEP_DONE message was emitted by the sink when it handed off the buffer to the device there is usually sufficient time to queue a new STEP event so that one can seamlessly continue stepping. \nA new GST_EVENT_STEP event is introduced to start the step operation. The step event is created with the following fields in the structure \nformat GST_TYPE_FORMAT The format of the step units \namount G_TYPE_UINT64 The amount of units to step. A amount immediately completes and can be used to cancel the current step and resume normal non stepping behaviour to the end of the segment. A amount steps until the end of the segment. \nrate G_TYPE_DOUBLE The rate at which the frames should be stepped in PLAYING mode. is the normal playback speed and direction of the segment is double speed. A speed of is not allowed. When performing a flushing step the speed is not relevant. Note that we don t allow negative rates here use a seek with a negative rate first to reverse the playback direction. \nflush G_TYPE_BOOLEAN when flushing is TRUE the step is performed immediately \nIn the PAUSED state the pipeline loses the PAUSED state the requested amount of data is skipped and the pipeline prerolls again when a non intermediate step completes. When the pipeline was stepping while the event is sent the current step operation is updated with the new amount and format. The sink will do a best effort to comply with the new amount. \nIn the PLAYING state the pipeline loses the PLAYING state the requested amount of data is skipped not rendered from the previous STEP request or from the position of the last PAUSED if no previous STEP operation was performed. The pipeline goes back to the PLAYING state when a non intermediate step completes. \nWhen flushing is FALSE the step will be performed later. \nIn the PAUSED state the step will be done when going to PLAYING. Any previous step operation will be overridden with the new STEP event. \nIn the PLAYING state the step operation will be performed after the current step operation completes. If there was no previous step operation the step operation will be performed from the position of the last PAUSED state. \nintermediate G_TYPE_BOOLEAN Signal that this step operation is an intermediate step part of a series of step operations. It is mostly interesting for stepping in the PAUSED state because the sink will only perform a preroll after a non intermediate step operation completes. Intermediate steps are useful to flush out data from other sinks in order to not cause excessive queueing. In the PLAYING state the intermediate flag has no visual effect. In all states the intermediate flag is passed to the corresponding GST_MESSAGE_STEP_DONE. \nThe application will create a STEP event to start or stop the stepping operation. Both stepping in PAUSED and PLAYING can be performed by means of the flush flag. \nThe event is usually sent to the pipeline which will typically distribute the event to all of its sinks. For some use cases like frame stepping on video frames only the event should only be sent to the video sink and upon reception of the STEP_DONE message one can step the other sinks to align the streams again. \nFor large stepping amounts there needs to be enough queueing in front of all the sinks. If large steps need to be performed they can be split up into smaller step operations using the intermediate flag on the step. \nSince the step event does not update the base_time of any of the elements the sinks should keep track of the amount of stepped data in order to remain synchronized against the clock. \nA GST_MESSAGE_STEP_START is created. It contains the following fields. \nactive If the step was queued or activated. \nformat GST_TYPE_FORMAT The format of the step units that queued activated. \namount G_TYPE_UINT64 The amount of units that were queued activated. \nrate G_TYPE_DOUBLE The rate and direction at which the frames were queued activated. \nflush G_TYPE_BOOLEAN If the queued activated frames will be flushed. \nintermediate G_TYPE_BOOLEAN If this is an intermediate step operation that queued activated. \nThe STEP_START message is emitted times \nfirst when an element received the STEP event and queued it. The active field will be FALSE in this case. \nsecond when the step operation started in the streaming thread. The active field is TRUE in this case. After this message is emitted the application can queue a new step operation. \nThe purpose of this message is to find out how many elements participate in the step operation and to queue new step operations at the earliest possible moment. \nA new GST_MESSAGE_STEP_DONE message is created. It contains the following fields \nThe message is emitted by the element that performs the step operation. The purpose is to return the duration in GST_FORMAT_TIME of the stepped media. This especially interesting to align other stream in case of stepping frames on the video sink element. \nWhen quickly switching between a forwards and a backwards step of for example one video frame we need either \noption might be very slow. For option we would ideally like to offload this caching functionality to a separate element which means that we need to forward the STEP event upstream. It s unclear how this could work in a generic way. What is a demuxer supposed to do when it received a step event a flushing seek to what stream position \n"});