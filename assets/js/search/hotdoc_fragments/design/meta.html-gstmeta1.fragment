fragment_downloaded_cb({"url": "design/meta.html#gstmeta1", "fragment": "GstMeta \nA GstMeta is a structure as follows \nThe purpose of this structure is to serve as a common header for all metadata information that we can attach to a buffer. Specific metadata such as timing metadata will have this structure as the first field. For example \nOr another example for the video memory regions that consists of both fields and methods. \nGstMeta derived structures define the API of the metadata. The API can consist of fields and or methods. It is possible to have different implementations for the same GstMeta structure. \nThe implementation of the GstMeta API would typically add more fields to the public structure that allow it to implement the API. \nGstMetaInfo will point to more information about the metadata and looks like this \nThe api member will contain a GType of the metadata API. A repository of registered MetaInfo will be maintained by the core. We will register some common metadata structures in core and some media specific info for audio video text in base. Plugins can register additional custom metadata. \nFor each implementation of api there will thus be a unique GstMetaInfo. In the case of metadata with a well defined API the implementation specific init function will setup the methods in the metadata structure. A unique GType will be made for each implementation and stored in the type field. \nAlong with the metadata description we will have functions to initialize free and or refcount a specific GstMeta instance. We also have the possibility to add a custom transform function that can be used to modify the metadata when a transformation happens. \nThere are no explicit methods to serialize and deserialize the metadata. Since each type has a GType we can reuse the GValue transform functions for this. \nThe purpose of the separate MetaInfo is to not have to carry the free init functions in each buffer instance but to define them globally. We still want quick access to the info so we need to make the buffer metadata point to the info. \nTechnically we could also specify the field and types in the MetaInfo and provide a generic API to retrieve the metadata fields without the need for a header file. We will not do this yet. \nAllocation of the GstBuffer structure will result in the allocation of a memory region of a customizable size bytes Only the first sizeof GstBuffer bytes of this region will initially be used. The remaining bytes will be part of the free metadata region of the buffer. Different implementations are possible and are invisible in the API or ABI. \nThe complete buffer with metadata could for example look as follows \n"});