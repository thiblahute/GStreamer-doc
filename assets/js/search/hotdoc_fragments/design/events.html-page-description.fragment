fragment_downloaded_cb({"url": "design/events.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"events.md\">\n<h1 id=\"events\">Events</h1>\n<p>Events are objects passed around in parallel to the buffer dataflow to\nnotify elements of various events.</p>\n<p>Events are received on pads using the event function. Some events should\nbe interleaved with the data stream so they require taking the\n<code>STREAM_LOCK</code>, others don\u2019t.</p>\n<p>Different types of events exist to implement various functionalities.</p>\n<ul>\n<li><code>GST_EVENT_FLUSH_START</code>: data is to be discarded</li>\n<li><code>GST_EVENT_FLUSH_STOP</code>: data is allowed again</li>\n<li><code>GST_EVENT_CAPS</code>: Format information about the following buffers</li>\n<li><code>GST_EVENT_SEGMENT</code>: Timing information for the following buffers</li>\n<li><code>GST_EVENT_TAG</code>: Stream metadata.</li>\n<li><code>GST_EVENT_BUFFERSIZE</code>: Buffer size requirements</li>\n<li><code>GST_EVENT_SINK_MESSAGE</code>: An event turned into a message by sinks</li>\n<li><code>GST_EVENT_EOS</code>: no more data is to be expected on a pad.</li>\n<li><code>GST_EVENT_QOS</code>: A notification of the quality of service of the stream</li>\n<li><code>GST_EVENT_SEEK</code>: A seek should be performed to a new position in the stream</li>\n<li><code>GST_EVENT_NAVIGATION</code>: A navigation event.</li>\n<li><code>GST_EVENT_LATENCY</code>: Configure the latency in a pipeline</li>\n<li><code>GST_EVENT_STEP</code>: Stepping event</li>\n<li><code>GST_EVENT_RECONFIGURE</code>: stream reconfigure event</li>\n</ul>\n<ul>\n<li><code>GST_EVENT_DRAIN</code>: Play all data downstream before returning.\n<blockquote>\n<p>not yet implemented, under investigation, might be needed to do\nstill frames in DVD.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"src-pads\">src pads</h2>\n<p>A <code>gst_pad_push_event()</code> on a srcpad will first store the sticky event\nin the sticky array before sending the event to the peer pad. If there\nis no peer pad and the event was not stored in the sticky array, FALSE\nis returned.</p>\n<p>Flushing pads will refuse the events and will not store the sticky\nevents.</p>\n<h2 id=\"sink-pads\">sink pads</h2>\n<p>A <code>gst_pad_send_event()</code> on a sinkpad will call the event function on\nthe pad. If the event function returns success, the sticky event is\nstored in the sticky event array and the event is marked for update.</p>\n<p>When the pad is flushing, the <code>_send_event()</code> function returns FALSE\nimmediately.</p>\n<p>When the next data item is pushed, the pending events are pushed first.</p>\n<p>This ensures that the event function is never called for flushing pads\nand that the sticky array only contains events for which the event\nfunction returned success.</p>\n<h2 id=\"pad-link\">pad link</h2>\n<p>When linking pads, the srcpad sticky events are marked for update when\nthey are different from the sinkpad events. The next buffer push will\npush the events to the sinkpad.</p>\n<h2 id=\"flush_startstop\">FLUSH_START/STOP</h2>\n<p>A flush event is sent both downstream and upstream to clear any pending\ndata from the pipeline. This might be needed to make the graph more\nresponsive when the normal dataflow gets interrupted by for example a\nseek event.</p>\n<p>Flushing happens in two stages.</p>\n<ol>\n<li>\n<p>a source element sends the <code>FLUSH_START</code> event to the downstream peer element.\nThe downstream element starts rejecting buffers from the upstream elements. It\nsends the flush event further downstream and discards any buffers it is\nholding as well as return from the chain function as soon as possible.\nThis makes sure that all upstream elements get unblocked.\nThis event is not synchronized with the <code>STREAM_LOCK</code> and can be done in the\napplication thread.</p>\n</li>\n<li>\n<p>a source element sends the <code>FLUSH_STOP</code> event to indicate\nthat the downstream element can accept buffers again. The downstream\nelement sends the flush event to its peer elements. After this step dataflow\ncontinues. The <code>FLUSH_STOP</code> call is synchronized with the <code>STREAM_LOCK</code> so any\ndata used by the chain function can safely freed here if needed. Any\npending EOS events should be discarded too.</p>\n</li>\n</ol>\n<p>After the flush completes the second stage, data is flowing again in the\npipeline and all buffers are more recent than those before the flush.</p>\n<p>For elements that use the pullrange function, they send both flush\nevents to the upstream pads in the same way to make sure that the\npullrange function unlocks and any pending buffers are cleared in the\nupstream elements.</p>\n<p>A <code>FLUSH_START</code> may instruct the pipeline to distribute a new <code>base_time</code>\nto elements so that the <code>running_time</code> is reset to 0. (see\n<a href=\"clocks.html\">clocks</a> and <a href=\"synchronisation.html\">synchronisation</a>).</p>\n<h2 id=\"eos\">EOS</h2>\n<p>The EOS event can only be sent on a sinkpad. It is typically emitted by\nthe source element when it has finished sending data. This event is\nmainly sent in the streaming thread but can also be sent from the\napplication thread.</p>\n<p>The downstream element should forward the EOS event to its downstream\npeer elements. This way the event will eventually reach the sinks which\nshould then post an EOS message on the bus when in PLAYING.</p>\n<p>An element might want to flush its internally queued data before\nforwarding the EOS event downstream. This flushing can be done in the\nsame thread as the one handling the EOS event.</p>\n<p>For elements with multiple sink pads it might be possible to wait for\nEOS on all the pads before forwarding the event.</p>\n<p>The EOS event should always be interleaved with the data flow, therefore\nthe GStreamer core will take the <code>STREAM_LOCK</code>.</p>\n<p>Sometimes the EOS event is generated by another element than the source,\nfor example a demuxer element can generate an EOS event before the\nsource element. This is not a problem, the demuxer does not send an EOS\nevent to the upstream element but returns <code>GST_FLOW_EOS</code>, causing the\nsource element to stop sending data.</p>\n<p>An element that sends EOS on a pad should stop sending data on that pad.\nSource elements typically <code>pause()</code> their task for that purpose.</p>\n<p>By default, a GstBin collects all EOS messages from all its sinks before\nposting the EOS message to its parent.</p>\n<p>The EOS is only posted on the bus by the sink elements in the PLAYING\nstate. If the EOS event is received in the PAUSED state, it is queued\nuntil the element goes to PLAYING.</p>\n<p>A <code>FLUSH_STOP</code> event on an element flushes the EOS state and all pending\nEOS messages.</p>\n<h2 id=\"segment\">SEGMENT</h2>\n<p>A segment event is sent downstream by an element to indicate that the\nfollowing group of buffers start and end at the specified positions. The\nnewsegment event also contains the playback speed and the applied rate\nof the stream.</p>\n<p>Since the stream time is always set to 0 at start and after a seek, a 0\npoint for all next buffer\u2019s timestamps has to be propagated through the\npipeline using the SEGMENT event.</p>\n<p>Before sending buffers, an element must send a SEGMENT event. An element\nis free to refuse buffers if they were not preceded by a SEGMENT event.</p>\n<p>Elements that sync to the clock should store the SEGMENT start and end\nvalues and subtract the start value from the buffer timestamp before\ncomparing it against the stream time (see <a href=\"clocks.html\">clocks</a>).</p>\n<p>An element is allowed to send out buffers with the SEGMENT start time\nalready subtracted from the timestamp. If it does so, it needs to send a\ncorrected SEGMENT downstream, ie, one with start time 0.</p>\n<p>A SEGMENT event should be generated as soon as possible in the pipeline\nand is usually generated by a demuxer or source. The event is generated\nbefore pushing the first buffer and after a seek, right before pushing\nthe new buffer.</p>\n<p>The SEGMENT event should be sent from the streaming thread and should be\nserialized with the buffers.</p>\n<p>Buffers should be clipped within the range indicated by the newsegment\nevent start and stop values. Sinks must drop buffers with timestamps out\nof the indicated segment range.</p>\n<h2 id=\"tag\">TAG</h2>\n<p>The tag event is sent downstream when an element has discovered metadata\ntags in a media file. Encoders can use this event to adjust their\ntagging system. A tag is serialized with buffers.</p>\n<h2 id=\"buffersize\">BUFFERSIZE</h2>\n<blockquote>\n<p><strong>Note</strong></p>\n<p>This event is not yet implemented.</p>\n</blockquote>\n<p>An element can suggest a buffersize for downstream elements. This is\ntypically done by elements that produce data on multiple source pads\nsuch as demuxers.</p>\n<h2 id=\"qos\">QOS</h2>\n<p>A QOS, or quality of service message, is generated in an element to\nreport to the upstream elements about the current quality of real-time\nperformance of the stream. This is typically done by the sinks that\nmeasure the amount of framedrops they have. (see <a href=\"qos.html\">qos</a>)</p>\n<h2 id=\"seek\">SEEK</h2>\n<p>A seek event is issued by the application to configure the playback\nrange of a stream. It is called form the application thread and travels\nupstream.</p>\n<p>The seek event contains the new start and stop position of playback\nafter the seek is performed. Optionally the stop position can be left at\n-1 to continue playback to the end of the stream. The seek event also\ncontains the new playback rate of the stream, 1.0 is normal playback,\n2.0 double speed and negative values mean backwards playback.</p>\n<p>A seek usually flushes the graph to minimize latency after the seek.\nThis behaviour is triggered by using the <code>SEEK_FLUSH</code> flag on the seek\nevent.</p>\n<p>The seek event usually starts from the sink elements and travels\nupstream from element to element until it reaches an element that can\nperform the seek. No intermediate element is allowed to assume that a\nseek to this location will happen. It is allowed to modify the start and\nstop times if it needs to do so. this is typically the case if a seek is\nrequested for a non-time position.</p>\n<p>The actual seek is performed in the application thread so that success\nor failure can be reported as a return value of the seek event. It is\ntherefore important that before executing the seek, the element acquires\nthe <code>STREAM_LOCK</code> so that the streaming thread and the seek get\nserialized.</p>\n<p>The general flow of executing the seek with FLUSH is as follows:</p>\n<ol>\n<li>\n<p>unblock the streaming threads, they could be blocked in a chain\nfunction. This is done by sending a <code>FLUSH_START</code> on all srcpads or by pausing\nthe streaming task, depending on the seek FLUSH flag.\nThe flush will make sure that all downstream elements unlock and\nthat control will return to this element chain/loop function.\nWe cannot lock the <code>STREAM_LOCK</code> before doing this since it might\ncause a deadlock.</p>\n</li>\n<li>\n<p>acquire the <code>STREAM_LOCK</code>. This will work since the chain/loop function\nwas unlocked/paused in step 1).</p>\n</li>\n<li>\n<p>perform the seek. since the <code>STREAM_LOCK</code> is held, the streaming thread\nwill wait for the seek to complete. Most likely, the stream thread\nwill pause because the peer elements are flushing.</p>\n</li>\n<li>\n<p>send a <code>FLUSH_STOP</code> event to all peer elements to allow streaming again.</p>\n</li>\n<li>\n<p>create a SEGMENT event to signal the new buffer timestamp base time.\nThis event must be queued to be sent by the streaming thread.</p>\n</li>\n<li>\n<p>start stopped tasks and unlock the <code>STREAM_LOCK</code>, dataflow will continue\nnow from the new position.</p>\n</li>\n</ol>\n<p>More information about the different seek types can be found in\n<a href=\"seeking.html\">seeking</a>.</p>\n<h2 id=\"navigation\">NAVIGATION</h2>\n<p>A navigation event is generated by a sink element to signal the elements\nof a navigation event such as a mouse movement or button click.\nNavigation events travel upstream.</p>\n<h2 id=\"latency\">LATENCY</h2>\n<p>A latency event is used to configure a certain latency in the pipeline.\nIt contains a single GstClockTime with the required latency. The latency\nvalue is calculated by the pipeline and distributed to all sink elements\nbefore they are set to PLAYING. The sinks will add the configured\nlatency value to the timestamps of the buffer in order to delay their\npresentation. (See also <a href=\"latency.html\">latency</a>).</p>\n<h2 id=\"drain\">DRAIN</h2>\n<blockquote>\n<p><strong>Note</strong></p>\n<p>This event is not yet implemented.</p>\n</blockquote>\n<p>Drain event indicates that upstream is about to perform a real-time\nevent, such as pausing to present an interactive menu or such, and needs\nto wait for all data it has sent to be played-out in the sink.</p>\n<p>Drain should only be used by live elements, as it may otherwise occur\nduring prerolling.</p>\n<p>Usually after draining the pipeline, an element either needs to modify\ntimestamps, or FLUSH to prevent subsequent data being discarded at the\nsinks for arriving late (only applies during playback scenarios).</p>\n\n</div>\n\n\n        "});