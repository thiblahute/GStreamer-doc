fragment_downloaded_cb({"url": "design/states.html#page-description", "fragment": "Both elements and pads can be in different states. The states of the pads are linked to the state of the element so the design of the states is mainly focused around the element states. \nAn element can be in states. NULL READY PAUSED and PLAYING. When an element is initially instantiated it is in the NULL state. \nNULL This is the initial state of an element. \nREADY The element should be prepared to go to PAUSED. \nPAUSED The element should be ready to accept and process data. Sink elements however only accept one buffer and then block. \nPLAYING The same as PAUSED except for live sources and sinks. Sinks accept and render data. Live sources produce data. \nWe call the sequence NULL PLAYING an upwards state change and PLAYING NULL a downwards state change. \nthe following state changes are possible \nNULL READY \nREADY PAUSED \nPAUSED PLAYING \nPLAYING PAUSED \nPAUSED READY \nREADY NULL \nAn element has state variables that are protected with the object LOCK \nThe STATE always reflects the current state of the element. The STATE_NEXT reflects the next state the element will go to. The STATE_PENDING always reflects the required state of the element. The STATE_RETURN reflects the last return value of a state change. \nThe STATE_NEXT and STATE_PENDING can be VOID_PENDING if the element is in the right state. \nAn element has a special lock to protect against concurrent invocations of set_state called the STATE_LOCK. \nThe state of an element can be changed with _element_set_state When changing the state of an element all intermediate states will also be set on the element until the final desired state is set. \nThe set_state function can return possible values \nGST_STATE_FAILURE The state change failed for some reason. The plugin should have posted an error message on the bus with information. \nGST_STATE_SUCCESS The state change is completed successfully. \nGST_STATE_ASYNC The state change will complete later on. This can happen when the element needs a long time to perform the state change or for sinks that need to receive the first buffer before they can complete the state change preroll \nGST_STATE_NO_PREROLL The state change is completed successfully but the element will not be able to produce data in the PAUSED state. \nIn the case of an ASYNC state change it is possible to proceed to the next state before the current state change completes however the element will only get to this next state before completing the previous ASYNC state change. After receiving an ASYNC return value you can use element_get_state to poll the status of the element. If the polling returns SUCCESS the element completed the state change to the last requested state with set_state \nWhen setting the state of an element the STATE_PENDING is set to the required state. Then the state change function of the element is called and the result of that function is used to update the STATE and STATE_RETURN fields STATE_NEXT STATE_PENDING and STATE_RETURN fields. If the function returned ASYNC this result is immediately returned to the caller. \nThe get_state function takes arguments two pointers that will hold the current and pending state and one GstClockTime that holds a timeout value. The function returns a GstElementStateReturn. \nIf the element returned SUCCESS to the previous _set_state function this function will return the last state set on the element and VOID_PENDING in the pending state value. The function returns GST_STATE_SUCCESS. \nIf the element returned NO_PREROLL to the previous _set_state function this function will return the last state set on the element and VOID_PENDING in the pending state value. The function returns GST_STATE_NO_PREROLL. \nIf the element returned FAILURE to the previous _set_state call this function will return FAILURE with the state set to the current state of the element and the pending state set to the value used in the last call of _set_state \nIf the element returned ASYNC to the previous _set_state call this function will wait for the element to complete its state change up to the amount of time specified in the GstClockTime. \nIf the element does not complete the state change in the specified amount of time this function will return ASYNC with the state set to the current state and the pending state set to the pending state. \nIf the element completes the state change within the specified timeout this function returns the updated state and VOID_PENDING as the pending state. \nIf the element aborts the ASYNC state change due to an error within the specified timeout this function returns FAILURE with the state set to last successful state and pending set to the last attempt. The element should also post an error message on the bus with more information about the problem. \nA GstBin manages the state of its children. It does this by propagating the state changes performed on it to all of its children. The _set_state function on a bin will call the _set_state function on all of its children that are not already in the target state or in a change state to the target state. \nThe children are iterated from the sink elements to the source elements. This makes sure that when changing the state of an element the downstream elements are in the correct state to process the eventual buffers. In the case of a downwards state change the sink elements will shut down first which makes the upstream elements shut down as well since the _push function returns a GST_FLOW_FLUSHING error. \nIf all the children return SUCCESS the function returns SUCCESS as well. \nIf one of the children returns FAILURE the function returns FAILURE as well. In this state it is possible that some elements successfully changed state. The application can check which elements have a changed state which were in error and which were not affected by iterating the elements and calling _get_state on the elements. \nIf after calling the state function on all children one of the children returned ASYNC the function returns ASYNC as well. \nIf after calling the state function on all children one of the children returned NO_PREROLL the function returns NO_PREROLL as well. \nIf both NO_PREROLL and ASYNC children are present NO_PREROLL is returned. \nThe current state of the bin can be retrieved with _get_state \nIf the bin is performing an ASYNC state change it will automatically update its current state fields when it receives state messages from the children. \nUpward state changes always return ASYNC either if the STATE_PENDING is reached or not. \nElement \nA B SUCCESS \nA B ASYNC \nA B while ASYNC \nBin \nA B all elements SUCCESS \nA B some elements ASYNC \nDownward state changes only return ASYNC if the final state is ASYNC. This is to make sure that it s not needed to wait for an element to complete the preroll or other ASYNC state changes when one only wants to shut down an element. \nElement \nA B SUCCESS \nA B ASYNC not final state \nA B ASYNC final state \nBin \nA B SUCCESS \nA B ASYNC not final state \nA B ASYNC final state \nElement committing SUCCESS \nSTATE_LOCK is taken in set_state \nchange state is called if SUCCESS commit state is called \ncommit state calls change_state to next state change. \nif final state is reached stack unwinds and result is returned to set_state and caller. \nElement committing ASYNC \nSTATE_LOCK is taken in set_state \nchange state is called and returns ASYNC \nASYNC returned to the caller. \nelement takes LOCK in streaming thread. \nelement calls commit_state in streaming thread. \ncommit state calls change_state to next state change. \nset_state cannot be called from multiple threads at the same time. The STATE_LOCK prevents this. \nState variables are protected with the LOCK. \nCalling set_state while get_state is called should unlock the get_state with an error. The cookie will do that. \n"});