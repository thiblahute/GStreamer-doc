fragment_downloaded_cb({"url": "design/tracing.html#page-description", "fragment": "This subsystem will provide a mechanism to get structured tracing info from GStreamer applications. This can be used for post run analysis as well as for live introspection. \nI d like to get statistics from a running application. \nI d like to to understand which parts of my pipeline use how many resources. \nI d like to know which parts of the pipeline use how much memory. \nI d like to know about ref counts of parts in the pipeline to find ref count issues. \nThe system brings the following new items core hooks probes in the core api that will expose internal state when tracing is in use tracers plugin features that can process data from the hooks and emit a log tracing front ends applications that consume logs from tracers \nLike the logging the tracer hooks can be compiled out and if not use a local condition to check if active. \nCertain GStreamer core function such as gst_pad_push or gst_element_add_pad will call into the tracer subsystem to dispatch into active tracing modules. Developers will be able to select a list of plugins by setting an environment variable such as GST_TRACERS meminfo dbus One can also pass parameters to plugins GST_TRACERS log events buffers stats all When then plugins are loaded we ll add them to certain hooks according to which they are interested in. \nRight now tracing info is logged as GstStructures to the TRACE level. Idea Another env var GST_TRACE_CHANNEL could be used to send the tracing to a file or a socket. See https bugzilla.gnome.org show_bug.cgi id for discussion on these environment variables. \nWe ll wrap interesting api calls with two macros e.g. gst_pad_push \nTODO ensonic gcc has some magic for wrapping functions http gcc.gnu.org onlinedocs gcc Constructing Calls.html http www.clifford.at cfun gccfeat gccfeat05.c \nTODO ensonic we should eval if we can use something like jump_label in the kernel http lwn.net Articles http lwn.net Articles http lxr.free electrons.com source kernel jump_label.c http lxr.free electrons.com source include linux jump_label.h http lxr.free electrons.com source arch x86 kernel jump_label.c TODO ensonic liblttng ust provides such a mechanism for user space but this is mostly about logging traces it is linux specific \nIn addition to api hooks we should also provide timer hooks. Interval timers are useful to get e.g. resource usage snapshots. Also absolute timers might make sense. All this could be implemented with a clock thread. We can use another env var GST_TRACE_TIMERS ms ms to configure timers and then pass them to the tracers like GST_TRACERS rusage timer ms meminfo timer ms Maybe we can create them ad hoc and avoid the GST_TRACE_TIMERS var. \nHooks already implemented \nTracers are plugin features. They have a simple api \nclass init Here the tracers describe the data the will emit. \ninstance init Tracers attach handlers to one or more hooks using gst_tracing_register_hook In case the are configurable they can read the options from the params property. This is the extra detail from the environment var. \nhook functions Hooks marshal the parameters given to a trace hook into varargs and also add some extra into such as a timestamp. Hooks will be called from misc threads. The trace plugins should only consume read the provided data. Expensive computation should be avoided to not affect the execution too much. Most trace plugins will log data to a trace channel. \ninstance destruction Tracers can output results and release data. This would ideally be done at the end of the applications but gst_deinit is not mandatory. gst_tracelib was using a gcc_destructor. Ideally tracer modules log data as they have them and leave aggregation to a tool that processes the log. \nMost tracers will log some kind of events a data transfer an event a message a query or a measurement. Every tracer should describe the data format. This way tools that process tracer logs can show the data in a meaningful way without having to know about the tracer plugin. \nOne way would be to introspect the data from the plugin. This has the disadvantage that the postprocessing app needs to load the plugins or talk to the gstreamer registry. An alternative is to also log the format description into the log. Right now we re logging several nested GstStructure from the tracer_class_init function except in the log tracer \nA few ideas that are not yet in the above spec \nRight now we log the classes as structures this is important so that the log is self contained. It would be nice to add them to the registry so that gst inspect can show them. We could also consider to add each value as a READONLY gobject property. The property has name description. We could use qdata for scope and flags or have some new property flags We would also need a new notify signal so that value change notifications would include a time stamp. This way the tracers would not needs to be aware of the logging. The core tracer would register the notify handlers and emit the log. Or we just add a gst_tracer_class_install_event and that mimics the g_object_class_install_property \nFrontends can \ntrack creation destruction of GstObject and GstMiniObject \nlog those which are still alive when app is exiting and raise an error if any \nThe tracer takes several parameters in a GstStructure like syntax without the structure name \nRun the leaks tracer on all GstProxyPad objects logging the references with a full backtraces \nRun the leaks tracer on all mini objects logging the references with less complete backtraces \nIf the GST_LEAKS_TRACER_SIG env variable is defined the tracer will handle the following UNIX signals \nSIGUSR1 log alive objects \nSIGUSR2 create a checkpoint and print a list of objects created and destroyed since the previous checkpoint. \ngst debug viewer could be given the trace log in addition to the debug log or a combined log Alternatively it would show a dialog that shows all local apps if the dbus plugin is loaded and read the log streams from the sockets files that are configured for the app. \nCounterpart of gst tracelib ui. \nA terminal app that shows summary running stats like the summary gst tracelib shows at the end of a run. Currently only shows an aggregated status. \nMaybe we can even feed the log into existing live graphers with a little driver https github.com dkogan feedgnuplot \nshould tracers log into the debug.log or into a separate log \nseparate log \nuse a binary format \nworse performance we re writing two logs at the same time \nneed to be careful when people to GST_DEBUG_CHANNEL stderr and GST_TRACE_CHANNEL stderr use a shared channel but what about the formats \ndebug log \nthe tracer subsystem would need to log the GST_TRACE at a level that is active \nshould the tracer call gst_debug_category_set_threshold to ensure things work even though the levels don t make a lot of sense here \nmake logging a tracer a hook in gst_debug_log_valist move gst_debug_log_default to the tracer module \nlog all debug log to the tracer log some of the current logging statements can be replaced by generic logging as shown in the log tracer \nadd tools gst debug to extract a human readable debug log from the trace log \nwe could maintain a list of log functions where gst_tracer_log_trace is the default one. This way e.g. gst validate could consume the traces directly. \nwhen hooking into a timer should we just have some predefined intervals \ncan we add a tracer module that registers the timer hook then we could do GST_TRACER timer ms rusage right now the tracer hooks are defined as an enum though. \nwhen connecting to a running app we can t easily get the current state if logging is using a socket as past events are not explicitly stored we could determine the current topology and emit events with GST_CLOCK_TIME_NONE as ts to indicate that the events are synthetic. \nwe need stable ids for scopes threads elements pads \nthe address can be reused \nwe can use gst_util_seqnum_next \nsomething like gst_object_get_path_string won t work as objects are initially without parent \nright now the tracing hooks are enabled disabled from configure with enable disable gst tracer hooks The tracer code and the plugins are still built though. We should add a enable disable gst tracer to disabled the whole system allthough this is a bit confusing with the enable disable trace option we have already. \n"});