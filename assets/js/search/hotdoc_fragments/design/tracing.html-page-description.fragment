fragment_downloaded_cb({"url": "design/tracing.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"tracing.md\">\n        <h1 id=\"tracing\">Tracing</h1>\n<p>This subsystem will provide a mechanism to get structured tracing info\nfrom GStreamer applications. This can be used for post-run analysis as\nwell as for live introspection.</p>\n<h2 id=\"use-cases\">Use cases</h2>\n<ul>\n<li>\n<p>I\u2019d like to get statistics from a running application.</p>\n</li>\n<li>\n<p>I\u2019d like to to understand which parts of my pipeline use how many\nresources.</p>\n</li>\n<li>\n<p>I\u2019d like to know which parts of the pipeline use how much memory.</p>\n</li>\n<li>\n<p>I\u2019d like to know about ref-counts of parts in the pipeline to find\nref-count issues.</p>\n</li>\n</ul>\n<h2 id=\"non-usecases\">Non use-cases</h2>\n<ul>\n<li>Some element in the pipeline does not play along the rules, find out\nwhich one. This could be done with generic tests.</li>\n</ul>\n<h2 id=\"design\">Design</h2>\n<p>The system brings the following new items: core hooks: probes in the\ncore api, that will expose internal state when tracing is in use\ntracers: plugin features that can process data from the hooks and emit a\nlog tracing front-ends: applications that consume logs from tracers</p>\n<p>Like the logging, the tracer hooks can be compiled out and if not use a\nlocal condition to check if active.</p>\n<p>Certain GStreamer core function (such as <code>gst_pad_push()</code> or\n<code>gst_element_add_pad()</code>) will call into the tracer subsystem to dispatch\ninto active tracing modules. Developers will be able to select a list of\nplugins by setting an environment variable, such as\n<code>GST_TRACERS=\"meminfo;dbus\"</code>. One can also pass parameters to plugins:\n<code>GST_TRACERS=\"log(events,buffers);stats(all)\"</code>. When then plugins are\nloaded, we\u2019ll add them to certain hooks according to which they are\ninterested in.</p>\n<p>Right now tracing info is logged as <code>GstStructures</code> to the TRACE level.\nIdea: Another env var <code>GST_TRACE_CHANNEL</code> could be used to send the\ntracing to a file or a socket. See\n<a href=\"https://bugzilla.gnome.org/show_bug.cgi?id=733188\">https://bugzilla.gnome.org/show_bug.cgi?id=733188</a> for discussion on\nthese environment variables.</p>\n<h2 id=\"hook-api\">Hook api</h2>\n<p>We\u2019ll wrap interesting api calls with two macros, e.g. <code>gst_pad_push()</code>:</p>\n<pre><code class=\"language-c\">GstFlowReturn gst_pad_push (GstPad * pad, GstBuffer * buffer) {\n  GstFlowReturn res;\n\n  g_return_val_if_fail (GST_IS_PAD (pad), GST_FLOW_ERROR);\n  g_return_val_if_fail (GST_PAD_IS_SRC (pad), GST_FLOW_ERROR);\n  g_return_val_if_fail (GST_IS_BUFFER (buffer), GST_FLOW_ERROR);\n\n  GST_TRACER_PAD_PUSH_PRE (pad, buffer);\n  res = gst_pad_push_data (pad,\n      GST_PAD_PROBE_TYPE_BUFFER | GST_PAD_PROBE_TYPE_PUSH, buffer);\n  GST_TRACER_PAD_PUSH_POST (pad, res);\n  return res;\n}\n</code></pre>\n<p>TODO(ensonic): gcc has some magic for wrapping functions -\n<a href=\"http://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html\">http://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html</a> -\n<a href=\"http://www.clifford.at/cfun/gccfeat/#gccfeat05.c\">http://www.clifford.at/cfun/gccfeat/#gccfeat05.c</a></p>\n<p>TODO(ensonic): we should eval if we can use something like jump_label\nin the kernel - <a href=\"http://lwn.net/Articles/412072/\">http://lwn.net/Articles/412072/</a> +\n<a href=\"http://lwn.net/Articles/435215/\">http://lwn.net/Articles/435215/</a> -\n<a href=\"http://lxr.free-electrons.com/source/kernel/jump_label.c\">http://lxr.free-electrons.com/source/kernel/jump_label.c</a> -\n<a href=\"http://lxr.free-electrons.com/source/include/linux/jump_label.h\">http://lxr.free-electrons.com/source/include/linux/jump_label.h</a> -\n<a href=\"http://lxr.free-electrons.com/source/arch/x86/kernel/jump_label.c\">http://lxr.free-electrons.com/source/arch/x86/kernel/jump_label.c</a>\nTODO(ensonic): liblttng-ust provides such a mechanism for user-space -\nbut this is mostly about logging traces - it is linux specific :/</p>\n<p>In addition to api hooks we should also provide timer hooks. Interval\ntimers are useful to get e.g. resource usage snapshots. Also absolute\ntimers might make sense. All this could be implemented with a clock\nthread. We can use another env-var <code>GST_TRACE_TIMERS=\"100ms,75ms\"</code> to\nconfigure timers and then pass them to the tracers like,\n<code>GST_TRACERS=\"rusage(timer=100ms);meminfo(timer=75ms)\"</code>. Maybe we can\ncreate them ad-hoc and avoid the <code>GST_TRACE_TIMERS</code> var.</p>\n<p>Hooks (* already implemented)</p>\n<pre><code>* gst_bin_add\n* gst_bin_remove\n* gst_element_add_pad\n* gst_element_post_message\n* gst_element_query\n* gst_element_remove_pad\n* gst_element_factory_make\n* gst_pad_link\n* gst_pad_pull_range\n* gst_pad_push\n* gst_pad_push_list\n* gst_pad_push_event\n* gst_pad_unlink\n</code></pre>\n<h2 id=\"tracer-api\">Tracer api</h2>\n<p>Tracers are plugin features. They have a simple api:</p>\n<p>class init Here the tracers describe the data the will emit.</p>\n<p>instance init Tracers attach handlers to one or more hooks using\n<code>gst_tracing_register_hook()</code>. In case the are configurable, they can\nread the options from the <em>params</em> property. This is the extra detail\nfrom the environment var.</p>\n<p>hook functions Hooks marshal the parameters given to a trace hook into\nvarargs and also add some extra into such as a timestamp. Hooks will be\ncalled from misc threads. The trace plugins should only consume (=read)\nthe provided data. Expensive computation should be avoided to not affect\nthe execution too much. Most trace plugins will log data to a trace\nchannel.</p>\n<p>instance destruction Tracers can output results and release data. This\nwould ideally be done at the end of the applications, but <code>gst_deinit()</code>\nis not mandatory. <code>gst_tracelib</code> was using a <code>gcc_destructor</code>. Ideally\ntracer modules log data as they have them and leave aggregation to a\ntool that processes the log.</p>\n<h2 id=\"tracer-event-classes\">tracer event classes</h2>\n<p>Most tracers will log some kind of <em>events</em> : a data transfer, an event,\na message, a query or a measurement. Every tracer should describe the\ndata format. This way tools that process tracer logs can show the data\nin a meaningful way without having to know about the tracer plugin.</p>\n<p>One way would be to introspect the data from the plugin. This has the\ndisadvantage that the postprocessing app needs to load the plugins or\ntalk to the gstreamer registry. An alternative is to also log the format\ndescription into the log. Right now we\u2019re logging several nested\n<code>GstStructure</code> from the <code>tracer_class_init()</code> function (except in the\nlog tracer).</p>\n<pre><code>gst_tracer_record_new (\"thread-rusage.class\",\n    // value in the log record (order does not matter)\n    // *thread-id* is a *key* to related the record to something as indicated\n    // by *scope* substructure \"thread-id\",\n    GST_TYPE_STRUCTURE, gst_structure_new (\"scope\", \"type\",\n        G_TYPE_GTYPE, G_TYPE_GUINT64, \"related-to\",\n        GST_TYPE_TRACER_VALUE_SCOPE, GST_TRACER_VALUE_SCOPE_THREAD,\n        NULL),\n        // next value in the record // *average-cpuload* is a measurement as indicated by the *value*\n        // substructure \"average-cpuload\",\n    GST_TYPE_STRUCTURE, gst_structure_new (\"value\", // value type\n        \"type\", G_TYPE_GTYPE, G_TYPE_UINT,\n        // human readable description, that can be used as a graph label\n        \"description\", G_TYPE_STRING, \"average cpu usage per thread\",\n        // flags that help to use the right graph type\n        // flags { aggregated, windowed, cumulative, \u2026 }\n        \"flags\", GST_TYPE_TRACER_VALUE_FLAGS, GST_TRACER_VALUE_FLAGS_AGGREGATED,\n        // value range\n        \"min\", G_TYPE_UINT, 0, \"max\", G_TYPE_UINT, 100, NULL),\n    \u2026 NULL);\n</code></pre>\n<p>A few ideas that are not yet in the above spec:</p>\n<ul>\n<li>it would be nice to describe the unit of values\n<ul>\n<li>putting it into the description is not flexible though, e.g. time\nwould be a guint64 but a ui would reformat it to e.g. h:m:s.ms</li>\n<li>other units are e.g.: percent, per-mille, or kbit/s</li>\n</ul>\n</li>\n<li>we\u2019d like to have some metadata on scopes\n<ul>\n<li>e.g. we\u2019d like to log the thread-names, so that a UI can show\nthat instead of thread-ids</li>\n<li>the stats tracer logs <em>new-element</em> and <em>new-pad</em> messages</li>\n<li>they add a unique <em>ix</em> to each instance as the memory ptr can be\nreused for new instances, the data is attached to the objects as qdata</li>\n<li>the latency tracer would like to also reference this metadata</li>\n</ul>\n</li>\n</ul>\n<p>Right now we log the classes as structures, this is important so that the log\nis self contained. It would be nice to add them to the registry, so that\ngst-inspect can show them. We could also consider to add each value as a\nREADONLY gobject property. The property has name/description. We could use\nqdata for scope and flags (or have some new property flags). We would also\nneed a new \"notify\" signal, so that value-change notifications would include a\ntime-stamp. This way the tracers would not needs to be aware of the\nlogging. The core tracer would register the notify handlers and emit the\nlog. Or we just add a <code>gst_tracer_class_install_event()</code> and that\nmimics the <code>g_object_class_install_property()</code>.</p>\n<p>Frontends can:</p>\n<ul>\n<li>do an events over time histogram</li>\n<li>plot curves of values over time or deltas</li>\n<li>show gauges</li>\n<li>collect statistics (min, max, avg, \u2026)</li>\n</ul>\n<h2 id=\"latency\">latency</h2>\n<ul>\n<li>register to buffer and event flow</li>\n<li>send custom event on buffer flow at source elements</li>\n<li>catch events on event transfer at sink elements</li>\n</ul>\n<h2 id=\"meminfo-not-yet-implemented\">meminfo (not yet implemented)</h2>\n<ul>\n<li>register to an interval-timer hook.</li>\n<li>call <code>mallinfo()</code> and log memory usage rusage</li>\n<li>register to an interval-timer hook.</li>\n<li>call <code>getrusage()</code> and log resource usage</li>\n</ul>\n<h2 id=\"dbus-not-yet-implemented\">dbus (not yet implemented)</h2>\n<ul>\n<li>provide a dbus iface to announce applications that are traced</li>\n<li>tracing UIs can use the dbus iface to find the channels where logging and\ntracing is getting logged to</li>\n<li>one would start the tracing UI first and when the application is started with\ntracing activated, the dbus plugin will announce the new application,\nupon which the tracing UI can start reading from the log channels, this avoid\nmissing some data</li>\n</ul>\n<h2 id=\"topology-not-yet-implemented\">topology (not yet implemented)</h2>\n<ul>\n<li>register to pipeline topology hooks</li>\n<li>tracing UIs can show a live pipeline graph</li>\n</ul>\n<h2 id=\"stats\">stats</h2>\n<ul>\n<li>register to buffer, event, message and query flow</li>\n<li>tracing apps can do e.g. statistics</li>\n</ul>\n<h2 id=\"refcounts-not-yet-implemented\">refcounts (not yet implemented)</h2>\n<ul>\n<li>log ref-counts of objects</li>\n<li>just logging them outside of glib/gobject would still make it hard to detect\nissues though</li>\n</ul>\n<h2 id=\"opengl-not-yet-implemented\">opengl (not yet implemented)</h2>\n<ul>\n<li>upload/download times</li>\n<li>there is not hardware agnostic way to get e.g. memory usage info (gl\nextensions)</li>\n</ul>\n<h2 id=\"memory-not-yet-implemented\">memory (not yet implemented)</h2>\n<ul>\n<li>trace live instance (and pointer to the memory)</li>\n<li>use an atexit handler to dump leaked instance\nhttps://bugzilla.gnome.org/show_bug.cgi?id=756760#c6</li>\n</ul>\n<h2 id=\"leaks\">leaks</h2>\n<ul>\n<li>\n<p>track creation/destruction of <code>GstObject</code> and <code>GstMiniObject</code></p>\n</li>\n<li>\n<p>log those which are still alive when app is exiting and raise an\nerror if any</p>\n</li>\n<li>\n<p>The tracer takes several parameters in a <code>GstStructure</code> like syntax (without the structure name):</p>\n<ul>\n<li>check-refs (boolean): Whether to also track object ref and unref operations\nexample: <code>GST_TRACERS=leaks(check-refs=true)</code> COMMAND</li>\n<li>stack-traces-flags: Flags to use when generating stack trace (does not generate stack trace\nif not set), valid values are \u201cfull\u201d to retrieve as much information as possible in the\nbacktrace, or \u201cnone\u201d for a simple backtrace (usually does not contain line number or source files).\nThis may significantly increase memory consumption. (You can also set the <code>GST_LEAKS_TRACER_STACK_TRACE</code>\nenvironment variable for that).</li>\n<li>filters: (string): A comma separated list of object types to trace (make sure to enclose in\nquotation marks)</li>\n</ul>\n</li>\n</ul>\n<p><strong>Run the leaks tracer on all <code>GstProxyPad</code> objects logging the references with a full backtraces</strong></p>\n<pre><code>GST_TRACERS=leaks(stack-traces-flags=full,filters=\u201dGstProxyPad\u201d,check-refs=true) COMMAND\n</code></pre>\n<p><strong>Run the leaks tracer on all (mini)objects logging the references with less complete backtraces</strong></p>\n<pre><code>GST_TRACERS=leaks(stack-traces-flags=fast,check-refs=true) COMMAND\n</code></pre>\n<ul>\n<li>\n<p>If the <code>GST_LEAKS_TRACER_SIG</code> env variable is defined the tracer\nwill handle the following UNIX signals:</p>\n</li>\n<li>\n<p>SIGUSR1: log alive objects</p>\n</li>\n<li>\n<p>SIGUSR2: create a checkpoint and print a list of objects created and\ndestroyed since the previous checkpoint.</p>\n</li>\n</ul>\n<h2 id=\"gstdebugviewer\">gst-debug-viewer</h2>\n<p>gst-debug-viewer could be given the trace log in addition to the debug\nlog (or a combined log). Alternatively it would show a dialog that shows\nall local apps (if the dbus plugin is loaded) and read the log streams\nfrom the sockets/files that are configured for the app.</p>\n<h2 id=\"gsttracer\">gst-tracer</h2>\n<p>Counterpart of gst-tracelib-ui.</p>\n<h2 id=\"gststats\">gst-stats</h2>\n<p>A terminal app that shows summary/running stats like the summary\ngst-tracelib shows at the end of a run. Currently only shows an\naggregated status.</p>\n<h2 id=\"livegraphers\">live-graphers</h2>\n<p>Maybe we can even feed the log into existing live graphers, with a\nlittle driver * <a href=\"https://github.com/dkogan/feedgnuplot\">https://github.com/dkogan/feedgnuplot</a></p>\n<ul>\n<li>\n<p>should tracers log into the debug.log or into a separate log?</p>\n</li>\n<li>\n<p>separate log</p>\n</li>\n<li>\n<p>use a binary format?</p>\n</li>\n<li>\n<p>worse performance (we\u2019re writing two logs at the same time)</p>\n</li>\n<li>\n<p>need to be careful when people to <code>GST_DEBUG_CHANNEL=stderr</code> and\nGST_TRACE_CHANNEL=stderr (use a shared channel, but what about the\nformats?)</p>\n</li>\n<li>\n<p>debug log</p>\n</li>\n<li>\n<p>the tracer subsystem would need to log the <code>GST_TRACE</code> at a level\nthat is active</p>\n</li>\n<li>\n<p>should the tracer call <code>gst_debug_category_set_threshold()</code> to\nensure things work, even though the levels don\u2019t make a lot of sense\nhere</p>\n</li>\n<li>\n<p>make logging a tracer (a hook in <code>gst_debug_log_valist()</code>, move\n<code>gst_debug_log_default()</code> to the tracer module)</p>\n</li>\n<li>\n<p>log all debug log to the tracer log, some of the current logging\nstatements can be replaced by generic logging as shown in the\nlog-tracer</p>\n</li>\n<li>\n<p>add tools/gst-debug to extract a human readable debug log from the\ntrace log</p>\n</li>\n<li>\n<p>we could maintain a list of log functions, where\ngst_tracer_log_trace() is the default one. This way e.g.\ngst-validate could consume the traces directly.</p>\n</li>\n<li>\n<p>when hooking into a timer, should we just have some predefined\nintervals?</p>\n</li>\n<li>\n<p>can we add a tracer module that registers the timer hook? then we\ncould do <code>GST_TRACER=\"timer(10ms);rusage\"</code> right now the tracer hooks\nare defined as an enum though.</p>\n</li>\n<li>\n<p>when connecting to a running app, we can\u2019t easily get the <em>current</em>\nstate if logging is using a socket, as past events are not\nexplicitly stored, we could determine the current topology and emit\nevents with <code>GST_CLOCK_TIME_NONE</code> as ts to indicate that the events\nare synthetic.</p>\n</li>\n<li>\n<p>we need stable ids for scopes (threads, elements, pads)</p>\n</li>\n<li>\n<p>the address can be reused</p>\n</li>\n<li>\n<p>we can use <code>gst_util_seqnum_next()</code></p>\n</li>\n<li>\n<p>something like <code>gst_object_get_path_string()</code> won\u2019t work as\nobjects are initially without parent</p>\n</li>\n<li>\n<p>right now the tracing-hooks are enabled/disabled from configure with\n<code>--{enable,disable}-gst-tracer-hooks</code> The tracer code and the plugins\nare still built though. We should add a\n<code>--{enable,disable}-gst-tracer</code> to disabled the whole system,\nallthough this is a bit confusing with the <code>--{enable,disable}-trace</code>\noption we have already.</p>\n</li>\n</ul>\n<h2 id=\"try-it\">Try it</h2>\n<h3 id=\"traces-for-buffer-flow-events-and-messages-in-trace-level\">Traces for buffer flow, events and messages in TRACE level:</h3>\n<pre><code>GST_DEBUG=\"GST_TRACER:7,GST_BUFFER*:7,GST_EVENT:7,GST_MESSAGE:7\"\nGST_TRACERS=log gst-launch-1.0 fakesrc num-buffers=10 ! fakesink -\n</code></pre>\n<h3 id=\"print-some-pipeline-stats-on-exit\">Print some pipeline stats on exit:</h3>\n<pre><code>GST_DEBUG=\"GST_TRACER:7\" GST_TRACERS=\"stats;rusage\"\nGST_DEBUG_FILE=trace.log gst-launch-1.0 fakesrc num-buffers=10\nsizetype=fixed ! queue ! fakesink &amp;&amp; gst-stats-1.0 trace.log\n</code></pre>\n<h3 id=\"get-ts-averagecpuload-currentcpuload-time-and-plot\">get ts, average-cpuload, current-cpuload, time and plot</h3>\n<pre><code>GST_DEBUG=\"GST_TRACER:7\" GST_TRACERS=\"stats;rusage\"\nGST_DEBUG_FILE=trace.log /usr/bin/gst-play-1.0 $HOME/Videos/movie.mp4 &amp;&amp;\n./scripts/gst-plot-traces.sh --format=png | gnuplot eog trace.log.*.png\n</code></pre>\n<h3 id=\"print-processing-latencies\">print processing latencies</h3>\n<pre><code>GST_DEBUG=\"GST_TRACER:7\" GST_TRACERS=latency gst-launch-1.0 \\\naudiotestsrc num-buffers=10 ! audioconvert ! volume volume=0.7 ! \\\nautoaudiosink\n</code></pre>\n<h3 id=\"raise-a-warning-if-a-leak-is-detected\">Raise a warning if a leak is detected</h3>\n<pre><code>GST_TRACERS=\"leaks\" gst-launch-1.0 videotestsrc num-buffers=10 !\nfakesink\n</code></pre>\n<h3 id=\"check-if-any-gstevent-or-gstmessage-is-leaked-and-raise-a-warning\">check if any GstEvent or GstMessage is leaked and raise a warning</h3>\n<pre><code>GST_DEBUG=\"GST_TRACER:7\" GST_TRACERS=\"leaks(GstEvent,GstMessage)\"\ngst-launch-1.0 videotestsrc num-buffers=10 ! fakesink\n</code></pre>\n<h2 id=\"performance\">Performance</h2>\n<pre><code>run ./tests/benchmarks/tracing.sh &lt;tracer(s)&gt; &lt;media&gt;\n\negrep -c \"(proc|thread)-rusage\" trace.log 658618 grep -c\n\"gst_tracer_log_trace\" trace.log 823351\n</code></pre>\n<ul>\n<li>we can optimize most of it by using quarks in structures or\neventually avoid structures totally</li>\n</ul>\n\n        \n\n    </div>\n\n\n        "});