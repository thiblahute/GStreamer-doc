fragment_downloaded_cb({"url": "design/latency.html#flushing-a-playing-pipeline", "fragment": "Flushing a playing pipeline \nWe can implement resynchronisation after an uncontrolled FLUSH in part of a pipeline in the same way. Indeed when a flush is performed on a PLAYING live element a new base time must be distributed to this element. \nA flush in a pipeline can happen in the following cases \nflushing seek in the pipeline \nperformed by the application on the pipeline \nperformed by the application on an element \nflush preformed by an element \nafter receiving a navigation event DVD \nWhen a playing sink is flushed by a FLUSH_START event an ASYNC_START message is posted by the element. As part of the message the fact that the element got flushed is included. The element also goes to a pending PAUSED state and has to be set to the PLAYING state again later. \nThe ASYNC_START message is kept by the parent bin. When the element prerolls it posts an ASYNC_DONE message. \nWhen all ASYNC_START messages are matched with an ASYNC_DONE message the bin will capture a new base_time from the clock and will bring all the sinks back to PLAYING after setting the new base time on them. It s also possible to perform additional latency calculations and adjustments before doing this. \n"});