fragment_downloaded_cb({"url": "design/gstghostpad.html#activation", "fragment": "Activation \nSometimes ghost pads should proxy activation functions. This thingie attempts to explain how it should work in the different cases. \nAll of the labeled boxes are pads. The dashes show pad links and the double lines are internal connections. The box around a b c and d is a bin. B and C are ghost pads and a and d are proxy pads. The arrow represents the direction of a state change algorithm. Not counting the bin there are three elements involved here the parent of D the parent of A and the parent of b and c. \nNow in the state change from READY to PAUSED assuming the pipeline does not have a live source all of the pads will end up activated at the end. There are possible activation modes \nWhen activating the state change algorithm will first visit the parent of D and activate D in push mode. Then it visits the bin. The bin will first change the state of its child before activating its pads. That means c will be activated in push mode. At this point d and C should also be active in push mode because it could be that activating c in push mode starts a thread which starts pushing to pads which aren t ready yet. Then b is activated in push mode. Then the bin activates C in push mode which should already be in push mode so nothing is done. It then activates B in push mode which activates b in push mode but it s already there then activates a in push mode as well. The order of activating a and b does not matter in this case. Then finally the state change algorithm moves to the parent of A activates A in push mode and dataflow begins. \nNot yet implemented. \nActivation mode is implausible so we can ignore it for now. That leaves us with the rest. \nis the same as until you get to activating b. Activating b will proxy directly to activating a which will activate B and A as well. Then when the state change algorithm gets to B and A it sees that they are already active so it ignores them. \nSimilarly in activating D will cause the activation of all of the rest of the pads in this order C d c b a B A. Then when the state change gets to the other elements they are already active and in fact data flow is already occurring. \nSo from these scenarios we can distill how ghost pad activation functions should work \nGhost source pads e.g. C push called by element state change handler behavior just return TRUE pull called by peer s activatepull behavior change the internal pad which proxies to its peer e.g. C changes d which changes c. \nInternal sink pads e.g. d push called by nobody doesn t seem possible behavior n a pull called by ghost pad behavior proxy to peer first \nInternal src pads e.g. a push called by ghost pad behavior activate peer in push mode pull called by peer s activatepull behavior proxy to ghost pad which proxies to its peer e.g. a calls B which calls A \nGhost sink pads e.g. B push called by element state change handler behavior change the internal pad which proxies to peer e.g. B changes a which changes b pull called by internal pad behavior proxy to peer \nIt doesn t really make sense to have activation functions on proxy pads that aren t part of a ghost pad arrangement. \n"});