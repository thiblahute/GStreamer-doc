fragment_downloaded_cb({"url": "design/clocks.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"clocks.md\">\n<h1 id=\"clocks\">Clocks</h1>\n<p>The <code>GstClock</code> returns a monotonically increasing time with the method\n<code>_get_time()</code>. Its accuracy and base time depends on the specific clock\nimplementation but time is always expressed in nanoseconds. Since the\nbaseline of the clock is undefined, the clock time returned is not\nmeaningful in itself, what matters are the deltas between two clock\ntimes. The time reported by the clock is called the <code>absolute_time</code>.</p>\n<h2 id=\"clock-selection\">Clock Selection</h2>\n<p>To synchronize the different elements, the <code>GstPipeline</code> is responsible\nfor selecting and distributing a global <code>GstClock</code> for all the elements in\nit.</p>\n<p>This selection happens whenever the pipeline goes to PLAYING. Whenever\nan element is added/removed from the pipeline, this selection will be\nredone in the next state change to PLAYING. Adding an element that can\nprovide a clock will post a <code>GST_MESSAGE_CLOCK_PROVIDE</code> message on the\nbus to inform parent bins of the fact that a clock recalculation is\nneeded.</p>\n<p>When a clock is selected, a <code>NEW_CLOCK</code> message is posted on the bus\nsignaling the clock to the application.</p>\n<p>When the element that provided the clock is removed from the pipeline, a\n<code>CLOCK_LOST</code> message is posted. The application must then set the\npipeline to PAUSED and PLAYING again in order to let the pipeline select\na new clock and distribute a new base time.</p>\n<p>The clock selection is performed as part of the state change from PAUSED\nto PLAYING and is described in <a href=\"states.html\">states</a>.</p>\n<h2 id=\"clock-features\">Clock features</h2>\n<p>The clock supports periodic and single shot clock notifications both\nsynchronous and asynchronous.</p>\n<p>One first needs to create a <code>GstClockID</code> for the periodic or single shot\nnotification using <code>_clock_new_single_shot_id()</code> or\n<code>_clock_new_periodic_id()</code>.</p>\n<p>To perform a blocking wait for the specific time of the <code>GstClockID</code> use\nthe <code>gst_clock_id_wait()</code>. To receive a callback when the specific time\nis reached in the clock use <code>gstclock_id_wait_async()</code>. Both these\ncalls can be interrupted with the <code>gst_clock_id_unschedule()</code> call. If\nthe blocking wait is unscheduled a value of <code>GST_CLOCK_UNSCHEDULED</code> is\nreturned.</p>\n<p>The async callbacks can happen from any thread, either provided by the\ncore or from a streaming thread. The application should be prepared for\nthis.</p>\n<p>A <code>GstClockID</code> that has been unscheduled cannot be used again for any wait\noperation.</p>\n<p>It is possible to perform a blocking wait on the same ID from multiple\nthreads. However, registering the same ID for multiple async\nnotifications is not possible, the callback will only be called once.</p>\n<p>None of the wait operations unref the <code>GstClockID</code>, the owner is\nresponsible for unreffing the ids itself. This holds true for both\nperiodic and single shot notifications. The reason being that the owner\nof the ClockID has to keep a handle to the ID to unblock the wait on\nFLUSHING events or state changes and if we unref it automatically, the\nhandle might be invalid.</p>\n<p>These clock operations do not operate on the stream time, so the\ncallbacks will also occur when not in PLAYING state as if the clock just\nkeeps on running. Some clocks however do not progress when the element\nthat provided the clock is not PLAYING.</p>\n<h2 id=\"clock-implementations\">Clock implementations</h2>\n<p>The GStreamer core provides a <code>GstSystemClock</code> based on the system time.\nAsynchronous callbacks are scheduled from an internal thread.</p>\n<p>Clock implementers are encouraged to subclass this systemclock as it\nimplements the async notification.</p>\n<p>Subclasses can however override all of the important methods for sync\nand async notifications to implement their own callback methods or\nblocking wait operations.</p>\n\n</div>\n\n\n\t"});