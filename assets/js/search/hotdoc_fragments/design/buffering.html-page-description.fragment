fragment_downloaded_cb({"url": "design/buffering.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"buffering.md\">\n        <h1 id=\"buffering\">Buffering</h1>\n<p>This document outlines the buffering policy used in the GStreamer core\nthat can be used by plugins and applications.</p>\n<p>The purpose of buffering is to accumulate enough data in a pipeline so\nthat playback can occur smoothly and without interruptions. It is\ntypically done when reading from a (slow) non-live network source but\ncan also be used for live sources.</p>\n<p>We want to be able to implement the following features:</p>\n<ul>\n<li>\n<p>buffering up to a specific amount of data, in memory, before\nstarting playback so that network fluctuations are minimized.</p>\n</li>\n<li>\n<p>download of the network file to a local disk with fast seeking in\nthe downloaded data. This is similar to the quicktime/youtube\nplayers.</p>\n</li>\n<li>\n<p>caching of semi-live streams to a local, on disk, ringbuffer with\nseeking in the cached area. This is similar to tivo-like\ntimeshifting.</p>\n</li>\n<li>\n<p>progress report about the buffering operations</p>\n</li>\n<li>\n<p>the possibility for the application to do more complex buffering</p>\n</li>\n</ul>\n<h2 id=\"some-use-cases\">Some use cases</h2>\n<h3 id=\"stream-buffering\">Stream buffering</h3>\n<pre><code>+---------+     +---------+     +-------+\n| httpsrc |     | buffer  |     | demux |\n|        src - sink      src - sink     ....\n+---------+     +---------+     +-------+\n</code></pre>\n<p>In this case we are reading from a slow network source into a buffer element\n(such as queue2).</p>\n<p>The buffer element has a low and high watermark expressed in bytes. The\nbuffer uses the watermarks as follows:</p>\n<ul>\n<li>\n<p>The buffer element will post <code>BUFFERING</code> messages until the high\nwatermark is hit. This instructs the application to keep the\npipeline PAUSED, which will eventually block the srcpad from\npushing while data is prerolled in the sinks.</p>\n</li>\n<li>\n<p>When the high watermark is hit, a <code>BUFFERING</code> message with 100%\nwill be posted, which instructs the application to continue\nplayback.</p>\n</li>\n<li>\n<p>When the low watermark is hit during playback, the queue will\nstart posting <code>BUFFERING</code> messages again, making the application\nPAUSE the pipeline again until the high watermark is hit again.\nThis is called the rebuffering stage.</p>\n</li>\n<li>\n<p>During playback, the queue level will fluctuate between the high\nand low watermarks as a way to compensate for network\nirregularities.</p>\n</li>\n</ul>\n<p>This buffering method is usable when the demuxer operates in push mode.\nSeeking in the stream requires the seek to happen in the network source.\nIt is mostly desirable when the total duration of the file is not known, such\nas in live streaming or when efficient seeking is not possible/required.</p>\n<h3 id=\"incremental-download\">Incremental download</h3>\n<pre><code>+---------+     +---------+     +-------+\n| httpsrc |     | buffer  |     | demux |\n|        src - sink      src - sink     ....\n+---------+     +----|----+     +-------+\n                     V\n                    file\n</code></pre>\n<p>In this case, we know the server is streaming a fixed length file to the\nclient. The application can choose to download the file to disk. The buffer\nelement will provide a push or pull based srcpad to the demuxer to navigate in\nthe downloaded file.</p>\n<p>This mode is only suitable when the client can determine the length of the\nfile on the server.</p>\n<p>In this case, buffering messages will be emitted as usual when the requested\nrange is not within the downloaded area + buffersize. The buffering message\nwill also contain an indication that incremental download is being performed.\nThis flag can be used to let the application control the buffering in a more\nintelligent way, using the <code>BUFFERING</code> query, for example.</p>\n<p>The application can use the <code>BUFFERING</code> query to get the estimated download time\nand match this time to the current/remaining playback time to control when\nplayback should start to have a non-interrupted playback experience.</p>\n<h3 id=\"timeshifting\">Timeshifting</h3>\n<pre><code>+---------+     +---------+     +-------+\n| httpsrc |     | buffer  |     | demux |\n|        src - sink      src - sink     ....\n+---------+     +----|----+     +-------+\n                     V\n              file-ringbuffer\n</code></pre>\n<p>In this mode, a fixed size ringbuffer is kept to download the server content.\nThis allows for seeking in the buffered data. Depending on the size of the\nbuffer one can seek further back in time.</p>\n<p>This mode is suitable for all live streams.</p>\n<p>As with the incremental download mode, buffering messages are emitted along\nwith an indication that timeshifting download is in progress.</p>\n<h3 id=\"live-buffering\">Live buffering</h3>\n<p>In live pipelines we usually introduce some latency between the capture and\nthe playback elements. This latency can be introduced by a queue (such as a\njitterbuffer) or by other means (in the audiosink).</p>\n<p>Buffering messages can be emitted in those live pipelines as well and serve as\nan indication to the user of the latency buffering. The application usually\ndoes not react to these buffering messages with a state change.</p>\n<h2 id=\"messages\">Messages</h2>\n<p>A <code>GST_MESSAGE_BUFFERING</code> must be posted on the bus when playback\ntemporarily stops to buffer and when buffering finishes. When the\npercentage field in the <code>BUFFERING</code> message is 100, buffering is done.\nValues less than 100 mean that buffering is in progress.</p>\n<p>The <code>BUFFERING</code> message should be intercepted and acted upon by the\napplication. The message contains at least one field that is sufficient\nfor basic functionality:</p>\n<ul>\n<li><strong><code>buffer-percent</code></strong>, <code>G_TYPE_INT</code>: between 0 and 100</li>\n</ul>\n<p>Several more clever ways of dealing with the buffering messages can be\nused when in incremental or timeshifting download mode. For this purpose\nadditional fields are added to the buffering message:</p>\n<ul>\n<li>\n<p><strong><code>buffering-mode</code></strong>, <code>GST_TYPE_BUFFERING_MODE</code>: <code>enum { \"stream\", \"download\", \"timeshift\", \"live\" }</code>: Buffering mode in use. See above for an explanation of the different\nalternatives. This field can be used to let the application have more control\nover the buffering process.</p>\n</li>\n<li>\n<p><strong><code>avg-in-rate</code></strong>, <code>G_TYPE_INT</code>: Average input buffering speed in bytes/second.\n-1 is unknown. This is the average number of bytes per second that is received\non the buffering element input (sink) pads. It is a measurement of the network\nspeed in most cases.</p>\n</li>\n<li>\n<p><strong><code>avg-out-rate</code></strong>, <code>G_TYPE_INT</code>: Average consumption speed in bytes/second. -1\nis unknown. This is the average number of bytes per second that is consumed by\nthe downstream element of the buffering element.</p>\n</li>\n<li>\n<p><strong><code>buffering-left</code></strong>, <code>G_TYPE_INT64</code>: Estimated time that buffering will take\nin milliseconds. -1 is unknown. This is measured based on the avg-in-rate and\nthe filled level of the queue. The application can use this hint to update the\nGUI about the estimated remaining time that buffering will take.</p>\n</li>\n</ul>\n<h2 id=\"application\">Application</h2>\n<p>While data is buffered the pipeline should remain in the PAUSED state.\nIt is also possible that more data should be buffered while the pipeline\nis PLAYING, in which case the pipeline should be PAUSED until the\nbuffering finishes.</p>\n<p><code>BUFFERING</code> messages can be posted while the pipeline is prerolling. The\napplication should not set the pipeline to PLAYING before a <code>BUFFERING</code>\nmessage with a 100 percent value is received, which might only happen\nafter the pipeline prerolls.</p>\n<p>An exception is made for live pipelines. The application may not change\nthe state of a live pipeline when a buffering message is received.\nUsually these buffering messages contain the \"buffering-mode\" = \"live\".</p>\n<p>The buffering message can also instruct the application to switch to a\nperiodical <code>BUFFERING</code> query instead, so it can more precisely control the\nbuffering process. The application can, for example, choose not to act\non the <code>BUFFERING</code> complete message (buffer-percent = 100) to resume\nplayback but use the estimated download time instead, resuming playback\nwhen it has determined that it should be able to provide uninterrupted\nplayback.</p>\n<h2 id=\"buffering-query\">Buffering Query</h2>\n<p>In addition to the <code>BUFFERING</code> messages posted by the buffering elements,\nwe want to be able to query the same information from the application.\nWe also want to be able to present the user with information about the\ndownloaded range in the file so that the GUI can react on it.</p>\n<p>In addition to all the fields present in the buffering message, the\n<code>BUFFERING</code> query contains the following field, which indicates the\navailable downloaded range in a specific format and the estimated time\nto complete:</p>\n<ul>\n<li>\n<p><strong><code>busy</code></strong>, <code>G_TYPE_BOOLEAN</code>: if buffering was busy. This flag allows the\napplication to pause the pipeline by using the query only.</p>\n</li>\n<li>\n<p><strong><code>format</code></strong>, <code>GST_TYPE_FORMAT</code>: the format of the \"start\" and \"stop\" values\nbelow</p>\n</li>\n<li>\n<p><strong><code>start</code></strong>, <code>G_TYPE_INT64</code>, -1 unknown: the start position of the available\ndata. If there are multiple ranges, this field contains the start position of\nthe currently downloading range.</p>\n</li>\n<li>\n<p><strong><code>stop</code></strong>, <code>G_TYPE_INT64</code>, -1 unknown: the stop position of the available\ndata. If there are multiple ranges, this field contains the stop position of\nthe currently downloading range.</p>\n</li>\n<li>\n<p><strong><code>estimated-total</code></strong>, <code>G_TYPE_INT64</code>: gives the estimated download time in\nmilliseconds. -1 unknown. When the size of the downloaded file is known, this\nvalue will contain the latest estimate of the remaining download time of the\ncurrently downloading range. This value is usually only filled for the\n\"download\" buffering mode. The application can use this information to estimate\nthe amount of remaining time to download till the end of the file.</p>\n</li>\n<li>\n<p><strong><code>buffering-ranges</code></strong>, <code>G_TYPE_ARRAY</code> of <code>GstQueryBufferingRange</code>: contains\noptionally the downloaded areas in the format given above. One of the ranges\ncontains the same start/stop position as above:</p>\n</li>\n</ul>\n<pre><code>    typedef struct\n    {\n      gint64 start;\n      gint64 stop;\n    } GstQueryBufferingRange;\n</code></pre>\n<p>For the <code>download</code> and <code>timeshift</code> buffering-modes, the start and stop\npositions specify the ranges where efficient seeking in the downloaded\nmedia is possible. Seeking outside of these ranges might be slow or not\nat all possible.</p>\n<p>For the <code>stream</code> and <code>live</code> mode the start and stop values describe the\noldest and newest item (expressed in <code>format</code>) in the buffer.</p>\n<h2 id=\"defaults\">Defaults</h2>\n<p>Some defaults for common elements:</p>\n<p>A <code>GstBaseSrc</code> with random access replies to the <code>BUFFERING</code> query with:</p>\n<pre><code>\"buffer-percent\" = 100\n\"buffering-mode\" = \"stream\"\n\"avg-in-rate\" = -1\n\"avg-out-rate\" = -1\n\"buffering-left\" = 0\n\"format\" = GST_FORMAT_BYTES\n\"start\" = 0\n\"stop\" = the total filesize\n\"estimated-total\" = 0\n\"buffering-ranges\" = NULL\n</code></pre>\n<p>A <code>GstBaseSrc</code> in push mode replies to the <code>BUFFERING</code> query with:</p>\n<pre><code>\"buffer-percent\" = 100\n\"buffering-mode\" = \"stream\"\n\"avg-in-rate\" = -1\n\"avg-out-rate\" = -1\n\"buffering-left\" = 0\n\"format\" = a valid GST_TYPE_FORMAT\n\"start\" = current position\n\"stop\" = current position\n\"estimated-total\" = -1\n\"buffering-ranges\" = NULL\n</code></pre>\n<h2 id=\"buffering-strategies\">Buffering strategies</h2>\n<p>Buffering strategies are specific implementations based on the buffering\nmessage and query described above.</p>\n<p>Most strategies have to balance buffering time versus maximal playback\nexperience.</p>\n<h3 id=\"simple-buffering\">Simple buffering</h3>\n<p>NON-live pipelines are kept in the paused state while buffering messages with\na percent &lt; 100% are received.</p>\n<p>This buffering strategy relies on the buffer size and low/high watermarks of\nthe element. It can work with a fixed size buffer in memory or on disk.</p>\n<p>The size of the buffer is usually expressed in a fixed amount of time units\nand the estimated bitrate of the upstream source is used to convert this time\nto bytes.</p>\n<p>All GStreamer applications must implement this strategy. Failure to do so\nwill result in starvation at the sink.</p>\n<h3 id=\"norebuffer-strategy\">No-rebuffer strategy</h3>\n<p>This strategy tries to buffer as much data as possible so that playback can\ncontinue without any further rebuffering.</p>\n<p>This strategy is initially similar to simple buffering, the difference is in\ndeciding on the condition to continue playback. When a 100% buffering message\nhas been received, the application will not yet start the playback but it will\nstart a periodic buffering query, which will return the estimated amount of\nbuffering time left. When the estimated time left is less than the remaining\nplayback time, playback can continue.</p>\n<p>This strategy requires a unlimited buffer size in memory or on disk, such as\nprovided by elements that implement the incremental download buffering mode.</p>\n<p>Usually, the application can choose to start playback even before the\nremaining buffer time elapsed in order to more quickly start the playback at\nthe expense of a possible rebuffering phase.</p>\n<h3 id=\"incremental-rebuffering\">Incremental rebuffering</h3>\n<p>The application implements the simple buffering strategy but with each\nrebuffering phase, it increases the size of the buffer.</p>\n<p>This strategy has quick, fixed time startup times but incrementally longer\nrebuffering times if the network is slower than the media bitrate.</p>\n\n        \n\n    </div>\n\n\n        "});