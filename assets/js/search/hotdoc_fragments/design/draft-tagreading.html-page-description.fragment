fragment_downloaded_cb({"url": "design/draft-tagreading.html#page-description", "fragment": "The tagreading metadata reading use case for mediacenter applications is not too well supported by the current GStreamer architecture. It uses demuxers on the files which generally said takes too long building seek index prerolling What we want is specialized elements parsing modes that just do the tag reading. \nThe idea is to define a TagReadIFace. Tag demuxers classic demuxers and decoder plugins can just implement the interface or provide a separate element that implements the interface. \nIn addition we need a tagreadbin that similar to decodebin does a typefind and then plugs the right tagread element s If will only look at elements that implement the interface. It can plug serval if possible. \nFor optimal performance typefind and tagread could share the list of already peeked buffers a queue element after sink but that would change pull to push \nThe plan is that applications can do the following pipeline filesrc tagbin for file_path in list_of_files filesrc.location file_path pipeline.set_state PAUSED wait for TAGS EOS pipeline.set_state READY \nit should have one sinkpad of type ANY \nit should send EOS when all metadata has been read done signal from all tagread elements \nspecial tagread elements should have RANK_NONE to be not autoplugged by decodebin \ngboolean iface property tag reading Switches the element to tagreading mode. Needed if normal element implement that behaviour. Elements will skip parsing unneeded data don t build a seeking index etc. \nsignal done Equivalent of EOS. \nmp3 with id3 and apetags \nplug id3demux apedemux \navi with vorbis audio \nplug avidemux \nnew pad audio vorbis \nplug vorbisdec or special vorbiscomment reader \nwould it make sense to have phase tag reading property on tagbin and or tagread elements \nst phase get tag data that are directly embedded in the data \nnd phase get tag data that has to be generated \ne.g. album art via web video thumbnails \nwhat about caching backends \nit would be good to allow applications to supply tagbin with a tagcache object instance. Whenever tagbin gets a location to tagread it consults the cache first. whenever there is a cache miss it will tag read and then store in the cache \ntagreadbin gst plugins base gst tagread \ntagreaderiface gst plugins base gst libs gst tag \nogg gst plugins base ext ogg \navi gst plugins good gst avi \nmp3 gst plugins good gst id3demux \nwav gst plugins good gst wavparse \nqt gst plugins bad gst qtdemux \n"});