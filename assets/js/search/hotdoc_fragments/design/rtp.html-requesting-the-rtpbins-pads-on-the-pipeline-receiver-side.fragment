fragment_downloaded_cb({"url": "design/rtp.html#requesting-the-rtpbins-pads-on-the-pipeline-receiver-side", "fragment": "Requesting the rtpbin s pads on the pipeline receiver side \nIf rtpauxreceive is set for session i j k then it has to call rtpbin set aux receive times giving those ids and this aux element. It has to be done before requesting the recv_rtp_sink_i recv_rtp_sink_j recv_rtp_sink_k. For a concrete case rtprtxreceive if the user wants it for session i then it has to call rtpbin set aux receive one time giving i and this aux element. Then the user can request recv_rtp_sink_i pad. \nCalling rtpbin set aux receive does not create the session. It add the given session id and aux element to a hashtable key session id value aux element Then when the user ask for rtpbin.recv_rtp_sink_i rtpbin lookup if there is an aux element for this i session id. If yes it requests a sink pad to this aux element and links it with the recv_rtp_src pad of the new gstrtpsession. rtpbin also checks that this aux element is connected only one time to ssrcdemux. Because rtpauxreceive has only one source pad. Each call to request rtpbin.recv_rtp_sink_k will also creates rtpbin.recv_rtp_src_k_ssrc_pt as usual. So that the user have it when then it requests rtpbin. from gst launch or using on_rtpbinreceive_pad_added callback from an application. \n"});