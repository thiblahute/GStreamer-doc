fragment_downloaded_cb({"url": "design/element-sink.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"element-sink.md\">\n<h1 id=\"sink-elements\">Sink elements</h1>\n<p>Sink elements consume data and normally have no source pads.</p>\n<p>Typical sink elements include:</p>\n<ul>\n<li>\n<p>audio/video renderers</p>\n</li>\n<li>\n<p>network sinks</p>\n</li>\n<li>\n<p>filesinks</p>\n</li>\n</ul>\n<p>Sinks are harder to construct than other element types as they are\ntreated specially by the GStreamer core.</p>\n<h2 id=\"state-changes\">state changes</h2>\n<p>A sink always returns ASYNC from the state change to PAUSED, this\nincludes a state change from READY\u2192PAUSED and PLAYING\u2192PAUSED. The reason\nfor this is that this way we can detect when the first buffer or event\narrives in the sink when the state change completes.</p>\n<p>A sink should block on the first EOS event or buffer received in the\nREADY\u2192PAUSED state before commiting the state to PAUSED.</p>\n<p>FLUSHING events have to be handled out of sync with the buffer flow and\ntake no part in the preroll procedure.</p>\n<p>Events other than EOS do not complete the preroll stage.</p>\n<h2 id=\"sink-overview\">sink overview</h2>\n<ul>\n<li>TODO: <code>PREROLL_LOCK</code> can be removed and we can safely use the <code>STREAM_LOCK</code>.</li>\n</ul>\n<pre><code>  # Commit the state. We return TRUE if we can continue\n  # streaming, FALSE in the case we go to a READY or NULL state.\n  # if we go to PLAYING, we don't need to block on preroll.\n  commit\n  {\n    LOCK\n    switch (pending)\n      case PLAYING:\n        need_preroll = FALSE\n\tbreak\n      case PAUSED:\n\tbreak\n      case READY:\n      case NULL:\n        return FALSE\n      case VOID:\n        return TRUE\n\n    # update state\n    state = pending\n    next = VOID\n    pending = VOID\n    UNLOCK\n    return TRUE\n  }\n\n  # Sync an object. We have to wait for the element to reach\n  # the PLAYING state before we can wait on the clock.\n  # Some items do not need synchronisation (most events) so the\n  # get_times method returns FALSE (not syncable)\n  # need_preroll indicates that we are not in the PLAYING state\n  # and therefore need to commit and potentially block on preroll\n  # if our clock_wait got interrupted we commit and block again.\n  # The reason for this is that the current item being rendered is\n  # not yet finished and we can use that item to finish preroll.\n  do_sync (obj)\n  {\n    # get timing information for this object\n    syncable = get_times (obj, &amp;start, &amp;stop)\n    if (!syncable)\n      return OK;\n again:\n    while (need_preroll)\n      if (need_commit)\n        need_commit = FALSE\n        if (!commit)\n          return FLUSHING\n\n      if (need_preroll)\n        # release PREROLL_LOCK and wait. prerolled can be observed\n        # and will be TRUE\n        prerolled = TRUE\n        PREROLL_WAIT (releasing PREROLL_LOCK)\n        prerolled = FALSE\n        if (flushing)\n          return FLUSHING\n\n    if (valid (start || stop))\n      PREROLL_UNLOCK\n      end_time = stop\n      ret = wait_clock (obj,start)\n      PREROLL_LOCK\n      if (flushing)\n        return FLUSHING\n      # if the clock was unscheduled, we redo the\n      # preroll\n      if (ret == UNSCHEDULED)\n        goto again\n  }\n\n  # render a prerollable item (EOS or buffer). It is\n  # always called with the PREROLL_LOCK helt.\n  render_object (obj)\n  {\n    ret = do_sync (obj)\n    if (ret != OK)\n      return ret;\n\n    # preroll and syncing done, now we can render\n    render(obj)\n  }\n                                   | # sinks that sync on buffer contents do like this\n                                   | while (more_to_render)\n                                   |   ret = render\n                                   |   if (ret == interrupted)\n                                   |     prerolled = TRUE\n    render (buffer)          -----&gt;|     PREROLL_WAIT (releasing PREROLL_LOCK)\n                                   |     prerolled = FALSE\n                                   |     if (flushing)\n                                   |       return FLUSHING\n                                   |\n\n  # queue a prerollable item (EOS or buffer). It is\n  # always called with the PREROLL_LOCK helt.\n  # This function will commit the state when receiving the\n  # first prerollable item.\n  # items are then added to the rendering queue or rendered\n  # right away if no preroll is needed.\n  queue (obj, prerollable)\n  {\n    if (need_preroll)\n      if (prerollable)\n        queuelen++\n\n      # first item in the queue while we need preroll\n      # will complete state change and call preroll\n      if (queuelen == 1)\n        preroll (obj)\n        if (need_commit)\n          need_commit = FALSE\n          if (!commit)\n            return FLUSHING\n\n      # then see if we need more preroll items before we\n      # can block\n      if (need_preroll)\n        if (queuelen &lt;= maxqueue)\n          queue.add (obj)\n          return OK\n\n    # now clear the queue and render each item before\n    # rendering the current item.\n    while (queue.hasItem)\n      render_object (queue.remove())\n\n    render_object (obj)\n    queuelen = 0\n  }\n\n  # various event functions\n  event\n    EOS:\n      # events must complete preroll too\n      STREAM_LOCK\n      PREROLL_LOCK\n      if (flushing)\n        return FALSE\n      ret = queue (event, TRUE)\n      if (ret == FLUSHING)\n        return FALSE\n      PREROLL_UNLOCK\n      STREAM_UNLOCK\n      break\n    SEGMENT:\n      # the segment must be used to clip incoming\n      # buffers. Then then go into the queue as non-prerollable\n      # items used for syncing the buffers\n      STREAM_LOCK\n      PREROLL_LOCK\n      if (flushing)\n        return FALSE\n      set_clip\n      ret = queue (event, FALSE)\n      if (ret == FLUSHING)\n        return FALSE\n      PREROLL_UNLOCK\n      STREAM_UNLOCK\n      break\n    FLUSH_START:\n      # set flushing and unblock all that is waiting\n      event                   ----&gt; subclasses can interrupt render\n      PREROLL_LOCK\n      flushing = TRUE\n      unlock_clock\n      PREROLL_SIGNAL\n      PREROLL_UNLOCK\n      STREAM_LOCK\n      lost_state\n      STREAM_UNLOCK\n      break\n    FLUSH_END:\n      # unset flushing and clear all data and eos\n      STREAM_LOCK\n      event\n      PREROLL_LOCK\n      queue.clear\n      queuelen = 0\n      flushing = FALSE\n      eos = FALSE\n      PREROLL_UNLOCK\n      STREAM_UNLOCK\n      break\n\n  # the chain function checks the buffer falls within the\n  # configured segment and queues the buffer for preroll and\n  # rendering\n  chain\n    STREAM_LOCK\n    PREROLL_LOCK\n    if (flushing)\n      return FLUSHING\n    if (clip)\n      queue (buffer, TRUE)\n    PREROLL_UNLOCK\n    STREAM_UNLOCK\n\n  state\n    switch (transition)\n      READY_PAUSED:\n        # no datapassing is going on so we always return ASYNC\n        ret = ASYNC\n\tneed_commit = TRUE\n        eos = FALSE\n        flushing = FALSE\n\tneed_preroll = TRUE\n\tprerolled = FALSE\n        break\n      PAUSED_PLAYING:\n        # we grab the preroll lock. This we can only do if the\n\t# chain function is either doing some clock sync, we are\n\t# waiting for preroll or the chain function is not being called.\n        PREROLL_LOCK\n\tif (prerolled || eos)\n          ret = OK\n\t  need_commit = FALSE\n\t  need_preroll = FALSE\n\t  if (eos)\n\t    post_eos\n\t  else\n            PREROLL_SIGNAL\n\telse\n\t  need_preroll = TRUE\n\t  need_commit = TRUE\n          ret = ASYNC\n        PREROLL_UNLOCK\n        break\n      PLAYING_PAUSED:\n                           ---&gt; subclass can interrupt render\n        # we grab the preroll lock. This we can only do if the\n\t# chain function is either doing some clock sync\n\t# or the chain function is not being called.\n        PREROLL_LOCK\n\tneed_preroll = TRUE\n        unlock_clock\n\tif (prerolled || eos)\n          ret = OK\n\telse\n          ret = ASYNC\n        PREROLL_UNLOCK\n        break\n      PAUSED_READY:\n                           ---&gt; subclass can interrupt render\n        # we grab the preroll lock. Set to flushing and unlock\n\t# everything. This should exit the chain functions and stop\n\t# streaming.\n        PREROLL_LOCK\n        flushing = TRUE\n        unlock_clock\n        queue.clear\n        queuelen = 0\n        PREROLL_SIGNAL\n        ret = OK\n        PREROLL_UNLOCK\n        break\n```\n</code></pre>\n\n</div>\n\n\n\t"});