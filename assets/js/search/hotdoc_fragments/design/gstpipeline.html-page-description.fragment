fragment_downloaded_cb({"url": "design/gstpipeline.html#page-description", "fragment": "A GstPipeline is usually a toplevel bin and provides all of its children with a clock. \nA GstPipeline also provides a toplevel GstBus see gstbus \nThe pipeline also calculates the running_time based on the selected clock see also clocks.txt and synchronisation \nThe pipeline will calculate a global latency for the elements in the pipeline. See also latency \nIn addition to the normal state change procedure of its parent class GstBin the pipeline performs the following actions during a state change \nThe running_time represents the total elapsed time measured in clock units that the pipeline spent in the PLAYING state see synchronisation The running_time is set to after a flushing seek. \nSince all of the children of a GstPipeline must use the same clock the pipeline must select one. This clock selection happens when the pipeline goes to the PLAYING state. \nThe default clock selection algorithm works as follows \nIf the application selected a clock use that clock. see below \nUse the clock of the most upstream element that can provide one. This selection is performed by iterating the element starting from the sinks going upstream. \nUse GstSystemClock this only happens when no element provides a usable clock. \nThe application can influence this clock selection with two methods gst_pipeline_use_clock and gst_pipeline_auto_clock \nThe _use_clock method forces the use of a specific clock on the pipeline regardless of what clock providers are available. Passing a NULL GstClock clock parameter to this method disables all clocking and makes the pipeline run as fast as possible. \nThe _auto_clock method removes the fixed clock and reactivates the auto matic clock selection algorithm described above. \nA GstPipeline provides a GstBus to the application. The bus can be retrieved with gst_pipeline_get_bus and can then be used to retrieve messages posted by the elements in the pipeline see gstbus \n"});