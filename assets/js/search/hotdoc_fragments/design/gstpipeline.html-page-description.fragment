fragment_downloaded_cb({"url": "design/gstpipeline.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gstpipeline.md\">\n<h1 id=\"gstpipeline\">GstPipeline</h1>\n<p>A <code>GstPipeline</code> is usually a toplevel bin and provides all of its children\nwith a clock.</p>\n<p>A <code>GstPipeline</code> also provides a toplevel <code>GstBus</code> (see <a href=\"gstbus.html\">gstbus</a>)</p>\n<p>The pipeline also calculates the running_time based on the selected\nclock (see also clocks.txt and <a href=\"synchronisation.html\">synchronisation</a>).</p>\n<p>The pipeline will calculate a global latency for the elements in the\npipeline. (See also <a href=\"latency.html\">latency</a>).</p>\n<h2 id=\"state-changes\">State changes</h2>\n<p>In addition to the normal state change procedure of its parent class\n<code>GstBin</code>, the pipeline performs the following actions during a state\nchange:</p>\n<ul>\n<li>NULL \u2192 READY:\n<ul>\n<li>set the bus to non-flushing</li>\n</ul>\n</li>\n<li>READY \u2192 PAUSED:\n<ul>\n<li>reset the running_time to 0</li>\n</ul>\n</li>\n<li>PAUSED \u2192 PLAYING:\n<ul>\n<li>Select and a clock.</li>\n<li>calculate base_time using the running_time.</li>\n<li>calculate and distribute latency.</li>\n<li>set clock and base_time on all elements before performing the state\nchange.</li>\n</ul>\n</li>\n<li>PLAYING \u2192 PAUSED:\n<ul>\n<li>calculate the running_time when the pipeline was PAUSED.</li>\n</ul>\n</li>\n<li>READY \u2192 NULL:\n<ul>\n<li>set the bus to flushing (when auto-flushing is enabled)</li>\n</ul>\n</li>\n</ul>\n<p>The running_time represents the total elapsed time, measured in clock\nunits, that the pipeline spent in the PLAYING state (see\n<a href=\"synchronisation.html\">synchronisation</a>). The running_time is set to 0 after a\nflushing seek.</p>\n<h2 id=\"clock-selection\">Clock selection</h2>\n<p>Since all of the children of a <code>GstPipeline</code> must use the same clock, the\npipeline must select one. This clock selection happens when the\npipeline goes to the PLAYING state.</p>\n<p>The default clock selection algorithm works as follows:</p>\n<ul>\n<li>\n<p>If the application selected a clock, use that clock. (see below)</p>\n</li>\n<li>\n<p>Use the clock of the most upstream element that can provide one.\nThis selection is performed by iterating the element starting from\nthe sinks going upstream.</p>\n<ul>\n<li>since this selection procedure happens in the PAUSED\u2192PLAYING\nstate change, all the sinks are prerolled and we can thus be\nsure that each sink is linked to some upstream element.</li>\n<li>in the case of a live pipeline (<code>NO_PREROLL</code>), the sink will not\nyet be prerolled and the selection process will select the clock\nof a more upstream element.</li>\n</ul>\n</li>\n<li>\n<p>use <code>GstSystemClock</code>, this only happens when no element provides a\nusable clock.</p>\n</li>\n</ul>\n<p>The application can influence this clock selection with two methods:\n<code>gst_pipeline_use_clock()</code> and <code>gst_pipeline_auto_clock()</code>.</p>\n<p>The <code>_use_clock()</code> method forces the use of a specific clock on the\npipeline regardless of what clock providers are children of the\npipeline. Setting NULL disables the clock completely and makes the\npipeline run as fast as possible.</p>\n<p>The <code>_auto_clock()</code> method removes the fixed clock and reactivates the\nauto- matic clock selection algorithm described above.</p>\n<h2 id=\"gstbus\">GstBus</h2>\n<p>A <code>GstPipeline</code> provides a <code>GstBus</code> to the application. The bus can be\nretrieved with <code>gst_pipeline_get_bus()</code> and can then be used to\nretrieve messages posted by the elements in the pipeline (see\n<a href=\"gstbus.html\">gstbus</a>).</p>\n\n</div>\n\n\n        "});