fragment_downloaded_cb({"url": "design/TODO.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"TODO.md\">\n        <h1 id=\"todo-future-development\">TODO - Future Development</h1>\n<h2 id=\"apiabi\">API/ABI</h2>\n<ul>\n<li>\n<p>implement return values from events in addition to the gboolean.\nThis should be done by making the event contain a <code>GstStructure</code> with\ninput/output values, similar to <code>GstQuery</code>. A typical use case is\nperforming a non-accurate seek to a keyframe, after the seek you\nwant to get the new stream time that will actually be used to update\nthe slider bar.</p>\n</li>\n<li>\n<p>make <code>_pad_push_event()</code> return a <code>GstFlowReturn</code></p>\n</li>\n<li>\n<p><code>GstEvent</code>, <code>GstMessage</code> register like <code>GstFormat</code> or <code>GstQuery</code>.</p>\n</li>\n<li>\n<p>query POSITION/DURATION return accuracy. Just a flag or accuracy\npercentage.</p>\n</li>\n<li>\n<p>use | instead of + as divider in serialization of Flags\n(gstvalue/gststructure)</p>\n</li>\n<li>\n<p>rethink how we handle dynamic replugging wrt segments and other\nevents that already got pushed and need to be pushed again. Might\nneed <code>GstFlowReturn</code> from <code>gst_pad_push_event()</code>. FIXED in 0.11 with\nsticky events.</p>\n</li>\n<li>\n<p>Optimize negotiation. We currently do a <code>get_caps()</code> call when we\nlink pads, which could potentially generate a huge list of caps and\nall their combinations, we need to avoid generating these huge lists\nby generating them We also need to incrementally return\nintersections etc, for this. somewhat incrementally when needed. We\ncan do this with a <code>gst_pad_iterate_caps()</code> call. We also need to\nincrementally return intersections etc, for this. FIXED in 0.11 with\na filter on getcaps functions.</p>\n</li>\n<li>\n<p>Elements in a bin have no clue about the final state of the parent\nelement since the bin sets the target state on its children in small\nsteps. This causes problems for elements that like to know the final\nstate (rtspsrc going to <code>PAUSED</code> or <code>READY</code> is different in that we can\navoid sending the useless <code>PAUSED</code> request).</p>\n</li>\n<li>\n<p>Make serialisation of structures more consistent, readable and nicer\ncode-wise.</p>\n</li>\n<li>\n<p>pad block has several issues:</p>\n<ul>\n<li>\n<p>can\u2019t block on selected things, like push, pull, <code>pad_alloc</code>,\nevents, \u2026</p>\n</li>\n<li>\n<p>can\u2019t check why the block happened. We should also be able to\nget the item/ reason that blocked the pad.</p>\n</li>\n<li>\n<p>it only blocks on datapassing. When EOS, the block never happens\nbut ideally should because pad block should inform the app when\nthere is no dataflow.</p>\n</li>\n<li>\n<p>the same goes for segment seeks that don\u2019t push in-band EOS\nevents. Maybe segment seeks should also send an EOS event when\nthey\u2019re done.</p>\n</li>\n<li>\n<p>blocking should only happen from one thread. If one thread does\n<code>pad_alloc</code> and another a push, the push might be busy while the\nblock callback is done.</p>\n</li>\n<li>\n<p>maybe this name is overloaded. We need to look at some more use\ncases before trying to fix this. FIXED in 0.11 with BLOCKING\nprobes.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>rethink the way we do upstream renegotiation. Currently it\u2019s done\nwith <code>pad_alloc</code> but this has many issues such as only being able to\nsuggest 1 format and the need to allocate a buffer of this suggested\nformat (some elements such as capsfilter only know about the format,\nnot the size). We would ideally like to let upstream renegotiate a\nnew format just like it did when it started. This could, for\nexample, easily be triggered with a RENEGOTIATE event. FIXED in 0.11\nwith RECONFIGURE events.</p>\n</li>\n<li>\n<p>Remove the result format value in queries. FIXED in 0.11</p>\n</li>\n<li>\n<p>Try to minimize the amount of acceptcaps calls when pushing buffers\naround. The element pushing the buffer usually negotiated already\nand decided on the format. The element receiving the buffer usually\nhas to accept the caps anyway.</p>\n</li>\n</ul>\n<h2 id=\"implementation\">IMPLEMENTATION</h2>\n<ul>\n<li>\n<p>implement more QOS, <a href=\"qos.html\">qos</a>.</p>\n</li>\n<li>\n<p>implement BUFFERSIZE.</p>\n</li>\n</ul>\n<h2 id=\"design\">DESIGN</h2>\n<ul>\n<li>unlinking pads in the <code>PAUSED</code> state needs to make sure the stream\nthread is not executing code. Can this be done with a flush to\nunlock all downstream chain functions? Do we do this automatically\nor let the app handle this?</li>\n</ul>\n\n        \n\n    </div>\n\n\n        "});