fragment_downloaded_cb({"url": "design/qos.html#collecting-statistics", "fragment": "Collecting statistics \nA buffer with timestamp B1 arrives in the sink at time T1. The buffer timestamp is then synchronized against the clock which yields a jitter J1 return value from the clock. The jitter J1 is simply calculated as \nWhere CT is the clock time when the entry arrives in the sink. This value is calculated inside the clock when we perform gst_clock_id_wait \nIf the jitter is negative the entry arrived in time and can be rendered after waiting for the clock to reach time B1 which is also CT J1 \nIf the jitter is positive however the entry arrived too late in the sink and should therefore be dropped. J1 is the amount of time the entry was late. \nAny buffer that arrives in the sink should generate a QoS event upstream. \nUsing the jitter we can calculate the time when the buffer arrived in the sink \nThe time the buffer leaves the sink after synchronisation is measured as \nFor buffers that arrive in time J1 the buffer leaves after synchronisation which is exactly B1. Late buffers J1 leave the sink when they arrive whithout any synchronisation which is T2 T1 B1 J1. \nUsing a previous T0 and a new T1 we can calculate the time it took for upstream to generate a buffer with timestamp B1. \nWe call PT1 the processing time needed to generate buffer with timestamp B1. \nMoreover given the duration of the buffer D1 the current data rate DR1 of the upstream element is given as \nFor values DR1 the upstream element is producing faster than real time. If DR1 is exactly the element is running at a perfect speed. \nValues DR1 mean that the upstream element cannot produce buffers of duration D1 in real time. It is exactly DR1 that tells the amount of speedup we require from upstream to regain real time performance. \nAn element that is not receiving enough data is said to be underflowed. \n"});