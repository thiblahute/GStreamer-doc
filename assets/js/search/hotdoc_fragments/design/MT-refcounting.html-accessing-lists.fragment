fragment_downloaded_cb({"url": "design/MT-refcounting.html#accessing-lists", "fragment": "Accessing lists \nIf the object property is a list concurrent list iteration is needed to get the contents of the list. GStreamer uses the cookie mechanism to mark the last update of a list. The list and the cookie are protected by the same lock. Each update to a list requires the following actions \nUpdating the cookie is usually done by incrementing its value by one. Since cookies use guint32 its wraparound is for all practical reasons is not a problem. \nIterating a list can safely be done by surrounding the list iteration with a lock unlock of the lock. \nIn some cases it is not a good idea to hold the lock for a long time while iterating the list. The state change code for a bin in GStreamer for example has to iterate over each element and perform a blocking call on each of them potentially causing infinite bin locking. In this case the cookie can be used to iterate a list. \nExample \nThe following algorithm iterates a list and reverses the updates in the case a concurrent update was done to the list while iterating. The idea is that whenever we reacquire the lock we check for updates to the cookie to decide if we are still iterating the right list. \n"});