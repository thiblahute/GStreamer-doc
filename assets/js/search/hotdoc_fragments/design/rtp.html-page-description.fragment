fragment_downloaded_cb({"url": "design/rtp.html#page-description", "fragment": "Requesting the rtpbin s pads on the pipeline receiver side \nRequesting the rtpbin s pads on the pipeline sender side \nBYE only the corresponding source not the whole session. \nBuilding retransmission packet fron original packet \nRetransmission ssrc and seqnum \nDeeper in the stored buffer history \nDeeper in the association algorithm \nBuilding original packet from rtx packet \nIf rtpauxreceive is set for session i j k then it has to call rtpbin set aux receive times giving those ids and this aux element. It has to be done before requesting the recv_rtp_sink_i recv_rtp_sink_j recv_rtp_sink_k. For a concrete case rtprtxreceive if the user wants it for session i then it has to call rtpbin set aux receive one time giving i and this aux element. Then the user can request recv_rtp_sink_i pad. \nCalling rtpbin set aux receive does not create the session. It add the given session id and aux element to a hashtable key session id value aux element Then when the user ask for rtpbin.recv_rtp_sink_i rtpbin lookup if there is an aux element for this i session id. If yes it requests a sink pad to this aux element and links it with the recv_rtp_src pad of the new gstrtpsession. rtpbin also checks that this aux element is connected only one time to ssrcdemux. Because rtpauxreceive has only one source pad. Each call to request rtpbin.recv_rtp_sink_k will also creates rtpbin.recv_rtp_src_k_ssrc_pt as usual. So that the user have it when then it requests rtpbin. from gst launch or using on_rtpbinreceive_pad_added callback from an application. \nFor the sender this is similar but a bit more complicated to implement. When the user asks for rtpbin.send_rtp_sink_i rtpbin will lookup in its second map key session id value aux send element If there is one aux element then it will set the sink pad of this aux sender element to be the ghost pad rtpbin.send_rtp_sink_i that the user asked. rtpbin will also request a src pad of this aux element to connect it to gstrtpsession_i. It will automatically create rtpbin.send_rtp_src_i the usuall way. Then if the user asks rtpbin.send_rtp_src_k then rtpbin will also lookup in that map and request another source pad of the aux element and connect it to the new gstrtpsession_k. \nWhen a collision happens for the given ssrc the associated source is marked bye. But we make sure that the whole session is not itself set bye. Because internally gstrtpsession can manages several sources and all have their own distinct ssrc. \nA rtx packet is mostly the same as an orignal packet except it has its own ssrc and its own seqnum. That s why rtprtxsend works in SSRC multiplexed mode. It also means that the same session is used. Another difference between rtx packet and its original is that it inserts the original seqnum OSN bytes at the beginning of the payload. Also rtprtxsend builds rtx packet without padding to let other elements do that. The last difference is the payload type. For now the user has to set it through the rtx payload type property. Later it will be automatically retreive this information from SDP. See fmtp field as specifies in the RPC4588 a fmtp apt fmtp is the payload type of the retransmission stream and apt the payload type of its associated master stream. \nTo choose rtx_ssrc it randomly selects a number between and until it is different than master_ssrc. rtx_seqnum is randomly selected between and \nFor the history it uses a GSequence with as its maximum size. Which is resonable as the default value is It contains the packets in reverse order they have been sent head newest tail oldest GSequence allows to add and remove an element in constant time like a queue Also GSequence allows to do a binary search when rtprtxsend lookup in its history. It s important if it receives a lot of requests or if the history is large. \nWhen it receives a GstRTPRetransmissionRequest event it will remember the ssrc and the seqnum from this request. \nOn incoming packets if the packet has its ssrc already associated then it knows if the ssrc is an rtx ssrc or a master stream ssrc. If this is a rtx packet then it recontructs the original and pushs the result to src pad as if it was a master packet. \nIf the ssrc is not yet associated rtprtxreceive checks the payload type. if the packet has its payload type marked as rtx then it will extract the OSN original seqnum number and lookup in its stored requests if a seqnum matchs. If found then it associates the current ssrc to the master ssrc marked in the request. If not found it just drops the packet. Then it removes the request from the stored requests. \nIf there are requests with the same seqnum and different ssrc then the couple seqnum ssrc is removed from the stored requests. A stored request actually means that actually the couple seqnum ssrc is stored. If it s happens the request is droped but it avoids to do bad associations. In this case the association is just delayed to the next request. \nHeader extensions payload and padding are mostly the same. Except that the OSN is removed from the payload. Then ssrc seqnum and original payload type are correctly set. Original payload type is actually also stored when the rtx request is handled. \n"});