fragment_downloaded_cb({"url": "design/rtp.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"rtp.md\">\n        <h1 id=\"rtp\">RTP</h1>\n<p>These design docs detail some of the lower-level mechanism of certain parts\nof GStreamer's RTP stack. For a higher-level overview see the <a href=\"../rtp.html\">RTP and RTSP\nsupport</a> section.</p>\n<h1 id=\"rtp-auxiliary-stream-design\">RTP auxiliary stream design</h1>\n<h2 id=\"auxiliary-elements\">Auxiliary elements</h2>\n<p>There are two kind of auxiliary elements, sender and receiver. Let's\ncall them rtpauxsend and rtpauxreceive.</p>\n<p>rtpauxsend has always one sink pad and can have unlimited requested src\npads. If only src pad then it works in SSRC-multiplexed mode, if several\nsrc pads then it works in session multiplexed mode.</p>\n<p>rtpauxreceive has always one ssrc pad and can have unlimited requested\nsink pads. If only one sink pad then it works in SSRC-multiplexed mode,\nif several sink pads then it works in session multiplexed mode.</p>\n<h2 id=\"rtpbin-and-auxiliary-elements\">Rtpbin and auxiliary elements</h2>\n<h3 id=\"basic-mechanism\">Basic mechanism</h3>\n<p>rtpbin knows for which session ids the given auxiliary element belong\nto. It's done through \"set-aux-send\", for rtpauxsend kind, and through\n\"set-aux-receive\" for rtpauxreceive kind. You can call those signals as\nmuch as needed for each auxiliary element. So for aux elements that work\nin SSRC-multiplexed mode this signal action is called only one time.</p>\n<p>The user has to call those action signals before to request the\ndifferents rtpbin pads. rtpbin is in charge to link those auxiliary\nelements with the sessions, and on receiver side, rtpbin has also to\nhandle the link with ssrcdemux.</p>\n<p>rtpbin never knows if the given rtpauxsend is actually a rtprtxsend\nelement or another aux element. rtpbin never knows if the given\nrtpauxreceive is actually a rtprtxreceive element or another aux\nelement. rtpbin has to be kept generic so that more aux elements can be\nadded later without changing rtpbin.</p>\n<p>It's currently not possible to use rtpbin with auxiliary stream from\ngst-launch. We can discuss about having the ability for rtpbin to\ninstanciate itself the special aux elements rtprtxsend and rtprtxreceive\nbut they need to be configured (\"payload-type\" and \"payload-types\"\nproperties) to make retransmission work. So having several rtprtxsend\nand rtprtxreceive in a rtpbin would require a lot of properties to\nmanage them form rtpbin. And for each auxiliary elements.</p>\n<p>If you want to use rtprtxreceive and rtprtpsend from gst-launch you have\nto use rtpsession, ssrcdemux and rtpjitterbuffer elements yourself. See\ngtk-doc of rtprtxreceive for an example.</p>\n<h3 id=\"requesting-the-rtpbins-pads-on-the-pipeline-receiver-side\">Requesting the rtpbin's pads on the pipeline receiver side</h3>\n<p>If rtpauxreceive is set for session, i, j, k then it has to call\nrtpbin::\"set-aux-receive\" 3 times giving those ids and this aux element.\nIt has to be done before requesting the <code>recv_rtp_sink_i</code>,\n<code>recv_rtp_sink_j</code>, <code>recv_rtp_sink_k</code>. For a concrete case\nrtprtxreceive, if the user wants it for session i, then it has to call\nrtpbin::\"set-aux-receive\" one time giving i and this aux element. Then\nthe user can request <code>recv_rtp_sink_i</code> pad.</p>\n<p>Calling rtpbin::\"set-aux-receive\" does not create the session. It add\nthe given session id and aux element to a hashtable(key:session id,\nvalue: aux element). Then when the user ask for\n<code>rtpbin.recv_rtp_sink_i</code>, rtpbin lookup if there is an aux element for\nthis i session id. If yes it requests a sink pad to this aux element and\nlinks it with the <code>recv_rtp_src</code> pad of the new gstrtpsession. rtpbin\nalso checks that this aux element is connected only one time to\nssrcdemux. Because rtpauxreceive has only one source pad. Each call to\nrequest <code>rtpbin.recv_rtp_sink_k</code> will also creates\n<code>rtpbin.recv_rtp_src_k_ssrc_pt</code> as usual. So that the user have it\nwhen then it requests rtpbin. (from gst-launch) or using\n<code>on_rtpbinreceive_pad_added</code> callback from an application.</p>\n<h3 id=\"requesting-the-rtpbins-pads-on-the-pipeline-sender-side\">Requesting the rtpbin's pads on the pipeline sender side</h3>\n<p>For the sender this is similar but a bit more complicated to implement.\nWhen the user asks for <code>rtpbin.send_rtp_sink_i</code>, rtpbin will lookup in\nits second map (key:session id, value: aux send element). If there is\none aux element, then it will set the sink pad of this aux sender\nelement to be the ghost pad <code>rtpbin.send_rtp_sink_i</code> that the user\nasked. rtpbin will also request a src pad of this aux element to connect\nit to <code>gstrtpsession_i</code>. It will automatically create\n<code>rtpbin.send_rtp_src_i</code> the usuall way. Then if the user asks\n<code>rtpbin.send_rtp_src_k</code>, then rtpbin will also lookup in that map and\nrequest another source pad of the aux element and connect it to the new\n<code>gstrtpsession_k</code>.</p>\n<h1 id=\"rtp-collision-design\">RTP collision design</h1>\n<h2 id=\"gstrtpcollision\">GstRTPCollision</h2>\n<p>Custon upstream event which contains the ssrc marked as collided.</p>\n<p>This event is generated on both pipeline sender and receiver side by the\ngstrtpsession element when it detects a conflict between ssrc. (same\nsession id and same ssrc)</p>\n<p>It's an upstream event so that means this event is for now only useful\non pipeline sender side. Because elements generating packets with the\ncollided SSRC are placed upstream from the gstrtpsession.</p>\n<h2 id=\"rtppayloader\">rtppayloader</h2>\n<p>When handling a <code>GstRTPCollision</code> event, the rtppayloader has to choose\nanother ssrc.</p>\n<h2 id=\"bye-only-the-corresponding-source-not-the-whole-session\">BYE only the corresponding source, not the whole session.</h2>\n<p>When a collision happens for the given ssrc, the associated source is\nmarked bye. But we make sure that the whole session is not itself set\nbye. Because internally, gstrtpsession can manages several sources and\nall have their own distinct ssrc.</p>\n<h1 id=\"rtp-retransmission-design\">RTP retransmission design</h1>\n<h2 id=\"gstrtpretransmissionrequest\">GstRTPRetransmissionRequest</h2>\n<p>Custom upstream event which mainly contains the ssrc and the seqnum of\nthe packet which is asked to be retransmisted.</p>\n<p>On the pipeline receiver side this event is generated by the\ngstrtpjitterbuffer element. Then it is translated to a NACK to be sent\nover the network.</p>\n<p>On the pipeline sender side, this event is generated by the\ngstrtpsession element when it receives a NACK from the network.</p>\n<h2 id=\"rtprtxsend-element\">rtprtxsend element</h2>\n<h3 id=\"basic-mechanism1\">Basic mechanism</h3>\n<p>rtprtxsend keeps a history of rtp packets that it has already sent. When\nit receives the event <code>GstRTPRetransmissionRequest</code> from the downstream\ngstrtpsession element, it loopkup the requested seqnum in its stored\npackets. If the packet is present in its history, it will create a RTX\npacket according to RFC 4588. Then this rtx packet is pushed to its src\npad as other packets.</p>\n<p>rtprtxsend works in SSRC-multiplexed mode, so it has one always sink and\nsrc pad.</p>\n<h3 id=\"building-retransmission-packet-fron-original-packet\">Building retransmission packet fron original packet</h3>\n<p>A rtx packet is mostly the same as an orignal packet, except it has its\nown ssrc and its own seqnum. That's why rtprtxsend works in\nSSRC-multiplexed mode. It also means that the same session is used.\nAnother difference between rtx packet and its original is that it\ninserts the original seqnum (OSN: 2 bytes) at the beginning of the\npayload. Also rtprtxsend builds rtx packet without padding, to let other\nelements do that. The last difference is the payload type. For now the\nuser has to set it through the rtx-payload-type property. Later it will\nbe automatically retreive this information from SDP. See fmtp field as\nspecifies in the RPC4588 (a=fmtp:99 apt=98) fmtp is the payload type of\nthe retransmission stream and apt the payload type of its associated\nmaster stream.</p>\n<h3 id=\"retransmission-ssrc-and-seqnum\">Retransmission ssrc and seqnum</h3>\n<p>To choose <code>rtx_ssrc</code> it randomly selects a number between 0 and 2^32-1\nuntil it is different than <code>master_ssrc</code>. <code>rtx_seqnum</code> is randomly\nselected between 0 and 2^16-1</p>\n<h3 id=\"deeper-in-the-stored-buffer-history\">Deeper in the stored buffer history</h3>\n<p>For the history it uses a GSequence with 2^15-1 as its maximum size.\nWhich is resonable as the default value is 100. It contains the packets\nin reverse order they have been sent (head:newest, tail:oldest)\nGSequence allows to add and remove an element in constant time (like a\nqueue). Also GSequence allows to do a binary search when rtprtxsend\nlookup in its history. It's important if it receives a lot of requests\nor if the history is large.</p>\n<h3 id=\"pending-rtx-packets\">Pending rtx packets</h3>\n<p>When looking up in its history, if seqnum is found then it pushes the\nbuffer into a GQueue to its tail. Before to send the current master\nstream packet, rtprtxsend sends all the buffers which are in this\nGQueue. Taking care of converting them to rtx packets. This way, rtx\npackets are sent in the same order they have been requested.\n(<code>g_list_foreach</code> traverse the queue from head to tail) The <code>GQueue</code> is\ncleared between sending 2 master stream packets. So for this <code>GQueue</code> to\ncontain more than one element, it means that rtprtxsend receives more\nthan one rtx request between sending 2 master packets.</p>\n<h3 id=\"collision\">Collision</h3>\n<p>When handling a <code>GstRTPCollision</code> event, if the ssrc is its rtx ssrc then\nrtprtxsend clear its history and its pending retransmission queue. Then\nit chooses a <code>rtx_ssrc</code> until it's different than master ssrc. If the\n<code>GstRTPCollision</code> event does not contain its rtx ssrc, for example its\nmaster ssrc or other, then it just forwards the event to upstream. So\nthat it can be handled by the rtppayloader.</p>\n<h2 id=\"rtprtxreceive-element\">Rtprtxreceive element</h2>\n<h3 id=\"basic-mechanism2\">Basic mechanism</h3>\n<p>The same rtprtxreceive instance can receive several master streams and\nseveral retransmission streams. So it will try to dynamically associate\na rtx ssrc with its master ssrc. So that it can reconstruct the original\nfrom the proper rtx packet.</p>\n<p>The algorithm is based on the fact that seqnums of different streams\n(considering all master and all rtx streams) evolve at a different rate.\nIt means that the initial seqnum is random for each one and the offset\ncould also be different. So that they are statistically all different at\na given time. If bad luck then the association is delayed to the next\nrtx request.</p>\n<p>The algorithm also needs to know if a given packet is a rtx packet or\nnot. To know this information there is the <code>rtx-payload-types</code> property.\nFor now the user as to configure it but later it will be automatically\nretreive this information from SDP. It needs to know if the current\npacket is rtx or not in order to know if it can extract the OSN from the\npayload. Otherwise it would extract the OSN even on master streams which\nmeans nothing and so it could do bad things. In theory maybe it could\nwork but we have this information in SDP so why not using it to avoid\nbad associations.</p>\n<p>Note that it also means that several master streams can have the same\npayload type. And also several rtx streams can have the same payload\ntype. So the information from SDP which gives us which rtx payload type\nbelong to a give master payload type is not enough to do the association\nbetween rtx ssrc and master ssrc.</p>\n<p>rtprtxreceive works in SSRC-multiplexed mode, so it has one always sink\nand src pad.</p>\n<h3 id=\"deeper-in-the-association-algorithm\">Deeper in the association algorithm</h3>\n<p>When it receives a <code>GstRTPRetransmissionRequest</code> event it will remember\nthe ssrc and the seqnum from this request.</p>\n<p>On incoming packets, if the packet has its ssrc already associated then\nit knows if the ssrc is an rtx ssrc or a master stream ssrc. If this is\na rtx packet then it recontructs the original and pushs the result to\nsrc pad as if it was a master packet.</p>\n<p>If the ssrc is not yet associated rtprtxreceive checks the payload type.\nif the packet has its payload type marked as rtx then it will extract\nthe OSN (original seqnum number) and lookup in its stored requests if a\nseqnum matchs. If found, then it associates the current ssrc to the\nmaster ssrc marked in the request. If not found it just drops the\npacket. Then it removes the request from the stored requests.</p>\n<p>If there are 2 requests with the same seqnum and different ssrc, then\nthe couple seqnum,ssrc is removed from the stored requests. A stored\nrequest actually means that actually the couple seqnum,ssrc is stored.\nIf it's happens the request is droped but it avoids to do bad\nassociations. In this case the association is just delayed to the next\nrequest.</p>\n<h3 id=\"building-original-packet-from-rtx-packet\">Building original packet from rtx packet</h3>\n<p>Header, extensions, payload and padding are mostly the same. Except that\nthe OSN is removed from the payload. Then ssrc, seqnum, and original\npayload type are correctly set. Original payload type is actually also\nstored when the rtx request is handled.</p>\n\n        \n\n    </div>\n\n\n        "});