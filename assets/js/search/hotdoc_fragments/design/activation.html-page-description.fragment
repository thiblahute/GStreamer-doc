fragment_downloaded_cb({"url": "design/activation.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"activation.md\">\n<h1 id=\"pad-deactivation\">Pad (de)activation</h1>\n<h2 id=\"activation\">Activation</h2>\n<p>When changing states, a bin will set the state on all of its children in\nsink-to-source order. As elements undergo the READY\u2192PAUSED transition,\ntheir pads are activated so as to prepare for data flow. Some pads will\nstart tasks to drive the data flow.</p>\n<p>An element activates its pads from sourcepads to sinkpads. This to make\nsure that when the sinkpads are activated and ready to accept data, the\nsourcepads are already active to pass the data downstream.</p>\n<p>Pads can be activated in one of two modes, PUSH and PULL. PUSH pads are\nthe normal case, where the source pad in a link sends data to the sink\npad via <code>gst_pad_push()</code>. PULL pads instead have sink pads request data\nfrom the source pads via <code>gst_pad_pull_range()</code>.</p>\n<p>To activate a pad, the core will call <code>gst_pad_set_active()</code> with a\nTRUE argument, indicating that the pad should be active. If the pad is\nalready active, be it in a PUSH or PULL mode, <code>gst_pad_set_active()</code>\nwill return without doing anything. Otherwise it will call the\nactivation function of the pad.</p>\n<p>Because the core does not know in which mode to activate a pad (PUSH or\nPULL), it delegates that choice to a method on the pad, <code>activate()</code>. The\n<code>activate()</code> function of a pad should choose whether to operate in PUSH or\nPULL mode. Once the choice is made, it should call <code>activate_mode()</code> with\nthe selected activation mode. The default <code>activate()</code> function will call\n<code>activate_mode()</code> with <code>#GST_PAD_MODE_PUSH</code>, as it is the default\nmechanism for data flow. A sink pad that supports either mode of\noperation might call <code>activate_mode(PULL)</code> if the SCHEDULING query\nupstream contains the <code>#GST_PAD_MODE_PULL</code> scheduling mode, and\n<code>activate_mode(PUSH)</code> otherwise.</p>\n<p>Consider the case <code>fakesrc ! fakesink</code>, where fakesink is configured to\noperate in PULL mode. State changes in the pipeline will start with\nfakesink, which is the most downstream element. The core will call\n<code>activate()</code> on fakesink\u2019s sink pad. For fakesink to go into PULL mode, it\nneeds to implement a custom <code>activate()</code> function that will call\n<code>activate_mode(PULL)</code> on its sink pad (because the default is to use PUSH\nmode). <code>activate_mode(PULL)</code> is then responsible for starting the task\nthat pulls from fakesrc:src. Clearly, fakesrc needs to be notified that\nfakesrc is about to pull on its src pad, even though the pipeline has\nnot yet changed fakesrc\u2019s state. For this reason, GStreamer will first\ncall call <code>activate_mode(PULL)</code> on fakesink:sink\u2019s peer before calling\n<code>activate_mode(PULL)</code> on fakesink:sinks.</p>\n<p>In short, upstream elements operating in PULL mode must be ready to\nproduce data in READY, after having <code>activate_mode(PULL)</code> called on their\nsource pad. Also, a call to <code>activate_mode(PULL)</code> needs to propagate\nthrough the pipeline to every pad that a <code>gst_pad_pull()</code> will reach. In\nthe case <code>fakesrc ! identity ! fakesink</code>, calling <code>activate_mode(PULL)</code>\non identity\u2019s source pad would need to activate its sink pad in pull\nmode as well, which should propagate all the way to fakesrc.</p>\n<p>If, on the other hand, <code>fakesrc ! fakesink</code> is operating in PUSH mode,\nthe activation sequence is different. First, <code>activate()</code> on fakesink:sink\ncalls <code>activate_mode(PUSH)</code> on fakesink:sink. Then fakesrc\u2019s pads are\nactivated: sources first, then sinks (of which fakesrc has none).\nfakesrc:src\u2019s activation function is then called.</p>\n<p>Note that it does not make sense to set an activation function on a\nsource pad. The peer of a source pad is downstream, meaning it should\nhave been activated first. If it was activated in PULL mode, the source\npad should have already had <code>activate_mode(PULL)</code> called on it, and thus\nneeds no further activation. Otherwise it should be in PUSH mode, which\nis the choice of the default activation function.</p>\n<p>So, in the PUSH case, the default activation function chooses PUSH mode,\nwhich calls <code>activate_mode(PUSH)</code>, which will then start a task on the\nsource pad and begin pushing. In this way PUSH scheduling is a bit\neasier, because it follows the order of state changes in a pipeline.\nfakesink is already in PAUSED with an active sink pad by the time\nfakesrc starts pushing data.</p>\n<h2 id=\"deactivation\">Deactivation</h2>\n<p>Pad deactivation occurs when its parent goes into the READY state or\nwhen the pad is deactivated explicitly by the application or element.\n<code>gst_pad_set_active()</code> is called with a FALSE argument, which then\ncalls <code>activate_mode(PUSH)</code> or <code>activate_mode(PULL)</code> with a FALSE\nargument, depending on the current activation mode of the pad.</p>\n<h2 id=\"mode-switching\">Mode switching</h2>\n<p>Changing from push to pull modes needs a bit of thought. This is\nactually possible and implemented but not yet documented here.</p>\n\n</div>\n\n\n        "});