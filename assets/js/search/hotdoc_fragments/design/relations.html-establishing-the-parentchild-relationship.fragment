fragment_downloaded_cb({"url": "design/relations.html#establishing-the-parentchild-relationship", "fragment": "establishing the parent child relationship \nThe application then calls a method on the parent object to take ownership of the child object. The parent performs the following actions \nthe _set_parent method performs the following actions \nThe function atomically checks if the child has no parent yet and will set the parent if not. It will also sink the child meaning all floating references to the child are invalid now as it takes over the refcount of the object. \nVisually \nafter _set_parent returns TRUE \nafter parent updates ref_pointer to child. \nonly one parent is able to _sink the same object because the _set_parent method is atomic. \nsince only one parent is able to _set_parent the object only one will add a reference to the object. \nsince the parent can hold multiple references to children we don t need to lock the parent when locking the child. Many threads can call _set_parent on the children with the same parent the parent can then add all those to its lists. \nNote that the signal is emitted before the parent has added the element to its internal data structures. This is not a problem since the parent usually has his own signal to inform the app that the child was reffed. One possible solution would be to update the internal structure first and then perform a rollback if the _set_parent failed. This is not a good solution as iterators might grab the half added child too soon. \n"});