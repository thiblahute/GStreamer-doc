fragment_downloaded_cb({"url": "design/orc-integration.html#page-description", "fragment": "Orc code can be in one of two forms in orc files that is converted by orcc to C code that calls liborc functions or C code that calls liborc to create complex operations at runtime. The former is mostly for functions with predetermined functionality. The latter is for functionality that is determined at runtime where writing orc functions for all combinations would be prohibitive. Orc also has a fast memcpy and memset which are useful independently. \nThis part is not integrated yet. \nOrc has built in functions orc_memcpy and orc_memset that work like memcpy and memset These are meant for large copies only. A reasonable cutoff for using orc_memcpy instead of memcpy is if the number of bytes is generally greater than DO NOT use orc_memcpy if the typical is size is less than bytes especially if the size is known at compile time as these cases are inlined by the compiler. \nExample sys ximage ximagesink.c \nAdd ORC_CFLAGS to libgstximagesink_la_CFLAGS and ORC_LIBS to libgstximagesink_la_LIBADD. Then in the source file add \nifdef HAVE_ORC include orc orc.h else define orc_memcpy a b c memcpy a b c endif \nThen switch relevant uses of memcpy to orc_memcpy \nThe above example works whether or not Orc is enabled at compile time. \nThe following lines are added near the top of Makefile.am for plugins that use Orc code in orc files this is for the volume plugin \nAlso add the generated source file to the plugin build \nAnd of course add ORC_CFLAGS to libgstvolume_la_CFLAGS and ORC_LIBS to libgstvolume_la_LIBADD. \nThe value assigned to ORC_BASE does not need to be related to the name of the plugin. \nThe Holy Grail of Orc usage is to programmatically generate Orc code at runtime have liborc compile it into binary code at runtime and then execute this code. Currently the best example of this is in Schroedinger. An example of how this would be used is audioconvert given an input format channel position manipulation dithering and quantizing configuration and output format a Orc code generator would create an OrcProgram add the appropriate instructions to do each step based on the configuration and then compile the program. Successfully compiling the program would return a function pointer that can be called to perform the operation. \nThis sort of advanced usage requires structural changes to current plugins e.g. audioconvert and will probably be developed incrementally. Moreover if such code is intended to be used without Orc as strict build runtime requirement two codepaths would need to be developed and tested. For this reason until GStreamer requires Orc I think it s a good idea to restrict such advanced usage to the cog plugin in bad which requires Orc. \nThe goal of the build process is to make Orc non essential for most developers and users. This is not to say you shouldn t have Orc installed without it you will get slow backup C code just that people compiling GStreamer are not forced to switch from Liboil to Orc immediately. \nWith Orc installed the build process will use the Orc Compiler orcc to convert each orc file into a temporary C source tmp orc.c and a temporary header file name orc.h if constructed from base orc The C source file is compiled and linked to the plugin and the header file is included by other source files in the plugin. \nIf make orc update is run in the source directory the files tmp orc.c and base orc.h are copied to base orc dist.c and base orc dist.h respectively. The dist. ch files are automatically disted via orc.mk. The dist. ch files should be checked in to git whenever the orc source is changed and checked in. Example workflow \nedit orc file make test etc. make orc update git add volume.orc volumeorc dist.c volumeorc dist.h git commit \nAt make dist time all of the orc files are compiled and then copied to their dist. ch counterparts and then the dist. ch files are added to the dist directory. \nWithout Orc installed or disable orc given to configure the dist. ch files are copied to tmp orc.c and name orc.h. When compiled Orc disabled DISABLE_ORC is defined in config.h and the C backup code is compiled. This backup code is pure C and does not include orc headers or require linking against liborc. \nThe common orc.mk build method is limited by the inflexibility of automake. The file tmp orc.c must be a fixed filename using ORC_NAME to generate the filename does not work because it conflicts with automake s dependency generation. Building multiple orc files is not possible due to this restriction. \nIf you create another orc file please add it to tests orc Makefile.am. This causes automatic test code to be generated and run during make check Each function in the orc file is tested by comparing the results of executing the run time compiled code and the C backup function. \nOrc doesn t have a mechanism for generating random numbers which prevents its use as is for dithering. One way around this is to generate suitable dithering values in one pass then use those values in a second Orc based pass. \nOrc doesn t handle bit float for no good reason. \nIrrespective of Orc handling bit float it would be useful to have a direct bit float to bit integer conversion. \naudioconvert is a good candidate for programmatically generated Orc code. \naudioconvert enumerates functions in terms of big endian vs. little endian. Orc s functions are native and swapped Programmatically generating code removes the need to worry about this. \nOrc doesn t handle bit samples. Fixing this is not a priority for ds \nOrc doesn t handle horizontal resampling yet. The plan is to add special sampling opcodes for nearest bilinear and cubic interpolation. \nLots of code in videotestsrc needs to be rewritten to be SIMD and Orc friendly e.g. stuff that uses oil_splat_u8 \nA fast low quality random number generator in Orc would be useful here. \nMany of the comments on audioconvert apply here as well. \nThere are a bunch of FIXMEs in here that are due to misapplied patches. \n"});