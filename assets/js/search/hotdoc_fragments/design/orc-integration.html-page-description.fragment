fragment_downloaded_cb({"url": "design/orc-integration.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"orc-integration.md\">\n        <h1 id=\"orc-integration\">Orc Integration</h1>\n<h2 id=\"about-orc\">About Orc</h2>\n<p>Orc code can be in one of two forms: in .orc files that is converted by\norcc to C code that calls liborc functions, or C code that calls liborc\nto create complex operations at runtime. The former is mostly for\nfunctions with predetermined functionality. The latter is for\nfunctionality that is determined at runtime, where writing .orc\nfunctions for all combinations would be prohibitive. Orc also has a fast\nmemcpy and memset which are useful independently.</p>\n<h2 id=\"fast-memcpy\">Fast memcpy()</h2>\n<p>*** This part is not integrated yet. ***</p>\n<p>Orc has built-in functions <code>orc_memcpy()</code> and <code>orc_memset()</code> that work\nlike <code>memcpy()</code> and <code>memset()</code>. These are meant for large copies only. A\nreasonable cutoff for using <code>orc_memcpy()</code> instead of <code>memcpy()</code> is if the\nnumber of bytes is generally greater than 100. <strong>DO NOT</strong> use <code>orc_memcpy()</code>\nif the typical is size is less than 20 bytes, especially if the size is\nknown at compile time, as these cases are inlined by the compiler.</p>\n<p>(Example: sys/ximage/ximagesink.c)</p>\n<p>Add $(ORC_CFLAGS) to libgstximagesink_la_CFLAGS and $(ORC_LIBS) to\nlibgstximagesink_la_LIBADD. Then, in the source file, add:</p>\n<p>#ifdef HAVE_ORC #include &lt;orc/orc.h&gt; #else #define\norc_memcpy(a,b,c) memcpy(a,b,c) #endif</p>\n<p>Then switch relevant uses of <code>memcpy()</code> to <code>orc_memcpy()</code>.</p>\n<p>The above example works whether or not Orc is enabled at compile time.</p>\n<h2 id=\"normal-usage\">Normal Usage</h2>\n<p>The following lines are added near the top of Makefile.am for plugins\nthat use Orc code in .orc files (this is for the volume plugin):</p>\n<pre><code>ORC_BASE=volume include $(top_srcdir)/common/orc.mk\n</code></pre>\n<p>Also add the generated source file to the plugin build:</p>\n<pre><code>nodist_libgstvolume_la_SOURCES = $(ORC_SOURCES)\n</code></pre>\n<p>And of course, add <code>$(ORC_CFLAGS)</code> to <code>libgstvolume_la_CFLAGS</code>, and\n<code>$(ORC_LIBS)</code> to <code>libgstvolume_la_LIBADD</code>.</p>\n<p>The value assigned to <code>ORC_BASE</code> does not need to be related to the name\nof the plugin.</p>\n<h2 id=\"advanced-usage\">Advanced Usage</h2>\n<p>The Holy Grail of Orc usage is to programmatically generate Orc code at\nruntime, have liborc compile it into binary code at runtime, and then\nexecute this code. Currently, the best example of this is in\nSchroedinger. An example of how this would be used is audioconvert:\ngiven an input format, channel position manipulation, dithering and\nquantizing configuration, and output format, a Orc code generator would\ncreate an OrcProgram, add the appropriate instructions to do each step\nbased on the configuration, and then compile the program. Successfully\ncompiling the program would return a function pointer that can be called\nto perform the operation.</p>\n<p>This sort of advanced usage requires structural changes to current\nplugins (e.g., audioconvert) and will probably be developed\nincrementally. Moreover, if such code is intended to be used without Orc\nas strict build/runtime requirement, two codepaths would need to be\ndeveloped and tested. For this reason, until GStreamer requires Orc, I\nthink it's a good idea to restrict such advanced usage to the cog plugin\nin -bad, which requires Orc.</p>\n<h2 id=\"build-process\">Build Process</h2>\n<p>The goal of the build process is to make Orc non-essential for most\ndevelopers and users. This is not to say you shouldn't have Orc\ninstalled -- without it, you will get slow backup C code, just that\npeople compiling GStreamer are not forced to switch from Liboil to Orc\nimmediately.</p>\n<p>With Orc installed, the build process will use the Orc Compiler (orcc)\nto convert each .orc file into a temporary C source (tmp-orc.c) and a\ntemporary header file (${name}orc.h if constructed from ${base}.orc).\nThe C source file is compiled and linked to the plugin, and the header\nfile is included by other source files in the plugin.</p>\n<p>If 'make orc-update' is run in the source directory, the files tmp-orc.c\nand ${base}orc.h are copied to ${base}orc-dist.c and ${base}orc-dist.h\nrespectively. The -dist.[ch] files are automatically disted via\norc.mk. The -dist.[ch] files should be checked in to git whenever the\n.orc source is changed and checked in. Example workflow:</p>\n<p>edit .orc file ... make, test, etc. make orc-update git add volume.orc\nvolumeorc-dist.c volumeorc-dist.h git commit</p>\n<p>At 'make dist' time, all of the .orc files are compiled, and then copied\nto their -dist.[ch] counterparts, and then the -dist.[ch] files are\nadded to the dist directory.</p>\n<p>Without Orc installed (or --disable-orc given to configure), the\n-dist.[ch] files are copied to tmp-orc.c and ${name}orc.h. When\ncompiled Orc disabled, DISABLE_ORC is defined in config.h, and the C\nbackup code is compiled. This backup code is pure C, and does not\ninclude orc headers or require linking against liborc.</p>\n<p>The common/orc.mk build method is limited by the inflexibility of\nautomake. The file tmp-orc.c must be a fixed filename, using ORC_NAME\nto generate the filename does not work because it conflicts with\nautomake's dependency generation. Building multiple .orc files is not\npossible due to this restriction.</p>\n<h2 id=\"testing\">Testing</h2>\n<p>If you create another .orc file, please add it to tests/orc/Makefile.am.\nThis causes automatic test code to be generated and run during 'make\ncheck'. Each function in the .orc file is tested by comparing the\nresults of executing the run-time compiled code and the C backup\nfunction.</p>\n<h2 id=\"orc-limitations\">Orc Limitations</h2>\n<h3 id=\"audioconvert\">audioconvert</h3>\n<p>Orc doesn't have a mechanism for generating random numbers, which\nprevents its use as-is for dithering. One way around this is to generate\nsuitable dithering values in one pass, then use those values in a second\nOrc-based pass.</p>\n<p>Orc doesn't handle 64-bit float, for no good reason.</p>\n<p>Irrespective of Orc handling 64-bit float, it would be useful to have a\ndirect 32-bit float to 16-bit integer conversion.</p>\n<p>audioconvert is a good candidate for programmatically generated Orc code.</p>\n<p>audioconvert enumerates functions in terms of big-endian vs.\nlittle-endian. Orc's functions are \"native\" and \"swapped\".\nProgrammatically generating code removes the need to worry about this.</p>\n<p>Orc doesn't handle 24-bit samples. Fixing this is not a priority (for ds).</p>\n<h3 id=\"videoscale\">videoscale</h3>\n<p>Orc doesn't handle horizontal resampling yet. The plan is to add special\nsampling opcodes, for nearest, bilinear, and cubic interpolation.</p>\n<h3 id=\"videotestsrc\">videotestsrc</h3>\n<p>Lots of code in videotestsrc needs to be rewritten to be SIMD (and Orc)\nfriendly, e.g., stuff that uses <code>oil_splat_u8()</code>.</p>\n<p>A fast low-quality random number generator in Orc would be useful here.</p>\n<h3 id=\"volume\">volume</h3>\n<p>Many of the comments on audioconvert apply here as well.</p>\n<p>There are a bunch of FIXMEs in here that are due to misapplied patches.</p>\n\n        \n\n    </div>\n\n\n        "});