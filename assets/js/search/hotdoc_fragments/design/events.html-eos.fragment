fragment_downloaded_cb({"url": "design/events.html#eos", "fragment": "EOS \nThe EOS event can only be sent on a sinkpad. It is typically emitted by the source element when it has finished sending data. This event is mainly sent in the streaming thread but can also be sent from the application thread. \nThe downstream element should forward the EOS event to its downstream peer elements. This way the event will eventually reach the sinks which should then post an EOS message on the bus when in PLAYING. \nAn element might want to flush its internally queued data before forwarding the EOS event downstream. This flushing can be done in the same thread as the one handling the EOS event. \nFor elements with multiple sink pads it might be possible to wait for EOS on all the pads before forwarding the event. \nThe EOS event should always be interleaved with the data flow therefore the GStreamer core will take the STREAM_LOCK. \nSometimes the EOS event is generated by another element than the source for example a demuxer element can generate an EOS event before the source element. This is not a problem the demuxer does not send an EOS event to the upstream element but returns GST_FLOW_EOS causing the source element to stop sending data. \nAn element that sends EOS on a pad should stop sending data on that pad. Source elements typically pause their task for that purpose. \nBy default a GstBin collects all EOS messages from all its sinks before posting the EOS message to its parent. \nThe EOS is only posted on the bus by the sink elements in the PLAYING state. If the EOS event is received in the PAUSED state it is queued until the element goes to PLAYING. \nA FLUSH_STOP event on an element flushes the EOS state and all pending EOS messages. \n"});