fragment_downloaded_cb({"url": "design/miniobject.html#locking", "fragment": "locking \nAll read and write access must be performed between a gst_mini_object_lock and gst_mini_object_unlock pair with the requested access method. \nA gst_mini_object_lock can fail when a WRITE lock is requested and the exclusive counter is Indeed a GstMiniObject object with an exclusive counter is locked EXCLUSIVELY by at least objects and is therefore not writable. \nOnce the GstMiniObject is locked with a certain access mode it can be recursively locked with the same or narrower access mode. For example first locking the GstMiniObject in READWRITE mode allows you to recusively lock the GstMiniObject in READWRITE READ and WRITE mode. Memory locked in READ mode cannot be locked recursively in WRITE or READWRITE mode. \nNote that multiple threads can READ lock the GstMiniObject concurrently but cannot lock the object in WRITE mode because the exclusive counter must be \nAll calls to gst_mini_object_lock need to be paired with one gst_mini_object_unlock call with the same access mode. When the last refcount of the object is removed there should be no more outstanding locks. \nNote that a shared counter of both and leaves the GstMiniObject writable. The reason is to make it easy to create and pass ownership of the GstMiniObject to another object while keeping it writable. When the GstMiniObject is created with a shared count of it is writable. When the GstMiniObject is then added to another object the shared count is incremented to and the GstMiniObject remains writable. The share counter has a similar purpose as the floating reference in GObject. \n"});