fragment_downloaded_cb({"url": "design/MT-refcounting.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"MT-refcounting.md\">\n<h1 id=\"conventions-for-thread-a-safe-api\">Conventions for thread a safe API</h1>\n<p>The GStreamer API is designed to be thread safe. This means that API functions\ncan be called from multiple threads at the same time. GStreamer internally uses\nthreads to perform the data passing and various asynchronous services such as\nthe clock can also use threads.</p>\n<p>This design decision has implications for the usage of the API and the objects\nwhich this document explains.</p>\n<h2 id=\"mt-safety-techniques\">MT safety techniques</h2>\n<p>Several design patterns are used to guarantee object consistency in GStreamer.\nThis is an overview of the methods used in various GStreamer subsystems.</p>\n<h3 id=\"refcounting\">Refcounting:</h3>\n<p>All shared objects have a refcount associated with them. Each reference\nobtained to the object should increase the refcount and each reference lost\nshould decrease the refcount.</p>\n<p>The refcounting is used to make sure that when another thread destroys the\nobject, the ones which still hold a reference to the object do not read from\ninvalid memory when accessing the object.</p>\n<p>Refcounting is also used to ensure that mutable data structures are only\nmodified when they are owned by the calling code.</p>\n<p>It is a requirement that when two threads have a handle on an object, the\nrefcount must be more than one. This means that when one thread passes an\nobject to another thread it must increase the refcount. This requirement makes\nsure that one thread cannot suddenly dispose the object making the other\nthread crash when it tries to access the pointer to invalid memory.</p>\n<h3 id=\"shared-data-structures-and-writability\">Shared data structures and writability:</h3>\n<p>All objects have a refcount associated with them. Each reference obtained to\nthe object should increase the refcount and each reference lost should\ndecrease the refcount.</p>\n<p>Each thread having a refcount to the object can safely read from the object.\nbut modifications made to the object should be preceded with a\n<code>_get_writable()</code> function call. This function will check the refcount of the\nobject and if the object is referenced by more than one instance, a copy is\nmade of the object that is then by definition only referenced from the calling\nthread. This new copy is then modifiable without being visible to other\nrefcount holders.</p>\n<p>This technique is used for information objects that, once created, never\nchange their values. The lifetime of these objects is generally short, the\nobjects are usually simple and cheap to copy/create.</p>\n<p>The advantage of this method is that no reader/writers locks are needed. all\nthreads can concurrently read but writes happen locally on a new copy. In most\ncases <code>_get_writable()</code> can avoid a real copy because the calling method is the\nonly one holding a reference, which makes read/write very cheap.</p>\n<p>The drawback is that sometimes 1 needless copy can be done. This would happen\nwhen N threads call <code>_get_writable()</code> at the same time, all seeing that N\nreferences are held on the object. In this case 1 copy too many will be done.\nThis is not a problem in any practical situation because the copy operation is\nfast.</p>\n<h3 id=\"mutable-substructures\">Mutable substructures:</h3>\n<p>Special techniques are necessary to ensure the consistency of compound shared\nobjects. As mentioned above, shared objects need to have a reference count of\n1 if they are to be modified. Implicit in this assumption is that all parts of\nthe shared object belong only to the object. For example, a <code>GstStructure</code> in\none <code>GstCaps</code> object should not belong to any other <code>GstCaps</code> object. This\ncondition suggests a parent-child relationship: structures can only be added\nto parent object if they do not already have a parent object.</p>\n<p>In addition, these substructures must not be modified while more than one code\nsegment has a reference on the parent object. For example, if the user creates\na <code>GstStructure</code>, adds it to a <code>GstCaps</code>, and the <code>GstCaps</code> is then referenced by\nother code segments, the <code>GstStructure</code> should then become immutable, so that\nchanges to that data structure do not affect other parts of the code. This\nmeans that the child is only mutable when the parent's reference count is 1,\nas well as when the child structure has no parent.</p>\n<p>The general solution to this problem is to include a field in child structures\npointing to the parent's atomic reference count. When set to NULL, this\nindicates that the child has no parent. Otherwise, procedures that modify the\nchild structure must check if the parent's refcount is 1, and otherwise must\ncause an error to be signaled.</p>\n<p>Note that this is an internal implementation detail; application or plugin\ncode that calls <code>_get_writable()</code> on an object is guaranteed to receive an\nobject of refcount 1, which must then be writable. The only trick is that a\npointer to a child structure of an object is only valid while the calling code\nhas a reference on the parent object, because the parent is the owner of the\nchild.</p>\n<h3 id=\"object-locking\">Object locking:</h3>\n<p>For objects that contain state information and generally have a longer\nlifetime, object locking is used to update the information contained in the\nobject.</p>\n<p>All readers and writers acquire the lock before accessing the object. Only one\nthread is allowed access the protected structures at a time.</p>\n<p>Object locking is used for all objects extending from <code>GstObject</code> such as\n<code>GstElement</code>, <code>GstPad</code>.</p>\n<p>Object locking can be done with recursive locks or regular mutexes. Object\nlocks in GStreamer are implemented with mutexes which cause deadlocks when\nlocked recursively from the same thread. This is done because regular mutexes\nare cheaper.</p>\n<h3 id=\"atomic-operations\">Atomic operations</h3>\n<p>Atomic operations are operations that are performed as one consistent\noperation even when executed by multiple threads. They do however not use the\nconventional aproach of using mutexes to protect the critical section but rely\non CPU features and instructions.</p>\n<p>The advantages are mostly speed related since there are no heavyweight locks\ninvolved. Most of these instructions also do not cause a context switch in case\nof concurrent access but use a retry mechanism or spinlocking.</p>\n<p>Disadvantages are that each of these instructions usually cause a cache flush\non multi-CPU machines when two processors perform concurrent access.</p>\n<p>Atomic operations are generally used for refcounting and for the allocation of\nsmall fixed size objects in a memchunk. They can also be used to implement a\nlockfree list or stack.</p>\n<h3 id=\"compare-and-swap\">Compare and swap</h3>\n<p>As part of the atomic operations, compare-and-swap (CAS) can be used to access\nor update a single property or pointer in an object without having to take a\nlock.</p>\n<p>This technique is currently not used in GStreamer but might be added in the\nfuture in performance critical places.</p>\n<h2 id=\"objects\">Objects</h2>\n<h3 id=\"locking-involved\">Locking involved:</h3>\n<ul>\n<li>atomic operations for refcounting</li>\n<li>object locking</li>\n</ul>\n<p>All objects should have a lock associated with them. This lock is used to keep\ninternal consistency when multiple threads call API function on the object.</p>\n<p>For objects that extend the GStreamer base object class this lock can be\nobtained with the macros <code>GST_OBJECT_LOCK()</code> and <code>GST_OBJECT_UNLOCK()</code>. For other object that do\nnot extend from the base <code>GstObject</code> class these macros can be different.</p>\n<h3 id=\"refcounting1\">refcounting</h3>\n<p>All new objects created have the <code>FLOATING</code> flag set. This means that the object\nis not owned or managed yet by anybody other than the one holding a reference\nto the object. The object in this state has a reference count of 1.</p>\n<p>Various object methods can take ownership of another object, this means that\nafter calling a method on object A with an object B as an argument, the object\nB is made sole property of object A. This means that after the method call you\nare not allowed to access the object anymore unless you keep an extra\nreference to the object. An example of such a method is the <code>_bin_add()</code> method.\nAs soon as this function is called in a Bin, the element passed as an argument\nis owned by the bin and you are not allowed to access it anymore without\ntaking a <code>_ref()</code> before adding it to the bin. The reason being that after the\n<code>_bin_add()</code> call disposing the bin also destroys the element.</p>\n<p>Taking ownership of an object happens through the process of \"sinking\" the\nobject. the <code>_sink()</code> method on an object will decrease the refcount of the\nobject if the FLOATING flag is set. The act of taking ownership of an object\nis then performed as a <code>_ref()</code> followed by a <code>_sink()</code> call on the object.</p>\n<p>The float/sink process is very useful when initializing elements that will\nthen be placed under control of a parent. The floating ref keeps the object\nalive until it is parented, and once the object is parented you can forget\nabout it.</p>\n<p>also see <a href=\"relations.html\">relations</a></p>\n<h3 id=\"parentchild-relations\">parent-child relations</h3>\n<p>One can create parent-child relationships with the <code>_object_set_parent()</code>\nmethod. This method refs and sinks the object and assigns its parent property\nto that of the managing parent.</p>\n<p>The child is said to have a weak link to the parent since the refcount of the\nparent is not increased in this process. This means that if the parent is\ndisposed it has to unset itself as the parent of the object before disposing\nitself, else the child object holds a parent pointer to invalid memory.</p>\n<p>The responsibilities for an object that sinks other objects are summarised as:</p>\n<ul>\n<li>\n<p>taking ownership of the object</p>\n<ul>\n<li>call <code>_object_set_parent()</code> to set itself as the object parent, this call\nwill <code>_ref()</code> and <code>_sink()</code> the object.</li>\n<li>keep reference to object in a datastructure such as a list or array.</li>\n</ul>\n</li>\n<li>\n<p>on dispose</p>\n<ul>\n<li>call <code>_object_unparent()</code> to reset the parent property and unref the\nobject.</li>\n<li>remove the object from the list.</li>\n</ul>\n</li>\n</ul>\n<p>also see <a href=\"relations.html\">relations</a></p>\n<h3 id=\"properties\">Properties</h3>\n<p>Most objects also expose state information with public properties in the\nobject. Two types of properties might exist: accessible with or without\nholding the object lock. All properties should only be accessed with their\ncorresponding macros. The public object properties are marked in the .h files\nwith /<em>&lt; public &gt;</em>/. The public properties that require a lock to be held are\nmarked with <code>/*&lt; public &gt;*/</code> <code>/* with &lt;lock_type&gt; */</code>, where <code>&lt;lock_type&gt;</code> can\nbe <code>LOCK</code> or <code>STATE_LOCK</code> or any other lock to mark the type(s) of lock to be\nheld.</p>\n<p><strong>Example</strong>:</p>\n<p>in <code>GstPad</code> there is a public property <code>direction</code>. It can be found in the\nsection marked as public and requiring the LOCK to be held. There exists\nalso a macro to access the property.</p>\n<pre><code class=\"language-c\">struct _GstRealPad {\n  ...\n  /*&lt; public &gt;*/ /* with LOCK */\n  ...\n  GstPadDirection                direction;\n  ...\n};\n\n#define GST_RPAD_DIRECTION(pad)      (GST_REAL_PAD_CAST(pad)-&gt;direction)\n</code></pre>\n<p>Accessing the property is therefore allowed with the following code example:</p>\n<pre><code class=\"language-c\">GST_OBJECT_LOCK (pad);\ndirection = GST_RPAD_DIRECTION (pad);\nGST_OBJECT_UNLOCK (pad);\n</code></pre>\n<h3 id=\"property-lifetime\">Property lifetime</h3>\n<p>All properties requiring a lock can change after releasing the associated\nlock. This means that as long as you hold the lock, the state of the\nobject regarding the locked properties is consistent with the information\nobtained. As soon as the lock is released, any values acquired from the\nproperties might not be valid anymore and can as best be described as a\nsnapshot of the state when the lock was held.</p>\n<p>This means that all properties that require access beyond the scope of the\ncritial section should be copied or refcounted before releasing the lock.</p>\n<p>Most object provide a <code>_get_&lt;property&gt;()</code> method to get a copy or refcounted\ninstance of the property value. The caller should not wory about any locks\nbut should unref/free the object after usage.</p>\n<p><strong>Example</strong>:</p>\n<p>the following example correctly gets the peer pad of an element. It is\nrequired to increase the refcount of the peer pad because as soon as the\nlock is released, the peer could be unreffed and disposed, making the\npointer obtained in the critical section point to invalid memory.</p>\n<pre><code class=\"language-c\">GST_OBJECT_LOCK (pad);\npeer = GST_RPAD_PEER (pad);\nif (peer)\ngst_object_ref (GST_OBJECT (peer));\nGST_OBJECT_UNLOCK (pad);\n... use peer ...\n\nif (peer)\n  gst_object_unref (GST_OBJECT (peer));\n</code></pre>\n<p>Note that after releasing the lock the peer might not actually be the peer\nanymore of the pad. If you need to be sure it is, you need to extend the\ncritical section to include the operations on the peer.</p>\n<p>The following code is equivalent to the above but with using the functions\nto access object properties.</p>\n<pre><code class=\"language-c\">peer = gst_pad_get_peer (pad);\nif (peer) {\n  ... use peer ...\n\n  gst_object_unref (GST_OBJECT (peer));\n}\n</code></pre>\n<p><strong>Example</strong>:</p>\n<p>Accessing the name of an object makes a copy of the name. The caller of the\nfunction should <code>g_free()</code> the name after usage.</p>\n<pre><code class=\"language-c\">GST_OBJECT_LOCK (object)\nname = g_strdup (GST_OBJECT_NAME (object));\nGST_OBJECT_UNLOCK (object)\n... use name ...\n\ng_free (name);\n</code></pre>\n<p>or:</p>\n<pre><code class=\"language-c\">name = gst_object_get_name (object);\n\n... use name ...\n\ng_free (name);\n</code></pre>\n<h3 id=\"accessor-methods\">Accessor methods</h3>\n<p>For aplications it is encouraged to use the public methods of the object. Most\nuseful operations can be performed with the methods so it is seldom required\nto access the public fields manually.</p>\n<p>All accessor methods that return an object should increase the refcount of the\nreturned object. The caller should <code>_unref()</code> the object after usage. Each\nmethod should state this refcounting policy in the documentation.</p>\n<h3 id=\"accessing-lists\">Accessing lists</h3>\n<p>If the object property is a list, concurrent list iteration is needed to get\nthe contents of the list. GStreamer uses the cookie mechanism to mark the last\nupdate of a list. The list and the cookie are protected by the same lock. Each\nupdate to a list requires the following actions:</p>\n<ul>\n<li>acquire lock</li>\n<li>update list</li>\n<li>update cookie</li>\n<li>release lock</li>\n</ul>\n<p>Updating the cookie is usually done by incrementing its value by one. Since\ncookies use guint32 its wraparound is for all practical reasons is not a\nproblem.</p>\n<p>Iterating a list can safely be done by surrounding the list iteration with a\nlock/unlock of the lock.</p>\n<p>In some cases it is not a good idea to hold the lock for a long time while\niterating the list. The state change code for a bin in GStreamer, for example,\nhas to iterate over each element and perform a blocking call on each of them\npotentially causing infinite bin locking. In this case the cookie can be used\nto iterate a list.</p>\n<p><strong>Example</strong>:</p>\n<p>The following algorithm iterates a list and reverses the updates in the\ncase a concurrent update was done to the list while iterating. The idea is\nthat whenever we reacquire the lock, we check for updates to the cookie to\ndecide if we are still iterating the right list.</p>\n<pre><code class=\"language-c\">GST_OBJECT_LOCK (lock);\n/* grab list and cookie */\ncookie = object-&gt;list_cookie;\nlist = object-list;\nwhile (list) {\n  GstObject *item = GST_OBJECT (list-&gt;data);\n  /* need to ref the item before releasing the lock */\n  gst_object_ref (item);\n  GST_OBJECT_UNLOCK (lock);\n\n  ... use/change item here...\n\n  /* release item here */\n  gst_object_unref (item);\n\n  GST_OBJECT_LOCK (lock);\n  if (cookie != object-&gt;list_cookie) {\n    /* handle rollback caused by concurrent modification\n     * of the list here */\n\n    ...rollback changes to items...\n\n    /* grab new cookie and list */\n    cookie = object-&gt;list_cookie;\n    list = object-&gt;list;\n  }\n  else {\n    list = g_list_next (list);\n  }\n}\nGST_OBJECT_UNLOCK (lock);\n</code></pre>\n<h3 id=\"gstiterator\">GstIterator</h3>\n<p><code>GstIterator</code> provides an easier way of retrieving elements in a concurrent\nlist. The following code example is equivalent to the previous example.</p>\n<p><strong>Example</strong>:</p>\n<pre><code class=\"language-c\">it = _get_iterator(object);\nwhile (!done) {\n    switch (gst_iterator_next (it, &amp;item)) {\n    case GST_ITERATOR_OK:\n\n        ... use/change item here...\n\n        /* release item here */\n        gst_object_unref (item);\n    break;\n    case GST_ITERATOR_RESYNC:\n        /* handle rollback caused by concurrent modification\n    * of the list here */\n\n    ...rollback changes to items...\n\n    /* resync iterator to start again */\n    gst_iterator_resync (it);\n    break;\n    case GST_ITERATOR_DONE:\n    done = TRUE;\n    break;\n    }\n}\ngst_iterator_free (it);\n</code></pre>\n\n</div>\n\n\n        "});