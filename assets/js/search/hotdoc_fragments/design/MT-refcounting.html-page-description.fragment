fragment_downloaded_cb({"url": "design/MT-refcounting.html#page-description", "fragment": "The GStreamer API is designed to be thread safe. This means that API functions can be called from multiple threads at the same time. GStreamer internally uses threads to perform the data passing and various asynchronous services such as the clock can also use threads. \nThis design decision has implications for the usage of the API and the objects which this document explains. \nSeveral design patterns are used to guarantee object consistency in GStreamer. This is an overview of the methods used in various GStreamer subsystems. \nAll shared objects have a refcount associated with them. Each reference obtained to the object should increase the refcount and each reference lost should decrease the refcount. \nThe refcounting is used to make sure that when another thread destroys the object the ones which still hold a reference to the object do not read from invalid memory when accessing the object. \nRefcounting is also used to ensure that mutable data structures are only modified when they are owned by the calling code. \nIt is a requirement that when two threads have a handle on an object the refcount must be more than one. This means that when one thread passes an object to another thread it must increase the refcount. This requirement makes sure that one thread cannot suddenly dispose the object making the other thread crash when it tries to access the pointer to invalid memory. \nAll objects have a refcount associated with them. Each reference obtained to the object should increase the refcount and each reference lost should decrease the refcount. \nEach thread having a refcount to the object can safely read from the object. but modifications made to the object should be preceded with a _get_writable function call. This function will check the refcount of the object and if the object is referenced by more than one instance a copy is made of the object that is then by definition only referenced from the calling thread. This new copy is then modifiable without being visible to other refcount holders. \nThis technique is used for information objects that once created never change their values. The lifetime of these objects is generally short the objects are usually simple and cheap to copy create. \nThe advantage of this method is that no reader writers locks are needed. all threads can concurrently read but writes happen locally on a new copy. In most cases _get_writable can avoid a real copy because the calling method is the only one holding a reference which makes read write very cheap. \nThe drawback is that sometimes needless copy can be done. This would happen when N threads call _get_writable at the same time all seeing that N references are held on the object. In this case copy too many will be done. This is not a problem in any practical situation because the copy operation is fast. \nSpecial techniques are necessary to ensure the consistency of compound shared objects. As mentioned above shared objects need to have a reference count of if they are to be modified. Implicit in this assumption is that all parts of the shared object belong only to the object. For example a GstStructure in one GstCaps object should not belong to any other GstCaps object. This condition suggests a parent child relationship structures can only be added to parent object if they do not already have a parent object. \nIn addition these substructures must not be modified while more than one code segment has a reference on the parent object. For example if the user creates a GstStructure adds it to a GstCaps and the GstCaps is then referenced by other code segments the GstStructure should then become immutable so that changes to that data structure do not affect other parts of the code. This means that the child is only mutable when the parent s reference count is as well as when the child structure has no parent. \nThe general solution to this problem is to include a field in child structures pointing to the parent s atomic reference count. When set to NULL this indicates that the child has no parent. Otherwise procedures that modify the child structure must check if the parent s refcount is and otherwise must cause an error to be signaled. \nNote that this is an internal implementation detail application or plugin code that calls _get_writable on an object is guaranteed to receive an object of refcount which must then be writable. The only trick is that a pointer to a child structure of an object is only valid while the calling code has a reference on the parent object because the parent is the owner of the child. \nFor objects that contain state information and generally have a longer lifetime object locking is used to update the information contained in the object. \nAll readers and writers acquire the lock before accessing the object. Only one thread is allowed access the protected structures at a time. \nObject locking is used for all objects extending from GstObject such as GstElement GstPad. \nObject locking can be done with recursive locks or regular mutexes. Object locks in GStreamer are implemented with mutexes which cause deadlocks when locked recursively from the same thread. This is done because regular mutexes are cheaper. \nAtomic operations are operations that are performed as one consistent operation even when executed by multiple threads. They do however not use the conventional aproach of using mutexes to protect the critical section but rely on CPU features and instructions. \nThe advantages are mostly speed related since there are no heavyweight locks involved. Most of these instructions also do not cause a context switch in case of concurrent access but use a retry mechanism or spinlocking. \nDisadvantages are that each of these instructions usually cause a cache flush on multi CPU machines when two processors perform concurrent access. \nAtomic operations are generally used for refcounting and for the allocation of small fixed size objects in a memchunk. They can also be used to implement a lockfree list or stack. \nAs part of the atomic operations compare and swap CAS can be used to access or update a single property or pointer in an object without having to take a lock. \nThis technique is currently not used in GStreamer but might be added in the future in performance critical places. \nAll objects should have a lock associated with them. This lock is used to keep internal consistency when multiple threads call API function on the object. \nFor objects that extend the GStreamer base object class this lock can be obtained with the macros GST_OBJECT_LOCK and GST_OBJECT_UNLOCK For other object that do not extend from the base GstObject class these macros can be different. \nAll new objects created have the FLOATING flag set. This means that the object is not owned or managed yet by anybody other than the one holding a reference to the object. The object in this state has a reference count of \nVarious object methods can take ownership of another object this means that after calling a method on object A with an object B as an argument the object B is made sole property of object A. This means that after the method call you are not allowed to access the object anymore unless you keep an extra reference to the object. An example of such a method is the _bin_add method. As soon as this function is called in a Bin the element passed as an argument is owned by the bin and you are not allowed to access it anymore without taking a _ref before adding it to the bin. The reason being that after the _bin_add call disposing the bin also destroys the element. \nTaking ownership of an object happens through the process of sinking the object. the _sink method on an object will decrease the refcount of the object if the FLOATING flag is set. The act of taking ownership of an object is then performed as a _ref followed by a _sink call on the object. \nThe float sink process is very useful when initializing elements that will then be placed under control of a parent. The floating ref keeps the object alive until it is parented and once the object is parented you can forget about it. \nalso see relations \nOne can create parent child relationships with the _object_set_parent method. This method refs and sinks the object and assigns its parent property to that of the managing parent. \nThe child is said to have a weak link to the parent since the refcount of the parent is not increased in this process. This means that if the parent is disposed it has to unset itself as the parent of the object before disposing itself else the child object holds a parent pointer to invalid memory. \nThe responsibilities for an object that sinks other objects are summarised as \ntaking ownership of the object \non dispose \nalso see relations \nMost objects also expose state information with public properties in the object. Two types of properties might exist accessible with or without holding the object lock. All properties should only be accessed with their corresponding macros. The public object properties are marked in the h files with public The public properties that require a lock to be held are marked with public with lock_type where lock_type can be LOCK or STATE_LOCK or any other lock to mark the type s of lock to be held. \nExample \nin GstPad there is a public property direction. It can be found in the section marked as public and requiring the LOCK to be held. There exists also a macro to access the property. \nAccessing the property is therefore allowed with the following code example \nAll properties requiring a lock can change after releasing the associated lock. This means that as long as you hold the lock the state of the object regarding the locked properties is consistent with the information obtained. As soon as the lock is released any values acquired from the properties might not be valid anymore and can as best be described as a snapshot of the state when the lock was held. \nThis means that all properties that require access beyond the scope of the critial section should be copied or refcounted before releasing the lock. \nMost object provide a _get_ property method to get a copy or refcounted instance of the property value. The caller should not wory about any locks but should unref free the object after usage. \nExample \nthe following example correctly gets the peer pad of an element. It is required to increase the refcount of the peer pad because as soon as the lock is released the peer could be unreffed and disposed making the pointer obtained in the critical section point to invalid memory. \nNote that after releasing the lock the peer might not actually be the peer anymore of the pad. If you need to be sure it is you need to extend the critical section to include the operations on the peer. \nThe following code is equivalent to the above but with using the functions to access object properties. \nExample \nAccessing the name of an object makes a copy of the name. The caller of the function should g_free the name after usage. \nor \nFor aplications it is encouraged to use the public methods of the object. Most useful operations can be performed with the methods so it is seldom required to access the public fields manually. \nAll accessor methods that return an object should increase the refcount of the returned object. The caller should _unref the object after usage. Each method should state this refcounting policy in the documentation. \nIf the object property is a list concurrent list iteration is needed to get the contents of the list. GStreamer uses the cookie mechanism to mark the last update of a list. The list and the cookie are protected by the same lock. Each update to a list requires the following actions \nUpdating the cookie is usually done by incrementing its value by one. Since cookies use guint32 its wraparound is for all practical reasons is not a problem. \nIterating a list can safely be done by surrounding the list iteration with a lock unlock of the lock. \nIn some cases it is not a good idea to hold the lock for a long time while iterating the list. The state change code for a bin in GStreamer for example has to iterate over each element and perform a blocking call on each of them potentially causing infinite bin locking. In this case the cookie can be used to iterate a list. \nExample \nThe following algorithm iterates a list and reverses the updates in the case a concurrent update was done to the list while iterating. The idea is that whenever we reacquire the lock we check for updates to the cookie to decide if we are still iterating the right list. \nGstIterator provides an easier way of retrieving elements in a concurrent list. The following code example is equivalent to the previous example. \nExample \n"});