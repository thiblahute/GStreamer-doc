fragment_downloaded_cb({"url": "design/decodebin.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"decodebin.md\">\n<h1 id=\"decodebin-design\">Decodebin design</h1>\n<h2 id=\"gstdecodebin\">GstDecodeBin</h2>\n<h3 id=\"description\">Description</h3>\n<ul>\n<li>\n<p>Autoplug and decode to raw media</p>\n</li>\n<li>\n<p>Input: single pad with ANY caps</p>\n</li>\n<li>\n<p>Output: Dynamic pads</p>\n</li>\n</ul>\n<h3 id=\"contents\">Contents</h3>\n<ul>\n<li>\n<p>a GstTypeFindElement connected to the single sink pad</p>\n</li>\n<li>\n<p>optionally a demuxer/parser</p>\n</li>\n<li>\n<p>optionally one or more DecodeGroup</p>\n</li>\n</ul>\n<h3 id=\"autoplugging\">Autoplugging</h3>\n<p>The goal is to reach 'target' caps (by default raw media).</p>\n<p>This is done by using the <code>GstCaps</code> of a source pad and finding the\navailable demuxers/decoders <code>GstElement</code> that can be linked to that pad.</p>\n<p>The process starts with the source pad of typefind and stops when no\nmore non-target caps are left. It is commonly done while pre-rolling,\nbut can also happen whenever a new pad appears on any element.</p>\n<p>Once a target caps has been found, that pad is ghosted and the\n'pad-added' signal is emitted.</p>\n<p>If no compatible elements can be found for a <code>GstCaps</code>, the pad is ghosted\nand the 'unknown-type' signal is emitted.</p>\n<h3 id=\"assisted-autoplugging\">Assisted auto-plugging</h3>\n<p>When starting the auto-plugging process for a given <code>GstCaps</code>, two signals\nare emitted in the following way in order to allow the application/user\nto assist or fine-tune the process.</p>\n<ul>\n<li>\n<p><strong>'autoplug-continue'</strong>:</p>\n<pre><code> gboolean user_function (GstElement * decodebin, GstPad *pad, GstCaps * caps)\n</code></pre>\n<p>This signal is fired at the very beginning with the source pad <code>GstCaps</code>. If\nthe callback returns TRUE, the process continues normally. If the\ncallback returns FALSE, then the <code>GstCaps</code> are considered as a target caps\nand the autoplugging process stops.</p>\n</li>\n<li>\n<p><strong>'autoplug-factories'</strong>:</p>\n<pre><code>GValueArray user_function (GstElement* decodebin, GstPad* pad, GstCaps* caps);\n</code></pre>\n<p>Get a list of elementfactories for @pad with @caps. This function is\nused to instruct decodebin2 of the elements it should try to\nautoplug. The default behaviour when this function is not overriden\nis to get all elements that can handle @caps from the registry\nsorted by rank.</p>\n</li>\n<li>\n<p><strong>'autoplug-select'</strong>:</p>\n<pre><code>gint user_function (GstElement* decodebin, GstPad* pad, GstCaps*caps, GValueArray* factories);\n</code></pre>\n<p>This signal is fired once autoplugging has got a list of compatible\n<code>GstElementFactory</code>. The signal is emitted with the <code>GstCaps</code> of the\nsource pad and a pointer on the GValueArray of compatible factories.</p>\n<p>The callback should return the index of the elementfactory in\n@factories that should be tried next.</p>\n<p>If the callback returns -1, the autoplugging process will stop as if\nno compatible factories were found.</p>\n</li>\n</ul>\n<p>The default implementation of this function will try to autoplug the\nfirst factory of the list.</p>\n<h3 id=\"target-caps\">Target Caps</h3>\n<p>The target caps are a read/write <code>GObject</code> property of decodebin.</p>\n<p>By default the target caps are:</p>\n<ul>\n<li>\n<p>Raw audio: audio/x-raw</p>\n</li>\n<li>\n<p>Raw video: video/x-raw</p>\n</li>\n<li>\n<p>Raw text: text/x-raw, format={utf8,pango-markup}</p>\n</li>\n</ul>\n<h3 id=\"media-chaingroup-handling\">Media chain/group handling</h3>\n<p>When autoplugging, all streams coming out of a demuxer will be grouped\nin a DecodeGroup.</p>\n<p>All new source pads created on that demuxer after it has emitted the\n'no-more-pads' signal will be put in another DecodeGroup.</p>\n<p>Only one decodegroup can be active at any given time. If a new\ndecodegroup is created while another one exists, that decodegroup will\nbe set as blocking until the existing one has drained.</p>\n<h2 id=\"decodegroup\">DecodeGroup</h2>\n<h3 id=\"description1\">Description</h3>\n<p>Streams belonging to the same group/chain of a media file.</p>\n<h3 id=\"contents1\">Contents</h3>\n<p>The DecodeGroup contains:</p>\n<ul>\n<li>\n<p>a <code>GstMultiQueue</code> to which all streams of the media group are connected.</p>\n</li>\n<li>\n<p>the eventual decoders which are autoplugged in order to produce the\nrequested target pads.</p>\n</li>\n</ul>\n<h3 id=\"proper-group-draining\">Proper group draining</h3>\n<p>The DecodeGroup takes care that all the streams in the group are\ncompletely drained (EOS has come through all source ghost pads).</p>\n<h3 id=\"preroll-and-block\">Pre-roll and block</h3>\n<p>The DecodeGroup has a global blocking feature. If enabled, all the\nghosted source pads for that group will be blocked.</p>\n<p>A method is available to unblock all blocked pads for that group.</p>\n<h2 id=\"gstmultiqueue\">GstMultiQueue</h2>\n<p>Multiple input-output data queue.</p>\n<p><code>multiqueue</code> achieves the same functionality as <code>queue</code>, with a\nfew differences:</p>\n<ul>\n<li>\n<p>Multiple streams handling.</p>\n<p>The element handles queueing data on more than one stream at once.\nTo achieve such a feature it has request sink pads (sink_%u) and\n'sometimes' src pads (src_%u).</p>\n<p>When requesting a given sinkpad, the associated srcpad for that\nstream will be created. Ex: requesting sink_1 will generate src_1.</p>\n</li>\n<li>\n<p>Non-starvation on multiple streams.</p>\n<p>If more than one stream is used with the element, the streams'\nqueues will be dynamically grown (up to a limit), in order to ensure\nthat no stream is risking data starvation. This guarantees that at\nany given time there are at least N bytes queued and available for\neach individual stream.</p>\n<p>If an EOS event comes through a srcpad, the associated queue should\nbe considered as 'not-empty' in the queue-size-growing algorithm.</p>\n</li>\n<li>\n<p>Non-linked srcpads graceful handling.</p>\n<p>A <code>GstTask</code> is started for all srcpads when going to\n<code>GST_STATE_PAUSED</code>.</p>\n<p>The task are blocking against a GCondition which will be fired in\ntwo different cases:</p>\n<ul>\n<li>\n<p>When the associated queue has received a buffer.</p>\n</li>\n<li>\n<p>When the associated queue was previously declared as 'not-linked'\nand the first buffer of the queue is scheduled to be pushed\nsynchronously in relation to the order in which it arrived globally\nin the element (see 'Synchronous data pushing' below).</p>\n</li>\n</ul>\n<p>When woken up by the GCondition, the <code>GstTask</code> will try to push the\nnext <code>GstBuffer</code>/<code>GstEvent</code> on the queue. If pushing the\n<code>GstBuffer</code>/<code>GstEvent</code> returns <code>GST_FLOW_NOT_LINKED</code>, then the\nassociated queue is marked as 'not-linked'. If pushing the\n<code>GstBuffer</code>/<code>GstEvent</code> succeeded the queue will no longer be marked as\n'not-linked'.</p>\n<p>If pushing on all srcpads returns <code>GstFlowReturn</code> different from\n<code>GST_FLOW_OK</code>, then all the srcpads' tasks are stopped and\nsubsequent pushes on sinkpads will return <code>GST_FLOW_NOT_LINKED</code>.</p>\n</li>\n<li>\n<p>Synchronous data pushing for non-linked pads.</p>\n<p>In order to better support dynamic switching between streams, the\nmultiqueue (unlike the current GStreamer queue) continues to push\nbuffers on non-linked pads rather than shutting down.</p>\n<p>In addition, to prevent a non-linked stream from very quickly\nconsuming all available buffers and thus 'racing ahead' of the other\nstreams, the element must ensure that buffers and inlined events for\na non-linked stream are pushed in the same order as they were\nreceived, relative to the other streams controlled by the element.\nThis means that a buffer cannot be pushed to a non-linked pad any\nsooner than buffers in any other stream which were received before\nit.</p>\n</li>\n</ul>\n<h2 id=\"parsers-decoders-and-autoplugging\">Parsers, decoders and auto-plugging</h2>\n<p>This section has DRAFT status.</p>\n<p>Some media formats come in different \"flavours\" or \"stream formats\".\nThese formats differ in the way the setup data and media data is\nsignalled and/or packaged. An example for this is H.264 video, where\nthere is a bytestream format (with codec setup data signalled inline and\nunits prefixed by a sync code and packet length information) and a \"raw\"\nformat where codec setup data is signalled out of band (via the caps)\nand the chunking is implicit in the way the buffers were muxed into a\ncontainer, to mention just two of the possible variants.</p>\n<p>Especially on embedded platforms it is common that decoders can only\nhandle one particular stream format, and not all of them.</p>\n<p>Where there are multiple stream formats, parsers are usually expected to\nbe able to convert between the different formats. This will, if\nimplemented correctly, work as expected in a static pipeline such as</p>\n<pre><code>... ! parser ! decoder ! sink\n</code></pre>\n<p>where the parser can query the decoder's capabilities even before\nprocessing the first piece of data, and configure itself to convert\naccordingly, if conversion is needed at all.</p>\n<p>In an auto-plugging context this is not so straight-forward though,\nbecause elements are plugged incrementally and not before the previous\nelement has processed some data and decided what it will output exactly\n(unless the template caps are completely fixed, then it can continue\nright away, this is not always the case here though, see below). A\nparser will thus have to decide on <em>some</em> output format so auto-plugging\ncan continue. It doesn't know anything about the available decoders and\ntheir capabilities though, so it's possible that it will choose a format\nthat is not supported by any of the available decoders, or by the\npreferred decoder.</p>\n<p>If the parser had sufficiently concise but fixed source pad template\ncaps, decodebin could continue to plug a decoder right away, allowing\nthe parser to configure itself in the same way as it would with a static\npipeline. This is not an option, unfortunately, because often the parser\nneeds to process some data to determine e.g. the format's profile or\nother stream properties (resolution, sample rate, channel configuration,\netc.), and there may be different decoders for different profiles (e.g.\nDSP codec for baseline profile, and software fallback for main/high\nprofile; or a DSP codec only supporting certain resolutions, with a\nsoftware fallback for unusual resolutions). So if decodebin just plugged\nthe most highest-ranking decoder, that decoder might not be be able to\nhandle the actual stream later on, which would yield an error (this is a\ndata flow error then which would be hard to intercept and avoid in\ndecodebin). In other words, we can't solve this issue by plugging a\ndecoder right away with the parser.</p>\n<p>So decodebin needs to communicate to the parser the set of available\ndecoder caps (which would contain the relevant capabilities/restrictions\nsuch as supported profiles, resolutions, etc.), after the usual\n\"autoplug-*\" signal filtering/sorting of course.</p>\n<p>This is done by plugging a capsfilter element right after the parser,\nand constructing set of filter caps from the list of available decoders\n(one appends at the end just the name(s) of the caps structures from the\nparser pad template caps to function as an 'ANY other' caps equivalent).\nThis let the parser negotiate to a supported stream format in the same\nway as with the static pipeline mentioned above, but of course incur\nsome overhead through the additional capsfilter element.</p>\n\n</div>\n\n\n        "});