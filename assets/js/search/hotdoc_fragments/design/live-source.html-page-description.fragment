fragment_downloaded_cb({"url": "design/live-source.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"live-source.md\">\n<h1 id=\"live-sources\">Live sources</h1>\n<p>A live source is a source that cannot be arbitrarily <code>PAUSED</code> without\nlosing data.</p>\n<p>A live source such as an element capturing audio or video, needs to be\nhandled in a special way. It does not make sense to start the dataflow\nin the <code>PAUSED</code> state for those devices as the user might wait a long time\nbetween going from <code>PAUSED</code> to <code>PLAYING</code>, making the previously captured\nbuffers irrelevant.</p>\n<p>A live source therefore only produces buffers in the <code>PLAYING</code> state. This\nhas implications for sinks waiting for a buffer to complete the preroll\nstate since such a buffer might never arrive.</p>\n<p>Live sources return <code>NO_PREROLL</code> when going to the <code>PAUSED</code> state to inform\nthe bin/pipeline that this element will not be able to produce data in\nthe <code>PAUSED</code> state. <code>NO_PREROLL</code> should be returned for both READY\u2192PAUSED\nand PLAYING\u2192PAUSED.</p>\n<p>When performing a <code>get_state()</code> on a bin with a non-zero timeout value,\nthe bin must be sure that there are no live sources in the pipeline\nbecause otherwise, the <code>get_state()</code> function would block on the sinks.</p>\n<p>A gstbin therefore always performs a zero timeout <code>get_state()</code> on its\nelements to discover the <code>NO_PREROLL</code> (and ERROR) elements before\nperforming a blocking wait.</p>\n<h2 id=\"scheduling\">Scheduling</h2>\n<p>Live sources will not produce data in the <code>PAUSED</code> state. They block in\nthe <code>get_range()</code> function or in the loop function until they go to PLAYING.</p>\n<h2 id=\"latency\">Latency</h2>\n<p>The live source timestamps its data with the time of the clock when\nthe data was captured. Normally, it will take some time to capture\nthe first sample of data and the last one. This means that when the\nbuffer arrives at the sink, it will already be late and will be dropped.</p>\n<p>The latency is the time it takes to construct one buffer of data and it's\nexposed with a <code>LATENCY</code> query.</p>\n<p>See <a href=\"latency.html\">latency</a></p>\n<h2 id=\"timestamps\">Timestamps</h2>\n<p>Live sources always timestamp their buffers with the <code>running_time</code> of\nthe pipeline. This is needed to be able to match the timestamps of\ndifferent live sources in order to synchronize them.</p>\n<p>This is in contrast to non-live sources, which timestamp their buffers\nstarting from <code>running_time</code> 0.</p>\n\n</div>\n\n\n        "});