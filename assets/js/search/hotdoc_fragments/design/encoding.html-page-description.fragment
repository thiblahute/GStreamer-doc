fragment_downloaded_cb({"url": "design/encoding.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"encoding.md\">\n        <h1 id=\"encoding-and-muxing\">Encoding and Muxing</h1>\n<h2 id=\"problems-this-proposal-attempts-to-solve\">Problems this proposal attempts to solve</h2>\n<ul>\n<li>\n<p>Duplication of pipeline code for gstreamer-based applications\nwishing to encode and or mux streams, leading to subtle differences\nand inconsistencies across those applications.</p>\n</li>\n<li>\n<p>No unified system for describing encoding targets for applications\nin a user-friendly way.</p>\n</li>\n<li>\n<p>No unified system for creating encoding targets for applications,\nresulting in duplication of code across all applications,\ndifferences and inconsistencies that come with that duplication, and\napplications hardcoding element names and settings resulting in poor\nportability.</p>\n</li>\n</ul>\n<h2 id=\"goals\">Goals</h2>\n<ol>\n<li>\n<p>Convenience encoding element</p>\n<p>Create a convenience <code>GstBin</code> for encoding and muxing several streams,\nhereafter called 'EncodeBin'.</p>\n<p>This element will only contain one single property, which is a profile.</p>\n</li>\n<li>\n<p>Define a encoding profile system</p>\n</li>\n<li>\n<p>Encoding profile helper library</p>\n</li>\n</ol>\n<p>Create a helper library to:</p>\n<ul>\n<li>\n<p>create EncodeBin instances based on profiles, and</p>\n</li>\n<li>\n<p>help applications to create/load/save/browse those profiles.</p>\n</li>\n</ul>\n<h2 id=\"encodebin\">EncodeBin</h2>\n<h3 id=\"proposed-api\">Proposed API</h3>\n<p>EncodeBin is a <code>GstBin</code> subclass.</p>\n<p>It implements the <code>GstTagSetter</code> interface, by which it will proxy the\ncalls to the muxer.</p>\n<p>Only two introspectable property (i.e. usable without extra API):</p>\n<ul>\n<li>A <code>GstEncodingProfile</code></li>\n<li>The name of the profile to use</li>\n</ul>\n<p>When a profile is selected, encodebin will:</p>\n<ul>\n<li>Add REQUEST sinkpads for all the GstStreamProfile</li>\n<li>Create the muxer and expose the source pad</li>\n</ul>\n<p>Whenever a request pad is created, encodebin will:</p>\n<ul>\n<li>Create the chain of elements for that pad</li>\n<li>Ghost the sink pad</li>\n<li>Return that ghost pad</li>\n</ul>\n<p>This allows reducing the code to the minimum for applications wishing to\nencode a source for a given profile:</p>\n<pre><code class=\"language-c\">encbin = gst_element_factory_make (\"encodebin, NULL);\ng_object_set (encbin, \"profile\", \"N900/H264 HQ\", NULL);\ngst_element_link (encbin, filesink);\n\nvsrcpad = gst_element_get_src_pad (source, \"src1\");\nvsinkpad = gst_element_get_request_pad (encbin, \"video\\_%u\");\ngst_pad_link (vsrcpad, vsinkpad);\n</code></pre>\n<h3 id=\"explanation-of-the-various-stages-in-encodebin\">Explanation of the Various stages in EncodeBin</h3>\n<p>This describes the various stages which can happen in order to end up\nwith a multiplexed stream that can then be stored or streamed.</p>\n<h4 id=\"incoming-streams\">Incoming streams</h4>\n<p>The streams fed to EncodeBin can be of various types:</p>\n<ul>\n<li>Video</li>\n<li>Uncompressed (but maybe subsampled)</li>\n<li>Compressed</li>\n<li>Audio</li>\n<li>Uncompressed (audio/x-raw)</li>\n<li>Compressed</li>\n<li>Timed text</li>\n<li>Private streams</li>\n</ul>\n<h4 id=\"steps-involved-for-raw-video-encoding\">Steps involved for raw video encoding</h4>\n<ol start=\"0\">\n<li>\n<p>Incoming Stream</p>\n</li>\n<li>\n<p>Transform raw video feed (optional)</p>\n</li>\n</ol>\n<p>Here we modify the various fundamental properties of a raw video stream\nto be compatible with the intersection of: * The encoder <code>GstCaps</code> and *\nThe specified \"Stream Restriction\" of the profile/target</p>\n<p>The fundamental properties that can be modified are: * width/height\nThis is done with a video scaler. The DAR (Display Aspect Ratio) MUST be\nrespected. If needed, black borders can be added to comply with the\ntarget DAR. * framerate * format/colorspace/depth All of this is done\nwith a colorspace converter</p>\n<ol start=\"2\">\n<li>Actual encoding (optional for raw streams)</li>\n</ol>\n<p>An encoder (with some optional settings) is used.</p>\n<ol start=\"3\">\n<li>Muxing</li>\n</ol>\n<p>A muxer (with some optional settings) is used.</p>\n<ol start=\"4\">\n<li>Outgoing encoded and muxed stream</li>\n</ol>\n<h4 id=\"steps-involved-for-raw-audio-encoding\">Steps involved for raw audio encoding</h4>\n<p>This is roughly the same as for raw video, expect for (1)</p>\n<ol>\n<li>Transform raw audo feed (optional)</li>\n</ol>\n<p>We modify the various fundamental properties of a raw audio stream to be\ncompatible with the intersection of: * The encoder <code>GstCaps</code> and * The\nspecified \"Stream Restriction\" of the profile/target</p>\n<p>The fundamental properties that can be modifier are: * Number of\nchannels * Type of raw audio (integer or floating point) * Depth\n(number of bits required to encode one sample)</p>\n<h4 id=\"steps-involved-for-encoded-audiovideo-streams\">Steps involved for encoded audio/video streams</h4>\n<p>Steps (1) and (2) are replaced by a parser if a parser is available for\nthe given format.</p>\n<h4 id=\"steps-involved-for-other-streams\">Steps involved for other streams</h4>\n<p>Other streams will just be forwarded as-is to the muxer, provided the\nmuxer accepts the stream type.</p>\n<h2 id=\"encoding-profile-system\">Encoding Profile System</h2>\n<p>This work is based on:</p>\n<ul>\n<li>\n<p>The existing <a href=\"http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer/html/GstPreset.html\">GstPreset API documentation</a> system for elements</p>\n</li>\n<li>\n<p>The gnome-media <a href=\"http://www.gnome.org/%7Ebmsmith/gconf-docs/C/gnome-media.html\">GConf audio profile system</a></p>\n</li>\n<li>\n<p>The investigation done into device profiles by Arista and\nTransmageddon: <a href=\"http://gstreamer.freedesktop.org/wiki/DeviceProfile\" title=\"FIXME: wiki is gone\">Research on a Device Profile API</a>,\nand <a href=\"http://gstreamer.freedesktop.org/wiki/PresetDesign\" title=\"FIXME: wiki is gone\">Research on defining presets usage</a>.</p>\n</li>\n</ul>\n<h3 id=\"terminology\">Terminology</h3>\n<ul>\n<li>Encoding Target Category A Target Category is a classification of\ndevices/systems/use-cases for encoding.</li>\n</ul>\n<p>Such a classification is required in order for: * Applications with a\nvery-specific use-case to limit the number of profiles they can offer\nthe user. A screencasting application has no use with the online\nservices targets for example. * Offering the user some initial\nclassification in the case of a more generic encoding application (like\na video editor or a transcoder).</p>\n<p>Ex: Consumer devices Online service Intermediate Editing Format\nScreencast Capture Computer</p>\n<ul>\n<li>\n<p>Encoding Profile Target A Profile Target describes a specific entity\nfor which we wish to encode. A Profile Target must belong to at\nleast one Target Category. It will define at least one Encoding\nProfile.</p>\n<p>Examples (with category): Nokia N900 (Consumer device) Sony PlayStation 3\n(Consumer device) Youtube (Online service) DNxHD (Intermediate editing\nformat) HuffYUV (Screencast) Theora (Computer)</p>\n</li>\n<li>\n<p>Encoding Profile A specific combination of muxer, encoders, presets\nand limitations.</p>\n<p>Examples: Nokia N900/H264 HQ, Ipod/High Quality, DVD/Pal,\nYoutube/High Quality HTML5/Low Bandwith, DNxHD</p>\n</li>\n</ul>\n<h3 id=\"encoding-profile\">Encoding Profile</h3>\n<p>An encoding profile requires the following information:</p>\n<ul>\n<li>Name This string is not translatable and must be unique. A\nrecommendation to guarantee uniqueness of the naming could be:\n<target>/<name></name></target></li>\n<li>Description This is a translatable string describing the profile</li>\n<li>Muxing format This is a string containing the GStreamer media-type\nof the container format.</li>\n<li>Muxing preset This is an optional string describing the preset(s) to\nuse on the muxer.</li>\n<li>Multipass setting This is a boolean describing whether the profile\nrequires several passes.</li>\n<li>List of Stream Profile</li>\n</ul>\n<p>2.3.1 Stream Profiles</p>\n<p>A Stream Profile consists of:</p>\n<ul>\n<li>Type The type of stream profile (audio, video, text, private-data)</li>\n<li>Encoding Format This is a string containing the GStreamer media-type\nof the encoding format to be used. If encoding is not to be applied,\nthe raw audio media type will be used.</li>\n<li>Encoding preset This is an optional string describing the preset(s)\nto use on the encoder.</li>\n<li>Restriction This is an optional GstCaps containing the restriction\nof the stream that can be fed to the encoder. This will generally\ncontaining restrictions in video width/heigh/framerate or audio\ndepth.</li>\n<li>presence This is an integer specifying how many streams can be used\nin the containing profile. 0 means that any number of streams can be\nused.</li>\n<li>pass This is an integer which is only meaningful if the multipass\nflag has been set in the profile. If it has been set it indicates\nwhich pass this Stream Profile corresponds to.</li>\n</ul>\n<h3 id=\"24-example-profile\">2.4 Example profile</h3>\n<p>The representation used here is XML only as an example. No decision is\nmade as to which formatting to use for storing targets and profiles.</p>\n<pre><code>&lt;gst-encoding-target&gt;\n      &lt;name&gt;Nokia N900&lt;/name&gt;\n      &lt;category&gt;Consumer Device&lt;/category&gt;\n      &lt;profiles&gt;\n        &lt;profile&gt;Nokia N900/H264 HQ&lt;/profile&gt;\n        &lt;profile&gt;Nokia N900/MP3&lt;/profile&gt;\n        &lt;profile&gt;Nokia N900/AAC&lt;/profile&gt;\n      &lt;/profiles&gt;\n    &lt;/gst-encoding-target&gt;\n    \n    &lt;gst-encoding-profile&gt;\n      &lt;name&gt;Nokia N900/H264 HQ&lt;/name&gt;\n      &lt;description&gt;\n        High Quality H264/AAC for the Nokia N900\n      &lt;/description&gt;\n      &lt;format&gt;video/quicktime,variant=iso&lt;/format&gt;\n      &lt;streams&gt;\n        &lt;stream-profile&gt;\n          &lt;type&gt;audio&lt;/type&gt;\n          &lt;format&gt;audio/mpeg,mpegversion=4&lt;/format&gt;\n          &lt;preset&gt;Quality High/Main&lt;/preset&gt;\n          &lt;restriction&gt;audio/x-raw,channels=[1,2]&lt;/restriction&gt;\n          &lt;presence&gt;1&lt;/presence&gt;\n        &lt;/stream-profile&gt;\n        &lt;stream-profile&gt;\n          &lt;type&gt;video&lt;/type&gt;\n          &lt;format&gt;video/x-h264&lt;/format&gt;\n          &lt;preset&gt;Profile Baseline/Quality High&lt;/preset&gt;\n          &lt;restriction&gt;\n            video/x-raw,width=[16, 800],\\\n\t    height=[16, 480],framerate=[1/1, 30000/1001]\n          &lt;/restriction&gt;\n          &lt;presence&gt;1&lt;/presence&gt;\n        &lt;/stream-profile&gt;\n      &lt;/streams&gt;  \n    &lt;/gst-encoding-profile&gt;\n</code></pre>\n<h3 id=\"api\">API</h3>\n<p>A proposed C API is contained in the gstprofile.h file in this\ndirectory.</p>\n<h3 id=\"modifications-required-in-the-existing-gstpreset-system\">Modifications required in the existing GstPreset system</h3>\n<h4 id=\"temporary-preset\">Temporary preset.</h4>\n<p>Currently a preset needs to be saved on disk in order to be used.</p>\n<p>This makes it impossible to have temporary presets (that exist only\nduring the lifetime of a process), which might be required in the new\nproposed profile system</p>\n<h4 id=\"categorisation-of-presets\">Categorisation of presets.</h4>\n<p>Currently presets are just aliases of a group of property/value without\nany meanings or explanation as to how they exclude each other.</p>\n<p>Take for example the H264 encoder. It can have presets for: * passes\n(1,2 or 3 passes) * profiles (Baseline, Main, ...) * quality (Low,\nmedium, High)</p>\n<p>In order to programmatically know which presets exclude each other, we\nhere propose the categorisation of these presets.</p>\n<p>This can be done in one of two ways 1. in the name (by making the name\nbe [<category>:]<name>) This would give for example: \"Quality:High\",\n\"Profile:Baseline\" 2. by adding a new _meta key This would give for\nexample: _meta/category:quality</name></category></p>\n<h4 id=\"aggregation-of-presets\">Aggregation of presets.</h4>\n<p>There can be more than one choice of presets to be done for an element\n(quality, profile, pass).</p>\n<p>This means that one can not currently describe the full configuration of\nan element with a single string but with many.</p>\n<p>The proposal here is to extend the <code>GstPreset</code> API to be able to set all\npresets using one string and a well-known separator ('/').</p>\n<p>This change only requires changes in the core preset handling code.</p>\n<p>This would allow doing the following: <code>gst_preset_load_preset (h264enc, \"pass:1/profile:baseline/quality:high\")</code></p>\n<h3 id=\"points-to-be-determined\">Points to be determined</h3>\n<p>This document hasn't determined yet how to solve the following problems:</p>\n<h4 id=\"storage-of-profiles\">Storage of profiles</h4>\n<p>One proposal for storage would be to use a system wide directory (like\n$prefix/share/gstreamer-0.10/profiles) and store XML files for every\nindividual profiles.</p>\n<p>Users could then add their own profiles in ~/.gstreamer-0.10/profiles</p>\n<p>This poses some limitations as to what to do if some applications want\nto have some profiles limited to their own usage.</p>\n<h2 id=\"helper-library-for-profiles\">Helper library for profiles</h2>\n<p>These helper methods could also be added to existing libraries (like\n<code>GstPreset</code>, GstPbUtils, ..).</p>\n<p>The various API proposed are in the accompanying gstprofile.h file.</p>\n<h3 id=\"getting-userreadable-names-for-formats\">Getting user-readable names for formats</h3>\n<p>This is already provided by GstPbUtils.</p>\n<h3 id=\"hierarchy-of-profiles\">Hierarchy of profiles</h3>\n<p>The goal is for applications to be able to present to the user a list of\ncombo-boxes for choosing their output profile:</p>\n<p>[ Category ] # optional, depends on the application [ Device/Site/..\n] # optional, depends on the application [ Profile ]</p>\n<p>Convenience methods are offered to easily get lists of categories,\ndevices, and profiles.</p>\n<h3 id=\"creating-profiles\">Creating Profiles</h3>\n<p>The goal is for applications to be able to easily create profiles.</p>\n<p>The applications needs to be able to have a fast/efficient way to: *\nselect a container format and see all compatible streams he can use with\nit. * select a codec format and see which container formats he can use\nwith it.</p>\n<p>The remaining parts concern the restrictions to encoder input.</p>\n<h3 id=\"ensuring-availability-of-plugins-for-profiles\">Ensuring availability of plugins for Profiles</h3>\n<p>When an application wishes to use a Profile, it should be able to query\nwhether it has all the needed plugins to use it.</p>\n<p>This part will use GstPbUtils to query, and if needed install the\nmissing plugins through the installed distribution plugin installer.</p>\n<h2 id=\"usecases-researched\">Use-cases researched</h2>\n<p>This is a list of various use-cases where encoding/muxing is being used.</p>\n<h3 id=\"transcoding\">Transcoding</h3>\n<p>The goal is to convert with as minimal loss of quality any input file\nfor a target use. A specific variant of this is transmuxing (see below).</p>\n<p>Example applications: Arista, Transmageddon</p>\n<h3 id=\"rendering-timelines\">Rendering timelines</h3>\n<p>The incoming streams are a collection of various segments that need to\nbe rendered. Those segments can vary in nature (i.e. the video\nwidth/height can change). This requires the use of identiy with the\nsingle-segment property activated to transform the incoming collection\nof segments to a single continuous segment.</p>\n<p>Example applications: PiTiVi, Jokosher</p>\n<h3 id=\"encoding-of-live-sources\">Encoding of live sources</h3>\n<p>The major risk to take into account is the encoder not encoding the\nincoming stream fast enough. This is outside of the scope of encodebin,\nand should be solved by using queues between the sources and encodebin,\nas well as implementing QoS in encoders and sources (the encoders\nemitting QoS events, and the upstream elements adapting themselves\naccordingly).</p>\n<p>Example applications: camerabin, cheese</p>\n<h3 id=\"screencasting-applications\">Screencasting applications</h3>\n<p>This is similar to encoding of live sources. The difference being that\ndue to the nature of the source (size and amount/frequency of updates)\none might want to do the encoding in two parts: * The actual live\ncapture is encoded with a 'almost-lossless' codec (such as huffyuv) *\nOnce the capture is done, the file created in the first step is then\nrendered to the desired target format.</p>\n<p>Fixing sources to only emit region-updates and having encoders capable\nof encoding those streams would fix the need for the first step but is\noutside of the scope of encodebin.</p>\n<p>Example applications: Istanbul, gnome-shell, recordmydesktop</p>\n<h3 id=\"live-transcoding\">Live transcoding</h3>\n<p>This is the case of an incoming live stream which will be\nbroadcasted/transmitted live. One issue to take into account is to\nreduce the encoding latency to a minimum. This should mostly be done by\npicking low-latency encoders.</p>\n<p>Example applications: Rygel, Coherence</p>\n<h3 id=\"transmuxing\">Transmuxing</h3>\n<p>Given a certain file, the aim is to remux the contents WITHOUT decoding\ninto either a different container format or the same container format.\nRemuxing into the same container format is useful when the file was not\ncreated properly (for example, the index is missing). Whenever\navailable, parsers should be applied on the encoded streams to validate\nand/or fix the streams before muxing them.</p>\n<p>Metadata from the original file must be kept in the newly created file.</p>\n<p>Example applications: Arista, Transmaggedon</p>\n<h3 id=\"lossless-cutting\">Loss-less cutting</h3>\n<p>Given a certain file, the aim is to extract a certain part of the file\nwithout going through the process of decoding and re-encoding that file.\nThis is similar to the transmuxing use-case.</p>\n<p>Example applications: PiTiVi, Transmageddon, Arista, ...</p>\n<h3 id=\"multipass-encoding\">Multi-pass encoding</h3>\n<p>Some encoders allow doing a multi-pass encoding. The initial pass(es)\nare only used to collect encoding estimates and are not actually muxed\nand outputted. The final pass uses previously collected information, and\nthe output is then muxed and outputted.</p>\n<h3 id=\"archiving-and-intermediary-format\">Archiving and intermediary format</h3>\n<p>The requirement is to have lossless</p>\n<h3 id=\"cd-ripping\">CD ripping</h3>\n<p>Example applications: Sound-juicer</p>\n<h3 id=\"dvd-ripping\">DVD ripping</h3>\n<p>Example application: Thoggen</p>\n<h3 id=\"research-links\">Research links</h3>\n<p>Some of these are still active documents, some other not</p>\n\n        \n\n    </div>\n\n\n        "});