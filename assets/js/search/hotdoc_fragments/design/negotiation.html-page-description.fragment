fragment_downloaded_cb({"url": "design/negotiation.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"negotiation.md\">\n<h1 id=\"negotiation\">Negotiation</h1>\n<p>Capabilities negotiation is the process of deciding on an adequate\nformat for dataflow within a GStreamer pipeline. Ideally, negotiation\n(also known as \"capsnego\") transfers information from those parts of the\npipeline that have information to those parts of the pipeline that are\nflexible, constrained by those parts of the pipeline that are not\nflexible.</p>\n<h2 id=\"basic-rules\">Basic rules</h2>\n<p>These simple rules must be followed:</p>\n<ol>\n<li>downstream suggests formats</li>\n<li>upstream decides on format</li>\n</ol>\n<p>There are 4 queries/events used in caps negotiation:</p>\n<ol>\n<li><code>GST_QUERY_CAPS</code>: get possible formats</li>\n<li><code>GST_QUERY_ACCEPT_CAPS</code>: check if format is possible</li>\n<li><code>GST_EVENT_CAPS</code>: configure format (downstream)</li>\n<li><code>GST_EVENT_RECONFIGURE</code>: inform upstream of possibly new caps</li>\n</ol>\n<h2 id=\"queries\">Queries</h2>\n<p>A pad can ask the peer pad for its supported <code>GstCaps</code>. It does this with\nthe CAPS query. The list of supported caps can be used to choose an\nappropriate <code>GstCaps</code> for the data transfer. The CAPS query works\nrecursively, elements should take their peers into consideration when\nconstructing the possible caps. Because the result caps can be very\nlarge, a filter can be used to restrict the caps. Only the caps that\nmatch the filter will be returned as the result caps. The order of the\nfilter caps gives the order of preference of the caller and should be\ntaken into account for the returned caps.</p>\n<ul>\n<li><strong><code>filter</code></strong> (in) <code>GST_TYPE_CAPS</code> (default NULL): - a <code>GstCaps</code> to filter the results against</li>\n<li><strong><code>caps</code></strong> (out) <code>GST_TYPE_CAPS</code> (default NULL): - the result caps</li>\n</ul>\n<p>A pad can ask the peer pad if it supports a given caps. It does this\nwith the <code>ACCEPT_CAPS</code> query. The caps must be fixed. The <code>ACCEPT_CAPS</code>\nquery is not required to work recursively, it can simply return TRUE if\na subsequent CAPS event with those caps would return success.</p>\n<ul>\n<li><strong><code>caps</code></strong> (in) <code>GST_TYPE_CAPS</code>: - a <code>GstCaps</code> to check, must be fixed</li>\n<li><strong><code>result</code></strong> (out) <code>G_TYPE_BOOLEAN</code> (default FALSE): - TRUE if the caps are accepted</li>\n</ul>\n<h2 id=\"events\">Events</h2>\n<p>When a media format is negotiated, peer elements are notified of the\n<code>GstCaps</code> with the CAPS event. The caps must be fixed.</p>\n<ul>\n<li><strong><code>caps</code></strong> <code>GST_TYPE_CAPS</code>: - the negotiated <code>GstCaps</code>, must be fixed</li>\n</ul>\n<h2 id=\"operation\">Operation</h2>\n<p>GStreamer\u2019s two scheduling modes, push mode and pull mode, lend\nthemselves to different mechanisms to achieve this goal. As it is more\ncommon we describe push mode negotiation first.</p>\n<h3 id=\"pushmode-negotiation\">Push-mode negotiation</h3>\n<p>Push-mode negotiation happens when elements want to push buffers and\nneed to decide on the format. This is called downstream negotiation\nbecause the upstream element decides the format for the downstream\nelement. This is the most common case.</p>\n<p>Negotiation can also happen when a downstream element wants to receive\nanother data format from an upstream element. This is called upstream\nnegotiation.</p>\n<p>The basics of negotiation are as follows:</p>\n<ul>\n<li>\n<p><code>GstCaps</code> (see <a href=\"caps.html\">caps</a>) are refcounted before they are pushed as\nan event to describe the contents of the following buffer.</p>\n</li>\n<li>\n<p>An element should reconfigure itself to the new format received as a\nCAPS event before processing the following buffers. If the data type\nin the caps event is not acceptable, the element should refuse the\nevent. The element should also refuse the next buffers by returning\nan appropriate <code>GST_FLOW_NOT_NEGOTIATED</code> return value from the\nchain function.</p>\n</li>\n<li>\n<p>Downstream elements can request a format change of the stream by\nsending a RECONFIGURE event upstream. Upstream elements will\nrenegotiate a new format when they receive a RECONFIGURE event.</p>\n</li>\n</ul>\n<p>The general flow for a source pad starting the negotiation.</p>\n<pre><code>            src              sink\n             |                 |\n             |  querycaps?     |\n             |----------------&gt;|\n             |     caps        |\nselect caps  |&lt; - - - - - - - -|\nfrom the     |                 |\ncandidates   |                 |\n             |                 |-.\n             |  accepts?       | |\n type A      |----------------&gt;| | optional\n             |      yes        | |\n             |&lt; - - - - - - - -| |\n             |                 |-'\n             |  send_event()   |\nsend CAPS    |----------------&gt;| Receive type A, reconfigure to\nevent A      |                 | process type A.\n             |                 |\n             |  push           |\npush buffer  |----------------&gt;| Process buffer of type A\n             |                 |\n</code></pre>\n<p>One possible implementation in pseudo code:</p>\n<pre><code>    [element wants to create a buffer]\n    if not format\n      # see what we can do\n      ourcaps = gst_pad_query_caps (srcpad)\n      # see what the peer can do filtered against our caps\n      candidates = gst_pad_peer_query_caps (srcpad, ourcaps)\n\n    foreach candidate in candidates\n      # make sure the caps is fixed\n      fixedcaps = gst_pad_fixate_caps (srcpad, candidate)\n\n    # see if the peer accepts it\n    if gst_pad_peer_accept_caps (srcpad, fixedcaps)\n      # store the caps as the negotiated caps, this will\n      # call the setcaps function on the pad\n      gst_pad_push_event (srcpad, gst_event_new_caps (fixedcaps))\n      break\n    endif\n  done\nendif\n</code></pre>\n<h4 id=\"negotiate-allocatorbufferpool-with-the-allocation-query\">Negotiate allocator/bufferpool with the ALLOCATION query</h4>\n<pre><code>    buffer = gst_buffer_new_allocate (NULL, size, 0);\n    # fill buffer and push\n</code></pre>\n<p>The general flow for a sink pad starting a renegotiation.</p>\n<pre><code>            src              sink\n             |                 |\n             |  accepts?       |\n             |&lt;----------------| type B\n             |      yes        |\n             |- - - - - - - - &gt;|-.\n             |                 | | suggest B caps next\n             |                 |&lt;'\n             |                 |\n             |   push_event()  |\n mark      .-|&lt;----------------| send RECONFIGURE event\nrenegotiate| |                 |\n           '&gt;|                 |\n             |  querycaps()    |\nrenegotiate  |----------------&gt;|\n             |  suggest B      |\n             |&lt; - - - - - - - -|\n             |                 |\n             |  send_event()   |\nsend CAPS    |----------------&gt;| Receive type B, reconfigure to\nevent B      |                 | process type B.\n             |                 |\n             |  push           |\npush buffer  |----------------&gt;| Process buffer of type B\n             |                 |\n</code></pre>\n<h4 id=\"use-cases\">Use cases:</h4>\n<h5 id=\"videotestsrc-xvimagesink\"><code>videotestsrc ! xvimagesink</code></h5>\n<ul>\n<li>\n<p>Who decides what format to use?</p>\n<ul>\n<li>src pad always decides, by convention. sinkpad can suggest a format\nby putting it high in the caps query result <code>GstCaps</code>.</li>\n<li>since the src decides, it can always choose something that it can do,\nso this step can only fail if the sinkpad stated it could accept\nsomething while later on it couldn't.</li>\n</ul>\n</li>\n<li>\n<p>When does negotiation happen?</p>\n<ul>\n<li>before srcpad does a push, it figures out a type as stated in 1), then\nit pushes a caps event with the type. The sink checks the media type and\nconfigures itself for this type.</li>\n<li>the source then usually does an <code>ALLOCATION</code> query to negotiate a\nbufferpool with the sink. It then allocates a buffer from the pool and\npushes it to the sink. Since the sink accepted the caps, it can create a\npool for the format.</li>\n<li>since the sink stated in 1) it could accept the type, it will be able to\nhandle it.</li>\n</ul>\n</li>\n<li>\n<p>How can sink request another format?</p>\n<ul>\n<li>sink asks if new format is possible for the source.</li>\n<li>sink pushes <code>RECONFIGURE</code> event upstream</li>\n<li>src receives the <code>RECONFIGURE</code> event and marks renegotiation</li>\n<li>On the next buffer push, the source renegotiates the caps and the\nbufferpool. The sink will put the new new preferred format high in the list\nof caps it returns from its caps query.</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"videotestsrc-queue-xvimagesink\"><code>videotestsrc ! queue ! xvimagesink</code></h5>\n<ul>\n<li>queue proxies all accept and caps queries to the other peer pad.</li>\n<li>queue proxies the bufferpool</li>\n<li>queue proxies the <code>RECONFIGURE</code> event</li>\n<li>queue stores <code>CAPS</code> event in the queue. This means that the queue can\ncontain buffers with different types.</li>\n</ul>\n<h3 id=\"pullmode-negotiation\">Pull-mode negotiation</h3>\n<p>A pipeline in pull mode has different negotiation needs than one\nactivated in push mode. Push mode is optimized for two use cases:</p>\n<ul>\n<li>\n<p>Playback of media files, in which the demuxers and the decoders are\nthe points from which format information should disseminate to the\nrest of the pipeline; and</p>\n</li>\n<li>\n<p>Recording from live sources, in which users are accustomed to\nputting a capsfilter directly after the source element; thus the\ncaps information flow proceeds from the user, through the potential\ncaps of the source, to the sinks of the pipeline.</p>\n</li>\n</ul>\n<p>In contrast, pull mode has other typical use cases:</p>\n<ul>\n<li>\n<p>Playback from a lossy source, such as RTP, in which more knowledge\nabout the latency of the pipeline can increase quality; or</p>\n</li>\n<li>\n<p>Audio synthesis, in which audio APIs are tuned to produce only the\nnecessary number of samples, typically driven by a hardware\ninterrupt to fill a DMA buffer or a Jack[0] port buffer.</p>\n</li>\n<li>\n<p>Low-latency effects processing, whereby filters should be applied as\ndata is transferred from a ring buffer to a sink instead of\nbeforehand. For example, instead of using the internal alsasink\nringbuffer thread in push-mode wavsrc ! volume ! alsasink, placing\nthe volume inside the sound card writer thread via wavsrc !\naudioringbuffer ! volume ! alsasink.</p>\n</li>\n</ul>\n<p>[0] <a href=\"http://jackit.sf.net\">http://jackit.sf.net</a></p>\n<p>The problem with pull mode is that the sink has to know the format in\norder to know how many bytes to pull via <code>gst_pad_pull_range()</code>. This\nmeans that before pulling, the sink must initiate negotation to decide\non a format.</p>\n<p>Recalling the principles of capsnego, whereby information must flow from\nthose that have it to those that do not, we see that the three named use\ncases have different negotiation requirements:</p>\n<ul>\n<li>\n<p>RTP and low-latency playback are both like the normal playback case,\nin which information flows downstream.</p>\n</li>\n<li>\n<p>In audio synthesis, the part of the pipeline that has the most\ninformation is the sink, constrained by the capabilities of the\ngraph that feeds it. However the caps are not completely specified;\nat some point the user has to intervene to choose the sample rate,\nat least. This can be done externally to gstreamer, as in the jack\nelements, or internally via a capsfilter, as is customary with live\nsources.</p>\n</li>\n</ul>\n<p>Given that sinks potentially need the input of sources, as in the RTP\ncase and at least as a filter in the synthesis case, there must be a\nnegotiation phase before the pull thread is activated. Also, given the\nlow latency offered by pull mode, we want to avoid capsnego from within\nthe pulling thread, in case it causes us to miss our scheduling\ndeadlines.</p>\n<p>The pull thread is usually started in the <code>PAUSED\u2192PLAYING</code> state change.\nWe must be able to complete the negotiation before this state change\nhappens.</p>\n<p>The time to do capsnego, then, is after the <code>SCHEDULING</code> query has\nsucceeded, but before the sink has spawned the pulling thread.</p>\n<h4 id=\"mechanism\">Mechanism</h4>\n<p>The sink determines that the upstream elements support pull based\nscheduling by doing a <code>SCHEDULING</code> query.</p>\n<p>The sink initiates the negotiation process by intersecting the results\nof <code>gst_pad_query_caps()</code> on its sink pad and its peer src pad. This is\nthe operation performed by <code>gst_pad_get_allowed_caps()</code> In the simple\npassthrough case, the peer pad\u2019s caps query should return the\nintersection of calling <code>get_allowed_caps()</code> on all of its sink pads. In\nthis way the sink element knows the capabilities of the entire pipeline.</p>\n<p>The sink element then fixates the resulting caps, if necessary,\nresulting in the flow caps. From now on, the caps query of the sinkpad\nwill only return these fixed caps meaning that upstream elements will\nonly be able to produce this format.</p>\n<p>If the sink element could not set caps on its sink pad, it should post\nan error message on the bus indicating that negotiation was not\npossible.</p>\n<p>When negotiation succeeded, the sinkpad and all upstream internally\nlinked pads are activated in pull mode. Typically, this operation will\ntrigger negotiation on the downstream elements, which will now be forced\nto negotiate to the final fixed desired caps of the sinkpad.</p>\n<p>After these steps, the sink element returns <code>ASYNC</code> from the state change\nfunction. The state will commit to <code>PAUSED</code> when the first buffer is\nreceived in the sink. This is needed to provide a consistent API to the\napplications that expect <code>ASYNC</code> return values from sinks but it also\nallows us to perform the remainder of the negotiation outside of the\ncontext of the pulling thread.</p>\n<h3 id=\"patterns\">Patterns</h3>\n<p>We can identify 3 patterns in negotiation:</p>\n<ul>\n<li>\n<p>Fixed\u00a0: Can't choose the output format</p>\n<ul>\n<li>Caps encoded in the stream</li>\n<li>A video/audio decoder</li>\n<li>usually uses <code>gst_pad_use_fixed_caps()</code></li>\n</ul>\n</li>\n<li>\n<p>Transform</p>\n<ul>\n<li>Caps not modified (passthrough)</li>\n<li>can do caps transform based on element property</li>\n<li>fixed caps get transformed into fixed caps</li>\n<li>videobox</li>\n</ul>\n</li>\n<li>\n<p>Dynamic\u00a0: can choose output format</p>\n<ul>\n<li>A converter element</li>\n<li>depends on downstream caps, needs to do a CAPS query to find\ntransform.</li>\n<li>usually prefers to use the identity transform</li>\n<li>fixed caps can be transformed into unfixed caps.</li>\n</ul>\n</li>\n</ul>\n\n</div>\n\n\n        "});