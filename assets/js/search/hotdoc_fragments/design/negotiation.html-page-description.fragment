fragment_downloaded_cb({"url": "design/negotiation.html#page-description", "fragment": "Capabilities negotiation is the process of deciding on an adequate format for dataflow within a GStreamer pipeline. Ideally negotiation also known as capsnego transfers information from those parts of the pipeline that have information to those parts of the pipeline that are flexible constrained by those parts of the pipeline that are not flexible. \nThese simple rules must be followed \nThere are queries events used in caps negotiation \nA pad can ask the peer pad for its supported GstCaps. It does this with the CAPS query. The list of supported caps can be used to choose an appropriate GstCaps for the data transfer. The CAPS query works recursively elements should take their peers into consideration when constructing the possible caps. Because the result caps can be very large a filter can be used to restrict the caps. Only the caps that match the filter will be returned as the result caps. The order of the filter caps gives the order of preference of the caller and should be taken into account for the returned caps. \nA pad can ask the peer pad if it supports a given caps. It does this with the ACCEPT_CAPS query. The caps must be fixed. The ACCEPT_CAPS query is not required to work recursively it can simply return TRUE if a subsequent CAPS event with those caps would return success. \nWhen a media format is negotiated peer elements are notified of the GstCaps with the CAPS event. The caps must be fixed. \nGStreamer s two scheduling modes push mode and pull mode lend themselves to different mechanisms to achieve this goal. As it is more common we describe push mode negotiation first. \nPush mode negotiation happens when elements want to push buffers and need to decide on the format. This is called downstream negotiation because the upstream element decides the format for the downstream element. This is the most common case. \nNegotiation can also happen when a downstream element wants to receive another data format from an upstream element. This is called upstream negotiation. \nThe basics of negotiation are as follows \nGstCaps see caps are refcounted before they are pushed as an event to describe the contents of the following buffer. \nAn element should reconfigure itself to the new format received as a CAPS event before processing the following buffers. If the data type in the caps event is not acceptable the element should refuse the event. The element should also refuse the next buffers by returning an appropriate GST_FLOW_NOT_NEGOTIATED return value from the chain function. \nDownstream elements can request a format change of the stream by sending a RECONFIGURE event upstream. Upstream elements will renegotiate a new format when they receive a RECONFIGURE event. \nThe general flow for a source pad starting the negotiation. \nOne possible implementation in pseudo code \nThe general flow for a sink pad starting a renegotiation. \nWho decides what format to use \nWhen does negotiation happen \nHow can sink request another format \nA pipeline in pull mode has different negotiation needs than one activated in push mode. Push mode is optimized for two use cases \nPlayback of media files in which the demuxers and the decoders are the points from which format information should disseminate to the rest of the pipeline and \nRecording from live sources in which users are accustomed to putting a capsfilter directly after the source element thus the caps information flow proceeds from the user through the potential caps of the source to the sinks of the pipeline. \nIn contrast pull mode has other typical use cases \nPlayback from a lossy source such as RTP in which more knowledge about the latency of the pipeline can increase quality or \nAudio synthesis in which audio APIs are tuned to produce only the necessary number of samples typically driven by a hardware interrupt to fill a DMA buffer or a Jack port buffer. \nLow latency effects processing whereby filters should be applied as data is transferred from a ring buffer to a sink instead of beforehand. For example instead of using the internal alsasink ringbuffer thread in push mode wavsrc volume alsasink placing the volume inside the sound card writer thread via wavsrc audioringbuffer volume alsasink. \nhttp jackit.sf.net \nThe problem with pull mode is that the sink has to know the format in order to know how many bytes to pull via gst_pad_pull_range This means that before pulling the sink must initiate negotation to decide on a format. \nRecalling the principles of capsnego whereby information must flow from those that have it to those that do not we see that the three named use cases have different negotiation requirements \nRTP and low latency playback are both like the normal playback case in which information flows downstream. \nIn audio synthesis the part of the pipeline that has the most information is the sink constrained by the capabilities of the graph that feeds it. However the caps are not completely specified at some point the user has to intervene to choose the sample rate at least. This can be done externally to gstreamer as in the jack elements or internally via a capsfilter as is customary with live sources. \nGiven that sinks potentially need the input of sources as in the RTP case and at least as a filter in the synthesis case there must be a negotiation phase before the pull thread is activated. Also given the low latency offered by pull mode we want to avoid capsnego from within the pulling thread in case it causes us to miss our scheduling deadlines. \nThe pull thread is usually started in the PAUSED PLAYING state change. We must be able to complete the negotiation before this state change happens. \nThe time to do capsnego then is after the SCHEDULING query has succeeded but before the sink has spawned the pulling thread. \nThe sink determines that the upstream elements support pull based scheduling by doing a SCHEDULING query. \nThe sink initiates the negotiation process by intersecting the results of gst_pad_query_caps on its sink pad and its peer src pad. This is the operation performed by gst_pad_get_allowed_caps In the simple passthrough case the peer pad s caps query should return the intersection of calling get_allowed_caps on all of its sink pads. In this way the sink element knows the capabilities of the entire pipeline. \nThe sink element then fixates the resulting caps if necessary resulting in the flow caps. From now on the caps query of the sinkpad will only return these fixed caps meaning that upstream elements will only be able to produce this format. \nIf the sink element could not set caps on its sink pad it should post an error message on the bus indicating that negotiation was not possible. \nWhen negotiation succeeded the sinkpad and all upstream internally linked pads are activated in pull mode. Typically this operation will trigger negotiation on the downstream elements which will now be forced to negotiate to the final fixed desired caps of the sinkpad. \nAfter these steps the sink element returns ASYNC from the state change function. The state will commit to PAUSED when the first buffer is received in the sink. This is needed to provide a consistent API to the applications that expect ASYNC return values from sinks but it also allows us to perform the remainder of the negotiation outside of the context of the pulling thread. \nWe can identify patterns in negotiation \nFixed Can t choose the output format \nTransform \nDynamic can choose output format \n"});