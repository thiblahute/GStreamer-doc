fragment_downloaded_cb({"url": "design/gstghostpad.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"gstghostpad.md\">\n        <h1 id=\"ghostpads\">Ghostpads</h1>\n<p>GhostPads are used to build complex compound elements out of existing\nelements. They are used to expose internal element pads on the complex\nelement.</p>\n<h2 id=\"some-design-requirements\">Some design requirements</h2>\n<ul>\n<li>\n<p>Must look like a real <code>GstPad</code> on both sides.</p>\n</li>\n<li>\n<p>target of Ghostpad must be changeable</p>\n</li>\n<li>\n<p>target can be initially NULL</p>\n</li>\n<li>\n<p>a GhostPad is implemented using a private <code>GstProxyPad</code> class:</p>\n</li>\n</ul>\n<pre><code>GstProxyPad\n(------------------)\n| GstPad           |\n|------------------|\n| GstPad *target   |\n(------------------)\n| GstPad *internal |\n(------------------)\n\nGstGhostPad\n(------------------)   -\\\n| GstPad           |    |\n|------------------|    |\n| GstPad *target   |     &gt; GstProxyPad\n|------------------|    |\n| GstPad *internal |    |\n|------------------|   -/\n| &lt;private data&gt;   |\n(------------------)\n</code></pre>\n<p>A <code>GstGhostPad</code> (X) is <em>always</em> created together with a <code>GstProxyPad</code> (Y).\nThe internal pad pointers are set to point to eachother. The\n<code>GstProxyPad</code> pairs have opposite directions, the <code>GstGhostPad</code> has the same\ndirection as the (future) ghosted pad (target).</p>\n<pre><code>(- X --------)\n|            |\n| target *   |\n|------------|\n| internal *----+\n(------------)  |\n  ^             V\n  |  (- Y --------)\n  |  |            |\n  |  | target *   |\n  |  |------------|\n  +----* internal |\n     (------------)\n\nWhich we will abbreviate to:\n\n(- X --------)\n|            |\n| target *---------&gt;//\n(------------)\n     |\n    (- Y --------)\n    | target *-----&gt;//\n    (------------)\n</code></pre>\n<p>The <code>GstGhostPad</code> (X) is also set as the parent of the <code>GstProxyPad</code> (Y).</p>\n<p>The target is a pointer to the internal pads peer. It is an optimisation to\nquickly get to the peer of a ghostpad without having to dereference the\ninternal-&gt;peer.</p>\n<p>Some use case follow with a description of how the datastructure\nis modified.</p>\n<h2 id=\"creating-a-ghostpad-with-a-target\">Creating a ghostpad with a target:</h2>\n<pre><code>gst_ghost_pad_new (char *name, GstPad *target)\n</code></pre>\n<ol>\n<li>create new GstGhostPad X + GstProxyPad Y</li>\n<li>X name set to @name</li>\n<li>X direction is the same as the target, Y is opposite.</li>\n<li>the target of X is set to @target</li>\n<li>Y is linked to @target</li>\n<li>link/unlink and activate functions are set up\non GstGhostPad.</li>\n</ol>\n<pre><code>                                (--------------\n  (- X --------)                |\n  |            |                |------)\n  | target *------------------&gt; | sink |\n  (------------)       -------&gt; |------)\n       |              /         (--------------\n      (- Y --------) / (pad link)\n//&lt;-----* target   |/\n      (------------)\n</code></pre>\n<ul>\n<li>Automatically takes same direction as target.</li>\n<li>target is filled in automatically.</li>\n</ul>\n<h2 id=\"creating-a-ghostpad-without-a-target\">Creating a ghostpad without a target</h2>\n<pre><code>gst_ghost_pad_new_no_target (char *name, GstPadDirection dir)\n</code></pre>\n<ol>\n<li>create new GstGhostPad X + GstProxyPad Y</li>\n<li>X name set to @name</li>\n<li>X direction is @dir</li>\n<li>link/unlink and activate functions are set up on GstGhostPad.</li>\n</ol>\n<pre><code>(- X --------)\n|            |\n| target *---------&gt;//\n(------------)\n     |\n    (- Y --------)\n    | target *-----&gt;//\n    (------------)\n</code></pre>\n<ul>\n<li>allows for setting the target later</li>\n</ul>\n<h2 id=\"setting-target-on-an-untargetted-unlinked-ghostpad\">Setting target on an untargetted unlinked ghostpad</h2>\n<pre><code>gst_ghost_pad_set_target (char *name, GstPad *newtarget)\n\n(- X --------)\n|            |\n| target *---------&gt;//\n(------------)\n     |\n    (- Y --------)\n    | target *-----&gt;//\n    (------------)\n</code></pre>\n<ol>\n<li>assert direction of newtarget == X direction</li>\n<li>target is set to newtarget</li>\n<li>internal pad Y is linked to newtarget</li>\n</ol>\n<pre><code>                                (--------------\n  (- X --------)                |\n  |            |                |------)\n  | target *------------------&gt; | sink |\n  (------------)       -------&gt; |------)\n       |              /         (--------------\n      (- Y --------) / (pad link)\n//&lt;-----* target   |/\n      (------------)\n</code></pre>\n<h2 id=\"setting-target-on-a-targetted-unlinked-ghostpad\">Setting target on a targetted unlinked ghostpad</h2>\n<pre><code>gst_ghost_pad_set_target (char *name, GstPad *newtarget)\n\n                                (--------------\n  (- X --------)                |\n  |            |                |-------)\n  | target *------------------&gt; | sink1 |\n  (------------)       -------&gt; |-------)\n       |              /         (--------------\n      (- Y --------) / (pad link)\n//&lt;-----* target   |/\n      (------------)\n</code></pre>\n<ol>\n<li>assert direction of newtarget (sink2) == X direction</li>\n<li>unlink internal pad Y and oldtarget</li>\n<li>target is set to newtarget (sink2)</li>\n<li>internal pad Y is linked to newtarget</li>\n</ol>\n<pre><code>                                (--------------\n  (- X --------)                |\n  |            |                |-------)\n  | target *------------------&gt; | sink2 |\n  (------------)       -------&gt; |-------)\n       |              /         (--------------\n      (- Y --------) / (pad link)\n//&lt;-----* target   |/\n      (------------)\n</code></pre>\n<ul>\n<li>Linking a pad to an untargetted ghostpad:</li>\n</ul>\n<pre><code>    gst_pad_link (src, X)\n\n         (- X --------)\n         |            |\n         | target *---------&gt;//\n         (------------)\n              |\n             (- Y --------)\n             | target *-----&gt;//\n             (------------)\n-------)\n       |\n (-----|\n | src |\n (-----|\n-------)\n</code></pre>\n<p>X is a sink <code>GstGhostPad</code> without a target. The internal <code>GstProxyPad</code> Y has\nthe same direction as the src pad (peer).</p>\n<ol>\n<li>link function is called</li>\n</ol>\n<ul>\n<li>\n<p>Y direction is same as @src</p>\n</li>\n<li>\n<p>Y target is set to @src</p>\n</li>\n<li>\n<p>Y is activated in the same mode as X</p>\n</li>\n<li>\n<p>core makes link from @src to X</p>\n<pre><code>```\n                  (- X --------)\n                  |            |\n                  | target *-----&gt;//\n                 &gt;(------------)\n(real pad link) /      |\n               /      (- Y ------)\n              /    -----* target |\n   -------)  /    /   (----------)\n          | /    /\n    (-----|/    /\n    | src |&lt;----\n    (-----|\n   -------)\n```\n</code></pre>\n</li>\n</ul>\n<h2 id=\"linking-a-pad-to-a-targetted-ghostpad\">Linking a pad to a targetted ghostpad:</h2>\n<pre><code>    gst_pad_link (src, X)\n\n                                       (--------\n               (- X --------)          |\n               |            |          |------)\n               | target *-------------&gt;| sink |\n               (------------)         &gt;|------)\n                          |          / (--------\n                          |         /\n                          |        /\n-------)                  |       / (real pad link)\n       |            (- Y ------) /\n (-----|            |          |/\n | src |       //&lt;----* target |\n (-----|            (----------)\n-------)\n</code></pre>\n<ol>\n<li>link function is called</li>\n</ol>\n<ul>\n<li>Y direction is same as @src</li>\n<li>Y target is set to @src</li>\n<li>Y is activated in the same mode as X</li>\n<li>core makes link from @src to X</li>\n</ul>\n<pre><code>                                          (--------\n                  (- X --------)          |\n                  |            |          |------)\n                  | target *-------------&gt;| sink |\n                 &gt;(------------)         &gt;|------)\n(real pad link) /            |          / (--------\n               /             |         /\n              /              |        /\n   -------)  /               |       / (real pad link)\n          | /          (- Y ------) /\n    (-----|/           |          |/\n    | src |&lt;-------------* target |\n    (-----|            (----------)\n   -------)\n</code></pre>\n<h2 id=\"setting-target-on-untargetted-linked-ghostpad\">Setting target on untargetted linked ghostpad:</h2>\n<pre><code>            gst_ghost_pad_set_target (char *name, GstPad *newtarget)\n\n                  (- X --------)\n                  |            |\n                  | target *------&gt;//\n                 &gt;(------------)\n(real pad link) /            |\n               /             |\n              /              |\n   -------)  /               |\n          | /          (- Y ------)\n    (-----|/           |          |\n    | src |&lt;-------------* target |\n    (-----|            (----------)\n   -------)\n</code></pre>\n<ol>\n<li>assert direction of @newtarget == X direction</li>\n<li>X target is set to @newtarget</li>\n<li>Y is linked to @newtarget</li>\n</ol>\n<pre><code>                                          (--------\n                  (- X --------)          |\n                  |            |          |------)\n                  | target *-------------&gt;| sink |\n                 &gt;(------------)         &gt;|------)\n(real pad link) /            |          / (--------\n               /             |         /\n              /              |        /\n   -------)  /               |       / (real pad link)\n          | /          (- Y ------) /\n    (-----|/           |          |/\n    | src |&lt;-------------* target |\n    (-----|            (----------)\n   -------)\n</code></pre>\n<h2 id=\"setting-target-on-targetted-linked-ghostpad\">Setting target on targetted linked ghostpad:</h2>\n<pre><code>    gst_ghost_pad_set_target (char *name, GstPad *newtarget)\n\n                                          (--------\n                  (- X --------)          |\n                  |            |          |-------)\n                  | target *-------------&gt;| sink1 |\n                 &gt;(------------)         &gt;|-------)\n(real pad link) /            |          / (--------\n               /             |         /\n              /              |        /\n   -------)  /               |       / (real pad link)\n          | /          (- Y ------) /\n    (-----|/           |          |/\n    | src |&lt;-------------* target |\n    (-----|            (----------)\n   -------)\n</code></pre>\n<ol>\n<li>assert direction of @newtarget == X direction</li>\n<li>Y and X target are unlinked</li>\n<li>X target is set to @newtarget</li>\n<li>Y is linked to @newtarget</li>\n</ol>\n<pre><code>                                          (--------\n                  (- X --------)          |\n                  |            |          |-------)\n                  | target *-------------&gt;| sink2 |\n                 &gt;(------------)         &gt;|-------)\n(real pad link) /            |          / (--------\n               /             |         /\n              /              |        /\n   -------)  /               |       / (real pad link)\n          | /          (- Y ------) /\n    (-----|/           |          |/\n    | src |&lt;-------------* target |\n    (-----|            (----------)\n   -------)\n</code></pre>\n<h2 id=\"activation\">Activation</h2>\n<p>Sometimes ghost pads should proxy activation functions. This thingie\nattempts to explain how it should work in the different cases.</p>\n<pre><code>    +---+     +----+                             +----+       +----+\n    | A +-----+ B  |                             | C  |-------+ D  |\n    +---+     +---=+                             +=---+       +----+\n                +--=-----------------------------=-+\n                |  +=---+   +----+  +----+  +---=+ |\n                |  | a  +---+ b  ====  c +--+ d  | |\n                |  +----+   +----+  +----+  +----+ |\n                |                                  |\n                +----------------------------------+\n                state change goes from right to left\n       &lt;-----------------------------------------------------------\n</code></pre>\n<p>All of the labeled boxes are pads. The dashes (---) show pad links, and\nthe double-lines (===) are internal connections. The box around a, b, c,\nand d is a bin. B and C are ghost pads, and a and d are proxy pads. The\narrow represents the direction of a state change algorithm. Not counting\nthe bin, there are three elements involved here\u2009\u2014\u2009the parent of D, the\nparent of A, and the parent of b and c.</p>\n<p>Now, in the state change from READY to PAUSED, assuming the pipeline\ndoes not have a live source, all of the pads will end up activated at\nthe end. There are 4 possible activation modes:</p>\n<ol>\n<li>AD and ab in PUSH, cd and CD in PUSH</li>\n<li>AD and ab in PUSH, cd and CD in PULL</li>\n<li>AD and ab in PULL, cd and CD in PUSH</li>\n<li>AD and ab in PULL, cd and CD in PULL</li>\n</ol>\n<p>When activating (1), the state change algorithm will first visit the\nparent of D and activate D in push mode. Then it visits the bin. The bin\nwill first change the state of its child before activating its pads.\nThat means c will be activated in push mode. [*] At this point, d and\nC should also be active in push mode, because it could be that\nactivating c in push mode starts a thread, which starts pushing to pads\nwhich aren\u2019t ready yet. Then b is activated in push mode. Then, the bin\nactivates C in push mode, which should already be in push mode, so\nnothing is done. It then activates B in push mode, which activates b in\npush mode, but it\u2019s already there, then activates a in push mode as\nwell. The order of activating a and b does not matter in this case.\nThen, finally, the state change algorithm moves to the parent of A,\nactivates A in push mode, and dataflow begins.</p>\n<p>[*] Not yet implemented.</p>\n<p>Activation mode (2) is implausible, so we can ignore it for now. That\nleaves us with the rest.</p>\n<p>(3) is the same as (1) until you get to activating b. Activating b will\nproxy directly to activating a, which will activate B and A as well.\nThen when the state change algorithm gets to B and A it sees that they\nare already active, so it ignores them.</p>\n<p>Similarly in (4), activating D will cause the activation of all of the\nrest of the pads, in this order: C d c b a B A. Then when the state\nchange gets to the other elements they are already active, and in fact\ndata flow is already occurring.</p>\n<p>So, from these scenarios, we can distill how ghost pad activation\nfunctions should work:</p>\n<p>Ghost source pads (e.g. C): push: called by: element state change\nhandler behavior: just return TRUE pull: called by: peer\u2019s activatepull\nbehavior: change the internal pad, which proxies to its peer e.g. C\nchanges d which changes c.</p>\n<p>Internal sink pads (e.g. d): push: called by: nobody (doesn\u2019t seem\npossible) behavior: n/a pull: called by: ghost pad behavior: proxy to\npeer first</p>\n<p>Internal src pads (e.g. a): push: called by: ghost pad behavior:\nactivate peer in push mode pull: called by: peer\u2019s activatepull\nbehavior: proxy to ghost pad, which proxies to its peer (e.g. a calls B\nwhich calls A)</p>\n<p>Ghost sink pads (e.g. B): push: called by: element state change handler\nbehavior: change the internal pad, which proxies to peer (e.g. B changes\na which changes b) pull: called by: internal pad behavior: proxy to peer</p>\n<p>It doesn\u2019t really make sense to have activation functions on proxy pads\nthat aren\u2019t part of a ghost pad arrangement.</p>\n\n        \n\n    </div>\n\n\n        "});