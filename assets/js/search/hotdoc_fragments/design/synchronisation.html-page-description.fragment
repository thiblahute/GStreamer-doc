fragment_downloaded_cb({"url": "design/synchronisation.html#page-description", "fragment": "This document outlines the techniques used for doing synchronised playback of multiple streams. \nSynchronisation in a GstPipeline is achieved using the following components \na GstClock which is global for all elements in a GstPipeline. \nTimestamps on a GstBuffer. \nthe SEGMENT event preceding the buffers. \nThis object provides a counter that represents the current time in nanoseconds. This value is called the absolute_time. A GstClock always counts time upwards and does not necessarily start at \nDifferent sources exist for this counter \nthe system time with g_get_current_time and with microsecond accuracy \nmonotonic time with g_get_monotonic_time with microsecond accuracy \nan audio device based on number of samples played \na network source based on packets received timestamps in those packets a typical example is an RTP source \n\nIn GStreamer any element can provide a GstClock object that can be used in the pipeline. The GstPipeline object will select a clock from all the providers and will distribute it to all other elements see gstpipeline \nWhile it is possible it is not recommended to create a clock derived from the contents of a stream for example create a clock from the PCR in an mpeg ts stream \nAfter a pipeline selected a clock it will maintain the running_time based on the selected clock. This running_time represents the total time spent in the PLAYING state and is calculated as follows \nIf the pipeline is NULL READY the running_time is undefined. \nIn PAUSED the running_time remains at the time when it was last PAUSED. When the stream is PAUSED for the first time the running_time is \nIn PLAYING the running_time is the delta between the absolute_time and the base time. The base time is defined as the absolute_time minus the running_time at the time when the pipeline is set to PLAYING. \nafter a flushing seek the running_time is set to see seeking This is accomplished by redistributing a new base_time to the elements that got flushed. \nThis algorithm captures the running_time when the pipeline is set from PLAYING to PAUSED and restores this time based on the current absolute_time when going back to PLAYING. This allows for both clocks that progress when in the PAUSED state systemclock and clocks that don t audioclock \nThe clock and pipeline now provide a running_time to all elements that want to perform synchronisation. Indeed the running time can be observed in each element during the PLAYING state as \nWe note C.running_time as the running_time obtained by looking at the clock. This value is monotonically increasing at the rate of the clock. \nThe GstBuffer timestamps and the preceding SEGMENT event See streams define a transformation of the buffer timestamps to running_time as follows \nThe following notation is used \nB GstBuffer B.timestamp buffer timestamp GST_BUFFER_PTS or GST_BUFFER_DTS \nS SEGMENT event preceding the buffers. S.start start field in the SEGMENT event. This is the lowest allowed timestamp. S.stop stop field in the SEGMENT event. This is the highers allowed timestamp. S.rate rate field of SEGMENT event. This is the playback rate. S.base a base time for the time. This is the total elapsed running_time of any previous segments. S.offset an offset to apply to S.start or S.stop. This is the amount that has already been elapsed in the segment. \nValid buffers for synchronisation are those with B.timestamp between S.start and S.stop after applying the S.offset All other buffers outside this range should be dropped or clipped to these boundaries see also segments \nThe following transformation to running_time exist \nWe write B.running_time as the running_time obtained from the SEGMENT event and the buffers of that segment. \nThe first displayable buffer will yield a value of since B.timestamp S.start and S.offset and S.base \nFor S.rate the timestamps will be scaled down to increase the playback rate. Likewise a rate between and will slow down playback. \nFor negative rates timestamps are received stop S.stop to S.start so that the first buffer received will be transformed into B.running_time of B.timestamp S.stop and S.base \nThis makes it so that B.running_time is always monotonically increasing starting from with both positive and negative rates. \nAs we have seen we can get a running_time \nWe prefix C. and B. before the two running times to note how they were calculated. \nThe task of synchronized playback is to make sure that we play a buffer with B.running_time at the moment when the clock reaches the same C.running_time. \nThus the following must hold \nexpaning \nor \nThe absolute_time when a buffer with B.running_time should be played is noted with B.sync_time. Thus \nOne then waits for the clock to reach B.sync_time before rendering the buffer in the sink See also clocks \nFor multiple streams this means that buffers with the same running_time are to be displayed at the same time. \nA demuxer must make sure that the SEGMENT it emits on its output pads yield the same running_time for buffers that should be played synchronized. This usually means sending the same SEGMENT on all pads and making sure that the synchronized buffers have the same timestamps. \nThe stream time is also known as the position in the stream and is a value between and the total duration of the media file. \nIt is the stream time that is used for \nreport the POSITION query in the pipeline \nthe position used in seek events queries \nthe position used to synchronize controller values \nAdditional fields in the SEGMENT are used \nS.time time field in the SEGMENT event. This the stream time of S.start \nS.applied_rate The rate already applied to the segment. \nStream time is calculated using the buffer times and the preceding SEGMENT event as follows \nFor negative rates B.timestamp will go backwards from S.stop to S.start making the stream time go backwards \nIn the PLAYING state it is also possible to use the pipeline clock to derive the current stream_time. \nGive the two formulas above to match the clock times with buffer timestamps allows us to rewrite the above formula for stream_time and for positive rates \nThis last formula is typically used in sinks to report the current position in an accurate and efficient way. \nNote that the stream time is never used for synchronisation against the clock. \n"});