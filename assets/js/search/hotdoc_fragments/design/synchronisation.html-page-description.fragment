fragment_downloaded_cb({"url": "design/synchronisation.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"synchronisation.md\">\n        <h1 id=\"synchronisation\">Synchronisation</h1>\n<p>This document outlines the techniques used for doing synchronised\nplayback of multiple streams.</p>\n<p>Synchronisation in a <code>GstPipeline</code> is achieved using the following 3\ncomponents:</p>\n<ul>\n<li>\n<p>a <code>GstClock</code>, which is global for all elements in a <code>GstPipeline</code>.</p>\n</li>\n<li>\n<p>Timestamps on a <code>GstBuffer</code>.</p>\n</li>\n<li>\n<p>the SEGMENT event preceding the buffers.</p>\n</li>\n</ul>\n<h2 id=\"a-gstclock\">A GstClock</h2>\n<p>This object provides a counter that represents the current time in\nnanoseconds. This value is called the <code>absolute_time</code>. A <code>GstClock</code>\nalways counts time upwards and does not necessarily start at 0.</p>\n<p>Different sources exist for this counter:</p>\n<ul>\n<li>\n<p>the system time (with <code>g_get_current_time()</code> and with microsecond\naccuracy)</p>\n</li>\n<li>\n<p>monotonic time (with <code>g_get_monotonic_time()</code> with microsecond\naccuracy)</p>\n</li>\n<li>\n<p>an audio device (based on number of samples played)</p>\n</li>\n<li>\n<p>a network source based on packets received + timestamps in those\npackets (a typical example is an RTP source)</p>\n</li>\n<li>\n<p>\u2026</p>\n</li>\n</ul>\n<p>In GStreamer any element can provide a <code>GstClock</code> object that can be used\nin the pipeline. The <code>GstPipeline</code> object will select a clock from all the\nproviders and will distribute it to all other elements (see\n<a href=\"gstpipeline.html\">gstpipeline</a>).</p>\n<p>While it is possible, it is not recommended to create a clock derived\nfrom the contents of a stream (for example, create a clock from the PCR\nin an mpeg-ts stream).</p>\n<h2 id=\"running-time\">Running time</h2>\n<p>After a pipeline selected a clock it will maintain the <code>running_time</code>\nbased on the selected clock. This <code>running_time</code> represents the total\ntime spent in the PLAYING state and is calculated as follows:</p>\n<ul>\n<li>\n<p>If the pipeline is NULL/READY, the <code>running_time</code> is undefined.</p>\n</li>\n<li>\n<p>In PAUSED, the <code>running_time</code> remains at the time when it was last\nPAUSED. When the stream is <code>PAUSED</code> for the first time, the\n<code>running_time</code> is 0.</p>\n</li>\n<li>\n<p>In PLAYING, the <code>running_time</code> is the delta between the\n<code>absolute_time</code> and the base time. The base time is defined as the\n<code>absolute_time</code> minus the <code>running_time</code> at the time when the pipeline\nis set to <code>PLAYING</code>.</p>\n</li>\n<li>\n<p>after a flushing seek, the <code>running_time</code> is set to 0 (see\n<a href=\"seeking.html\">seeking</a>). This is accomplished by redistributing a new\nbase_time to the elements that got flushed.</p>\n</li>\n</ul>\n<p>This algorithm captures the <code>running_time</code> when the pipeline is set from\n<code>PLAYING</code> to <code>PAUSED</code> and restores this time based on the current\n<code>absolute_time</code> when going back to <code>PLAYING</code>. This allows for both clocks\nthat progress when in the <code>PAUSED</code> state (systemclock) and clocks that\ndon\u2019t (audioclock).</p>\n<p>The clock and pipeline now provide a <code>running_time</code> to all elements that\nwant to perform synchronisation. Indeed, the running time can be\nobserved in each element (during the PLAYING state) as:</p>\n<pre><code>    C.running_time = absolute_time - base_time\n</code></pre>\n<p>We note <code>C.running_time</code> as the <code>running_time</code> obtained by looking at the\nclock. This value is monotonically increasing at the rate of the clock.</p>\n<h2 id=\"timestamps\">Timestamps</h2>\n<p>The <code>GstBuffer</code> timestamps and the preceding SEGMENT event (See\n<a href=\"streams.html\">streams</a>) define a transformation of the buffer timestamps\nto <code>running_time</code> as follows:</p>\n<p>The following notation is used:</p>\n<p><strong>B</strong>: <code>GstBuffer</code>\n- B.timestamp = buffer timestamp (<code>GST_BUFFER_PTS</code> or <code>GST_BUFFER_DTS</code>)</p>\n<p><strong>S</strong>:  SEGMENT event preceding the buffers.\n- S.start: start field in the SEGMENT event. This is the lowest allowed\ntimestamp.\n- S.stop: stop field in the SEGMENT event. This is the highers allowed\ntimestamp.\n- S.rate: rate field of SEGMENT event. This is the playback rate.\n- S.base: a base time for the time. This is the total elapsed <code>running_time</code>\nof any previous segments.\n- S.offset: an offset to apply to S.start or S.stop. This is the amount that\nhas already been elapsed in the segment.</p>\n<p>Valid buffers for synchronisation are those with B.timestamp between\n<code>S.start</code> and <code>S.stop</code> (after applying the <code>S.offset</code>). All other buffers\noutside this range should be dropped or clipped to these boundaries (see\nalso <a href=\"segments.html\">segments</a>).</p>\n<p>The following transformation to <code>running_time</code> exist:</p>\n<pre><code>    if (S.rate &gt; 0.0)\n      B.running_time = (B.timestamp - (S.start + S.offset)) / ABS (S.rate) + S.base\n      =&gt;\n      B.timestamp = (B.running_time - S.base) * ABS (S.rate) + S.start + S.offset\n    else\n      B.running_time = ((S.stop - S.offset) - B.timestamp) / ABS (S.rate) + S.base\n      =&gt;\n      B.timestamp = S.stop - S.offset - ((B.running_time - S.base) * ABS (S.rate))\n</code></pre>\n<p>We write <code>B.running_time</code> as the <code>running_time</code> obtained from the <code>SEGMENT</code>\nevent and the buffers of that segment.</p>\n<p>The first displayable buffer will yield a value of 0 (since <code>B.timestamp == S.start and S.offset and S.base == 0</code>).</p>\n<p>For <code>S.rate &gt; 1.0</code>, the timestamps will be scaled down to increase the\nplayback rate. Likewise, a rate between 0.0 and 1.0 will slow down\nplayback.</p>\n<p>For negative rates, timestamps are received stop S.stop to <code>S.start</code> so\nthat the first buffer received will be transformed into <code>B.running_time</code>\nof 0 (<code>B.timestamp == S.stop and S.base == 0</code>).</p>\n<p>This makes it so that <code>B.running_time</code> is always monotonically increasing\nstarting from 0 with both positive and negative rates.</p>\n<h2 id=\"synchronisation1\">Synchronisation</h2>\n<p>As we have seen, we can get a <code>running_time</code>:</p>\n<ul>\n<li>using the clock and the element\u2019s <code>base_time</code> with:</li>\n</ul>\n<pre><code>        C.running_time = absolute_time - base_time\n</code></pre>\n<ul>\n<li>using the buffer timestamp and the preceding <code>SEGMENT</code> event as (assuming\npositive playback rate):</li>\n</ul>\n<pre><code>        B.running_time = (B.timestamp - (S.start + S.offset)) / ABS (S.rate) + S.base\n</code></pre>\n<p>We prefix C. and B. before the two running times to note how they were\ncalculated.</p>\n<p>The task of synchronized playback is to make sure that we play a buffer\nwith <code>B.running_time</code> at the moment when the clock reaches the same\n<code>C.running_time</code>.</p>\n<p>Thus the following must hold:</p>\n<pre><code>    B.running_time = C.running_time\n</code></pre>\n<p>expaning:</p>\n<pre><code>    B.running_time = absolute_time - base_time\n</code></pre>\n<p>or:</p>\n<pre><code>    absolute_time = B.running_time + base_time\n</code></pre>\n<p>The <code>absolute_time</code> when a buffer with <code>B.running_time</code> should be played\nis noted with <code>B.sync_time</code>. Thus:</p>\n<pre><code>    B.sync_time = B.running_time + base_time\n</code></pre>\n<p>One then waits for the clock to reach <code>B.sync_time</code> before rendering the\nbuffer in the sink (See also <a href=\"clocks.html\">clocks</a>).</p>\n<p>For multiple streams this means that buffers with the same <code>running_time</code>\nare to be displayed at the same time.</p>\n<p>A demuxer must make sure that the <code>SEGMENT</code> it emits on its output pads\nyield the same <code>running_time</code> for buffers that should be played\nsynchronized. This usually means sending the same <code>SEGMENT</code> on all pads\nand making sure that the synchronized buffers have the same timestamps.</p>\n<h2 id=\"stream-time\">Stream time</h2>\n<p>The stream time is also known as the position in the stream and is a\nvalue between 0 and the total duration of the media file.</p>\n<p>It is the stream time that is used for:</p>\n<ul>\n<li>\n<p>report the <code>POSITION</code> query in the pipeline</p>\n</li>\n<li>\n<p>the position used in seek events/queries</p>\n</li>\n<li>\n<p>the position used to synchronize controller values</p>\n</li>\n</ul>\n<p>Additional fields in the <code>SEGMENT</code> are used:</p>\n<ul>\n<li>\n<p><code>S.time</code>: time field in the <code>SEGMENT</code> event. This the stream-time of\n<code>S.start</code></p>\n</li>\n<li>\n<p><code>S.applied_rate</code>: The rate already applied to the segment.</p>\n</li>\n</ul>\n<p>Stream time is calculated using the buffer times and the preceding\n<code>SEGMENT</code> event as follows:</p>\n<pre><code>    stream_time = (B.timestamp - S.start) * ABS (S.applied_rate) + S.time\n    =&gt; B.timestamp = (stream_time - S.time) / ABS(S.applied_rate) + S.start\n</code></pre>\n<p>For negative rates, <code>B.timestamp</code> will go backwards from <code>S.stop</code> to\n<code>S.start</code>, making the stream time go backwards:</p>\n<pre><code>    stream_time = (S.stop - B.timestamp) * ABS(S.applied_rate) + S.time\n    =&gt; B.timestamp = S.stop - (stream_time - S.time) / ABS(S.applied_rate)\n</code></pre>\n<p>In the <code>PLAYING</code> state, it is also possible to use the pipeline clock to\nderive the current <code>stream_time</code>.</p>\n<p>Give the two formulas above to match the clock times with buffer\ntimestamps allows us to rewrite the above formula for <code>stream_time</code> (and\nfor positive rates).</p>\n<pre><code>    C.running_time = absolute_time - base_time\n    B.running_time = (B.timestamp - (S.start + S.offset)) / ABS (S.rate) + S.base\n\n    =&gt;\n      (B.timestamp - (S.start + S.offset)) / ABS (S.rate) + S.base = absolute_time - base_time;\n\n    =&gt;\n      (B.timestamp - (S.start + S.offset)) / ABS (S.rate) = absolute_time - base_time - S.base;\n\n    =&gt;\n      (B.timestamp - (S.start + S.offset)) = (absolute_time - base_time - S.base) * ABS (S.rate)\n\n    =&gt;\n      (B.timestamp - S.start) = S.offset + (absolute_time - base_time - S.base) * ABS (S.rate)\n\n    filling (B.timestamp - S.start) in the above formule for stream time\n\n    =&gt;\n      stream_time = (S.offset + (absolute_time - base_time - S.base) * ABS (S.rate)) * ABS (S.applied_rate) + S.time\n</code></pre>\n<p>This last formula is typically used in sinks to report the current\nposition in an accurate and efficient way.</p>\n<p>Note that the stream time is never used for synchronisation against the\nclock.</p>\n\n        \n\n    </div>\n\n\n        "});