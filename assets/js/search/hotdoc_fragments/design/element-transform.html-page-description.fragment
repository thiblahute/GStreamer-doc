fragment_downloaded_cb({"url": "design/element-transform.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"element-transform.md\">\n<h1 id=\"transform-elements\">Transform elements</h1>\n<p>Transform elements transform input buffers to output buffers based on\nthe sink and source caps.</p>\n<p>An important requirement for a transform is that the output caps are\ncompletely defined by the input caps and vice versa. This means that a\ntypical decoder element can NOT be implemented with a transform element,\nthis is because the output caps like width and height of the\ndecompressed video frame, for example, are encoded in the stream and\nthus not defined by the input caps.</p>\n<p>Typical transform elements include:</p>\n<ul>\n<li>\n<p>audio convertors (audioconvert, audioresample,\u2026)</p>\n</li>\n<li>\n<p>video convertors (colorspace, videoscale, \u2026)</p>\n</li>\n<li>\n<p>filters (capsfilter, volume, colorbalance, \u2026)</p>\n</li>\n</ul>\n<p>The implementation of the transform element has to take care of the\nfollowing things:</p>\n<ul>\n<li>\n<p>efficient negotiation both up and downstream</p>\n</li>\n<li>\n<p>efficient buffer alloc and other buffer management</p>\n</li>\n</ul>\n<p>Some transform elements can operate in different modes:</p>\n<ul>\n<li>\n<p>passthrough (no changes are done on the input buffers)</p>\n</li>\n<li>\n<p>in-place (changes made directly to the incoming buffers without\nrequiring a copy or new buffer allocation)</p>\n</li>\n<li>\n<p>metadata changes only</p>\n</li>\n</ul>\n<p>Depending on the mode of operation the buffer allocation strategy might\nchange.</p>\n<p>The transform element should at any point be able to renegotiate sink\nand src caps as well as change the operation mode.</p>\n<p>In addition, the transform element will typically take care of the\nfollowing things as well:</p>\n<ul>\n<li>\n<p>flushing, seeking</p>\n</li>\n<li>\n<p>state changes</p>\n</li>\n<li>\n<p>timestamping, this is typically done by copying the input timestamps\nto the output buffers but subclasses should be able to override\nthis.</p>\n</li>\n<li>\n<p>QoS, avoiding calls to the subclass transform function</p>\n</li>\n<li>\n<p>handle scheduling issues such as push and pull based operation.</p>\n</li>\n</ul>\n<p>In the next sections, we will describe the behaviour of the transform\nelement in each of the above use cases. We focus mostly on the buffer\nallocation strategies and caps negotiation.</p>\n<h2 id=\"processing\">Processing</h2>\n<p>A transform has 2 main processing functions:</p>\n<ul>\n<li>\n<p><strong><code>transform()</code></strong>: Transform the input buffer to the output buffer. The\noutput buffer is guaranteed to be writable and different from the input buffer.</p>\n</li>\n<li>\n<p><strong><code>transform_ip()</code></strong>: Transform the input buffer in-place. The input buffer\nis writable and of bigger or equal size than the output buffer.</p>\n</li>\n</ul>\n<p>A transform can operate in the following modes:</p>\n<ul>\n<li>\n<p><em>passthrough</em>: The element will not make changes to the buffers, buffers are\npushed straight through, caps on both sides need to be the same. The element\ncan optionally implement a <code>transform_ip()</code> function to take a look at the data,\nthe buffer does not have to be writable.</p>\n</li>\n<li>\n<p><em>in-place</em>: Changes can be made to the input buffer directly to obtain the\noutput buffer. The transform must implement a <code>transform_ip()</code> function.</p>\n</li>\n<li>\n<p><em>copy-transform</em>: The transform is performed by copying and transforming the\ninput buffer to a new output buffer. The transform must implement a <code>transform()</code> function.</p>\n</li>\n</ul>\n<p>When no <code>transform()</code> function is provided, only in-place and passthrough\noperation is allowed, this means that source and destination caps must\nbe equal or that the source buffer size is bigger or equal than the\ndestination buffer.</p>\n<p>When no <code>transform_ip()</code> function is provided, only passthrough and\ncopy-transforms are supported. Providing this function is an\noptimisation that can avoid a buffer copy.</p>\n<p>When no functions are provided, we can only process in passthrough mode.</p>\n<h2 id=\"negotiation\">Negotiation</h2>\n<p>Typical (re)negotiation of the transform element in push mode always\ngoes from sink to src, this means triggers the following sequence:</p>\n<ul>\n<li>\n<p>the sinkpad receives a new caps event.</p>\n</li>\n<li>\n<p>the transform function figures out what it can convert these caps\nto.</p>\n</li>\n<li>\n<p>try to see if we can configure the caps unmodified on the peer. We\nneed to do this because we prefer to not do anything.</p>\n</li>\n<li>\n<p>the transform configures itself to transform from the new sink caps\nto the target src caps</p>\n</li>\n<li>\n<p>the transform processes and sets the output caps on the src pad</p>\n</li>\n</ul>\n<p>We call this downstream negotiation (DN) and it goes roughly like this:</p>\n<pre><code>          sinkpad              transform               srcpad\nCAPS event   |                    |                      |\n------------&gt;|  find_transform()  |                      |\n             |-------------------&gt;|                      |\n             |                    |       CAPS event     |\n             |                    |---------------------&gt;|\n             | &lt;configure caps&gt; &lt;-|                      |\n</code></pre>\n<p>These steps configure the element for a transformation from the input\ncaps to the output caps.</p>\n<p>The transform has 3 function to perform the negotiation:</p>\n<ul>\n<li>\n<p><strong><code>transform_caps()</code></strong>: Transform the caps on a certain pad to all the\npossible supported caps on the other pad. The input caps are guaranteed to be\na simple caps with just one structure. The caps do not have to be fixed.</p>\n</li>\n<li>\n<p><strong><code>fixate_caps()</code></strong>: Given a caps on one pad, fixate the caps on the other\npad. The target caps are writable.</p>\n</li>\n<li>\n<p><strong><code>set_caps()</code></strong>: Configure the transform for a transformation between src\ncaps and dest caps. Both caps are guaranteed to be fixed caps.</p>\n</li>\n</ul>\n<p>If no <code>transform_caps()</code> is defined, we can only perform the identity\ntransform, by default.</p>\n<p>If no <code>set_caps()</code> is defined, we don\u2019t care about caps. In that case we\nalso assume nothing is going to write to the buffer and we don\u2019t enforce\na writable buffer for the <code>transform_ip()</code> function, when present.</p>\n<p>One common function that we need for the transform element is to find\nthe best transform from one format (src) to another (dest). Some\nrequirements of this function are:</p>\n<ul>\n<li>\n<p>has a fixed src caps</p>\n</li>\n<li>\n<p>finds a fixed dest caps that the transform element can transform to</p>\n</li>\n<li>\n<p>the dest caps are compatible and can be accepted by peer elements</p>\n</li>\n<li>\n<p>the transform function prefers to make src caps == dest caps</p>\n</li>\n<li>\n<p>the transform function can optionally fixate dest caps.</p>\n</li>\n</ul>\n<p>The <code>find_transform()</code> function goes like this:</p>\n<ul>\n<li>\n<p>start from src aps, these caps are fixed.</p>\n</li>\n<li>\n<p>check if the caps are acceptable for us as src caps. This is usually\nenforced by the padtemplate of the element.</p>\n</li>\n<li>\n<p>calculate all caps we can transform too with <code>transform_caps()</code></p>\n</li>\n<li>\n<p>if the original caps are a subset of the transforms, try to see if\nthe the caps are acceptable for the peer. If this is possible, we\ncan perform passthrough and make src == dest. This is performed by\nsimply calling <code>gst_pad_peer_query_accept_caps()</code>.</p>\n</li>\n<li>\n<p>if the caps are not fixed, we need to fixate it, start by taking the\npeer caps and intersect with them.</p>\n</li>\n<li>\n<p>for each of the transformed caps retrieved with <code>transform_caps()</code>:</p>\n</li>\n<li>\n<p>try to fixate the caps with <code>fixate_caps()</code></p>\n</li>\n<li>\n<p>if the caps are fixated, check if the peer accepts them with\n<code>_peer_query_accept_caps()</code>, if the peer accepts, we have found a dest caps.</p>\n</li>\n<li>\n<p>if we run out of caps, we fail to find a transform.</p>\n</li>\n<li>\n<p>if we found a destination caps, configure the transform with\n<code>set_caps()</code>.</p>\n</li>\n</ul>\n<p>After this negotiation process, the transform element is usually in a\nsteady state. We can identify these steady states:</p>\n<ul>\n<li>\n<p>src and sink pads both have the same caps. Note that when the caps\nare equal on both pads, the input and output buffers automatically\nhave the same size. The element can operate on the buffers in the\nfollowing ways: (Same caps, SC)</p>\n</li>\n<li>\n<p>passthrough: buffers are inspected but no metadata or buffer data is\nchanged. The input buffers don\u2019t need to be writable. The input\nbuffer is simply pushed out again without modifications. (SCP)</p>\n<pre><code>          sinkpad              transform               srcpad\n  chain()    |                    |                      |\n------------&gt;|   handle_buffer()  |                      |\n             |-------------------&gt;|      pad_push()      |\n             |                    |---------------------&gt;|\n             |                    |                      |\n</code></pre>\n</li>\n<li>\n<p>in-place: buffers are modified in-place, this means that the input\nbuffer is modified to produce a new output buffer. This requires the\ninput buffer to be writable. If the input buffer is not writable, a\nnew buffer has to be allocated from the bufferpool. (SCI)</p>\n<pre><code>          sinkpad              transform               srcpad\n  chain()    |                    |                      |\n------------&gt;|   handle_buffer()  |                      |\n             |-------------------&gt;|                      |\n             |                    |   [!writable]        |\n             |                    |   alloc buffer       |\n             |                  .-|                      |\n             |  &lt;transform_ip&gt;  | |                      |\n             |                  '&gt;|                      |\n             |                    |      pad_push()      |\n             |                    |---------------------&gt;|\n             |                    |                      |\n</code></pre>\n</li>\n<li>\n<p>copy transform: a new output buffer is allocate from the bufferpool\nand data from the input buffer is transformed into the output\nbuffer. (SCC)</p>\n<pre><code>          sinkpad              transform               srcpad\n  chain()    |                    |                      |\n------------&gt;|   handle_buffer()  |                      |\n             |-------------------&gt;|                      |\n             |                    |     alloc buffer     |\n             |                  .-|                      |\n             |     &lt;transform&gt;  | |                      |\n             |                  '&gt;|                      |\n             |                    |      pad_push()      |\n             |                    |---------------------&gt;|\n             |                    |                      |\n</code></pre>\n</li>\n<li>\n<p>src and sink pads have different caps. The element can operate on\nthe buffers in the following way: (Different Caps, DC)</p>\n</li>\n<li>\n<p>in-place: input buffers are modified in-place. This means that the\ninput buffer has a size that is larger or equal to the output size.\nThe input buffer will be resized to the size of the output buffer.\nIf the input buffer is not writable or the output size is bigger\nthan the input size, we need to pad-alloc a new buffer. (DCI)</p>\n<pre><code>          sinkpad              transform               srcpad\n  chain()    |                    |                      |\n------------&gt;|   handle_buffer()  |                      |\n             |-------------------&gt;|                      |\n             |                    | [!writable || !size] |\n             |                    |     alloc buffer     |\n             |                  .-|                      |\n             |  &lt;transform_ip&gt;  | |                      |\n             |                  '&gt;|                      |\n             |                    |      pad_push()      |\n             |                    |---------------------&gt;|\n             |                    |                      |\n</code></pre>\n</li>\n<li>\n<p>copy transform: a new output buffer is allocated and the data from\nthe input buffer is transformed into the output buffer. The flow is\nexactly the same as the case with the same-caps negotiation. (DCC)</p>\n</li>\n</ul>\n<p>We can immediately observe that the copy transform states will need to\nallocate a new buffer from the bufferpool. When the transform element is\nreceiving a non-writable buffer in the in-place state, it will also need\nto perform an allocation. There is no reason why the passthrough state\nwould perform an allocation.</p>\n<p>This steady state changes when one of the following actions occur:</p>\n<ul>\n<li>\n<p>the sink pad receives new caps, this triggers the above downstream\nrenegotation process, see above for the flow.</p>\n</li>\n<li>\n<p>the transform element wants to renegotiate (because of changed\nproperties, for example). This essentially clears the current steady\nstate and triggers the downstream and upstream renegotiation\nprocess. This situation also happens when a RECONFIGURE event was\nreceived on the transform srcpad.</p>\n</li>\n</ul>\n<h2 id=\"allocation\">Allocation</h2>\n<p>After the transform element is configured with caps, a bufferpool needs\nto be negotiated to perform the allocation of buffers. We have 2 cases:</p>\n<ul>\n<li>\n<p>The element is operating in passthrough we don\u2019t need to allocate a\nbuffer in the transform element.</p>\n</li>\n<li>\n<p>The element is not operating in passthrough and needs to allocation\nan output buffer.</p>\n</li>\n</ul>\n<p>In case 1, we don\u2019t query and configure a pool. We let upstream decide\nif it wants to use a bufferpool and then we will proxy the bufferpool\nfrom downstream to upstream.</p>\n<p>In case 2, we query and set a bufferpool on the srcpad that will be used\nfor doing the allocations.</p>\n<p>In order to perform allocation, we need to be able to get the size of\nthe output buffer after the transform. We need additional function to\nretrieve the size. There are two functions:</p>\n<ul>\n<li>\n<p><code>transform_size()</code>: Given a caps and a size on one pad, and a caps on the\nother pad, calculate the size of the other buffer. This function is able to\nperform all size transforms and is the preferred method of transforming\na size.</p>\n</li>\n<li>\n<p><code>get_unit_size()</code>: When the input size and output size are always\na multiple of each other (audio conversion, ..) we can define a more simple\n<code>get_unit_size()</code> function. The transform will use this function to get the\nsame amount of units in the source and destination buffers. For performance\nreasons, the mapping between caps and size is kept in a cache.</p>\n</li>\n</ul>\n\n</div>\n\n\n\t"});