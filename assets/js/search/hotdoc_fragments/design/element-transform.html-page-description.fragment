fragment_downloaded_cb({"url": "design/element-transform.html#page-description", "fragment": "Transform elements transform input buffers to output buffers based on the sink and source caps. \nAn important requirement for a transform is that the output caps are completely defined by the input caps and vice versa. This means that a typical decoder element can NOT be implemented with a transform element this is because the output caps like width and height of the decompressed video frame for example are encoded in the stream and thus not defined by the input caps. \nTypical transform elements include \naudio convertors audioconvert audioresample \nvideo convertors colorspace videoscale \nfilters capsfilter volume colorbalance \nThe implementation of the transform element has to take care of the following things \nefficient negotiation both up and downstream \nefficient buffer alloc and other buffer management \nSome transform elements can operate in different modes \npassthrough no changes are done on the input buffers \nin place changes made directly to the incoming buffers without requiring a copy or new buffer allocation \nmetadata changes only \nDepending on the mode of operation the buffer allocation strategy might change. \nThe transform element should at any point be able to renegotiate sink and src caps as well as change the operation mode. \nIn addition the transform element will typically take care of the following things as well \nflushing seeking \nstate changes \ntimestamping this is typically done by copying the input timestamps to the output buffers but subclasses should be able to override this. \nQoS avoiding calls to the subclass transform function \nhandle scheduling issues such as push and pull based operation. \nIn the next sections we will describe the behaviour of the transform element in each of the above use cases. We focus mostly on the buffer allocation strategies and caps negotiation. \nA transform has main processing functions \ntransform Transform the input buffer to the output buffer. The output buffer is guaranteed to be writable and different from the input buffer. \ntransform_ip Transform the input buffer in place. The input buffer is writable and of bigger or equal size than the output buffer. \nA transform can operate in the following modes \npassthrough The element will not make changes to the buffers buffers are pushed straight through caps on both sides need to be the same. The element can optionally implement a transform_ip function to take a look at the data the buffer does not have to be writable. \nin place Changes can be made to the input buffer directly to obtain the output buffer. The transform must implement a transform_ip function. \ncopy transform The transform is performed by copying and transforming the input buffer to a new output buffer. The transform must implement a transform function. \nWhen no transform function is provided only in place and passthrough operation is allowed this means that source and destination caps must be equal or that the source buffer size is bigger or equal than the destination buffer. \nWhen no transform_ip function is provided only passthrough and copy transforms are supported. Providing this function is an optimisation that can avoid a buffer copy. \nWhen no functions are provided we can only process in passthrough mode. \nTypical re negotiation of the transform element in push mode always goes from sink to src this means triggers the following sequence \nthe sinkpad receives a new caps event. \nthe transform function figures out what it can convert these caps to. \ntry to see if we can configure the caps unmodified on the peer. We need to do this because we prefer to not do anything. \nthe transform configures itself to transform from the new sink caps to the target src caps \nthe transform processes and sets the output caps on the src pad \nWe call this downstream negotiation DN and it goes roughly like this \nThese steps configure the element for a transformation from the input caps to the output caps. \nThe transform has function to perform the negotiation \ntransform_caps Transform the caps on a certain pad to all the possible supported caps on the other pad. The input caps are guaranteed to be a simple caps with just one structure. The caps do not have to be fixed. \nfixate_caps Given a caps on one pad fixate the caps on the other pad. The target caps are writable. \nset_caps Configure the transform for a transformation between src caps and dest caps. Both caps are guaranteed to be fixed caps. \nIf no transform_caps is defined we can only perform the identity transform by default. \nIf no set_caps is defined we don t care about caps. In that case we also assume nothing is going to write to the buffer and we don t enforce a writable buffer for the transform_ip function when present. \nOne common function that we need for the transform element is to find the best transform from one format src to another dest Some requirements of this function are \nhas a fixed src caps \nfinds a fixed dest caps that the transform element can transform to \nthe dest caps are compatible and can be accepted by peer elements \nthe transform function prefers to make src caps dest caps \nthe transform function can optionally fixate dest caps. \nThe find_transform function goes like this \nstart from src aps these caps are fixed. \ncheck if the caps are acceptable for us as src caps. This is usually enforced by the padtemplate of the element. \ncalculate all caps we can transform too with transform_caps \nif the original caps are a subset of the transforms try to see if the the caps are acceptable for the peer. If this is possible we can perform passthrough and make src dest. This is performed by simply calling gst_pad_peer_query_accept_caps \nif the caps are not fixed we need to fixate it start by taking the peer caps and intersect with them. \nfor each of the transformed caps retrieved with transform_caps \ntry to fixate the caps with fixate_caps \nif the caps are fixated check if the peer accepts them with _peer_query_accept_caps if the peer accepts we have found a dest caps. \nif we run out of caps we fail to find a transform. \nif we found a destination caps configure the transform with set_caps \nAfter this negotiation process the transform element is usually in a steady state. We can identify these steady states \nsrc and sink pads both have the same caps. Note that when the caps are equal on both pads the input and output buffers automatically have the same size. The element can operate on the buffers in the following ways Same caps SC \npassthrough buffers are inspected but no metadata or buffer data is changed. The input buffers don t need to be writable. The input buffer is simply pushed out again without modifications. SCP \nin place buffers are modified in place this means that the input buffer is modified to produce a new output buffer. This requires the input buffer to be writable. If the input buffer is not writable a new buffer has to be allocated from the bufferpool. SCI \ncopy transform a new output buffer is allocate from the bufferpool and data from the input buffer is transformed into the output buffer. SCC \nsrc and sink pads have different caps. The element can operate on the buffers in the following way Different Caps DC \nin place input buffers are modified in place. This means that the input buffer has a size that is larger or equal to the output size. The input buffer will be resized to the size of the output buffer. If the input buffer is not writable or the output size is bigger than the input size we need to pad alloc a new buffer. DCI \ncopy transform a new output buffer is allocated and the data from the input buffer is transformed into the output buffer. The flow is exactly the same as the case with the same caps negotiation. DCC \nWe can immediately observe that the copy transform states will need to allocate a new buffer from the bufferpool. When the transform element is receiving a non writable buffer in the in place state it will also need to perform an allocation. There is no reason why the passthrough state would perform an allocation. \nThis steady state changes when one of the following actions occur \nthe sink pad receives new caps this triggers the above downstream renegotation process see above for the flow. \nthe transform element wants to renegotiate because of changed properties for example This essentially clears the current steady state and triggers the downstream and upstream renegotiation process. This situation also happens when a RECONFIGURE event was received on the transform srcpad. \nAfter the transform element is configured with caps a bufferpool needs to be negotiated to perform the allocation of buffers. We have cases \nThe element is operating in passthrough we don t need to allocate a buffer in the transform element. \nThe element is not operating in passthrough and needs to allocation an output buffer. \nIn case we don t query and configure a pool. We let upstream decide if it wants to use a bufferpool and then we will proxy the bufferpool from downstream to upstream. \nIn case we query and set a bufferpool on the srcpad that will be used for doing the allocations. \nIn order to perform allocation we need to be able to get the size of the output buffer after the transform. We need additional function to retrieve the size. There are two functions \ntransform_size Given a caps and a size on one pad and a caps on the other pad calculate the size of the other buffer. This function is able to perform all size transforms and is the preferred method of transforming a size. \nget_unit_size When the input size and output size are always a multiple of each other audio conversion we can define a more simple get_unit_size function. The transform will use this function to get the same amount of units in the source and destination buffers. For performance reasons the mapping between caps and size is kept in a cache. \n"});