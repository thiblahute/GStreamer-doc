fragment_downloaded_cb({"url": "design/streams.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"streams.md\">\n        <h1 id=\"streams\">Streams</h1>\n<p>This document describes the objects that are passed from element to\nelement in the streaming thread.</p>\n<h2 id=\"stream-objects\">Stream objects</h2>\n<p>The following objects are to be expected in the streaming thread:</p>\n<ul>\n<li>events</li>\n<li><code>STREAM_START</code> (START)</li>\n<li><code>SEGMENT</code> (SEGMENT)</li>\n<li><code>EOS</code> * (EOS)</li>\n<li><code>TAG</code> (T)</li>\n<li>buffers * (B)</li>\n</ul>\n<p>Objects marked with * need to be synchronised to the clock in sinks and\nlive sources.</p>\n<h2 id=\"typical-stream\">Typical stream</h2>\n<p>A typical stream starts with a stream start event that marks the\nstart of the stream, followed by a segment event that marks the\nbuffer timestamp range. After that buffers are sent one after the\nother. After the last buffer an EOS marks the end of the stream. No\nmore buffers are to be processed after the EOS event.</p>\n<pre><code>+-----+-------+ +-++-+     +-+ +---+\n|START|SEGMENT| |B||B| ... |B| |EOS|\n+-----+-------+ +-++-+     +-+ +---+\n</code></pre>\n<ol>\n<li>\n<p><strong><code>STREAM_START</code></strong></p>\n<ul>\n<li>marks the start of a stream; unlike the <code>SEGMENT</code> event, there\nwill be no <code>STREAM_START</code> event after flushing seeks.</li>\n</ul>\n</li>\n<li>\n<p><strong><code>SEGMENT</code></strong>, rate, start/stop, time</p>\n<ul>\n<li>marks valid buffer timestamp range (start, stop)</li>\n<li>marks <code>stream_time</code> of buffers (time). This is the stream time of buffers\nwith a timestamp of <code>S.start</code>.</li>\n<li>marks playback rate (rate). This is the required playback rate.</li>\n<li>marks applied rate (<code>applied_rate</code>). This is the already applied playback\nrate. (See also <a href=\"trickmodes.html\">trickmodes</a>)</li>\n<li>marks <code>running_time</code> of buffers. This is the time used to synchronize\nagainst the clock.</li>\n</ul>\n</li>\n<li>\n<p><strong>N buffers</strong></p>\n<ul>\n<li>\n<p>displayable buffers are between start/stop of the <code>SEGMENT</code> (S). Buffers\noutside the segment range should be dropped or clipped.</p>\n</li>\n<li>\n<p><code>running_time</code>:</p>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code>        if (S.rate &gt; 0.0)\n          running_time = (B.timestamp - S.start) / ABS (S.rate) + S.base\n        else\n          running_time = (S.stop - B.timestamp) / ABS (S.rate) + S.base\n</code></pre>\n<ul>\n<li>\n<p>a monotonically increasing value that can be used to synchronize\nagainst the clock (See also\n<a href=\"synchronisation.html\">synchronisation</a>).</p>\n</li>\n<li>\n<p><code>stream_time</code>:</p>\n<ul>\n<li>current position in stream between 0 and duration.</li>\n</ul>\n</li>\n</ul>\n<pre><code>        stream_time = (B.timestamp - S.start) * ABS (S.applied_rate) + S.time\n</code></pre>\n<ol start=\"4\">\n<li><strong><code>EOS</code></strong>\n<ul>\n<li>marks the end of data, nothing is to be expected after <code>EOS</code>, elements\nshould refuse more data and return <code>GST_FLOW_EOS</code>. A <code>FLUSH_STOP</code>\nevent clears the <code>EOS</code> state of an element.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"elements\">Elements</h2>\n<p>These events are generated typically either by the <code>GstBaseSrc</code> class for\nsources operating in push mode, or by a parser/demuxer operating in\npull-mode and pushing parsed/demuxed data downstream.</p>\n\n        \n\n    </div>\n\n\n        "});