fragment_downloaded_cb({"url": "design/element-transform.html#negotiation", "fragment": "Negotiation \nTypical re negotiation of the transform element in push mode always goes from sink to src this means triggers the following sequence \nthe sinkpad receives a new caps event. \nthe transform function figures out what it can convert these caps to. \ntry to see if we can configure the caps unmodified on the peer. We need to do this because we prefer to not do anything. \nthe transform configures itself to transform from the new sink caps to the target src caps \nthe transform processes and sets the output caps on the src pad \nWe call this downstream negotiation DN and it goes roughly like this \nThese steps configure the element for a transformation from the input caps to the output caps. \nThe transform has function to perform the negotiation \ntransform_caps Transform the caps on a certain pad to all the possible supported caps on the other pad. The input caps are guaranteed to be a simple caps with just one structure. The caps do not have to be fixed. \nfixate_caps Given a caps on one pad fixate the caps on the other pad. The target caps are writable. \nset_caps Configure the transform for a transformation between src caps and dest caps. Both caps are guaranteed to be fixed caps. \nIf no transform_caps is defined we can only perform the identity transform by default. \nIf no set_caps is defined we don t care about caps. In that case we also assume nothing is going to write to the buffer and we don t enforce a writable buffer for the transform_ip function when present. \nOne common function that we need for the transform element is to find the best transform from one format src to another dest Some requirements of this function are \nhas a fixed src caps \nfinds a fixed dest caps that the transform element can transform to \nthe dest caps are compatible and can be accepted by peer elements \nthe transform function prefers to make src caps dest caps \nthe transform function can optionally fixate dest caps. \nThe find_transform function goes like this \nstart from src aps these caps are fixed. \ncheck if the caps are acceptable for us as src caps. This is usually enforced by the padtemplate of the element. \ncalculate all caps we can transform too with transform_caps \nif the original caps are a subset of the transforms try to see if the the caps are acceptable for the peer. If this is possible we can perform passthrough and make src dest. This is performed by simply calling gst_pad_peer_query_accept_caps \nif the caps are not fixed we need to fixate it start by taking the peer caps and intersect with them. \nfor each of the transformed caps retrieved with transform_caps \ntry to fixate the caps with fixate_caps \nif the caps are fixated check if the peer accepts them with _peer_query_accept_caps if the peer accepts we have found a dest caps. \nif we run out of caps we fail to find a transform. \nif we found a destination caps configure the transform with set_caps \nAfter this negotiation process the transform element is usually in a steady state. We can identify these steady states \nsrc and sink pads both have the same caps. Note that when the caps are equal on both pads the input and output buffers automatically have the same size. The element can operate on the buffers in the following ways Same caps SC \npassthrough buffers are inspected but no metadata or buffer data is changed. The input buffers don t need to be writable. The input buffer is simply pushed out again without modifications. SCP \nin place buffers are modified in place this means that the input buffer is modified to produce a new output buffer. This requires the input buffer to be writable. If the input buffer is not writable a new buffer has to be allocated from the bufferpool. SCI \ncopy transform a new output buffer is allocate from the bufferpool and data from the input buffer is transformed into the output buffer. SCC \nsrc and sink pads have different caps. The element can operate on the buffers in the following way Different Caps DC \nin place input buffers are modified in place. This means that the input buffer has a size that is larger or equal to the output size. The input buffer will be resized to the size of the output buffer. If the input buffer is not writable or the output size is bigger than the input size we need to pad alloc a new buffer. DCI \ncopy transform a new output buffer is allocated and the data from the input buffer is transformed into the output buffer. The flow is exactly the same as the case with the same caps negotiation. DCC \nWe can immediately observe that the copy transform states will need to allocate a new buffer from the bufferpool. When the transform element is receiving a non writable buffer in the in place state it will also need to perform an allocation. There is no reason why the passthrough state would perform an allocation. \nThis steady state changes when one of the following actions occur \nthe sink pad receives new caps this triggers the above downstream renegotation process see above for the flow. \nthe transform element wants to renegotiate because of changed properties for example This essentially clears the current steady state and triggers the downstream and upstream renegotiation process. This situation also happens when a RECONFIGURE event was received on the transform srcpad. \n"});