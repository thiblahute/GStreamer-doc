fragment_downloaded_cb({"url": "design/seeking.html#page-description", "fragment": "Seeking in GStreamer means configuring the pipeline for playback of the media between a certain start and stop time called the playback segment. By default a pipeline will play from position to the total duration of the media at a rate of \nA seek is performed by sending a SEEK event to the sink elements of a pipeline. Sending the SEEK event to a bin will by default forward the event to all sinks in the bin. \nWhen performing a seek the start and stop values of the segment can be specified as absolute positions or relative to the currently configured playback segment. Note that it is not possible to seek relative to the current playback position. To seek relative to the current playback position one must query the position first and then perform an absolute seek to the desired position. \nIf a seek operation is requested using the GST_SEEK_FLAG_FLUSH flag all pending data in the pipeline is discarded and playback starts from the new position immediately. If this flag is not set the seek is queued to be executed as soon as possible which might be after all queues are emptied. \nSeeking can be performed in different formats such as time frames or samples. \nThe seeking can be performed to a nearby key unit or to the exact estimated unit in the media GST_SEEK_FLAG_KEY_UNIT See below for more details on this. \nThe seeking can be performed by using an estimated target position or in an accurate way GST_SEEK_FLAG_ACCURATE For some formats this can result in having to scan the complete file in order to accurately find the target unit. See below for more details on this. \nNon segment seeking will make the pipeline emit EOS when the configured segment has been played. \nSegment seeking using the GST_SEEK_FLAG_SEGMENT will not emit an EOS at the end of the playback segment but will post a SEGMENT_DONE message on the bus. This message is posted by the element driving the playback in the pipeline typically a demuxer. After receiving the message the application can reconnect the pipeline or issue other seek events in the pipeline. Since the message is posted as early as possible in the pipeline the application has some time to issue a new seek to make the transition seamless. Typically the allowed delay is defined by the buffer sizes of the sinks as well as the size of any queues in the pipeline. \nThe seek can also change the playback speed of the configured segment. A speed of is normal speed is double speed. Negative values mean backward playback. \nWhen performing a seek with a playback rate different from the GST_SEEK_FLAG_SKIP flag can be used to instruct decoders and demuxers that they are allowed to skip decoding. This can be useful when resource consumption is more important than accurately producing all frames. \nA seek event is created with gst_event_new_seek \nThe different kinds of seeking methods and their internal workings are described below. \nThis is the most common way of performing a seek in a playback application. The application issues a seek on the pipeline and the new media is immediately played after the seek call returns. \nThis seek type is typically performed after issuing segment seeks to finish the playback of the pipeline. \nPerforming a non flushing seek in a PAUSED pipeline blocks until the pipeline is set to playing again since all data passing is blocked in the prerolled sinks. \nThis seek is typically performed when starting seamless looping. \nThis seek is typically performed when continuing seamless looping. \nThis section aims to explain the behaviour expected by an element with regard to the KEY_UNIT and ACCURATE seek flags using a parser or demuxer as an example. \nWhen a seek to a certain position is requested the demuxer parser will do two things ignoring flushing and segment seeks and simplified for illustration purposes \nsend a segment event with a new start position \nstart pushing data buffers again \nTo ensure that the data corresponding to the requested seek position can actually be decoded a demuxer or parser needs to start pushing data from a keyframe keyunit at or before the requested seek position. \nUnless requested differently via the KEY_UNIT flag the start of the segment event should be the requested seek position. \nSo by default a demuxer parser will then start pushing data from position DATA and send a segment event with start position SEG_START and DATA SEG_START. \nIf DATA SEG_START a well behaved video decoder will start decoding frames from DATA but take into account the segment configured by the demuxer via the segment event and only actually output decoded video frames from SEG_START onwards dropping all decoded frames that are before the segment start and adjusting the timestamp duration of the buffer that overlaps the segment start clipping A not so well behaved video decoder will start decoding frames from DATA and push decoded video frames out starting from position DATA in which case the frames that are before the configured segment start will usually be dropped clipped downstream e.g. by the video sink \nIf the KEY_UNIT flag is specified the demuxer parser should adjust the segment start to the position of the key frame closest to the requested seek position and then start pushing out data from there. The nearest key frame may be before or after the requested seek position but many implementations will only look for the closest keyframe before the requested position. \nMost media players and thumbnailers do and should be doing KEY_UNIT seeks by default for performance reasons to ensure almost instant responsiveness when scrubbing dragging the seek slider in PAUSED or PLAYING mode This works well for most media but results in suboptimal behaviour for a small number of odd files e.g. files that only have one keyframe at the very beginning or only a few keyframes throughout the entire stream At the time of writing a solution for this still needs to be found but could be implemented demuxer parser side e.g. make demuxers parsers ignore the KEY_UNIT flag if the position adjustment would be larger than th of the duration or somesuch. \nFlags can be used to influence snapping direction for those cases where it matters. SNAP_BEFORE will select the preceding position to the seek target and SNAP_AFTER will select the following one. If both flags are set the nearest one to the seek target will be used. If none of these flags are set the seeking implemention is free to select whichever it wants. \nif the KEY_UNIT flag is not specified the demuxer parser should start pushing data from a key unit preceding the seek position or from the seek position if that falls on a key unit and the start of the new segment should be the requested seek position. \nif the KEY_UNIT flag is specified the demuxer parser should start pushing data from the key unit nearest the seek position or from the seek position if that falls on a key unit and the start of the new segment should be adjusted to the position of that key unit which was nearest the requested seek position ie. the new segment start should be the position from which data is pushed \nIf the ACCURATE flag is specified in a seek request the demuxer parser is asked to do whatever it takes to make sure the position seeked to is accurate in relation to the beginning of the stream. This means that it is not acceptable to just approximate the position e.g. using an average bitrate The achieved position must be exact. In the worst case the demuxer or parser needs to push data from the beginning of the file and let downstream clip everything before the requested segment start. \nThe ACCURATE flag does not affect what the segment start should be in relation to the requested seek position. Only the KEY_UNIT flag or its absence has any effect on that. \nVideo editors and frame stepping applications usually use the ACCURATE flag. \nif the ACCURATE flag is not specified it is up to the demuxer parser to decide how exact the seek should be. In this case the expectation is that the demuxer parser does a resonable best effort attempt trading speed for accuracy. In the absence of an index the seek position may be approximated. \nif the ACCURATE flag is specified absolute accuracy is required and speed is of no concern. It is not acceptable to just approximate the seek position in that case. \nthe ACCURATE flag does not imply that the segment starts at the requested seek position or should be adjusted to the nearest keyframe only the KEY_UNIT flag determines that. \nAll combinations of these two flags are valid \nneither flag specified segment starts at seek position send data from preceding key frame or earlier feel free to approximate the seek position \nonly KEY_UNIT specified segment starts from position of nearest keyframe send data from nearest keyframe feel free to approximate the seek position \nonly ACCURATE specified segment starts at seek position send data from preceding key frame or earlier do not approximate the seek position under any circumstances \nACCURATE KEY_UNIT specified segment starts from position of nearest keyframe send data from nearest key frame do not approximate the seek position under any circumstances \n"});