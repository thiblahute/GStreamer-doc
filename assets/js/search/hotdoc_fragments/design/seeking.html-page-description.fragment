fragment_downloaded_cb({"url": "design/seeking.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"seeking.md\">\n<h1 id=\"seeking\">Seeking</h1>\n<p>Seeking in GStreamer means configuring the pipeline for playback of the\nmedia between a certain start and stop time, called the playback\nsegment. By default a pipeline will play from position 0 to the total\nduration of the media at a rate of 1.0.</p>\n<p>A seek is performed by sending a <code>SEEK</code> event to the sink elements of a\npipeline. Sending the <code>SEEK</code> event to a bin will by default forward the\nevent to all sinks in the bin.</p>\n<p>When performing a seek, the start and stop values of the segment can be\nspecified as absolute positions or relative to the currently configured\nplayback segment. Note that it is not possible to seek relative to the\ncurrent playback position. To seek relative to the current playback\nposition, one must query the position first and then perform an absolute\nseek to the desired position.</p>\n<p>If a seek operation is requested using the <code>GST_SEEK_FLAG_FLUSH</code> flag, all\npending data in the pipeline is discarded and playback starts from the new\nposition immediately.  If this flag is not set, the seek is queued to be\nexecuted as soon as possible, which might be after all queues are emptied.</p>\n<p>Seeking can be performed in different formats such as time, frames or\nsamples.</p>\n<p>The seeking can be performed to a nearby key unit or to the exact\n(estimated) unit in the media (<code>GST_SEEK_FLAG_KEY_UNIT</code>). See below\nfor more details on this.</p>\n<p>The seeking can be performed by using an estimated target position or in\nan accurate way (<code>GST_SEEK_FLAG_ACCURATE</code>). For some formats this can\nresult in having to scan the complete file in order to accurately find\nthe target unit. See below for more details on this.</p>\n<p>Non segment seeking will make the pipeline emit EOS when the configured\nsegment has been played.</p>\n<p>Segment seeking (using the <code>GST_SEEK_FLAG_SEGMENT</code>) will not emit an\nEOS at the end of the playback segment but will post a <code>SEGMENT_DONE</code>\nmessage on the bus. This message is posted by the element driving the\nplayback in the pipeline, typically a demuxer. After receiving the\nmessage, the application can reconnect the pipeline or issue other seek\nevents in the pipeline. Since the message is posted as early as possible\nin the pipeline, the application has some time to issue a new seek to\nmake the transition seamless. Typically the allowed delay is defined by\nthe buffer sizes of the sinks as well as the size of any queues in the\npipeline.</p>\n<p>The seek can also change the playback speed of the configured segment. A\nspeed of 1.0 is normal speed, 2.0 is double speed. Negative values mean\nbackward playback.</p>\n<p>When performing a seek with a playback rate different from 1.0, the\n<code>GST_SEEK_FLAG_SKIP</code> flag can be used to instruct decoders and demuxers\nthat they are allowed to skip decoding. This can be useful when resource\nconsumption is more important than accurately producing all frames.</p>\n<!-- FIXME # Seeking in push based elements-->\n<h2 id=\"generating-seeking-events\">Generating seeking events</h2>\n<p>A seek event is created with <code>gst_event_new_seek()</code>.</p>\n<h2 id=\"seeking-variants\">Seeking variants</h2>\n<p>The different kinds of seeking methods and their internal workings are\ndescribed below.</p>\n<h3 id=\"flush-seeking\">FLUSH seeking</h3>\n<p>This is the most common way of performing a seek in a playback\napplication. The application issues a seek on the pipeline and the new\nmedia is immediately played after the seek call returns.</p>\n<h3 id=\"seeking-without-flush\">seeking without FLUSH</h3>\n<p>This seek type is typically performed after issuing segment seeks to\nfinish the playback of the pipeline.</p>\n<p>Performing a non-flushing seek in a <code>PAUSED</code> pipeline blocks until the\npipeline is set to playing again, since all data passing is blocked in\nthe prerolled sinks.</p>\n<h3 id=\"segment-seeking-with-flush\">segment seeking with FLUSH</h3>\n<p>This seek is typically performed when starting seamless looping.</p>\n<h3 id=\"segment-seeking-without-flush\">segment seeking without FLUSH</h3>\n<p>This seek is typically performed when continuing seamless looping.</p>\n<h2 id=\"key_unit-and-accurate-flags\"><code>KEY_UNIT</code> and <code>ACCURATE</code> flags</h2>\n<p>This section aims to explain the behaviour expected by an element with\nregard to the <code>KEY_UNIT</code> and <code>ACCURATE</code> seek flags, using a parser\nor demuxer as an example.</p>\n<h3 id=\"default-behaviour\">DEFAULT BEHAVIOUR:</h3>\n<p>When a seek to a certain position is requested, the demuxer/parser will\ndo two things (ignoring flushing and segment seeks, and simplified for\nillustration purposes):</p>\n<ul>\n<li>\n<p>send a segment event with a new start position</p>\n</li>\n<li>\n<p>start pushing data/buffers again</p>\n</li>\n</ul>\n<p>To ensure that the data corresponding to the requested seek position can\nactually be decoded, a demuxer or parser needs to start pushing data\nfrom a keyframe/keyunit at or before the requested seek position.</p>\n<p>Unless requested differently (via the <code>KEY_UNIT</code> flag), the start of the\nsegment event should be the requested seek position.</p>\n<p>So by default a demuxer/parser will then start pushing data from\nposition DATA and send a segment event with start position <code>SEG_START</code>,\nand <code>DATA \u21d0 SEG_START</code>.</p>\n<p>If <code>DATA &lt; SEG_START</code>, a well-behaved video decoder will start decoding\nframes from DATA, but take into account the segment configured by the\ndemuxer via the segment event, and only actually output decoded video\nframes from <code>SEG_START</code> onwards, dropping all decoded frames that are\nbefore the segment start and adjusting the timestamp/duration of the\nbuffer that overlaps the segment start (\"clipping\"). A\nnot-so-well-behaved video decoder will start decoding frames from DATA\nand push decoded video frames out starting from position DATA, in which\ncase the frames that are before the configured segment start will\nusually be dropped/clipped downstream (e.g. by the video sink).</p>\n<h3 id=\"gst_seek_flag_key_unit\"><code>GST_SEEK_FLAG_KEY_UNIT</code></h3>\n<p>If the <code>KEY_UNIT</code> flag is specified, the demuxer/parser should adjust the\nsegment start to the position of the key frame closest to the requested\nseek position and then start pushing out data from there. The nearest\nkey frame may be before or after the requested seek position, but many\nimplementations will only look for the closest keyframe before the\nrequested position.</p>\n<p>Most media players and thumbnailers do (and should be doing) <code>KEY_UNIT</code>\nseeks by default, for performance reasons, to ensure almost-instant\nresponsiveness when scrubbing (dragging the seek slider in <code>PAUSED</code> or\n<code>PLAYING</code> mode). This works well for most media, but results in suboptimal\nbehaviour for a small number of <em>odd</em> files (e.g. files that only have\none keyframe at the very beginning, or only a few keyframes throughout\nthe entire stream). At the time of writing, a solution for this still\nneeds to be found, but could be implemented demuxer/parser-side, e.g.\nmake demuxers/parsers ignore the <code>KEY_UNIT</code> flag if the position\nadjustment would be larger than 1/10th of the duration or somesuch.</p>\n<p>Flags can be used to influence snapping direction for those cases where\nit matters. <code>SNAP_BEFORE</code> will select the preceding position to the seek\ntarget, and <code>SNAP_AFTER</code> will select the following one. If both flags are\nset, the nearest one to the seek target will be used. If none of these\nflags are set, the seeking implemention is free to select whichever it\nwants.</p>\n<h4 id=\"summary\">Summary:</h4>\n<ul>\n<li>\n<p>if the <code>KEY_UNIT</code> flag is <strong>not</strong> specified, the demuxer/parser\nshould start pushing data from a key unit preceding the seek\nposition (or from the seek position if that falls on a key unit),\nand the start of the new segment should be the requested seek\nposition.</p>\n</li>\n<li>\n<p>if the <code>KEY_UNIT</code> flag is specified, the demuxer/parser should start\npushing data from the key unit nearest the seek position (or from\nthe seek position if that falls on a key unit), and the start of the\nnew segment should be adjusted to the position of that key unit\nwhich was nearest the requested seek position (ie. the new segment\nstart should be the position from which data is pushed).</p>\n</li>\n</ul>\n<h3 id=\"gst_seek_flag_accurate\"><code>GST_SEEK_FLAG_ACCURATE</code></h3>\n<p>If the <code>ACCURATE</code> flag is specified in a seek request, the demuxer/parser\nis asked to do whatever it takes (!) to make sure the position\nseeked to is accurate in relation to the beginning of the stream. This\nmeans that it is not acceptable to just approximate the position (e.g.\nusing an average bitrate). The achieved position must be exact. In the\nworst case, the demuxer or parser needs to push data from the beginning\nof the file and let downstream clip everything before the requested\nsegment start.</p>\n<p>The <code>ACCURATE</code> flag does not affect what the segment start should be in\nrelation to the requested seek position. Only the <code>KEY_UNIT</code> flag (or its\nabsence) has any effect on that.</p>\n<p>Video editors and frame-stepping applications usually use the <code>ACCURATE</code>\nflag.</p>\n<h4 id=\"summary1\">Summary:</h4>\n<ul>\n<li>\n<p>if the <code>ACCURATE</code> flag is <strong>not</strong> specified, it is up to the\ndemuxer/parser to decide how exact the seek should be. In this case,\nthe expectation is that the demuxer/parser does a\nresonable best effort attempt, trading speed for accuracy. In the\nabsence of an index, the seek position may be approximated.</p>\n</li>\n<li>\n<p>if the <code>ACCURATE</code> flag <strong>is</strong> specified, absolute accuracy is required,\nand speed is of no concern. It is not acceptable to just approximate\nthe seek position in that case.</p>\n</li>\n<li>\n<p>the <code>ACCURATE</code> flag does not imply that the segment starts at the\nrequested seek position or should be adjusted to the nearest\nkeyframe, only the <code>KEY_UNIT</code> flag determines that.</p>\n</li>\n</ul>\n<h3 id=\"accurate-and-key_unit-combinations\"><code>ACCURATE</code> and <code>KEY_UNIT</code> combinations:</h3>\n<p>All combinations of these two flags are valid:</p>\n<ul>\n<li>\n<p>neither flag specified: segment starts at seek position, send data\nfrom preceding key frame (or earlier), feel free to approximate the\nseek position</p>\n</li>\n<li>\n<p>only <code>KEY_UNIT</code> specified: segment starts from position of nearest\nkeyframe, send data from nearest keyframe, feel free to approximate\nthe seek position</p>\n</li>\n<li>\n<p>only <code>ACCURATE</code> specified: segment starts at seek position, send data\nfrom preceding key frame (or earlier), do not approximate the seek\nposition under any circumstances</p>\n</li>\n<li>\n<p><code>ACCURATE | KEY_UNIT</code> specified: segment starts from position of\nnearest keyframe, send data from nearest key frame, do not\napproximate the seek position under any circumstances</p>\n</li>\n</ul>\n\n</div>\n\n\n\t"});