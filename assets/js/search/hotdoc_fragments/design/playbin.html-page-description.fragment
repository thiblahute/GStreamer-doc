fragment_downloaded_cb({"url": "design/playbin.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"playbin.md\">\n<h1 id=\"playbin\">playbin</h1>\n<p>The purpose of this element is to decode and render the media contained\nin a given generic uri. The element extends <code>GstPipeline</code> and is typically\nused in playback situations.</p>\n<p>Required features:</p>\n<ul>\n<li>accept and play any valid uri. This includes</li>\n<li>rendering video/audio</li>\n<li>overlaying subtitles on the video</li>\n<li>optionally read external subtitle files</li>\n<li>allow for hardware (non raw) sinks</li>\n<li>selection of audio/video/subtitle streams based on language.</li>\n<li>perform network buffering/incremental download</li>\n<li>gapless playback</li>\n<li>support for visualisations with configurable sizes</li>\n<li>ability to reject files that are too big, or of a format that would\nrequire too much CPU/memory usage.</li>\n<li>be very efficient with adding elements such as converters to reduce\nthe amount of negotiation that has to happen.</li>\n<li>handle chained oggs. This includes having support for dynamic pad\nadd and remove from a demuxer.</li>\n</ul>\n<h2 id=\"components\">Components</h2>\n<h3 id=\"decodebin\">decodebin</h3>\n<ul>\n<li>performs the autoplugging of demuxers/decoders</li>\n<li>emits signals when for steering the autoplugging</li>\n<li>to decide if a non-raw media format is acceptable as output</li>\n<li>to sort the possible decoders for a non-raw format</li>\n<li>see also decodebin2 design doc</li>\n</ul>\n<h3 id=\"uridecodebin\">uridecodebin</h3>\n<ul>\n<li>combination of a source to handle the given uri, an optional\nqueueing element and one or more decodebin2 elements to decode the\nnon-raw streams.</li>\n</ul>\n<h3 id=\"playsink\">playsink</h3>\n<ul>\n<li>handles display of audio/video/text.</li>\n<li>has request audio/video/text input pad. There is only one sinkpad\nper type. The requested pads define the configuration of the\ninternal pipeline.</li>\n<li>allows for setting audio/video sinks or does automatic\nsink selection.</li>\n<li>allows for configuration of visualisation element.</li>\n<li>allows for enable/disable of visualisation, audio and video.</li>\n</ul>\n<h3 id=\"playbin1\">playbin</h3>\n<ul>\n<li>combination of one or more uridecodebin elements to read the uri and\nsubtitle uri.</li>\n<li>support for queuing new media to support gapless playback.</li>\n<li>handles stream selection.</li>\n<li>uses playsink to display.</li>\n<li>selection of sinks and configuration of uridecodebin with raw\noutput formats.</li>\n</ul>\n<h2 id=\"gapless-playback-feature\">Gapless playback feature</h2>\n<p>playbin has an <code>about-to-finish</code> signal. The application should\nconfigure a new uri (and optional suburi) in the callback. When the\ncurrent media finishes, this new media will be played next.</p>\n\n</div>\n\n\n\t"});