fragment_downloaded_cb({"url": "design/qos.html#gstbasesink", "fragment": "GstBaseSink \nThe primary implementor of QoS is GstBaseSink. It will calculate the following values \nupstream running average of processing time in stream time. \nrunning average of buffer durations. \nrunning average of render time in system time \nrendered dropped buffers \nThe processing time and the average buffer durations will be used to calculate a proportion. \nThe processing time in system time is compared to render time to decide if the majority of the time is spend upstream or in the sink itself. This value is used to decide overflow or underflow. \nThe number of rendered and dropped buffers is used to query stats on the sink. \nA QoS event with the most current values is sent upstream for each buffer that was received by the sink. \nNormally QoS is only enabled for video pipelines. The reason being that drops in audio are more disturbing than dropping video frames. Also video requires in general more processing than audio. \nNormally there is a threshold for when buffers get dropped in a video sink. Frames that arrive milliseconds late are still rendered as it is not noticeable for the human eye. \nA QoS message is posted whenever a part of a buffer is dropped. \nIn throttle mode the sink sends QoS event upstream with the timestamp set to the running_time of the latest buffer and the jitter set to the throttle interval. If the throttled buffer is late the lateness is subtracted from the throttle interval in order to keep the desired throttle interval. \n"});