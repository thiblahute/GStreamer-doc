<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Caps negotiation</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/utils.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/navigation.js"></script>


<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>


<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body data-spy="scroll" data-target=".scrollspy" data-offset="70">


<nav class="navbar navbar-fixed-top navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a href="https://gstreamer.freedesktop.org/" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
							</ul>
		</div>
	</div>
</nav>

<main class="page-row page-row-expanded">
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-doc-1.0" data-hotdoc-ref="plugin-development/advanced/negotiation.html" class="page_container" id="page-wrapper">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-xl-2" id="sidenav-column">
	<div class="panel panel-collapse" id="sidenav" data-hotdoc-role="navigation">
		<div id="sidenav-search" role="search">
			<input type="text" class="form-control" placeholder="Fetching index" id="sidenav-lookup-field" disabled>
		</div>
		<div id="sitenav-wrapper" class="mCustomScrollbar" data-mcs-theme="minimal">
			<div class="sidenav-main-panel-body">
				<div id="site-navigation">
				</div>
			</div>
			<!-- FIXME -->
			<div style="height: 76px;"></div>
		</div>
	</div>
</div>

<div class="col-sm-12 col-md-9 col-xl-8">
	<div id="main">
				
<div id="page-description" data-hotdoc-source="negotiation.md">
<h1 id="caps-negotiation">Caps negotiation</h1>
<p>Caps negotiation is the act of finding a media format (GstCaps) between
elements that they can handle. This process in GStreamer can in most
cases find an optimal solution for the complete pipeline. In this
section we explain how this works.</p>
<h2 id="caps-negotiation-basics">Caps negotiation basics</h2>
<p>In GStreamer, negotiation of the media format always follows the
following simple rules:</p>
<ul>
<li>
<p>A downstream element suggest a format on its sinkpad and places the
suggestion in the result of the CAPS query performed on the sinkpad.
See also <a href="../../#implementing-a-caps-query-function">Implementing a CAPS query
function</a>.</p>
</li>
<li>
<p>An upstream element decides on a format. It sends the selected media
format downstream on its source pad with a CAPS event. Downstream
elements reconfigure themselves to handle the media type in the CAPS
event on the sinkpad.</p>
</li>
<li>
<p>A downstream element can inform upstream that it would like to
suggest a new format by sending a RECONFIGURE event upstream. The
RECONFIGURE event simply instructs an upstream element to restart
the negotiation phase. Because the element that sent out the
RECONFIGURE event is now suggesting another format, the format in
the pipeline might change.</p>
</li>
</ul>
<p>In addition to the CAPS and RECONFIGURE event and the CAPS query, there
is an ACCEPT_CAPS query to quickly check if a certain caps can be
accepted by an element.</p>
<p>All negotiation follows these simple rules. Let's take a look at some
typical uses cases and how negotiation happens.</p>
<h2 id="caps-negotiation-use-cases">Caps negotiation use cases</h2>
<p>In what follows we will look at some use cases for push-mode scheduling.
The pull-mode scheduling negotiation phase is discussed in <a href="../../#pull-mode-caps-negotiation">Pull-mode
Caps negotiation</a> and is actually similar
as we will see.</p>
<p>Since the sink pads only suggest formats and the source pads need to
decide, the most complicated work is done in the source pads. We can
identify 3 caps negotiation use cases for the source pads:</p>
<ul>
<li>
<p>Fixed negotiation. An element can output one format only. See <a href="../../#fixed-negotiation">Fixed
negotiation</a>.</p>
</li>
<li>
<p>Transform negotiation. There is a (fixed) transform between the
input and output format of the element, usually based on some
element property. The caps that the element will produce depend on
the upstream caps and the caps that the element can accept depend on
the downstream caps. See <a href="../../#transform-negotiation">Transform
negotiation</a>.</p>
</li>
<li>
<p>Dynamic negotiation. An element can output many formats. See
<a href="../../#dynamic-negotiation">Dynamic negotiation</a>.</p>
</li>
</ul>
<h3 id="fixed-negotiation">Fixed negotiation</h3>
<p>In this case, the source pad can only produce a fixed format. Usually
this format is encoded inside the media. No downstream element can ask
for a different format, the only way that the source pad will
renegotiate is when the element decides to change the caps itself.</p>
<p>Elements that could implement fixed caps (on their source pads) are, in
general, all elements that are not renegotiable. Examples include:</p>
<ul>
<li>
<p>A typefinder, since the type found is part of the actual data stream
and can thus not be re-negotiated. The typefinder will look at the
stream of bytes, figure out the type, send a CAPS event with the
caps and then push buffers of the type.</p>
</li>
<li>
<p>Pretty much all demuxers, since the contained elementary data
streams are defined in the file headers, and thus not renegotiable.</p>
</li>
<li>
<p>Some decoders, where the format is embedded in the data stream and
not part of the peercaps <em>and</em> where the decoder itself is not
reconfigurable, too.</p>
</li>
<li>
<p>Some sources that produce a fixed format.</p>
</li>
</ul>
<p><code>gst_pad_use_fixed_caps()</code> is used on the source pad with fixed caps. As
long as the pad is not negotiated, the default CAPS query will return
the caps presented in the padtemplate. As soon as the pad is negotiated,
the CAPS query will return the negotiated caps (and nothing else). These
are the relevant code snippets for fixed caps source pads.</p>
<pre><code class="language-c">
[..]
  pad = gst_pad_new_from_static_template (..);
  gst_pad_use_fixed_caps (pad);
[..]


</code></pre>
<p>The fixed caps can then be set on the pad by calling <code>gst_pad_set_caps ()</code>.</p>
<pre><code class="language-c">
[..]
    caps = gst_caps_new_simple ("audio/x-raw",
        "format", G_TYPE_STRING, GST_AUDIO_NE(F32),
        "rate", G_TYPE_INT, &lt;samplerate&gt;,
        "channels", G_TYPE_INT, &lt;num-channels&gt;, NULL);
    if (!gst_pad_set_caps (pad, caps)) {
      GST_ELEMENT_ERROR (element, CORE, NEGOTIATION, (NULL),
          ("Some debug information here"));
      return GST_FLOW_ERROR;
    }
[..]


</code></pre>
<p>These types of elements also don't have a relation between the input
format and the output format, the input caps simply don't contain the
information needed to produce the output caps.</p>
<p>All other elements that need to be configured for the format should
implement full caps negotiation, which will be explained in the next few
sections.</p>
<h3 id="transform-negotiation">Transform negotiation</h3>
<p>In this negotiation technique, there is a fixed transform between the
element input caps and the output caps. This transformation could be
parameterized by element properties but not by the content of the stream
(see <a href="../../#fixed-negotiation">Fixed negotiation</a> for that use-case).</p>
<p>The caps that the element can accept depend on the (fixed
transformation) downstream caps. The caps that the element can produce
depend on the (fixed transformation of) the upstream caps.</p>
<p>This type of element can usually set caps on its source pad from the
<code>_event()</code> function on the sink pad when it received the CAPS event.
This means that the caps transform function transforms a fixed caps into
another fixed caps. Examples of elements include:</p>
<ul>
<li>
<p>Videobox. It adds configurable border around a video frame depending
on object properties.</p>
</li>
<li>
<p>Identity elements. All elements that don't change the format of the
data, only the content. Video and audio effects are an example.
Other examples include elements that inspect the stream.</p>
</li>
<li>
<p>Some decoders and encoders, where the output format is defined by
input format, like mulawdec and mulawenc. These decoders usually
have no headers that define the content of the stream. They are
usually more like conversion elements.</p>
</li>
</ul>
<p>Below is an example of a negotiation steps of a typical transform
element. In the sink pad CAPS event handler, we compute the caps for the
source pad and set those.</p>
<pre><code class="language-c">
  [...]

static gboolean
gst_my_filter_setcaps (GstMyFilter *filter,
               GstCaps *caps)
{
  GstStructure *structure;
  int rate, channels;
  gboolean ret;
  GstCaps *outcaps;

  structure = gst_caps_get_structure (caps, 0);
  ret = gst_structure_get_int (structure, "rate", &amp;rate);
  ret = ret &amp;&amp; gst_structure_get_int (structure, "channels", &amp;channels);
  if (!ret)
    return FALSE;

  outcaps = gst_caps_new_simple ("audio/x-raw",
      "format", G_TYPE_STRING, GST_AUDIO_NE(S16),
      "rate", G_TYPE_INT, rate,
      "channels", G_TYPE_INT, channels, NULL);
  ret = gst_pad_set_caps (filter-&gt;srcpad, outcaps);
  gst_caps_unref (outcaps);

  return ret;
}

static gboolean
gst_my_filter_sink_event (GstPad    *pad,
                  GstObject *parent,
                  GstEvent  *event)
{
  gboolean ret;
  GstMyFilter *filter = GST_MY_FILTER (parent);

  switch (GST_EVENT_TYPE (event)) {
    case GST_EVENT_CAPS:
    {
      GstCaps *caps;

      gst_event_parse_caps (event, &amp;caps);
      ret = gst_my_filter_setcaps (filter, caps);
      break;
    }
    default:
      ret = gst_pad_event_default (pad, parent, event);
      break;
  }
  return ret;
}

  [...]


</code></pre>
<h3 id="dynamic-negotiation">Dynamic negotiation</h3>
<p>A last negotiation method is the most complex and powerful dynamic
negotiation.</p>
<p>Like with the transform negotiation in <a href="../../#transform-negotiation">Transform
negotiation</a>, dynamic negotiation will perform a
transformation on the downstream/upstream caps. Unlike the transform
negotiation, this transform will convert fixed caps to unfixed caps.
This means that the sink pad input caps can be converted into unfixed
(multiple) formats. The source pad will have to choose a format from all
the possibilities. It would usually like to choose a format that
requires the least amount of effort to produce but it does not have to
be. The selection of the format should also depend on the caps that can
be accepted downstream (see a QUERY_CAPS function in <a href="../../#implementing-a-caps-query-function">Implementing a
CAPS query function</a>).</p>
<p>A typical flow goes like this:</p>
<ul>
<li>
<p>Caps are received on the sink pad of the element.</p>
</li>
<li>
<p>If the element prefers to operate in passthrough mode, check if
downstream accepts the caps with the ACCEPT_CAPS query. If it does,
we can complete negotiation and we can operate in passthrough mode.</p>
</li>
<li>
<p>Calculate the possible caps for the source pad.</p>
</li>
<li>
<p>Query the downstream peer pad for the list of possible caps.</p>
</li>
<li>
<p>Select from the downstream list the first caps that you can
transform to and set this as the output caps. You might have to
fixate the caps to some reasonable defaults to construct fixed caps.</p>
</li>
</ul>
<p>Examples of this type of elements include:</p>
<ul>
<li>
<p>Converter elements such as videoconvert, audioconvert,
audioresample, videoscale, ...</p>
</li>
<li>
<p>Source elements such as audiotestsrc, videotestsrc, v4l2src,
pulsesrc, ...</p>
</li>
</ul>
<p>Let's look at the example of an element that can convert between
samplerates, so where input and output samplerate don't have to be the
same:</p>
<pre><code class="language-c">
static gboolean
gst_my_filter_setcaps (GstMyFilter *filter,
               GstCaps *caps)
{
  if (gst_pad_set_caps (filter-&gt;srcpad, caps)) {
    filter-&gt;passthrough = TRUE;
  } else {
    GstCaps *othercaps, *newcaps;
    GstStructure *s = gst_caps_get_structure (caps, 0), *others;

    /* no passthrough, setup internal conversion */
    gst_structure_get_int (s, "channels", &amp;filter-&gt;channels);
    othercaps = gst_pad_get_allowed_caps (filter-&gt;srcpad);
    others = gst_caps_get_structure (othercaps, 0);
    gst_structure_set (others,
      "channels", G_TYPE_INT, filter-&gt;channels, NULL);

    /* now, the samplerate value can optionally have multiple values, so
     * we "fixate" it, which means that one fixed value is chosen */
    newcaps = gst_caps_copy_nth (othercaps, 0);
    gst_caps_unref (othercaps);
    gst_pad_fixate_caps (filter-&gt;srcpad, newcaps);
    if (!gst_pad_set_caps (filter-&gt;srcpad, newcaps))
      return FALSE;

    /* we are now set up, configure internally */
    filter-&gt;passthrough = FALSE;
    gst_structure_get_int (s, "rate", &amp;filter-&gt;from_samplerate);
    others = gst_caps_get_structure (newcaps, 0);
    gst_structure_get_int (others, "rate", &amp;filter-&gt;to_samplerate);
  }

  return TRUE;
}

static gboolean
gst_my_filter_sink_event (GstPad    *pad,
                  GstObject *parent,
                  GstEvent  *event)
{
  gboolean ret;
  GstMyFilter *filter = GST_MY_FILTER (parent);

  switch (GST_EVENT_TYPE (event)) {
    case GST_EVENT_CAPS:
    {
      GstCaps *caps;

      gst_event_parse_caps (event, &amp;caps);
      ret = gst_my_filter_setcaps (filter, caps);
      break;
    }
    default:
      ret = gst_pad_event_default (pad, parent, event);
      break;
  }
  return ret;
}

static GstFlowReturn
gst_my_filter_chain (GstPad    *pad,
             GstObject *parent,
             GstBuffer *buf)
{
  GstMyFilter *filter = GST_MY_FILTER (parent);
  GstBuffer *out;

  /* push on if in passthrough mode */
  if (filter-&gt;passthrough)
    return gst_pad_push (filter-&gt;srcpad, buf);

  /* convert, push */
  out = gst_my_filter_convert (filter, buf);
  gst_buffer_unref (buf);

  return gst_pad_push (filter-&gt;srcpad, out);
}


</code></pre>
<h2 id="upstream-caps-renegotiation">Upstream caps (re)negotiation</h2>
<p>Upstream negotiation's primary use is to renegotiate (part of) an
already-negotiated pipeline to a new format. Some practical examples
include to select a different video size because the size of the video
window changed, and the video output itself is not capable of rescaling,
or because the audio channel configuration changed.</p>
<p>Upstream caps renegotiation is requested by sending a
GST_EVENT_RECONFIGURE event upstream. The idea is that it will
instruct the upstream element to reconfigure its caps by doing a new
query for the allowed caps and then choosing a new caps. The element
that sends out the RECONFIGURE event would influence the selection of
the new caps by returning the new preferred caps from its
GST_QUERY_CAPS query function. The RECONFIGURE event will set the
GST_PAD_FLAG_NEED_RECONFIGURE on all pads that it travels over.</p>
<p>It is important to note here that different elements actually have
different responsibilities here:</p>
<ul>
<li>
<p>Elements that want to propose a new format upstream need to first
check if the new caps are acceptable upstream with an ACCEPT_CAPS
query. Then they would send a RECONFIGURE event and be prepared to
answer the CAPS query with the new preferred format. It should be
noted that when there is no upstream element that can (or wants) to
renegotiate, the element needs to deal with the currently configured
format.</p>
</li>
<li>
<p>Elements that operate in transform negotiation according to
<a href="../../#transform-negotiation">Transform negotiation</a> pass the RECONFIGURE
event upstream. Because these elements simply do a fixed transform
based on the upstream caps, they need to send the event upstream so
that it can select a new format.</p>
</li>
<li>
<p>Elements that operate in fixed negotiation (<a href="../../#fixed-negotiation">Fixed
negotiation</a>) drop the RECONFIGURE event. These
elements can't reconfigure and their output caps don't depend on the
upstream caps so the event can be dropped.</p>
</li>
<li>
<p>Elements that can be reconfigured on the source pad (source pads
implementing dynamic negotiation in <a href="../../#dynamic-negotiation">Dynamic
negotiation</a>) should check its
NEED_RECONFIGURE flag with <code>gst_pad_check_reconfigure ()</code> and it
should start renegotiation when the function returns TRUE.</p>
</li>
</ul>
<h2 id="implementing-a-caps-query-function">Implementing a CAPS query function</h2>
<p>A <code>_query ()</code>-function with the GST_QUERY_CAPS query type is called
when a peer element would like to know which formats this pad supports,
and in what order of preference. The return value should be all formats
that this elements supports, taking into account limitations of peer
elements further downstream or upstream, sorted by order of preference,
highest preference first.</p>
<pre><code class="language-c">
static gboolean
gst_my_filter_query (GstPad *pad, GstObject * parent, GstQuery * query)
{
  gboolean ret;
  GstMyFilter *filter = GST_MY_FILTER (parent);

  switch (GST_QUERY_TYPE (query)) {
    case GST_QUERY_CAPS
    {
      GstPad *otherpad;
      GstCaps *temp, *caps, *filt, *tcaps;
      gint i;

      otherpad = (pad == filter-&gt;srcpad) ? filter-&gt;sinkpad :
                                           filter-&gt;srcpad;
      caps = gst_pad_get_allowed_caps (otherpad);

      gst_query_parse_caps (query, &amp;filt);

      /* We support *any* samplerate, indifferent from the samplerate
       * supported by the linked elements on both sides. */
      for (i = 0; i &lt; gst_caps_get_size (caps); i++) {
        GstStructure *structure = gst_caps_get_structure (caps, i);

        gst_structure_remove_field (structure, "rate");
      }

      /* make sure we only return results that intersect our
       * padtemplate */
      tcaps = gst_pad_get_pad_template_caps (pad);
      if (tcaps) {
        temp = gst_caps_intersect (caps, tcaps);
        gst_caps_unref (caps);
        gst_caps_unref (tcaps);
        caps = temp;
      }
      /* filter against the query filter when needed */
      if (filt) {
        temp = gst_caps_intersect (caps, filt);
        gst_caps_unref (caps);
        caps = temp;
      }
      gst_query_set_caps_result (query, caps);
      gst_caps_unref (caps);
      ret = TRUE;
      break;
    }
    default:
      ret = gst_pad_query_default (pad, parent, query);
      break;
  }
  return ret;
}


</code></pre>
<h2 id="pullmode-caps-negotiation">Pull-mode Caps negotiation</h2>
<p>WRITEME, the mechanism of pull-mode negotiation is not yet fully
understood.</p>
<p>Using all the knowledge you've acquired by reading this chapter, you
should be able to write an element that does correct caps negotiation.
If in doubt, look at other elements of the same type in our git
repository to get an idea of how they do what you want to do.</p>

</div>


	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
</div>
<div class="hidden-xs col-xl-2">
</div>
	</div>
</div>
</main>

<footer class="page-row">
	<div class="container-fluid">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-xl-2"></div>
		<div class="col-sm-12 col-md-9 col-xl-8">
						
		</div>
		<div class="hidden-xs col-xl-2"></div>
	</div>
</div>
</footer>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>