<!DOCTYPE html>
<html lang="en">
<head>

<base href="../..">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>Events: Seeking, Navigation and More</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/bootstrap-toc.min.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/scrollspy.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/jquery.touchSwipe.min.js"></script>
<script src="assets/js/anchor.min.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>

<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/trie.js"></script>
<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>

<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body class="no-script
" data-spy="scroll" data-target="#toc" data-offset="70">

<script>
$('body').removeClass('no-script');
</script>

<nav class="navbar navbar-fixed-top navbar-default" id="topnav">
	<div class="container-fluid">
		<div class="navbar-right">
			<a id="toc-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<form action="" class="navbar-form pull-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                        </form>
		</div>
		<div class="navbar-header">
			<a id="sidenav-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<a id="home-link" href="index.html" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        API References<span class="caret"></span>
    </a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="libgstreamer-1.0/c/index.html">GStreamer core</a>
			</li>
					<li>
				<a href="libs.html">GStreamer Libraries</a>
			</li>
					<li>
				<a href="plugins_doc.html">GStreamer Plugins</a>
			</li>
		</ul>
</li>

<li>
    <a href="application-development/index.html">Application manual</a>
</li>


<li>
    <a href="tutorials/index.html">Tutorials</a>
</li>

			</ul>
			<div class="hidden-xs hidden-sm navbar-text navbar-center">
							</div>
		</div>
	</div>
</nav>

<main>
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-1.0" data-hotdoc-ref="plugin-development/advanced/events.html" class="page_container" id="page-wrapper">
<script src="assets/js/utils.js"></script>

<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
	<script src="assets/js/navigation.js"></script>
			<script src="assets/js/sitemap.js"></script>
	</div>

<div id="body">
	<div id="main">
				    <div id="page-description" data-hotdoc-source="events.md" data-hotdoc-role="main">
        <h1 id="events-seeking-navigation-and-more">Events: Seeking, Navigation and More</h1>
<p>There are many different event types but only two ways they can travel
in the pipeline: downstream or upstream. It is very important to
understand how both of these methods work because if one element in the
pipeline is not handling them correctly the whole event system of the
pipeline is broken. We will try to explain here how these methods work
and how elements are supposed to implement them.</p>
<h2 id="downstream-events">Downstream events</h2>
<p>Downstream events are received through the sink pad's event handler, as
set using <code>gst_pad_set_event_function ()</code> when the pad was created.</p>
<p>Downstream events can travel in two ways: they can be in-band
(serialised with the buffer flow) or out-of-band (travelling through the
pipeline instantly, possibly not in the same thread as the streaming
thread that is processing the buffers, skipping ahead of buffers being
processed or queued in the pipeline). The most common downstream events
(SEGMENT, CAPS, TAG, EOS) are all serialised with the buffer flow.</p>
<p>Here is a typical event function:</p>
<pre><code class="language-c">static gboolean
gst_my_filter_sink_event (GstPad  *pad, GstObject * parent, GstEvent * event)
{
  GstMyFilter *filter;
  gboolean ret;

  filter = GST_MY_FILTER (parent);
  ...

  switch (GST_EVENT_TYPE (event)) {
    case GST_EVENT_SEGMENT:
      /* maybe save and/or update the current segment (e.g. for output
       * clipping) or convert the event into one in a different format
       * (e.g. BYTES to TIME) or drop it and set a flag to send a segment
       * event in a different format later */
      ret = gst_pad_push_event (filter-&gt;src_pad, event);
      break;
    case GST_EVENT_EOS:
      /* end-of-stream, we should close down all stream leftovers here */
      gst_my_filter_stop_processing (filter);
      ret = gst_pad_push_event (filter-&gt;src_pad, event);
      break;
    case GST_EVENT_FLUSH_STOP:
      gst_my_filter_clear_temporary_buffers (filter);
      ret = gst_pad_push_event (filter-&gt;src_pad, event);
      break;
    default:
      ret = gst_pad_event_default (pad, parent, event);
      break;
  }

  ...
  return ret;
}

</code></pre>
<p>If your element is chain-based, you will almost always have to implement
a sink event function, since that is how you are notified about
segments, caps and the end of the stream.</p>
<p>If your element is exclusively loop-based, you may or may not want a
sink event function (since the element is driving the pipeline it will
know the length of the stream in advance or be notified by the flow
return value of <code>gst_pad_pull_range()</code>. In some cases even loop-based
element may receive events from upstream though (for example audio
decoders with an id3demux or apedemux element in front of them, or
demuxers that are being fed input from sources that send additional
information about the stream in custom events, as DVD sources do).</p>
<h2 id="upstream-events">Upstream events</h2>
<p>Upstream events are generated by an element somewhere downstream in the
pipeline (example: a video sink may generate navigation events that
informs upstream elements about the current position of the mouse
pointer). This may also happen indirectly on request of the application,
for example when the application executes a seek on a pipeline this seek
request will be passed on to a sink element which will then in turn
generate an upstream seek event.</p>
<p>The most common upstream events are seek events, Quality-of-Service
(QoS) and reconfigure events.</p>
<p>An upstream event can be sent using the <code>gst_pad_send_event</code> function.
This function simply call the default event handler of that pad. The
default event handler of pads is <code>gst_pad_event_default</code>, and it
basically sends the event to the peer of the internally linked pad. So
upstream events always arrive on the src pad of your element and are
handled by the default event handler except if you override that handler
to handle it yourself. There are some specific cases where you have to
do that :</p>
<ul>
<li>
<p>If you have multiple sink pads in your element. In that case you
will have to decide which one of the sink pads you will send the
event to (if not all of them).</p>
</li>
<li>
<p>If you need to handle that event locally. For example a navigation
event that you will want to convert before sending it upstream, or a
QoS event that you want to handle.</p>
</li>
</ul>
<p>The processing you will do in that event handler does not really matter
but there are important rules you have to absolutely respect because one
broken element event handler is breaking the whole pipeline event
handling. Here they are :</p>
<ul>
<li>
<p>Always handle events you won't handle using the default
<code>gst_pad_event_default</code> method. This method will depending on the
event, forward the event or drop it.</p>
</li>
<li>
<p>If you are generating some new event based on the one you received
don't forget to gst_event_unref the event you received.</p>
</li>
<li>
<p>Event handler function are supposed to return TRUE or FALSE
indicating if the event has been handled or not. Never simply return
TRUE/FALSE in that handler except if you really know that you have
handled that event.</p>
</li>
<li>
<p>Remember that the event handler might be called from a different
thread than the streaming thread, so make sure you use appropriate
locking everywhere.</p>
</li>
</ul>
<h2 id="all-events-together">All Events Together</h2>
<p>In this chapter follows a list of all defined events that are currently
being used, plus how they should be used/interpreted. You can check the
what type a certain event is using the GST_EVENT_TYPE macro (or if you
need a string for debugging purposes you can use
GST_EVENT_TYPE_NAME).</p>
<p>In this chapter, we will discuss the following events:</p>
<ul>
<li>
<p><a href="plugin-development/advanced/events.html#stream-start">Stream Start</a></p>
</li>
<li>
<p><a href="plugin-development/advanced/events.html#caps">Caps</a></p>
</li>
<li>
<p><a href="plugin-development/advanced/events.html#segment">Segment</a></p>
</li>
<li>
<p><a href="plugin-development/advanced/events.html#tag-metadata">Tag (metadata)</a></p>
</li>
<li>
<p><a href="plugin-development/advanced/events.html#end-of-stream-eos">End of Stream (EOS)</a></p>
</li>
<li>
<p><a href="plugin-development/advanced/events.html#table-of-contents">Table Of Contents</a></p>
</li>
<li>
<p><a href="plugin-development/advanced/events.html#gap">Gap</a></p>
</li>
<li>
<p><a href="plugin-development/advanced/events.html#flush-start">Flush Start</a></p>
</li>
<li>
<p><a href="plugin-development/advanced/events.html#flush-stop">Flush Stop</a></p>
</li>
<li>
<p><a href="plugin-development/advanced/events.html#quality-of-service-qos">Quality Of Service (QOS)</a></p>
</li>
<li>
<p><a href="plugin-development/advanced/events.html#seek-request">Seek Request</a></p>
</li>
<li>
<p><a href="plugin-development/advanced/events.html#navigation">Navigation</a></p>
</li>
</ul>
<p>For more comprehensive information about events and how they should be
used correctly in various circumstances please consult the GStreamer
design documentation. This section only gives a general overview.</p>
<h3 id="stream-start">Stream Start</h3>
<p>WRITEME</p>
<h3 id="caps">Caps</h3>
<p>The CAPS event contains the format description of the following buffers.
See <a href="plugin-development/advanced/negotiation.html">Caps negotiation</a> for more information
about negotiation.</p>
<h3 id="segment">Segment</h3>
<p>A segment event is sent downstream to announce the range of valid
timestamps in the stream and how they should be transformed into
running-time and stream-time. A segment event must always be sent before
the first buffer of data and after a flush (see above).</p>
<p>The first segment event is created by the element driving the pipeline,
like a source operating in push-mode or a demuxer/decoder operating
pull-based. This segment event then travels down the pipeline and may be
transformed on the way (a decoder, for example, might receive a segment
event in BYTES format and might transform this into a segment event in
TIMES format based on the average bitrate).</p>
<p>Depending on the element type, the event can simply be forwarded using
<code>gst_pad_event_default ()</code>, or it should be parsed and a modified event
should be sent on. The last is true for demuxers, which generally have a
byte-to-time conversion concept. Their input is usually byte-based, so
the incoming event will have an offset in byte units
(<code>GST_FORMAT_BYTES</code>), too. Elements downstream, however, expect segment
events in time units, so that it can be used to synchronize against the
pipeline clock. Therefore, demuxers and similar elements should not
forward the event, but parse it, free it and send a segment event (in
time units, <code>GST_FORMAT_TIME</code>) further downstream.</p>
<p>The segment event is created using the function <code>gst_event_new_segment ()</code>. See the API reference and design document for details about its
parameters.</p>
<p>Elements parsing this event can use gst_event_parse_segment() to
extract the event details. Elements may find the GstSegment API useful
to keep track of the current segment (if they want to use it for output
clipping, for example).</p>
<h3 id="tag-metadata">Tag (metadata)</h3>
<p>Tagging events are being sent downstream to indicate the tags as parsed
from the stream data. This is currently used to preserve tags during
stream transcoding from one format to the other. Tags are discussed
extensively in <a href="plugin-development/advanced/tagging.html">Tagging (Metadata and Streaminfo)</a>. Most elements
will simply forward the event by calling <code>gst_pad_event_default ()</code>.</p>
<p>The tag event is created using the function <code>gst_event_new_tag ()</code>, but
more often elements will send a tag event downstream that will be
converted into a message on the bus by sink elements. All of these
functions require a filled-in taglist as argument, which they will take
ownership of.</p>
<p>Elements parsing this event can use the function <code>gst_event_parse_tag ()</code> to
acquire the taglist that the event contains.</p>
<h3 id="end-of-stream-eos">End of Stream (EOS)</h3>
<p>End-of-stream events are sent if the stream that an element sends out is
finished. An element receiving this event (from upstream, so it receives
it on its sinkpad) will generally just process any buffered data (if
there is any) and then forward the event further downstream. The
<code>gst_pad_event_default ()</code> takes care of all this, so most elements do
not need to support this event. Exceptions are elements that explicitly
need to close a resource down on EOS, and N-to-1 elements. Note that the
stream itself is <em>not</em> a resource that should be closed down on EOS!
Applications might seek back to a point before EOS and continue playing
again.</p>
<p>The EOS event has no properties, which makes it one of the simplest
events in GStreamer. It is created using the <code>gst_event_new_eos()</code>
function.</p>
<p>It is important to note that <em>only elements driving the pipeline should
ever send an EOS event</em>. If your element is chain-based, it is not
driving the pipeline. Chain-based elements should just return
GST_FLOW_EOS from their chain function at the end of the stream (or
the configured segment), the upstream element that is driving the
pipeline will then take care of sending the EOS event (or alternatively
post a SEGMENT_DONE message on the bus depending on the mode of
operation). If you are implementing your own source element, you also do
not need to ever manually send an EOS event, you should also just return
GST_FLOW_EOS in your create or fill function (assuming your element
derives from GstBaseSrc or GstPushSrc).</p>
<h3 id="table-of-contents">Table Of Contents</h3>
<p>WRITEME</p>
<h3 id="gap">Gap</h3>
<p>WRITEME</p>
<h3 id="flush-start">Flush Start</h3>
<p>The flush start event is sent downstream (in push mode) or upstream (in
pull mode) if all buffers and caches in the pipeline should be emptied.
“Queue” elements will empty their internal list of buffers when they
receive this event, for example. File sink elements (e.g. “filesink”)
will flush the kernel-to-disk cache (<code>fdatasync ()</code> or <code>fflush ()</code>) when
they receive this event. Normally, elements receiving this event will
simply just forward it, since most filter or filter-like elements don't
have an internal cache of data. <code>gst_pad_event_default ()</code> does just
that, so for most elements, it is enough to forward the event using the
default event handler.</p>
<p>As a side-effect of flushing all data from the pipeline, this event
unblocks the streaming thread by making all pads reject data until they
receive a <a href="plugin-development/advanced/events.html#flush-stop">Flush Stop</a> signal (elements trying to push data
will get a FLUSHING flow return and stop processing data).</p>
<p>The flush-start event is created with the <code>gst_event_new_flush_start ()</code>. Like the EOS event, it has no properties. This event is usually
only created by elements driving the pipeline, like source elements
operating in push-mode or pull-range based demuxers/decoders.</p>
<h3 id="flush-stop">Flush Stop</h3>
<p>The flush-stop event is sent by an element driving the pipeline after a
flush-start and tells pads and elements downstream that they should
accept events and buffers again (there will be at least a SEGMENT event
before any buffers first though).</p>
<p>If your element keeps temporary caches of stream data, it should clear
them when it receives a FLUSH-STOP event (and also whenever its chain
function receives a buffer with the DISCONT flag set).</p>
<p>The flush-stop event is created with <code>gst_event_new_flush_stop ()</code>. It
has one parameter that controls if the running-time of the pipeline
should be reset to 0 or not. Normally after a flushing seek, the
running_time is set back to 0.</p>
<h3 id="quality-of-service-qos">Quality Of Service (QOS)</h3>
<p>The QOS event contains a report about the current real-time performance
of the stream. See more info in <a href="plugin-development/advanced/qos.html">Quality Of Service (QoS)</a>.</p>
<h3 id="seek-request">Seek Request</h3>
<p>Seek events are meant to request a new stream position to elements. This
new position can be set in several formats (time, bytes or “default
units” [a term indicating frames for video, channel-independent samples
for audio, etc.]). Seeking can be done with respect to the end-of-file
or start-of-file, and usually happens in upstream direction (downstream
seeking is done by sending a SEGMENT event with the appropriate offsets
for elements that support that, like filesink).</p>
<p>Elements receiving seek events should, depending on the element type,
either just forward it upstream (filters, decoders), change the format
in which the event is given and then forward it (demuxers), or handle
the event by changing the file pointer in their internal stream resource
(file sources, demuxers/decoders driving the pipeline in pull-mode) or
something else.</p>
<p>Seek events are built up using positions in specified formats (time,
bytes, units). They are created using the function <code>gst_event_new_seek ()</code>. Note that many plugins do not support seeking from the end of the
stream. An element not driving the pipeline and forwarding a seek
request should not assume that the seek succeeded or actually happened,
it should operate based on the SEGMENT events it receives.</p>
<p>Elements parsing this event can do this using <code>gst_event_parse_seek()</code>.</p>
<h3 id="navigation">Navigation</h3>
<p>Navigation events are sent upstream by video sinks to inform upstream
elements of where the mouse pointer is, if and where mouse pointer
clicks have happened, or if keys have been pressed or released.</p>
<p>All this information is contained in the event structure which can be
obtained with <code>gst_event_get_structure ()</code>.</p>
<p>Check out the navigationtest element in gst-plugins-good for an idea how
to extract navigation information from this event.</p>

    </div>
        




		
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
	<hr>
	<div id="footer">
		    

	</div>
</div>

<div id="toc-column">
	
		<div class="edit-button">
		

	</div>
		<div id="toc-wrapper">
		<nav id="toc"></nav>
	</div>
</div>
</div>
</main>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>
