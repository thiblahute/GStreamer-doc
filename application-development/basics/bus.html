<html lang="en">
<head>

<base href="../..">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>Bus</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/bootstrap-toc.min.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/jquery.touchSwipe.min.js"></script>
<script src="assets/js/anchor.min.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>

<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>

<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body class="no-script
" data-spy="scroll" data-target="#toc" data-offset="70">

<script>
$('body').removeClass('no-script');
</script>

<nav class="navbar navbar-fixed-top navbar-default" id="topnav">
	<div class="container-fluid">
		<div class="navbar-right">
			<a id="toc-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<form action="" class="navbar-form pull-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                        </form>
		</div>
		<div class="navbar-header">
			<a id="sidenav-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<a id="home-link" href="index.html" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        API References<span class="caret"></span>
    </a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="libgstreamer-1.0/c/index.html">GStreamer core</a>
			</li>
					<li>
				<a href="libs.html">GStreamer Libraries</a>
			</li>
					<li>
				<a href="plugins_doc.html">GStreamer Plugins</a>
			</li>
		</ul>
</li>

<li>
    <a href="application-development/index.html">Application manual</a>
</li>


<li>
    <a href="tutorials/index.html">Tutorials</a>
</li>

			</ul>
			<div class="hidden-xs hidden-sm navbar-text navbar-center">
							</div>
		</div>
	</div>
</nav>

<main>
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-1.0" data-hotdoc-ref="application-development/basics/bus.html" class="page_container" id="page-wrapper">
<script src="assets/js/utils.js"></script>

<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
	<script src="assets/js/navigation.js"></script>
			<script src="assets/js/sitemap.js"></script>
	</div>

<div id="body">
	<div id="main">
				    <div id="page-description" data-hotdoc-source="bus.md" data-hotdoc-role="main">
        <h1 id="bus">Bus</h1>
<p>A bus is a simple system that takes care of forwarding messages from the
streaming threads to an application in its own thread context. The
advantage of a bus is that an application does not need to be
thread-aware in order to use GStreamer, even though GStreamer itself is
heavily threaded.</p>
<p>Every pipeline contains a bus by default, so applications do not need to
create a bus or anything. The only thing applications should do is set a
message handler on a bus, which is similar to a signal handler to an
object. When the mainloop is running, the bus will periodically be
checked for new messages, and the callback will be called when any
message is available.</p>
<h2 id="how-to-use-a-bus">How to use a bus</h2>
<p>There are two different ways to use a bus:</p>
<ul>
<li>
<p>Run a GLib/Gtk+ main loop (or iterate the default GLib main context
yourself regularly) and attach some kind of watch to the bus. This
way the GLib main loop will check the bus for new messages and
notify you whenever there are messages.</p>
<p>Typically you would use <code>gst_bus_add_watch ()</code> or
<code>gst_bus_add_signal_watch ()</code> in this case.</p>
<p>To use a bus, attach a message handler to the bus of a pipeline
using <code>gst_bus_add_watch ()</code>. This handler will be called whenever
the pipeline emits a message to the bus. In this handler, check the
signal type (see next section) and do something accordingly. The
return value of the handler should be TRUE to keep the handler
attached to the bus, return FALSE to remove it.</p>
</li>
<li>
<p>Check for messages on the bus yourself. This can be done using
<code>gst_bus_peek ()</code> and/or <code>gst_bus_poll ()</code>.</p>
</li>
</ul>
<pre><code class="language-c">#include &lt;gst/gst.h&gt;

static GMainLoop *loop;

static gboolean
my_bus_callback (GstBus     *bus,
         GstMessage *message,
         gpointer    data)
{
  g_print ("Got %s message\n", GST_MESSAGE_TYPE_NAME (message));

  switch (GST_MESSAGE_TYPE (message)) {
    case GST_MESSAGE_ERROR: {
      GError *err;
      gchar *debug;

      gst_message_parse_error (message, &amp;err, &amp;debug);
      g_print ("Error: %s\n", err-&gt;message);
      g_error_free (err);
      g_free (debug);

      g_main_loop_quit (loop);
      break;
    }
    case GST_MESSAGE_EOS:
      /* end-of-stream */
      g_main_loop_quit (loop);
      break;
    default:
      /* unhandled message */
      break;
  }

  /* we want to be notified again the next time there is a message
   * on the bus, so returning TRUE (FALSE means we want to stop watching
   * for messages on the bus and our callback should not be called again)
   */
  return TRUE;
}

gint
main (gint   argc,
      gchar *argv[])
{
  GstElement *pipeline;
  GstBus *bus;
  guint bus_watch_id;

  /* init */
  gst_init (&amp;argc, &amp;argv);

  /* create pipeline, add handler */
  pipeline = gst_pipeline_new ("my_pipeline");

  /* adds a watch for new message on our pipeline's message bus to
   * the default GLib main context, which is the main context that our
   * GLib main loop is attached to below
   */
  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
  bus_watch_id = gst_bus_add_watch (bus, my_bus_callback, NULL);
  gst_object_unref (bus);

  /* [...] */

  /* create a mainloop that runs/iterates the default GLib main context
   * (context NULL), in other words: makes the context check if anything
   * it watches for has happened. When a message has been posted on the
   * bus, the default main context will automatically call our
   * my_bus_callback() function to notify us of that message.
   * The main loop will be run until someone calls g_main_loop_quit()
   */
  loop = g_main_loop_new (NULL, FALSE);
  g_main_loop_run (loop);

  /* clean up */
  gst_element_set_state (pipeline, GST_STATE_NULL);
  gst_object_unref (pipeline);
  g_source_remove (bus_watch_id);
  g_main_loop_unref (loop);

  return 0;
}

</code></pre>
<p>It is important to know that the handler will be called in the thread
context of the mainloop. This means that the interaction between the
pipeline and application over the bus is <em>asynchronous</em>, and thus not
suited for some real-time purposes, such as cross-fading between audio
tracks, doing (theoretically) gapless playback or video effects. All
such things should be done in the pipeline context, which is easiest by
writing a GStreamer plug-in. It is very useful for its primary purpose,
though: passing messages from pipeline to application. The advantage of
this approach is that all the threading that GStreamer does internally
is hidden from the application and the application developer does not
have to worry about thread issues at all.</p>
<p>Note that if you're using the default GLib mainloop integration, you
can, instead of attaching a watch, connect to the “message” signal on
the bus. This way you don't have to <code>switch()</code> on all possible message
types; just connect to the interesting signals in form of
“message::&lt;type&gt;”, where &lt;type&gt; is a specific message type (see
the next section for an explanation of message types).</p>
<p>The above snippet could then also be written as:</p>
<pre><code class="language-c">GstBus *bus;

[..]

bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline);
gst_bus_add_signal_watch (bus);
g_signal_connect (bus, "message::error", G_CALLBACK (cb_message_error), NULL);
g_signal_connect (bus, "message::eos", G_CALLBACK (cb_message_eos), NULL);

[..]

</code></pre>
<p>If you aren't using GLib mainloop, the asynchronous message signals
won't be available by default. You can however install a custom sync
handler that wakes up the custom mainloop and that uses
<code>gst_bus_async_signal_func ()</code> to emit the signals. (see also
<a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstBus.html">documentation</a>
for details)</p>
<h2 id="message-types">Message types</h2>
<p>GStreamer has a few pre-defined message types that can be passed over
the bus. The messages are extensible, however. Plug-ins can define
additional messages, and applications can decide to either have specific
code for those or ignore them. All applications are strongly recommended
to at least handle error messages by providing visual feedback to the
user.</p>
<p>All messages have a message source, type and timestamp. The message
source can be used to see which element emitted the message. For some
messages, for example, only the ones emitted by the top-level pipeline
will be interesting to most applications (e.g. for state-change
notifications). Below is a list of all messages and a short explanation
of what they do and how to parse message-specific content.</p>
<ul>
<li>
<p>Error, warning and information notifications: those are used by
elements if a message should be shown to the user about the state of
the pipeline. Error messages are fatal and terminate the
data-passing. The error should be repaired to resume pipeline
activity. Warnings are not fatal, but imply a problem nevertheless.
Information messages are for non-problem notifications. All those
messages contain a <code>GError</code> with the main error type and message,
and optionally a debug string. Both can be extracted using
<code>gst_message_parse_error()</code>, <code>_parse_warning ()</code> and <code>_parse_info ()</code>.
Both error and debug strings should be freed after use.</p>
</li>
<li>
<p>End-of-stream notification: this is emitted when the stream has
ended. The state of the pipeline will not change, but further media
handling will stall. Applications can use this to skip to the next
song in their playlist. After end-of-stream, it is also possible to
seek back in the stream. Playback will then continue automatically.
This message has no specific arguments.</p>
</li>
<li>
<p>Tags: emitted when metadata was found in the stream. This can be
emitted multiple times for a pipeline (e.g. once for descriptive
metadata such as artist name or song title, and another one for
stream-information, such as samplerate and bitrate). Applications
should cache metadata internally. <code>gst_message_parse_tag()</code> should be
used to parse the taglist, which should be <code>gst_tag_list_unref ()</code>'ed
when no longer needed.</p>
</li>
<li>
<p>State-changes: emitted after a successful state change.
<code>gst_message_parse_state_changed ()</code> can be used to parse the old
and new state of this transition.</p>
</li>
<li>
<p>Buffering: emitted during caching of network-streams. One can
manually extract the progress (in percent) from the message by
extracting the “buffer-percent” property from the structure returned
by <code>gst_message_get_structure()</code>. See also <a href="application-development/advanced/buffering.html">Buffering</a></p>
</li>
<li>
<p>Element messages: these are special messages that are unique to
certain elements and usually represent additional features. The
element's documentation should mention in detail which element
messages a particular element may send. As an example, the 'qtdemux'
QuickTime demuxer element may send a 'redirect' element message on
certain occasions if the stream contains a redirect instruction.</p>
</li>
<li>
<p>Application-specific messages: any information on those can be
extracted by getting the message structure (see above) and reading
its fields. Usually these messages can safely be ignored.</p>
<p>Application messages are primarily meant for internal use in
applications in case the application needs to marshal information
from some thread into the main thread. This is particularly useful
when the application is making use of element signals (as those
signals will be emitted in the context of the streaming thread).</p>
</li>
</ul>

    </div>
        




		
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
	<hr>
	<div id="footer">
		    

	</div>
</div>

<div id="toc-column">
	
		<div class="edit-button">
		

	</div>
		<div id="toc-wrapper">
		<nav id="toc"></nav>
	</div>
</div>
</div>
</main>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>
