<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Playback tutorial 3: Short-cutting the pipeline</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/utils.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/navigation.js"></script>


<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>


<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body data-spy="scroll" data-target="#toc" data-offset="70">


<nav class="navbar navbar-fixed-top navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a href="https://gstreamer.freedesktop.org/" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				<li>
    <a href="api.html" data-hotdoc-relative-link="true">API Reference</a>
</li>

<li>
    <a href="application-development/index.html" data-hotdoc-relative-link="true">Application manual</a>
</li>


<li>
    <a href="tutorials/index.html" data-hotdoc-relative-link="true">Tutorials</a>
</li>

			</ul>
			<form action="" class="navbar-form navbar-right">
				<div class="form-group has-feedback">
					<input type="text" class="form-control" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
					<span class="glyphicon glyphicon-search form-control-feedback"></span>
				</div>
			</form>
		</div>
	</div>
</nav>

<main class="page-row page-row-expanded">
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-1.0" data-hotdoc-ref="tutorials/playback/short-cutting-the-pipeline.html" class="page_container" id="page-wrapper">
	<div class="row">
		
<div class="hidden-xs hidden-sm col-md-3 col-lg-3 col-xl-2" id="sidenav-column">
	<div class="panel panel-collapse" id="sidenav" data-hotdoc-role="navigation">
		<div id="sitenav-wrapper" class="mCustomScrollbar" data-mcs-theme="minimal">
			<div class="sidenav-main-panel-body">
				<div id="site-navigation">
				</div>
			</div>
		</div>
	</div>
</div>

<div class="col-sm-12 col-md-9 col-lg-7 col-xl-8">

	<div id="main">
				    <div id="page-description" data-hotdoc-source="short-cutting-the-pipeline.md">
        <h1 id="playback-tutorial-3-shortcutting-the-pipeline">Playback tutorial 3: Short-cutting the pipeline</h1>
<h2 id="goal">Goal</h2>
<p><a href="../basic/short-cutting-the-pipeline.html">Basic tutorial 8: Short-cutting the pipeline</a> showed
how an application can manually extract or inject data into a pipeline
by using two special elements called <code>appsrc</code> and <code>appsink</code>.
<code>playbin</code> allows using these elements too, but the method to connect
them is different. To connect an <code>appsink</code> to <code>playbin</code> see <a href="custom-playbin-sinks.html">Playback tutorial 7: Custom playbin sinks</a>.
This tutorial shows:</p>
<ul>
<li>How to connect <code>appsrc</code> with <code>playbin</code></li>
<li>How to configure the <code>appsrc</code></li>
</ul>
<h2 id="a-playbin-waveform-generator">A playbin waveform generator</h2>
<p>Copy this code into a text file named <code>playback-tutorial-3.c</code>.</p>
<p><strong>playback-tutorial-3.c</strong></p>
<pre><code class="language-c">#include &lt;gst/gst.h&gt;
#include &lt;gst/audio/audio.h&gt;
#include &lt;string.h&gt;

#define CHUNK_SIZE 1024   /* Amount of bytes we are sending in each buffer */
#define SAMPLE_RATE 44100 /* Samples per second we are sending */

/* Structure to contain all our information, so we can pass it to callbacks */
typedef struct _CustomData {
  GstElement *pipeline;
  GstElement *app_source;

  guint64 num_samples;   /* Number of samples generated so far (for timestamp generation) */
  gfloat a, b, c, d;     /* For waveform generation */

  guint sourceid;        /* To control the GSource */

  GMainLoop *main_loop;  /* GLib's Main Loop */
} CustomData;

/* This method is called by the idle GSource in the mainloop, to feed CHUNK_SIZE bytes into appsrc.
 * The ide handler is added to the mainloop when appsrc requests us to start sending data (need-data signal)
 * and is removed when appsrc has enough data (enough-data signal).
 */
static gboolean push_data (CustomData *data) {
  GstBuffer *buffer;
  GstFlowReturn ret;
  int i;
  GstMapInfo map;
  gint16 *raw;
  gint num_samples = CHUNK_SIZE / 2; /* Because each sample is 16 bits */
  gfloat freq;

  /* Create a new empty buffer */
  buffer = gst_buffer_new_and_alloc (CHUNK_SIZE);

  /* Set its timestamp and duration */
  GST_BUFFER_TIMESTAMP (buffer) = gst_util_uint64_scale (data-&gt;num_samples, GST_SECOND, SAMPLE_RATE);
  GST_BUFFER_DURATION (buffer) = gst_util_uint64_scale (CHUNK_SIZE, GST_SECOND, SAMPLE_RATE);

  /* Generate some psychodelic waveforms */
  gst_buffer_map (buffer, &amp;map, GST_MAP_WRITE);
  raw = (gint16 *)map.data;
  data-&gt;c += data-&gt;d;
  data-&gt;d -= data-&gt;c / 1000;
  freq = 1100 + 1000 * data-&gt;d;
  for (i = 0; i &lt; num_samples; i++) {
    data-&gt;a += data-&gt;b;
    data-&gt;b -= data-&gt;a / freq;
    raw[i] = (gint16)(500 * data-&gt;a);
  }
  gst_buffer_unmap (buffer, &amp;map);
  data-&gt;num_samples += num_samples;

  /* Push the buffer into the appsrc */
  g_signal_emit_by_name (data-&gt;app_source, "push-buffer", buffer, &amp;ret);

  /* Free the buffer now that we are done with it */
  gst_buffer_unref (buffer);

  if (ret != GST_FLOW_OK) {
    /* We got some error, stop sending data */
    return FALSE;
  }

  return TRUE;
}

/* This signal callback triggers when appsrc needs data. Here, we add an idle handler
 * to the mainloop to start pushing data into the appsrc */
static void start_feed (GstElement *source, guint size, CustomData *data) {
  if (data-&gt;sourceid == 0) {
    g_print ("Start feeding\n");
    data-&gt;sourceid = g_idle_add ((GSourceFunc) push_data, data);
  }
}

/* This callback triggers when appsrc has enough data and we can stop sending.
 * We remove the idle handler from the mainloop */
static void stop_feed (GstElement *source, CustomData *data) {
  if (data-&gt;sourceid != 0) {
    g_print ("Stop feeding\n");
    g_source_remove (data-&gt;sourceid);
    data-&gt;sourceid = 0;
  }
}

/* This function is called when an error message is posted on the bus */
static void error_cb (GstBus *bus, GstMessage *msg, CustomData *data) {
  GError *err;
  gchar *debug_info;

  /* Print error details on the screen */
  gst_message_parse_error (msg, &amp;err, &amp;debug_info);
  g_printerr ("Error received from element %s: %s\n", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);
  g_printerr ("Debugging information: %s\n", debug_info ? debug_info : "none");
  g_clear_error (&amp;err);
  g_free (debug_info);

  g_main_loop_quit (data-&gt;main_loop);
}

/* This function is called when playbin has created the appsrc element, so we have
 * a chance to configure it. */
static void source_setup (GstElement *pipeline, GstElement *source, CustomData *data) {
  GstAudioInfo info;
  GstCaps *audio_caps;

  g_print ("Source has been created. Configuring.\n");
  data-&gt;app_source = source;

  /* Configure appsrc */
  gst_audio_info_set_format (&amp;info, GST_AUDIO_FORMAT_S16, SAMPLE_RATE, 1, NULL);
  audio_caps = gst_audio_info_to_caps (&amp;info);
  g_object_set (source, "caps", audio_caps, "format", GST_FORMAT_TIME, NULL);
  g_signal_connect (source, "need-data", G_CALLBACK (start_feed), data);
  g_signal_connect (source, "enough-data", G_CALLBACK (stop_feed), data);
  gst_caps_unref (audio_caps);
  g_free (audio_caps_text);
}

int main(int argc, char *argv[]) {
  CustomData data;
  GstBus *bus;

  /* Initialize cumstom data structure */
  memset (&amp;data, 0, sizeof (data));
  data.b = 1; /* For waveform generation */
  data.d = 1;

  /* Initialize GStreamer */
  gst_init (&amp;argc, &amp;argv);

  /* Create the playbin element */
  data.pipeline = gst_parse_launch ("playbin uri=appsrc://", NULL);
  g_signal_connect (data.pipeline, "source-setup", G_CALLBACK (source_setup), &amp;data);

  /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */
  bus = gst_element_get_bus (data.pipeline);
  gst_bus_add_signal_watch (bus);
  g_signal_connect (G_OBJECT (bus), "message::error", (GCallback)error_cb, &amp;data);
  gst_object_unref (bus);

  /* Start playing the pipeline */
  gst_element_set_state (data.pipeline, GST_STATE_PLAYING);

  /* Create a GLib Main Loop and set it to run */
  data.main_loop = g_main_loop_new (NULL, FALSE);
  g_main_loop_run (data.main_loop);

  /* Free resources */
  gst_element_set_state (data.pipeline, GST_STATE_NULL);
  gst_object_unref (data.pipeline);
  return 0;
}
</code></pre>
<p>To use an <code>appsrc</code> as the source for the pipeline, simply instantiate a
<code>playbin</code> and set its URI to <code>appsrc://</code></p>
<pre><code class="language-c">/* Create the playbin element */
data.pipeline = gst_parse_launch ("playbin uri=appsrc://", NULL);
</code></pre>
<p><code>playbin</code> will create an internal <code>appsrc</code> element and fire the
<code>source-setup</code> signal to allow the application to configure
it:</p>
<pre><code class="language-c">g_signal_connect (data.pipeline, "source-setup", G_CALLBACK (source_setup), &amp;data);
</code></pre>
<p>In particular, it is important to set the caps property of <code>appsrc</code>,
since, once the signal handler returns, <code>playbin</code> will instantiate the
next element in the pipeline according to these
caps:</p>
<pre><code class="language-c">/* This function is called when playbin has created the appsrc element, so we have
 * a chance to configure it. */
static void source_setup (GstElement *pipeline, GstElement *source, CustomData *data) {
  GstAudioInfo info;
  GstCaps *audio_caps;

  g_print ("Source has been created. Configuring.\n");
  data-&gt;app_source = source;

  /* Configure appsrc */
  gst_audio_info_set_format (&amp;info, GST_AUDIO_FORMAT_S16, SAMPLE_RATE, 1, NULL);
  audio_caps = gst_audio_info_to_caps (&amp;info);
  g_object_set (source, "caps", audio_caps, "format", GST_FORMAT_TIME, NULL);
  g_signal_connect (source, "need-data", G_CALLBACK (start_feed), data);
  g_signal_connect (source, "enough-data", G_CALLBACK (stop_feed), data);
  gst_caps_unref (audio_caps);
  g_free (audio_caps_text);
}
</code></pre>
<p>The configuration of the <code>appsrc</code> is exactly the same as in
<a href="../basic/short-cutting-the-pipeline.html">Basic tutorial 8: Short-cutting the pipeline</a>:
the caps are set to <code>audio/x-raw</code>, and two callbacks are registered,
so the element can tell the application when it needs to start and stop
pushing data. See <a href="../basic/short-cutting-the-pipeline.html">Basic tutorial 8: Short-cutting the pipeline</a>
for more details.</p>
<p>From this point onwards, <code>playbin</code> takes care of the rest of the
pipeline, and the application only needs to worry about generating more
data when told so.</p>
<p>To learn how data can be extracted from <code>playbin</code> using the
<code>appsink</code> element, see <a href="custom-playbin-sinks.html">Playback tutorial 7: Custom playbin sinks</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This tutorial applies the concepts shown in
<a href="../basic/short-cutting-the-pipeline.html">Basic tutorial 8: Short-cutting the pipeline</a> to
<code>playbin</code>. In particular, it has shown:</p>
<ul>
<li>How to connect <code>appsrc</code> with <code>playbin</code> using the special
URI <code>appsrc://</code></li>
<li>How to configure the <code>appsrc</code> using the <code>source-setup</code> signal</li>
</ul>
<p>It has been a pleasure having you here, and see you soon!</p>

    </div>
        



        <div id="subpages"></div>
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>

</div>

<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2">
	<div id="toc-column">
		<div id="toc-wrapper" class="mCustomScrollbar" data-mcs-theme="dark">
			<nav id="toc"></nav>
		</div>
	</div>
</div>
	</div>
</div>
</main>


<footer class="page-row">
	<div class="container-fluid">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-xl-2"></div>
		<div class="col-sm-12 col-md-9 col-xl-8">
						
		</div>
		<div class="hidden-xs col-xl-2"></div>
	</div>
</div>
</footer>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>