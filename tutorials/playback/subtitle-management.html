<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Playback tutorial 2: Subtitle management</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/utils.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/navigation.js"></script>


<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>


<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body data-spy="scroll" data-target=".scrollspy" data-offset="70">


<nav class="navbar navbar-fixed-top navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a href="https://gstreamer.freedesktop.org/" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
							</ul>
		</div>
	</div>
</nav>

<main class="page-row page-row-expanded">
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-doc-1.0" data-hotdoc-ref="tutorials/playback/subtitle-management.html" class="page_container" id="page-wrapper">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-xl-2" id="sidenav-column">
	<div class="panel panel-collapse" id="sidenav" data-hotdoc-role="navigation">
		<div id="sidenav-search" role="search">
			<input type="text" class="form-control" placeholder="Fetching index" id="sidenav-lookup-field" disabled>
		</div>
		<div id="sitenav-wrapper" class="mCustomScrollbar" data-mcs-theme="minimal">
			<div class="sidenav-main-panel-body">
				<div id="site-navigation">
				</div>
			</div>
			<!-- FIXME -->
			<div style="height: 76px;"></div>
		</div>
	</div>
</div>

<div class="col-sm-12 col-md-9 col-xl-8">
	<div id="main">
				
<div id="page-description" data-hotdoc-source="subtitle-management.md">
<h1 id="playback-tutorial-2-subtitle-management">Playback tutorial 2: Subtitle management</h1>
<h2 id="goal">Goal</h2>
<p>This tutorial is very similar to the previous one, but instead of
switching among different audio streams, we will use subtitle streams.
This will allow us to learn:</p>
<ul>
<li>
<p>How to choose the subtitle stream</p>
</li>
<li>
<p>How to add external subtitles</p>
</li>
<li>
<p>How to customize the font used for the subtitles</p>
</li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>We already know (from the previous tutorial) that container files can
hold multiple audio and video streams, and that we can very easily
choose among them by changing the <code>current-audio</code> or
<code>current-video</code> <code>playbin</code> property. Switching subtitles is just as
easy.</p>
<p>It is worth noting that, just like it happens with audio and video,
<code>playbin</code> takes care of choosing the right decoder for the subtitles,
and that the plugin structure of GStreamer allows adding support for new
formats as easily as copying a file. Everything is invisible to the
application developer.</p>
<p>Besides subtitles embedded in the container, <code>playbin</code> offers the
possibility to add an extra subtitle stream from an external URI.</p>
<p>This tutorial opens a file which already contains 5 subtitle streams,
and adds another one from another file (for the Greek language).</p>
<h2 id="the-multilingual-player-with-subtitles">The multilingual player with subtitles</h2>
<p>Copy this code into a text file named <code>playback-tutorial-2.c</code> (or find
it in the GStreamer installation).</p>
<p><strong>playback-tutorial-2.c</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;gst/gst.h&gt;

/* Structure to contain all our information, so we can pass it around */
typedef struct _CustomData {
  GstElement *playbin;  /* Our one and only element */

  gint n_video;          /* Number of embedded video streams */
  gint n_audio;          /* Number of embedded audio streams */
  gint n_text;           /* Number of embedded subtitle streams */

  gint current_video;    /* Currently playing video stream */
  gint current_audio;    /* Currently playing audio stream */
  gint current_text;     /* Currently playing subtitle stream */

  GMainLoop *main_loop;  /* GLib's Main Loop */
} CustomData;

/* playbin flags */
typedef enum {
  GST_PLAY_FLAG_VIDEO         = (1 &lt;&lt; 0), /* We want video output */
  GST_PLAY_FLAG_AUDIO         = (1 &lt;&lt; 1), /* We want audio output */
  GST_PLAY_FLAG_TEXT          = (1 &lt;&lt; 2)  /* We want subtitle output */
} GstPlayFlags;

/* Forward definition for the message and keyboard processing functions */
static gboolean handle_message (GstBus *bus, GstMessage *msg, CustomData *data);
static gboolean handle_keyboard (GIOChannel *source, GIOCondition cond, CustomData *data);

int main(int argc, char *argv[]) {
  CustomData data;
  GstBus *bus;
  GstStateChangeReturn ret;
  gint flags;
  GIOChannel *io_stdin;

  /* Initialize GStreamer */
  gst_init (&amp;argc, &amp;argv);

  /* Create the elements */
  data.playbin = gst_element_factory_make ("playbin", "playbin");

  if (!data.playbin) {
    g_printerr ("Not all elements could be created.\n");
    return -1;
  }

  /* Set the URI to play */
  g_object_set (data.playbin, "uri", "https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.ogv", NULL);

  /* Set the subtitle URI to play and some font description */
  g_object_set (data.playbin, "suburi", "https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer_gr.srt", NULL);
  g_object_set (data.playbin, "subtitle-font-desc", "Sans, 18", NULL);

  /* Set flags to show Audio, Video and Subtitles */
  g_object_get (data.playbin, "flags", &amp;flags, NULL);
  flags |= GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_TEXT;
  g_object_set (data.playbin, "flags", flags, NULL);

  /* Add a bus watch, so we get notified when a message arrives */
  bus = gst_element_get_bus (data.playbin);
  gst_bus_add_watch (bus, (GstBusFunc)handle_message, &amp;data);

  /* Add a keyboard watch so we get notified of keystrokes */
#ifdef G_OS_WIN32
  io_stdin = g_io_channel_win32_new_fd (fileno (stdin));
#else
  io_stdin = g_io_channel_unix_new (fileno (stdin));
#endif
  g_io_add_watch (io_stdin, G_IO_IN, (GIOFunc)handle_keyboard, &amp;data);

  /* Start playing */
  ret = gst_element_set_state (data.playbin, GST_STATE_PLAYING);
  if (ret == GST_STATE_CHANGE_FAILURE) {
    g_printerr ("Unable to set the pipeline to the playing state.\n");
    gst_object_unref (data.playbin);
    return -1;
  }

  /* Create a GLib Main Loop and set it to run */
  data.main_loop = g_main_loop_new (NULL, FALSE);
  g_main_loop_run (data.main_loop);

  /* Free resources */
  g_main_loop_unref (data.main_loop);
  g_io_channel_unref (io_stdin);
  gst_object_unref (bus);
  gst_element_set_state (data.playbin, GST_STATE_NULL);
  gst_object_unref (data.playbin);
  return 0;
}

/* Extract some metadata from the streams and print it on the screen */
static void analyze_streams (CustomData *data) {
  gint i;
  GstTagList *tags;
  gchar *str;
  guint rate;

  /* Read some properties */
  g_object_get (data-&gt;playbin, "n-video", &amp;data-&gt;n_video, NULL);
  g_object_get (data-&gt;playbin, "n-audio", &amp;data-&gt;n_audio, NULL);
  g_object_get (data-&gt;playbin, "n-text", &amp;data-&gt;n_text, NULL);

  g_print ("%d video stream(s), %d audio stream(s), %d text stream(s)\n",
    data-&gt;n_video, data-&gt;n_audio, data-&gt;n_text);

  g_print ("\n");
  for (i = 0; i &lt; data-&gt;n_video; i++) {
    tags = NULL;
    /* Retrieve the stream's video tags */
    g_signal_emit_by_name (data-&gt;playbin, "get-video-tags", i, &amp;tags);
    if (tags) {
      g_print ("video stream %d:\n", i);
      gst_tag_list_get_string (tags, GST_TAG_VIDEO_CODEC, &amp;str);
      g_print ("  codec: %s\n", str ? str : "unknown");
      g_free (str);
      gst_tag_list_free (tags);
    }
  }

  g_print ("\n");
  for (i = 0; i &lt; data-&gt;n_audio; i++) {
    tags = NULL;
    /* Retrieve the stream's audio tags */
    g_signal_emit_by_name (data-&gt;playbin, "get-audio-tags", i, &amp;tags);
    if (tags) {
      g_print ("audio stream %d:\n", i);
      if (gst_tag_list_get_string (tags, GST_TAG_AUDIO_CODEC, &amp;str)) {
        g_print ("  codec: %s\n", str);
        g_free (str);
      }
      if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &amp;str)) {
        g_print ("  language: %s\n", str);
        g_free (str);
      }
      if (gst_tag_list_get_uint (tags, GST_TAG_BITRATE, &amp;rate)) {
        g_print ("  bitrate: %d\n", rate);
      }
      gst_tag_list_free (tags);
    }
  }

  g_print ("\n");
  for (i = 0; i &lt; data-&gt;n_text; i++) {
    tags = NULL;
    /* Retrieve the stream's subtitle tags */
    g_print ("subtitle stream %d:\n", i);
    g_signal_emit_by_name (data-&gt;playbin, "get-text-tags", i, &amp;tags);
    if (tags) {
      if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &amp;str)) {
        g_print ("  language: %s\n", str);
        g_free (str);
      }
      gst_tag_list_free (tags);
    } else {
      g_print ("  no tags found\n");
    }
  }

  g_object_get (data-&gt;playbin, "current-video", &amp;data-&gt;current_video, NULL);
  g_object_get (data-&gt;playbin, "current-audio", &amp;data-&gt;current_audio, NULL);
  g_object_get (data-&gt;playbin, "current-text", &amp;data-&gt;current_text, NULL);

  g_print ("\n");
  g_print ("Currently playing video stream %d, audio stream %d and subtitle stream %d\n",
      data-&gt;current_video, data-&gt;current_audio, data-&gt;current_text);
  g_print ("Type any number and hit ENTER to select a different subtitle stream\n");
}

/* Process messages from GStreamer */
static gboolean handle_message (GstBus *bus, GstMessage *msg, CustomData *data) {
  GError *err;
  gchar *debug_info;

  switch (GST_MESSAGE_TYPE (msg)) {
    case GST_MESSAGE_ERROR:
      gst_message_parse_error (msg, &amp;err, &amp;debug_info);
      g_printerr ("Error received from element %s: %s\n", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);
      g_printerr ("Debugging information: %s\n", debug_info ? debug_info : "none");
      g_clear_error (&amp;err);
      g_free (debug_info);
      g_main_loop_quit (data-&gt;main_loop);
      break;
    case GST_MESSAGE_EOS:
      g_print ("End-Of-Stream reached.\n");
      g_main_loop_quit (data-&gt;main_loop);
      break;
    case GST_MESSAGE_STATE_CHANGED: {
      GstState old_state, new_state, pending_state;
      gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);
      if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data-&gt;playbin)) {
        if (new_state == GST_STATE_PLAYING) {
          /* Once we are in the playing state, analyze the streams */
          analyze_streams (data);
        }
      }
    } break;
  }

  /* We want to keep receiving messages */
  return TRUE;
}

/* Process keyboard input */
static gboolean handle_keyboard (GIOChannel *source, GIOCondition cond, CustomData *data) {
  gchar *str = NULL;

  if (g_io_channel_read_line (source, &amp;str, NULL, NULL, NULL) == G_IO_STATUS_NORMAL) {
    int index = atoi (str);
    if (index &lt; 0 || index &gt;= data-&gt;n_text) {
      g_printerr ("Index out of bounds\n");
    } else {
      /* If the input was a valid subtitle stream index, set the current subtitle stream */
      g_print ("Setting current subtitle stream to %d\n", index);
      g_object_set (data-&gt;playbin, "current-text", index, NULL);
    }
  }
  g_free (str);
  return TRUE;
}
</code></pre>
<blockquote>
<p><img src="images/icons/emoticons/information.png" alt="information" id="information"> Need help?</p>
<p>If you need help to compile this code, refer to the <strong>Building the
tutorials</strong> section for your platform: [Linux], [Mac OS X] or
[Windows], or use this specific command on Linux:</p>
<p><code>gcc playback-tutorial-2.c -o playback-tutorial-2 `pkg-config --cflags --libs gstreamer-1.0`</code></p>
<p>If you need help to run this code, refer to the <strong>Running the
tutorials</strong> section for your platform: [Linux][1], [Mac OS X][2] or
[Windows][3].</p>
<p>This tutorial opens a window and displays a movie, with accompanying
audio. The media is fetched from the Internet, so the window might
take a few seconds to appear, depending on your connection
speed. The number of subtitle streams is shown in the terminal, and
the user can switch from one to another by entering a number and
pressing enter. A small delay is to be
expected. <em>Please read the note at the bottom of this
page.</em> Bear in mind that
there is no latency management (buffering), so on slow connections,
the movie might stop after a few seconds. See how
<a href="../basic/streaming.html">Basic tutorial 12: Streaming</a> solves this issue.</p>
<p>Required libraries: <code>gstreamer-1.0</code></p>
</blockquote>
<h2 id="walkthrough">Walkthrough</h2>
<p>This tutorial is copied from
<a href="playbin-usage.html">Playback tutorial 1: Playbin usage</a> with some changes, so let's
review only the changes.</p>
<pre><code class="language-c">/* Set the subtitle URI to play and some font description */
g_object_set (data.playbin, "suburi", "https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer_gr.srt", NULL);
g_object_set (data.playbin, "subtitle-font-desc", "Sans, 18", NULL);
</code></pre>
<p>After setting the media URI, we set the <code>suburi</code> property, which points
<code>playbin</code> to a file containing a subtitle stream. In this case, the
media file already contains multiple subtitle streams, so the one
provided in the <code>suburi</code> is added to the list, and will be the currently
selected one.</p>
<p>Note that metadata concerning a subtitle stream (like its language)
resides in the container file, therefore, subtitles not embedded in a
container will not have metadata. When running this tutorial you will
find that the first subtitle stream does not have a language tag.</p>
<p>The <code>subtitle-font-desc</code> property allows specifying the font to render
the subtitles. Since <a href="http://www.pango.org/">Pango</a> is the library used
to render fonts, you can check its documentation to see how this font
should be specified, in particular, the
<a href="http://developer.gnome.org/pango/stable/pango-Fonts.html#pango-font-description-from-string">pango-font-description-from-string</a> function.</p>
<p>In a nutshell, the format of the string representation is <code>[FAMILY-LIST] [STYLE-OPTIONS] [SIZE]</code> where <code>FAMILY-LIST</code> is a comma separated list of
families optionally terminated by a comma, <code>STYLE_OPTIONS</code> is a
whitespace separated list of words where each word describes one of
style, variant, weight, or stretch, and <code>SIZE</code> is an decimal number
(size in points). For example the following are all valid string
representations:</p>
<ul>
<li>sans bold 12</li>
<li>serif, monospace bold italic condensed 16</li>
<li>normal 10</li>
</ul>
<p>The commonly available font families are: Normal, Sans, Serif and
Monospace.</p>
<p>The available styles are: Normal (the font is upright), Oblique (the
font is slanted, but in a roman style), Italic (the font is slanted in
an italic style).</p>
<p>The available weights are: Ultra-Light, Light, Normal, Bold, Ultra-Bold,
Heavy.</p>
<p>The available variants are: Normal, Small_Caps (A font with the lower
case characters replaced by smaller variants of the capital characters)</p>
<p>The available stretch styles
are: Ultra-Condensed, Extra-Condensed, Condensed, Semi-Condensed, Normal, Semi-Expanded, Expanded,
Extra-Expanded, Ultra-Expanded</p>
<pre><code class="language-c">/* Set flags to show Audio, Video and Subtitles */
g_object_get (data.playbin, "flags", &amp;flags, NULL);
flags |= GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_TEXT;
g_object_set (data.playbin, "flags", flags, NULL);
</code></pre>
<p>We set the <code>flags</code> property to allow Audio, Video and Text (Subtitles).</p>
<p>The rest of the tutorial is the same as <a href="playbin-usage.html">Playback tutorial 1: Playbin usage</a>, except
that the keyboard input changes the <code>current-text</code> property instead of
the <code>current-audio</code>. As before, keep in mind that stream changes are not
immediate, since there is a lot of information flowing through the
pipeline that needs to reach the end of it before the new stream shows
up.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This tutorial showed how to handle subtitles from <code>playbin</code>, whether
they are embedded in the container or in a different file:</p>
<ul>
<li>
<p>Subtitles are chosen using the <code>current-tex</code>t and <code>n-tex</code>t
properties of <code>playbin</code>.</p>
</li>
<li>
<p>External subtitle files can be selected using the <code>suburi</code> property.</p>
</li>
<li>
<p>Subtitle appearance can be customized with the
<code>subtitle-font-desc</code> property.</p>
</li>
</ul>
<p>The next playback tutorial shows how to change the playback speed.</p>
<p>Remember that attached to this page you should find the complete source
code of the tutorial and any accessory files needed to build it.
It has been a pleasure having you here, and see you soon!</p>

</div>


        <div id="subpages"></div>
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
</div>
<div class="hidden-xs col-xl-2">
</div>
	</div>
</div>
</main>


<footer class="page-row">
	<div class="container-fluid">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-xl-2"></div>
		<div class="col-sm-12 col-md-9 col-xl-8">
						
		</div>
		<div class="hidden-xs col-xl-2"></div>
	</div>
</div>
</footer>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>