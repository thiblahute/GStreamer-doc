<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Basic tutorial 5: GUI toolkit integration</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/devhelp.css" type="text/css">
<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/utils.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/navigation.js"></script>


<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>


<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body data-spy="scroll" data-target="#toc" data-offset="70">

<nav class="navbar navbar-fixed-top navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a id="home-link" class="hotdoc-navbar-brand">
				
<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        API References<span class="caret"></span>
    </a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="gstreamer-1.0/index.html">GStreamer core</a>
			</li>
					<li>
				<a href="gst-plugins-base-1.0/index.html">GStreamer Plugins Base</a>
			</li>
					<li>
				<a href="gst-plugins-good-1.0/index.html">GStreamer Plugins Good</a>
			</li>
					<li>
				<a href="gst-plugins-bad-1.0/index.html">GStreamer Plugins Bad</a>
			</li>
					<li>
				<a href="gst-plugins-ugly-1.0/index.html">GStreamer Plugins Ugly</a>
			</li>
					<li>
				<a href="gst-libav-1.0/index.html">GStreamer ffmpeg</a>
			</li>
					<li>
				<a href="gstreamer-vaapi-1.0/index.html">GStreamer VAAPI</a>
			</li>
					<li>
				<a href="gst-devtools-1.0/index.html">GStreamer Validate</a>
			</li>
					<li>
				<a href="gst-rtsp-server/index.html">GStreamer RTSP server</a>
			</li>
					<li>
				<a href="gst-editing-services-1.0/c/index.html">GStreamer Editing Services</a>
			</li>
		</ul></li>

<li>
    <a href="application-development/index.html">Application manual</a>
</li>


<li>
    <a href="tutorials/index.html">Tutorials</a>
</li>

			</ul>
						<form action="" class="navbar-form navbar-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                       </form>
		</div>
	</div>
</nav>

<main class="page-row page-row-expanded">
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-1.0" data-hotdoc-ref="tutorials/basic/toolkit-integration.html" class="page_container" id="page-wrapper">
	<div class="row">
		
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 col-xl-2" id="sidenav-column">
	<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
		<div id="sitenav-wrapper">
			<div class="sidenav-main-panel-body">
				<div id="site-navigation">
				</div>
			</div>
		</div>
	</div>
	<button id="offcanvasleft" class="btn btn-xs" type="button" data-toggle="offcanvasleft">
		<i class="glyphicon glyphicon-chevron-right" id="offcanvasleft-chevron"></i>
	</button>
</div>

<div class="col-xs-12 col-sm-12 col-md-9 col-lg-7 col-xl-8" id="content-column">

	<div id="main">
				    <div id="page-description" data-hotdoc-source="toolkit-integration.md">
        <h1 id="basic-tutorial-5-gui-toolkit-integration">Basic tutorial 5: GUI toolkit integration</h1>
<h2 id="goal">Goal</h2>
<p>This tutorial shows how to integrate GStreamer in a Graphical User
Interface (GUI) toolkit like <a href="http://www.gtk.org">GTK+</a>. Basically,
GStreamer takes care of media playback while the GUI toolkit handles
user interaction. The most interesting parts are those in which both
libraries have to interact: Instructing GStreamer to output video to a
GTK+ window and forwarding user actions to GStreamer.</p>
<p>In particular, you will learn:</p>
<ul>
<li>
<p>How to tell GStreamer to output video to a particular window
(instead of creating its own window).</p>
</li>
<li>
<p>How to continuously refresh the GUI with information from GStreamer.</p>
</li>
<li>
<p>How to update the GUI from the multiple threads of GStreamer, an
operation forbidden on most GUI toolkits.</p>
</li>
<li>
<p>A mechanism to subscribe only to the messages you are interested in,
instead of being notified of all of them.</p>
</li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>We are going to build a media player using the
<a href="http://www.gtk.org/">GTK+</a> toolkit, but the concepts apply to other
toolkits like <a href="http://qt-project.org/">QT</a>, for example. A minimum
knowledge of <a href="http://www.gtk.org/">GTK+</a> will help understand this
tutorial.</p>
<p>The main point is telling GStreamer to output the video to a window of
our choice. The specific mechanism depends on the operating system (or
rather, on the windowing system), but GStreamer provides a layer of
abstraction for the sake of platform independence. This independence
comes through the <code>GstVideoOverlay</code> interface, that allows the application to
tell a video sink the handler of the window that should receive the
rendering.</p>
<blockquote>
<p><img src="images/icons/emoticons/information.svg" alt="Information" id="information">
<strong>GObject interfaces</strong></p>
<p>A GObject <em>interface</em> (which GStreamer uses) is a set of functions that an element can implement. If it does, then it is said to support that particular interface. For example, video sinks usually create their own windows to display video, but, if they are also capable of rendering to an external window, they can choose to implement the <code>GstVideoOverlay</code> interface and provide functions to specify this external window. From the application developer point of view, if a certain interface is supported, you can use it and forget about which kind of element is implementing it. Moreover, if you are using <code>playbin</code>, it will automatically expose some of the interfaces supported by its internal elements: You can use your interface functions directly on <code>playbin</code> without knowing who is implementing them!</p>
</blockquote>
<p>Another issue is that GUI toolkits usually only allow manipulation of
the graphical “widgets” through the main (or application) thread,
whereas GStreamer usually spawns multiple threads to take care of
different tasks. Calling <a href="http://www.gtk.org/">GTK+</a> functions from
within callbacks will usually fail, because callbacks execute in the
calling thread, which does not need to be the main thread. This problem
can be solved by posting a message on the GStreamer bus in the callback:
The messages will be received by the main thread which will then react
accordingly.</p>
<p>Finally, so far we have registered a <code>handle_message</code> function that got
called every time a message appeared on the bus, which forced us to
parse every message to see if it was of interest to us. In this tutorial
a different method is used that registers a callback for each kind of
message, so there is less parsing and less code overall.</p>
<h2 id="a-media-player-in-gtk">A media player in GTK+</h2>
<p>Let's write a very simple media player based on playbin, this time,
with a GUI!</p>
<p>Copy this code into a text file named <code>basic-tutorial-5.c</code> (or find it
in the SDK installation).</p>
<p><strong>basic-tutorial-5.c</strong></p>
<pre><code class="language-c">#include &lt;string.h&gt;

#include &lt;gtk/gtk.h&gt;
#include &lt;gst/gst.h&gt;
#include &lt;gst/video/videooverlay.h&gt;

#include &lt;gdk/gdk.h&gt;
#if defined (GDK_WINDOWING_X11)
#include &lt;gdk/gdkx.h&gt;
#elif defined (GDK_WINDOWING_WIN32)
#include &lt;gdk/gdkwin32.h&gt;
#elif defined (GDK_WINDOWING_QUARTZ)
#include &lt;gdk/gdkquartz.h&gt;
#endif

/* Structure to contain all our information, so we can pass it around */
typedef struct _CustomData {
  GstElement *playbin;           /* Our one and only pipeline */

  GtkWidget *slider;              /* Slider widget to keep track of current position */
  GtkWidget *streams_list;        /* Text widget to display info about the streams */
  gulong slider_update_signal_id; /* Signal ID for the slider update signal */

  GstState state;                 /* Current state of the pipeline */
  gint64 duration;                /* Duration of the clip, in nanoseconds */
} CustomData;

/* This function is called when the GUI toolkit creates the physical window that will hold the video.
 * At this point we can retrieve its handler (which has a different meaning depending on the windowing system)
 * and pass it to GStreamer through the VideoOverlay interface. */
static void realize_cb (GtkWidget *widget, CustomData *data) {
  GdkWindow *window = gtk_widget_get_window (widget);
  guintptr window_handle;

  if (!gdk_window_ensure_native (window))
    g_error ("Couldn't create native window needed for GstVideoOverlay!");

  /* Retrieve window handler from GDK */
#if defined (GDK_WINDOWING_WIN32)
  window_handle = (guintptr)GDK_WINDOW_HWND (window);
#elif defined (GDK_WINDOWING_QUARTZ)
  window_handle = gdk_quartz_window_get_nsview (window);
#elif defined (GDK_WINDOWING_X11)
  window_handle = GDK_WINDOW_XID (window);
#endif
  /* Pass it to playbin, which implements VideoOverlay and will forward it to the video sink */
  gst_video_overlay_set_window_handle (GST_VIDEO_OVERLAY (data-&gt;playbin), window_handle);
}

/* This function is called when the PLAY button is clicked */
static void play_cb (GtkButton *button, CustomData *data) {
  gst_element_set_state (data-&gt;playbin, GST_STATE_PLAYING);
}

/* This function is called when the PAUSE button is clicked */
static void pause_cb (GtkButton *button, CustomData *data) {
  gst_element_set_state (data-&gt;playbin, GST_STATE_PAUSED);
}

/* This function is called when the STOP button is clicked */
static void stop_cb (GtkButton *button, CustomData *data) {
  gst_element_set_state (data-&gt;playbin, GST_STATE_READY);
}

/* This function is called when the main window is closed */
static void delete_event_cb (GtkWidget *widget, GdkEvent *event, CustomData *data) {
  stop_cb (NULL, data);
  gtk_main_quit ();
}

/* This function is called everytime the video window needs to be redrawn (due to damage/exposure,
 * rescaling, etc). GStreamer takes care of this in the PAUSED and PLAYING states, otherwise,
 * we simply draw a black rectangle to avoid garbage showing up. */
static gboolean draw_cb (GtkWidget *widget, cairo_t *cr, CustomData *data) {
  if (data-&gt;state &lt; GST_STATE_PAUSED) {
    GtkAllocation allocation;

    /* Cairo is a 2D graphics library which we use here to clean the video window.
     * It is used by GStreamer for other reasons, so it will always be available to us. */
    gtk_widget_get_allocation (widget, &amp;allocation);
    cairo_set_source_rgb (cr, 0, 0, 0);
    cairo_rectangle (cr, 0, 0, allocation.width, allocation.height);
    cairo_fill (cr);
  }

  return FALSE;
}

/* This function is called when the slider changes its position. We perform a seek to the
 * new position here. */
static void slider_cb (GtkRange *range, CustomData *data) {
  gdouble value = gtk_range_get_value (GTK_RANGE (data-&gt;slider));
  gst_element_seek_simple (data-&gt;playbin, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT,
      (gint64)(value * GST_SECOND));
}

/* This creates all the GTK+ widgets that compose our application, and registers the callbacks */
static void create_ui (CustomData *data) {
  GtkWidget *main_window;  /* The uppermost window, containing all other windows */
  GtkWidget *video_window; /* The drawing area where the video will be shown */
  GtkWidget *main_box;     /* VBox to hold main_hbox and the controls */
  GtkWidget *main_hbox;    /* HBox to hold the video_window and the stream info text widget */
  GtkWidget *controls;     /* HBox to hold the buttons and the slider */
  GtkWidget *play_button, *pause_button, *stop_button; /* Buttons */

  main_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  g_signal_connect (G_OBJECT (main_window), "delete-event", G_CALLBACK (delete_event_cb), data);

  video_window = gtk_drawing_area_new ();
  gtk_widget_set_double_buffered (video_window, FALSE);
  g_signal_connect (video_window, "realize", G_CALLBACK (realize_cb), data);
  g_signal_connect (video_window, "draw", G_CALLBACK (draw_cb), data);

  play_button = gtk_button_new_from_stock (GTK_STOCK_MEDIA_PLAY);
  g_signal_connect (G_OBJECT (play_button), "clicked", G_CALLBACK (play_cb), data);

  pause_button = gtk_button_new_from_stock (GTK_STOCK_MEDIA_PAUSE);
  g_signal_connect (G_OBJECT (pause_button), "clicked", G_CALLBACK (pause_cb), data);

  stop_button = gtk_button_new_from_stock (GTK_STOCK_MEDIA_STOP);
  g_signal_connect (G_OBJECT (stop_button), "clicked", G_CALLBACK (stop_cb), data);

  data-&gt;slider = gtk_scale_new_with_range (GTK_ORIENTATION_HORIZONTAL, 0, 100, 1);
  gtk_scale_set_draw_value (GTK_SCALE (data-&gt;slider), 0);
  data-&gt;slider_update_signal_id = g_signal_connect (G_OBJECT (data-&gt;slider), "value-changed", G_CALLBACK (slider_cb), data);

  data-&gt;streams_list = gtk_text_view_new ();
  gtk_text_view_set_editable (GTK_TEXT_VIEW (data-&gt;streams_list), FALSE);

  controls = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
  gtk_box_pack_start (GTK_BOX (controls), play_button, FALSE, FALSE, 2);
  gtk_box_pack_start (GTK_BOX (controls), pause_button, FALSE, FALSE, 2);
  gtk_box_pack_start (GTK_BOX (controls), stop_button, FALSE, FALSE, 2);
  gtk_box_pack_start (GTK_BOX (controls), data-&gt;slider, TRUE, TRUE, 2);

  main_hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
  gtk_box_pack_start (GTK_BOX (main_hbox), video_window, TRUE, TRUE, 0);
  gtk_box_pack_start (GTK_BOX (main_hbox), data-&gt;streams_list, FALSE, FALSE, 2);

  main_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
  gtk_box_pack_start (GTK_BOX (main_box), main_hbox, TRUE, TRUE, 0);
  gtk_box_pack_start (GTK_BOX (main_box), controls, FALSE, FALSE, 0);
  gtk_container_add (GTK_CONTAINER (main_window), main_box);
  gtk_window_set_default_size (GTK_WINDOW (main_window), 640, 480);

  gtk_widget_show_all (main_window);
}

/* This function is called periodically to refresh the GUI */
static gboolean refresh_ui (CustomData *data) {
  gint64 current = -1;

  /* We do not want to update anything unless we are in the PAUSED or PLAYING states */
  if (data-&gt;state &lt; GST_STATE_PAUSED)
    return TRUE;

  /* If we didn't know it yet, query the stream duration */
  if (!GST_CLOCK_TIME_IS_VALID (data-&gt;duration)) {
    if (!gst_element_query_duration (data-&gt;playbin, GST_FORMAT_TIME, &amp;data-&gt;duration)) {
      g_printerr ("Could not query current duration.\n");
    } else {
      /* Set the range of the slider to the clip duration, in SECONDS */
      gtk_range_set_range (GTK_RANGE (data-&gt;slider), 0, (gdouble)data-&gt;duration / GST_SECOND);
    }
  }

  if (gst_element_query_position (data-&gt;playbin, GST_FORMAT_TIME, &amp;current)) {
    /* Block the "value-changed" signal, so the slider_cb function is not called
     * (which would trigger a seek the user has not requested) */
    g_signal_handler_block (data-&gt;slider, data-&gt;slider_update_signal_id);
    /* Set the position of the slider to the current pipeline positoin, in SECONDS */
    gtk_range_set_value (GTK_RANGE (data-&gt;slider), (gdouble)current / GST_SECOND);
    /* Re-enable the signal */
    g_signal_handler_unblock (data-&gt;slider, data-&gt;slider_update_signal_id);
  }
  return TRUE;
}

/* This function is called when new metadata is discovered in the stream */
static void tags_cb (GstElement *playbin, gint stream, CustomData *data) {
  /* We are possibly in a GStreamer working thread, so we notify the main
   * thread of this event through a message in the bus */
  gst_element_post_message (playbin,
    gst_message_new_application (GST_OBJECT (playbin),
      gst_structure_new_empty ("tags-changed")));
}

/* This function is called when an error message is posted on the bus */
static void error_cb (GstBus *bus, GstMessage *msg, CustomData *data) {
  GError *err;
  gchar *debug_info;

  /* Print error details on the screen */
  gst_message_parse_error (msg, &amp;err, &amp;debug_info);
  g_printerr ("Error received from element %s: %s\n", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);
  g_printerr ("Debugging information: %s\n", debug_info ? debug_info : "none");
  g_clear_error (&amp;err);
  g_free (debug_info);

  /* Set the pipeline to READY (which stops playback) */
  gst_element_set_state (data-&gt;playbin, GST_STATE_READY);
}

/* This function is called when an End-Of-Stream message is posted on the bus.
 * We just set the pipeline to READY (which stops playback) */
static void eos_cb (GstBus *bus, GstMessage *msg, CustomData *data) {
  g_print ("End-Of-Stream reached.\n");
  gst_element_set_state (data-&gt;playbin, GST_STATE_READY);
}

/* This function is called when the pipeline changes states. We use it to
 * keep track of the current state. */
static void state_changed_cb (GstBus *bus, GstMessage *msg, CustomData *data) {
  GstState old_state, new_state, pending_state;
  gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);
  if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data-&gt;playbin)) {
    data-&gt;state = new_state;
    g_print ("State set to %s\n", gst_element_state_get_name (new_state));
    if (old_state == GST_STATE_READY &amp;&amp; new_state == GST_STATE_PAUSED) {
      /* For extra responsiveness, we refresh the GUI as soon as we reach the PAUSED state */
      refresh_ui (data);
    }
  }
}

/* Extract metadata from all the streams and write it to the text widget in the GUI */
static void analyze_streams (CustomData *data) {
  gint i;
  GstTagList *tags;
  gchar *str, *total_str;
  guint rate;
  gint n_video, n_audio, n_text;
  GtkTextBuffer *text;

  /* Clean current contents of the widget */
  text = gtk_text_view_get_buffer (GTK_TEXT_VIEW (data-&gt;streams_list));
  gtk_text_buffer_set_text (text, "", -1);

  /* Read some properties */
  g_object_get (data-&gt;playbin, "n-video", &amp;n_video, NULL);
  g_object_get (data-&gt;playbin, "n-audio", &amp;n_audio, NULL);
  g_object_get (data-&gt;playbin, "n-text", &amp;n_text, NULL);

  for (i = 0; i &lt; n_video; i++) {
    tags = NULL;
    /* Retrieve the stream's video tags */
    g_signal_emit_by_name (data-&gt;playbin, "get-video-tags", i, &amp;tags);
    if (tags) {
      total_str = g_strdup_printf ("video stream %d:\n", i);
      gtk_text_buffer_insert_at_cursor (text, total_str, -1);
      g_free (total_str);
      gst_tag_list_get_string (tags, GST_TAG_VIDEO_CODEC, &amp;str);
      total_str = g_strdup_printf ("  codec: %s\n", str ? str : "unknown");
      gtk_text_buffer_insert_at_cursor (text, total_str, -1);
      g_free (total_str);
      g_free (str);
      gst_tag_list_free (tags);
    }
  }

  for (i = 0; i &lt; n_audio; i++) {
    tags = NULL;
    /* Retrieve the stream's audio tags */
    g_signal_emit_by_name (data-&gt;playbin, "get-audio-tags", i, &amp;tags);
    if (tags) {
      total_str = g_strdup_printf ("\naudio stream %d:\n", i);
      gtk_text_buffer_insert_at_cursor (text, total_str, -1);
      g_free (total_str);
      if (gst_tag_list_get_string (tags, GST_TAG_AUDIO_CODEC, &amp;str)) {
        total_str = g_strdup_printf ("  codec: %s\n", str);
        gtk_text_buffer_insert_at_cursor (text, total_str, -1);
        g_free (total_str);
        g_free (str);
      }
      if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &amp;str)) {
        total_str = g_strdup_printf ("  language: %s\n", str);
        gtk_text_buffer_insert_at_cursor (text, total_str, -1);
        g_free (total_str);
        g_free (str);
      }
      if (gst_tag_list_get_uint (tags, GST_TAG_BITRATE, &amp;rate)) {
        total_str = g_strdup_printf ("  bitrate: %d\n", rate);
        gtk_text_buffer_insert_at_cursor (text, total_str, -1);
        g_free (total_str);
      }
      gst_tag_list_free (tags);
    }
  }

  for (i = 0; i &lt; n_text; i++) {
    tags = NULL;
    /* Retrieve the stream's subtitle tags */
    g_signal_emit_by_name (data-&gt;playbin, "get-text-tags", i, &amp;tags);
    if (tags) {
      total_str = g_strdup_printf ("\nsubtitle stream %d:\n", i);
      gtk_text_buffer_insert_at_cursor (text, total_str, -1);
      g_free (total_str);
      if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &amp;str)) {
        total_str = g_strdup_printf ("  language: %s\n", str);
        gtk_text_buffer_insert_at_cursor (text, total_str, -1);
        g_free (total_str);
        g_free (str);
      }
      gst_tag_list_free (tags);
    }
  }
}

/* This function is called when an "application" message is posted on the bus.
 * Here we retrieve the message posted by the tags_cb callback */
static void application_cb (GstBus *bus, GstMessage *msg, CustomData *data) {
  if (g_strcmp0 (gst_structure_get_name (gst_message_get_structure (msg)), "tags-changed") == 0) {
    /* If the message is the "tags-changed" (only one we are currently issuing), update
     * the stream info GUI */
    analyze_streams (data);
  }
}

int main(int argc, char *argv[]) {
  CustomData data;
  GstStateChangeReturn ret;
  GstBus *bus;

  /* Initialize GTK */
  gtk_init (&amp;argc, &amp;argv);

  /* Initialize GStreamer */
  gst_init (&amp;argc, &amp;argv);

  /* Initialize our data structure */
  memset (&amp;data, 0, sizeof (data));
  data.duration = GST_CLOCK_TIME_NONE;

  /* Create the elements */
  data.playbin = gst_element_factory_make ("playbin", "playbin");

  if (!data.playbin) {
    g_printerr ("Not all elements could be created.\n");
    return -1;
  }

  /* Set the URI to play */
  g_object_set (data.playbin, "uri", "https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm", NULL);

  /* Connect to interesting signals in playbin */
  g_signal_connect (G_OBJECT (data.playbin), "video-tags-changed", (GCallback) tags_cb, &amp;data);
  g_signal_connect (G_OBJECT (data.playbin), "audio-tags-changed", (GCallback) tags_cb, &amp;data);
  g_signal_connect (G_OBJECT (data.playbin), "text-tags-changed", (GCallback) tags_cb, &amp;data);

  /* Create the GUI */
  create_ui (&amp;data);

  /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */
  bus = gst_element_get_bus (data.playbin);
  gst_bus_add_signal_watch (bus);
  g_signal_connect (G_OBJECT (bus), "message::error", (GCallback)error_cb, &amp;data);
  g_signal_connect (G_OBJECT (bus), "message::eos", (GCallback)eos_cb, &amp;data);
  g_signal_connect (G_OBJECT (bus), "message::state-changed", (GCallback)state_changed_cb, &amp;data);
  g_signal_connect (G_OBJECT (bus), "message::application", (GCallback)application_cb, &amp;data);
  gst_object_unref (bus);

  /* Start playing */
  ret = gst_element_set_state (data.playbin, GST_STATE_PLAYING);
  if (ret == GST_STATE_CHANGE_FAILURE) {
    g_printerr ("Unable to set the pipeline to the playing state.\n");
    gst_object_unref (data.playbin);
    return -1;
  }

  /* Register a function that GLib will call every second */
  g_timeout_add_seconds (1, (GSourceFunc)refresh_ui, &amp;data);

  /* Start the GTK main loop. We will not regain control until gtk_main_quit is called. */
  gtk_main ();

  /* Free resources */
  gst_element_set_state (data.playbin, GST_STATE_NULL);
  gst_object_unref (data.playbin);
  return 0;
}
</code></pre>
<blockquote>
<p><img src="images/icons/emoticons/information.svg" alt="Information" id="information1">
Need help?</p>
<p>If you need help to compile this code, refer to the <strong>Building the tutorials</strong>  section for your platform: <a href="../../installing/on-linux.html#InstallingonLinux-Build">Linux</a>, <a href="../../installing/on-mac-osx.html#InstallingonMacOSX-Build">Mac OS X</a> or <a href="../../installing/on-windows.html#InstallingonWindows-Build">Windows</a>, or use this specific command on Linux:</p>
<p><code>gcc basic-tutorial-5.c -o basic-tutorial-5 `pkg-config --cflags --libs gstreamer-interfaces-1.0 gtk+-3.0 gstreamer-1.0</code></p>
<p>If you need help to run this code, refer to the <strong>Running the tutorials</strong> section for your platform: <a href="../../installing/on-linux.html#InstallingonLinux-Run">Linux</a>, <a href="../../installing/on-mac-osx.html#InstallingonMacOSX-Run">Mac OS X</a> or <a href="../../installing/on-windows.html#InstallingonWindows-Run">Windows</a>.</p>
<p>This tutorial opens a GTK+ window and displays a movie, with accompanying audio. The media is fetched from the Internet, so the window might take a few seconds to appear, depending on your connection speed. The Window has some GTK+ buttons to Pause, Stop and Play the movie, and a slider to show the current position of the stream, which can be dragged to change it. Also, information about the stream is shown on a column at the right edge of the window.</p>
<p>Bear in mind that there is no latency management (buffering), so on slow connections, the movie might stop after a few seconds. See how <a href="streaming.html">Basic tutorial 12: Streaming</a> solves this issue.</p>
<p>Required libraries: <code>gstreamer-video-1.0 gtk+-3.0 gstreamer-1.0</code></p>
</blockquote>
<h2 id="walkthrough">Walkthrough</h2>
<p>Regarding this tutorial's structure, we are not going to use forward
function definitions anymore: Functions will be defined before they are
used. Also, for clarity of explanation, the order in which the snippets
of code are presented will not always match the program order. Use the
line numbers to locate the snippets in the complete code.</p>
<pre><code class="language-c">#include &lt;gdk/gdk.h&gt;
#if defined (GDK_WINDOWING_X11)
#include &lt;gdk/gdkx.h&gt;
#elif defined (GDK_WINDOWING_WIN32)
#include &lt;gdk/gdkwin32.h&gt;
#elif defined (GDK_WINDOWING_QUARTZ)
#include &lt;gdk/gdkquartzwindow.h&gt;
#endif
</code></pre>
<p>The first thing worth noticing is that we are no longer completely
platform-independent. We need to include the appropriate GDK headers for
the windowing system we are going to use. Fortunately, there are not
that many supported windowing systems, so these three lines often
suffice: X11 for Linux, Win32 for Windows and Quartz for Mac OSX.</p>
<p>This tutorial is composed mostly of callback functions, which will be
called from GStreamer or GTK+, so let's review the <code>main</code> function,
which registers all these callbacks.</p>
<pre><code class="language-c">int main(int argc, char *argv[]) {
  CustomData data;
  GstStateChangeReturn ret;
  GstBus *bus;

  /* Initialize GTK */
  gtk_init (&amp;argc, &amp;argv);

  /* Initialize GStreamer */
  gst_init (&amp;argc, &amp;argv);

  /* Initialize our data structure */
  memset (&amp;data, 0, sizeof (data));
  data.duration = GST_CLOCK_TIME_NONE;

  /* Create the elements */
  data.playbin = gst_element_factory_make ("playbin", "playbin");

  if (!data.playbin) {
    g_printerr ("Not all elements could be created.\n");
    return -1;
  }

  /* Set the URI to play */
  g_object_set (data.playbin, "uri", "https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm", NULL);
</code></pre>
<p>Standard GStreamer initialization and playbin pipeline creation, along
with GTK+ initialization. Not much new.</p>
<pre><code class="language-c">  /* Connect to interesting signals in playbin */
  g_signal_connect (G_OBJECT (data.playbin), "video-tags-changed", (GCallback) tags_cb, &amp;data);
  g_signal_connect (G_OBJECT (data.playbin), "audio-tags-changed", (GCallback) tags_cb, &amp;data);
  g_signal_connect (G_OBJECT (data.playbin), "text-tags-changed", (GCallback) tags_cb, &amp;data);
</code></pre>
<p>We are interested in being notified when new tags (metadata) appears on
the stream. For simplicity, we are going to handle all kinds of tags
(video, audio and text) from the same callback <code>tags_cb</code>.</p>
<pre><code class="language-c">/* Create the GUI */
create_ui (&amp;data);
</code></pre>
<p>All GTK+ widget creation and signal registration happens in this
function. It contains only GTK-related function calls, so we will skip
over its definition. The signals to which it registers convey user
commands, as shown below when reviewing the
callbacks.</p>
<pre><code class="language-c">  /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */
  bus = gst_element_get_bus (data.playbin);
  gst_bus_add_signal_watch (bus);
  g_signal_connect (G_OBJECT (bus), "message::error", (GCallback)error_cb, &amp;data);
  g_signal_connect (G_OBJECT (bus), "message::eos", (GCallback)eos_cb, &amp;data);
  g_signal_connect (G_OBJECT (bus), "message::state-changed", (GCallback)state_changed_cb, &amp;data);
  g_signal_connect (G_OBJECT (bus), "message::application", (GCallback)application_cb, &amp;data);
  gst_object_unref (bus);
</code></pre>
<p>In <a href="../playback/playbin-usage.html">Playback tutorial 1: Playbin usage</a>, <code>gst_bus_add_watch()</code> is
used to register a function that receives every message posted to the
GStreamer bus. We can achieve a finer granularity by using signals
instead, which allow us to register only to the messages we are
interested in. By calling <code>gst_bus_add_signal_watch()</code> we instruct the
bus to emit a signal every time it receives a message. This signal has
the name <code>message::detail</code> where <em><code>detail</code></em> is the message that
triggered the signal emission. For example, when the bus receives the
EOS message, it emits a signal with the name <code>message::eos</code>.</p>
<p>This tutorial is using the <code>Signals</code>'s details to register only to the
messages we care about. If we had registered to the <code>message</code> signal, we
would be notified of every single message, just like
<code>gst_bus_add_watch()</code> would do.</p>
<p>Keep in mind that, in order for the bus watches to work (be it a
<code>gst_bus_add_watch()</code> or a <code>gst_bus_add_signal_watch()</code>), there must be
GLib <code>Main Loop</code> running. In this case, it is hidden inside the
<a href="http://www.gtk.org/">GTK+</a> main loop.</p>
<pre><code class="language-c">/* Register a function that GLib will call every second */
g_timeout_add_seconds (1, (GSourceFunc)refresh_ui, &amp;data);
</code></pre>
<p>Before transferring control to GTK+, we use <code>g_timeout_add_seconds ()</code> to register yet another callback, this time with a timeout, so it
gets called every second. We are going to use it to refresh the GUI from
the <code>refresh_ui</code> function.</p>
<p>After this, we are done with the setup and can start the GTK+ main loop.
We will regain control from our callbacks when interesting things
happen. Let's review the callbacks. Each callback has a different
signature, depending on who will call it. You can look up the signature
(the meaning of the parameters and the return value) in the
documentation of the signal.</p>
<pre><code class="language-c">/* This function is called when the GUI toolkit creates the physical window that will hold the video.
 * At this point we can retrieve its handler (which has a different meaning depending on the windowing system)
 * and pass it to GStreamer through the VideoOverlay interface. */
static void realize_cb (GtkWidget *widget, CustomData *data) {
  GdkWindow *window = gtk_widget_get_window (widget);
  guintptr window_handle;

  if (!gdk_window_ensure_native (window))
    g_error ("Couldn't create native window needed for GstVideoOverlay!");

  /* Retrieve window handler from GDK */
#if defined (GDK_WINDOWING_WIN32)
  window_handle = (guintptr)GDK_WINDOW_HWND (window);
#elif defined (GDK_WINDOWING_QUARTZ)
  window_handle = gdk_quartz_window_get_nsview (window);
#elif defined (GDK_WINDOWING_X11)
  window_handle = GDK_WINDOW_XID (window);
#endif
  /* Pass it to playbin, which implements VideoOverlay and will forward it to the video sink */
  gst_video_overlay_set_window_handle (GST_VIDEO_OVERLAY (data-&gt;playbin), window_handle);
}
</code></pre>
<p>The code comments talks by itself. At this point in the life cycle of
the application, we know the handle (be it an X11's <code>XID</code>, a Window's
<code>HWND</code> or a Quartz's <code>NSView</code>) of the window where GStreamer should
render the video. We simply retrieve it from the windowing system and
pass it to <code>playbin</code> through the <code>GstVideoOverlay</code> interface using
<code>gst_video_overlay_set_window_handle()</code>. <code>playbin</code> will locate the video
sink and pass the handler to it, so it does not create its own window
and uses this one.</p>
<p>Not much more to see here; <code>playbin</code> and the <code>GstVideoOverlay</code> really simplify
this process a lot!</p>
<pre><code class="language-c">/* This function is called when the PLAY button is clicked */
static void play_cb (GtkButton *button, CustomData *data) {
  gst_element_set_state (data-&gt;playbin, GST_STATE_PLAYING);
}

/* This function is called when the PAUSE button is clicked */
static void pause_cb (GtkButton *button, CustomData *data) {
  gst_element_set_state (data-&gt;playbin, GST_STATE_PAUSED);
}

/* This function is called when the STOP button is clicked */
static void stop_cb (GtkButton *button, CustomData *data) {
  gst_element_set_state (data-&gt;playbin, GST_STATE_READY);
}
</code></pre>
<p>These three little callbacks are associated with the PLAY, PAUSE and
STOP buttons in the GUI. They simply set the pipeline to the
corresponding state. Note that in the STOP state we set the pipeline to
<code>READY</code>. We could have brought the pipeline all the way down to the
<code>NULL</code> state, but, the transition would then be a little slower, since some
resources (like the audio device) would need to be released and
re-acquired.</p>
<pre><code class="language-c">/* This function is called when the main window is closed */
static void delete_event_cb (GtkWidget *widget, GdkEvent *event, CustomData *data) {
  stop_cb (NULL, data);
  gtk_main_quit ();
}
</code></pre>
<p>gtk_main_quit() will eventually make the call to to gtk_main_run()
in <code>main</code> to terminate, which, in this case, finishes the program. Here,
we call it when the main window is closed, after stopping the pipeline
(just for the sake of tidiness).</p>
<pre><code class="language-c">/* This function is called everytime the video window needs to be redrawn (due to damage/exposure,
 * rescaling, etc). GStreamer takes care of this in the PAUSED and PLAYING states, otherwise,
 * we simply draw a black rectangle to avoid garbage showing up. */
static gboolean expose_cb (GtkWidget *widget, GdkEventExpose *event, CustomData *data) {
  if (data-&gt;state &lt; GST_STATE_PAUSED) {
    GtkAllocation allocation;
    GdkWindow *window = gtk_widget_get_window (widget);
    cairo_t *cr;

    /* Cairo is a 2D graphics library which we use here to clean the video window.
     * It is used by GStreamer for other reasons, so it will always be available to us. */
    gtk_widget_get_allocation (widget, &amp;allocation);
    cr = gdk_cairo_create (window);
    cairo_set_source_rgb (cr, 0, 0, 0);
    cairo_rectangle (cr, 0, 0, allocation.width, allocation.height);
    cairo_fill (cr);
  }

  return FALSE;
}
</code></pre>
<p>When there is data flow (in the <code>PAUSED</code> and <code>PLAYING</code> states) the video
sink takes care of refreshing the content of the video window. In the
other cases, however, it will not, so we have to do it. In this example,
we just fill the window with a black
rectangle.</p>
<pre><code class="language-c">/* This function is called when the slider changes its position. We perform a seek to the
 * new position here. */
static void slider_cb (GtkRange *range, CustomData *data) {
  gdouble value = gtk_range_get_value (GTK_RANGE (data-&gt;slider));
  gst_element_seek_simple (data-&gt;playbin, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT,
      (gint64)(value * GST_SECOND));
}
</code></pre>
<p>This is an example of how a complex GUI element like a seeker bar (or
slider that allows seeking) can be very easily implemented thanks to
GStreamer and GTK+ collaborating. If the slider has been dragged to a
new position, tell GStreamer to seek to that position
with <code>gst_element_seek_simple()</code> (as seen in <a href="time-management.html">Basic tutorial 4: Time
management</a>). The
slider has been setup so its value represents seconds.</p>
<p>It is worth mentioning that some performance (and responsiveness) can be
gained by doing some throttling, this is, not responding to every single
user request to seek. Since the seek operation is bound to take some
time, it is often nicer to wait half a second (for example) after a seek
before allowing another one. Otherwise, the application might look
unresponsive if the user drags the slider frantically, which would not
allow any seek to complete before a new one is queued.</p>
<pre><code class="language-c">/* This function is called periodically to refresh the GUI */
static gboolean refresh_ui (CustomData *data) {
  gint64 current = -1;

  /* We do not want to update anything unless we are in the PAUSED or PLAYING states */
  if (data-&gt;state &lt; GST_STATE_PAUSED)
    return TRUE;
</code></pre>
<p>This function will move the slider to reflect the current position of
the media. First off, if we are not in the <code>PLAYING</code> state, we have
nothing to do here (plus, position and duration queries will normally
fail).</p>
<pre><code class="language-c">/* If we didn't know it yet, query the stream duration */
if (!GST_CLOCK_TIME_IS_VALID (data-&gt;duration)) {
  if (!gst_element_query_duration (data-&gt;playbin, GST_FORMAT_TIME, &amp;data-&gt;duration)) {
    g_printerr ("Could not query current duration.\n");
  } else {
    /* Set the range of the slider to the clip duration, in SECONDS */
    gtk_range_set_range (GTK_RANGE (data-&gt;slider), 0, (gdouble)data-&gt;duration / GST_SECOND);
  }
}
</code></pre>
<p>We recover the duration of the clip if we didn't know it, so we can set
the range for the slider.</p>
<pre><code class="language-c">if (gst_element_query_position (data-&gt;playbin, GST_FORMAT_TIME, &amp;current)) {
  /* Block the "value-changed" signal, so the slider_cb function is not called
   * (which would trigger a seek the user has not requested) */
  g_signal_handler_block (data-&gt;slider, data-&gt;slider_update_signal_id);
  /* Set the position of the slider to the current pipeline positoin, in SECONDS */
  gtk_range_set_value (GTK_RANGE (data-&gt;slider), (gdouble)current / GST_SECOND);
  /* Re-enable the signal */
  g_signal_handler_unblock (data-&gt;slider, data-&gt;slider_update_signal_id);
}
return TRUE;
</code></pre>
<p>We query the current pipeline position, and set the position of the
slider accordingly. This would trigger the emission of the
<code>value-changed</code> signal, which we use to know when the user is dragging
the slider. Since we do not want seeks happening unless the user
requested them, we disable the <code>value-changed</code> signal emission during
this operation with <code>g_signal_handler_block()</code> and
<code>g_signal_handler_unblock()</code>.</p>
<p>Returning TRUE from this function will keep it called in the future. If
we return FALSE, the timer will be
removed.</p>
<pre><code class="language-c">/* This function is called when new metadata is discovered in the stream */
static void tags_cb (GstElement *playbin, gint stream, CustomData *data) {
  /* We are possibly in a GStreamer working thread, so we notify the main
   * thread of this event through a message in the bus */
  gst_element_post_message (playbin,
    gst_message_new_application (GST_OBJECT (playbin),
      gst_structure_new_empty ("tags-changed")));
}
</code></pre>
<p>This is one of the key points of this tutorial. This function will be
called when new tags are found in the media, <strong>from a streaming
thread</strong>, this is, from a thread other than the application (or main)
thread. What we want to do here is to update a GTK+ widget to reflect
this new information, but <strong>GTK+ does not allow operating from threads
other than the main one</strong>.</p>
<p>The solution is to make <code>playbin</code> post a message on the bus and return
to the calling thread. When appropriate, the main thread will pick up
this message and update GTK.</p>
<p><code>gst_element_post_message()</code> makes a GStreamer element post the given
message to the bus. <code>gst_message_new_application()</code> creates a new
message of the <code>APPLICATION</code> type. GStreamer messages have different
types, and this particular type is reserved to the application: it will
go through the bus unaffected by GStreamer. The list of types can be
found in the <code>GstMessageType</code> documentation.</p>
<p>Messages can deliver additional information through their embedded
<code>GstStructure</code>, which is a very flexible data container. Here, we create
a new structure with <code>gst_structure_new</code>, and name it <code>tags-changed</code>, to
avoid confusion in case we wanted to send other application messages.</p>
<p>Later, once in the main thread, the bus will receive this message and
emit the <code>message::application</code> signal, which we have associated to the
<code>application_cb</code> function:</p>
<pre><code class="language-c">/* This function is called when an "application" message is posted on the bus.
 * Here we retrieve the message posted by the tags_cb callback */
static void application_cb (GstBus *bus, GstMessage *msg, CustomData *data) {
  if (g_strcmp0 (gst_structure_get_name (gst_message_get_structure (msg)), "tags-changed") == 0) {
    /* If the message is the "tags-changed" (only one we are currently issuing), update
     * the stream info GUI */
    analyze_streams (data);
  }
}
</code></pre>
<p>Once me made sure it is the <code>tags-changed</code> message, we call the
<code>analyze_streams</code> function, which is also used in <a href="../playback/playbin-usage.html">Playback tutorial 1: Playbin usage</a> and is
more detailed there. It basically recovers the tags from the stream and
writes them in a text widget in the GUI.</p>
<p>The <code>error_cb</code>, <code>eos_cb</code> and <code>state_changed_cb</code> are not really worth
explaining, since they do the same as in all previous tutorials, but
from their own function now.</p>
<p>And this is it! The amount of code in this tutorial might seem daunting
but the required concepts are few and easy. If you have followed the
previous tutorials and have a little knowledge of GTK, you probably
understood this one can now enjoy your very own media player!</p>
<p><img src="images/tutorials/basic-tutorial-5.png" alt=""></p>
<h2 id="exercise">Exercise</h2>
<p>If this media player is not good enough for you, try to change the text
widget that displays the information about the streams into a proper
list view (or tree view). Then, when the user selects a different
stream, make GStreamer switch streams! To switch streams, you will need
to read <a href="../playback/playbin-usage.html">Playback tutorial 1: Playbin usage</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This tutorial has shown:</p>
<ul>
<li>
<p>How to output the video to a particular window handle
using <code>gst_video_overlay_set_window_handle()</code>.</p>
</li>
<li>
<p>How to refresh the GUI periodically by registering a timeout
callback with <code>g_timeout_add_seconds ()</code>.</p>
</li>
<li>
<p>How to convey information to the main thread by means of application
messages through the bus with <code>gst_element_post_message()</code>.</p>
</li>
<li>
<p>How to be notified only of interesting messages by making the bus
emit signals with <code>gst_bus_add_signal_watch()</code> and discriminating
among all message types using the signal details.</p>
</li>
</ul>
<p>This allows you to build a somewhat complete media player with a proper
Graphical User Interface.</p>
<p>The following basic tutorials keep focusing on other individual
GStreamer topics</p>
<p>It has been a pleasure having you here, and see you soon!</p>

    </div>
        




		<div id="subpages"></div>
		</div>
		<div id="search_results">
			<p>The results of the search are</p>
		</div>
	</div>

</div>

<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2">
	<div id="toc-column">
		
					<div class="edit-button">
				

			</div>
				<div id="toc-wrapper">
			<nav id="toc"></nav>
		</div>
	</div>
</div>
	</div>

</main>


<footer class="page-row">
	<div class="container-fluid">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-lg-3 col-xl-2" id="footer-left-column"></div>
		<div class="col-xs-12 col-sm-12 col-md-9 col-lg-7 col-xl-8" id="footer-content-column">
						    

		</div>
		<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2" id="footer-right-column"></div>
	</div>
</div>
</footer>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>