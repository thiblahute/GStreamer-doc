<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Basic tutorial 8: Short-cutting the pipeline</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/utils.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/navigation.js"></script>


<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>


<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body data-spy="scroll" data-target="#toc" data-offset="70">

<nav class="navbar navbar-fixed-top navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a id="home-link" class="hotdoc-navbar-brand">
				
<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a href="../../api.html">API References</a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="../../gstreamer-1.0/index.html">GStreamer core</a>
			</li>
					<li>
				<a href="../../gst-plugins-base-1.0/index.html">GStreamer Plugins Base</a>
			</li>
					<li>
				<a href="../../gst-plugins-good-1.0/index.html">GStreamer Plugins Good</a>
			</li>
					<li>
				<a href="../../gst-plugins-bad-1.0/index.html">GStreamer Plugins Bad</a>
			</li>
					<li>
				<a href="../../gst-plugins-ugly-1.0/index.html">GStreamer Plugins Ugly</a>
			</li>
					<li>
				<a href="../../gst-libav-1.0/index.html">GStreamer ffmpeg</a>
			</li>
					<li>
				<a href="../../gstreamer-vaapi-1.0/index.html">GStreamer VAAPI</a>
			</li>
					<li>
				<a href="../../gst-devtools-1.0/index.html">GStreamer Validate</a>
			</li>
					<li>
				<a href="../../gst-editing-services-1.0/c/index.html">GStreamer Editing Services</a>
			</li>
		</ul></li>

<li>
    <a href="../../application-development/index.html">Application manual</a>
</li>


<li>
    <a href="../index.html">Tutorials</a>
</li>

			</ul>
						<form action="" class="navbar-form navbar-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                       </form>
		</div>
	</div>
</nav>

<main class="page-row page-row-expanded">
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-1.0" data-hotdoc-ref="tutorials/basic/short-cutting-the-pipeline.html" class="page_container" id="page-wrapper">
	<div class="row">
		
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 col-xl-2" id="sidenav-column">
	<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
		<div id="sitenav-wrapper">
			<div class="sidenav-main-panel-body">
				<div id="site-navigation">
				</div>
			</div>
		</div>
	</div>
	<button id="offcanvasleft" class="btn btn-xs" type="button" data-toggle="offcanvasleft">
		<i class="glyphicon glyphicon-chevron-right" id="offcanvasleft-chevron"></i>
	</button>
</div>

<div class="col-xs-12 col-sm-12 col-md-9 col-lg-7 col-xl-8" id="content-column">

	<div id="main">
				    <div id="page-description" data-hotdoc-source="short-cutting-the-pipeline.md">
        <h1 id="basic-tutorial-8-shortcutting-the-pipeline">Basic tutorial 8: Short-cutting the pipeline</h1>
<h2 id="goal">Goal</h2>
<p>Pipelines constructed with GStreamer do not need to be completely
closed. Data can be injected into the pipeline and extracted from it at
any time, in a variety of ways. This tutorial shows:</p>
<ul>
<li>
<p>How to inject external data into a general GStreamer pipeline.</p>
</li>
<li>
<p>How to extract data from a general GStreamer pipeline.</p>
</li>
<li>
<p>How to access and manipulate this data.</p>
</li>
</ul>
<p><a href="../playback/short-cutting-the-pipeline.html">Playback tutorial 3: Short-cutting the pipeline</a> explains
how to achieve the same goals in a playbin-based pipeline.</p>
<h2 id="introduction">Introduction</h2>
<p>Applications can interact with the data flowing through a GStreamer
pipeline in several ways. This tutorial describes the easiest one, since
it uses elements that have been created for this sole purpose.</p>
<p>The element used to inject application data into a GStreamer pipeline is
<code>appsrc</code>, and its counterpart, used to extract GStreamer data back to
the application is <code>appsink</code>. To avoid confusing the names, think of it
from GStreamer's point of view: <code>appsrc</code> is just a regular source, that
provides data magically fallen from the sky (provided by the
application, actually). <code>appsink</code> is a regular sink, where the data
flowing through a GStreamer pipeline goes to die (it is recovered by the
application, actually).</p>
<p><code>appsrc</code> and <code>appsink</code> are so versatile that they offer their own API
(see their documentation), which can be accessed by linking against the
<code>gstreamer-app</code> library. In this tutorial, however, we will use a
simpler approach and control them through signals.</p>
<p><code>appsrc</code> can work in a variety of modes: in <strong>pull</strong> mode, it requests
data from the application every time it needs it. In <strong>push</strong> mode, the
application pushes data at its own pace. Furthermore, in push mode, the
application can choose to be blocked in the push function when enough
data has already been provided, or it can listen to the
<code>enough-data</code> and <code>need-data</code> signals to control flow. This example
implements the latter approach. Information regarding the other methods
can be found in the <code>appsrc</code> documentation.</p>
<h3 id="buffers">Buffers</h3>
<p>Data travels through a GStreamer pipeline in chunks called <strong>buffers</strong>.
Since this example produces and consumes data, we need to know about
<code>GstBuffer</code>s.</p>
<p>Source Pads produce buffers, that are consumed by Sink Pads; GStreamer
takes these buffers and passes them from element to element.</p>
<p>A buffer simply represents a unit of data, do not assume that all
buffers will have the same size, or represent the same amount of time.
Neither should you assume that if a single buffer enters an element, a
single buffer will come out. Elements are free to do with the received
buffers as they please. <code>GstBuffer</code>s may also contain more than one
actual memory buffer. Actual memory buffers are abstracted away using
<code>GstMemory</code> objects, and a <code>GstBuffer</code> can contain multiple <code>GstMemory</code> objects.</p>
<p>Every buffer has attached time-stamps and duration, that describe in
which moment the content of the buffer should be decoded, rendered or
displayed. Time stamping is a very complex and delicate subject, but
this simplified vision should suffice for now.</p>
<p>As an example, a <code>filesrc</code> (a GStreamer element that reads files)
produces buffers with the “ANY” caps and no time-stamping information.
After demuxing (see <a href="dynamic-pipelines.html">Basic tutorial 3: Dynamic pipelines</a>)
buffers can have some specific caps, for example “video/x-h264”. After
decoding, each buffer will contain a single video frame with raw caps
(for example, “video/x-raw-yuv”) and very precise time stamps indicating
when should that frame be displayed.</p>
<h3 id="this-tutorial">This tutorial</h3>
<p>This tutorial expands <a href="multithreading-and-pad-availability.html">Basic tutorial 7: Multithreading and Pad Availability</a> in
two ways: firstly, the <code>audiotestsrc</code> is replaced by an <code>appsrc</code> that
will generate the audio data. Secondly, a new branch is added to the
<code>tee</code> so data going into the audio sink and the wave display is also
replicated into an <code>appsink</code>. The <code>appsink</code> uploads the information back
into the application, which then just notifies the user that data has
been received, but it could obviously perform more complex tasks.</p>
<p><img src="images/tutorials/basic-tutorial-8.png" alt=""></p>
<h2 id="a-crude-waveform-generator">A crude waveform generator</h2>
<p>Copy this code into a text file named <code>basic-tutorial-8.c</code> (or find it
in the SDK installation).</p>
<pre><code class="language-c">#include &lt;gst/gst.h&gt;
#include &lt;gst/audio/audio.h&gt;
#include &lt;string.h&gt;

#define CHUNK_SIZE 1024   /* Amount of bytes we are sending in each buffer */
#define SAMPLE_RATE 44100 /* Samples per second we are sending */

/* Structure to contain all our information, so we can pass it to callbacks */
typedef struct _CustomData {
  GstElement *pipeline, *app_source, *tee, *audio_queue, *audio_convert1, *audio_resample, *audio_sink;
  GstElement *video_queue, *audio_convert2, *visual, *video_convert, *video_sink;
  GstElement *app_queue, *app_sink;

  guint64 num_samples;   /* Number of samples generated so far (for timestamp generation) */
  gfloat a, b, c, d;     /* For waveform generation */

  guint sourceid;        /* To control the GSource */

  GMainLoop *main_loop;  /* GLib's Main Loop */
} CustomData;

/* This method is called by the idle GSource in the mainloop, to feed CHUNK_SIZE bytes into appsrc.
 * The ide handler is added to the mainloop when appsrc requests us to start sending data (need-data signal)
 * and is removed when appsrc has enough data (enough-data signal).
 */
static gboolean push_data (CustomData *data) {
  GstBuffer *buffer;
  GstFlowReturn ret;
  int i;
  GstMapInfo map;
  gint16 *raw;
  gint num_samples = CHUNK_SIZE / 2; /* Because each sample is 16 bits */
  gfloat freq;

  /* Create a new empty buffer */
  buffer = gst_buffer_new_and_alloc (CHUNK_SIZE);

  /* Set its timestamp and duration */
  GST_BUFFER_TIMESTAMP (buffer) = gst_util_uint64_scale (data-&gt;num_samples, GST_SECOND, SAMPLE_RATE);
  GST_BUFFER_DURATION (buffer) = gst_util_uint64_scale (CHUNK_SIZE, GST_SECOND, SAMPLE_RATE);

  /* Generate some psychodelic waveforms */
  gst_buffer_map (buffer, &amp;map, GST_MAP_WRITE);
  raw = (gint16 *)map.data;
  data-&gt;c += data-&gt;d;
  data-&gt;d -= data-&gt;c / 1000;
  freq = 1100 + 1000 * data-&gt;d;
  for (i = 0; i &lt; num_samples; i++) {
    data-&gt;a += data-&gt;b;
    data-&gt;b -= data-&gt;a / freq;
    raw[i] = (gint16)(500 * data-&gt;a);
  }
  gst_buffer_unmap (buffer, &amp;map);
  data-&gt;num_samples += num_samples;

  /* Push the buffer into the appsrc */
  g_signal_emit_by_name (data-&gt;app_source, "push-buffer", buffer, &amp;ret);

  /* Free the buffer now that we are done with it */
  gst_buffer_unref (buffer);

  if (ret != GST_FLOW_OK) {
    /* We got some error, stop sending data */
    return FALSE;
  }

  return TRUE;
}

/* This signal callback triggers when appsrc needs data. Here, we add an idle handler
 * to the mainloop to start pushing data into the appsrc */
static void start_feed (GstElement *source, guint size, CustomData *data) {
  if (data-&gt;sourceid == 0) {
    g_print ("Start feeding\n");
    data-&gt;sourceid = g_idle_add ((GSourceFunc) push_data, data);
  }
}

/* This callback triggers when appsrc has enough data and we can stop sending.
 * We remove the idle handler from the mainloop */
static void stop_feed (GstElement *source, CustomData *data) {
  if (data-&gt;sourceid != 0) {
    g_print ("Stop feeding\n");
    g_source_remove (data-&gt;sourceid);
    data-&gt;sourceid = 0;
  }
}

/* The appsink has received a buffer */
static void new_sample (GstElement *sink, CustomData *data) {
  GstSample *sample;

  /* Retrieve the buffer */
  g_signal_emit_by_name (sink, "pull-sample", &amp;sample);
  if (sample) {
    /* The only thing we do in this example is print a * to indicate a received buffer */
    g_print ("*");
    gst_buffer_unref (sample);
  }
}

/* This function is called when an error message is posted on the bus */
static void error_cb (GstBus *bus, GstMessage *msg, CustomData *data) {
  GError *err;
  gchar *debug_info;

  /* Print error details on the screen */
  gst_message_parse_error (msg, &amp;err, &amp;debug_info);
  g_printerr ("Error received from element %s: %s\n", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);
  g_printerr ("Debugging information: %s\n", debug_info ? debug_info : "none");
  g_clear_error (&amp;err);
  g_free (debug_info);

  g_main_loop_quit (data-&gt;main_loop);
}

int main(int argc, char *argv[]) {
  CustomData data;
  GstPadTemplate *tee_src_pad_template;
  GstPad *tee_audio_pad, *tee_video_pad, *tee_app_pad;
  GstPad *queue_audio_pad, *queue_video_pad, *queue_app_pad;
  GstAudioInfo info;
  GstCaps *audio_caps;
  GstBus *bus;

  /* Initialize cumstom data structure */
  memset (&amp;data, 0, sizeof (data));
  data.b = 1; /* For waveform generation */
  data.d = 1;

  /* Initialize GStreamer */
  gst_init (&amp;argc, &amp;argv);

  /* Create the elements */
  data.app_source = gst_element_factory_make ("appsrc", "audio_source");
  data.tee = gst_element_factory_make ("tee", "tee");
  data.audio_queue = gst_element_factory_make ("queue", "audio_queue");
  data.audio_convert1 = gst_element_factory_make ("audioconvert", "audio_convert1");
  data.audio_resample = gst_element_factory_make ("audioresample", "audio_resample");
  data.audio_sink = gst_element_factory_make ("autoaudiosink", "audio_sink");
  data.video_queue = gst_element_factory_make ("queue", "video_queue");
  data.audio_convert2 = gst_element_factory_make ("audioconvert", "audio_convert2");
  data.visual = gst_element_factory_make ("wavescope", "visual");
  data.video_convert = gst_element_factory_make ("videoconvert", "csp");
  data.video_sink = gst_element_factory_make ("autovideosink", "video_sink");
  data.app_queue = gst_element_factory_make ("queue", "app_queue");
  data.app_sink = gst_element_factory_make ("appsink", "app_sink");

  /* Create the empty pipeline */
  data.pipeline = gst_pipeline_new ("test-pipeline");

  if (!data.pipeline || !data.app_source || !data.tee || !data.audio_queue || !data.audio_convert1 ||
      !data.audio_resample || !data.audio_sink || !data.video_queue || !data.audio_convert2 || !data.visual ||
      !data.video_convert || !data.video_sink || !data.app_queue || !data.app_sink) {
    g_printerr ("Not all elements could be created.\n");
    return -1;
  }

  /* Configure wavescope */
  g_object_set (data.visual, "shader", 0, "style", 0, NULL);

  /* Configure appsrc */
  gst_audio_info_set_format (&amp;info, GST_AUDIO_FORMAT_S16, SAMPLE_RATE, 1, NULL);
  audio_caps = gst_audio_info_to_caps (&amp;info);
  g_object_set (data.app_source, "caps", audio_caps, "format", GST_FORMAT_TIME, NULL);
  g_signal_connect (data.app_source, "need-data", G_CALLBACK (start_feed), &amp;data);
  g_signal_connect (data.app_source, "enough-data", G_CALLBACK (stop_feed), &amp;data);

  /* Configure appsink */
  g_object_set (data.app_sink, "emit-signals", TRUE, "caps", audio_caps, NULL);
  g_signal_connect (data.app_sink, "new-sample", G_CALLBACK (new_sample), &amp;data);
  gst_caps_unref (audio_caps);
  g_free (audio_caps_text);

  /* Link all elements that can be automatically linked because they have "Always" pads */
  gst_bin_add_many (GST_BIN (data.pipeline), data.app_source, data.tee, data.audio_queue, data.audio_convert1, data.audio_resample,
      data.audio_sink, data.video_queue, data.audio_convert2, data.visual, data.video_convert, data.video_sink, data.app_queue,
      data.app_sink, NULL);
  if (gst_element_link_many (data.app_source, data.tee, NULL) != TRUE ||
      gst_element_link_many (data.audio_queue, data.audio_convert1, data.audio_resample, data.audio_sink, NULL) != TRUE ||
      gst_element_link_many (data.video_queue, data.audio_convert2, data.visual, data.video_convert, data.video_sink, NULL) != TRUE ||
      gst_element_link_many (data.app_queue, data.app_sink, NULL) != TRUE) {
    g_printerr ("Elements could not be linked.\n");
    gst_object_unref (data.pipeline);
    return -1;
  }

  /* Manually link the Tee, which has "Request" pads */
  tee_src_pad_template = gst_element_class_get_pad_template (GST_ELEMENT_GET_CLASS (data.tee), "src_%d");
  tee_audio_pad = gst_element_request_pad (data.tee, tee_src_pad_template, NULL, NULL);
  g_print ("Obtained request pad %s for audio branch.\n", gst_pad_get_name (tee_audio_pad));
  queue_audio_pad = gst_element_get_static_pad (data.audio_queue, "sink");
  tee_video_pad = gst_element_request_pad (data.tee, tee_src_pad_template, NULL, NULL);
  g_print ("Obtained request pad %s for video branch.\n", gst_pad_get_name (tee_video_pad));
  queue_video_pad = gst_element_get_static_pad (data.video_queue, "sink");
  tee_app_pad = gst_element_request_pad (data.tee, tee_src_pad_template, NULL, NULL);
  g_print ("Obtained request pad %s for app branch.\n", gst_pad_get_name (tee_app_pad));
  queue_app_pad = gst_element_get_static_pad (data.app_queue, "sink");
  if (gst_pad_link (tee_audio_pad, queue_audio_pad) != GST_PAD_LINK_OK ||
      gst_pad_link (tee_video_pad, queue_video_pad) != GST_PAD_LINK_OK ||
      gst_pad_link (tee_app_pad, queue_app_pad) != GST_PAD_LINK_OK) {
    g_printerr ("Tee could not be linked\n");
    gst_object_unref (data.pipeline);
    return -1;
  }
  gst_object_unref (queue_audio_pad);
  gst_object_unref (queue_video_pad);
  gst_object_unref (queue_app_pad);

  /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */
  bus = gst_element_get_bus (data.pipeline);
  gst_bus_add_signal_watch (bus);
  g_signal_connect (G_OBJECT (bus), "message::error", (GCallback)error_cb, &amp;data);
  gst_object_unref (bus);

  /* Start playing the pipeline */
  gst_element_set_state (data.pipeline, GST_STATE_PLAYING);

  /* Create a GLib Main Loop and set it to run */
  data.main_loop = g_main_loop_new (NULL, FALSE);
  g_main_loop_run (data.main_loop);

  /* Release the request pads from the Tee, and unref them */
  gst_element_release_request_pad (data.tee, tee_audio_pad);
  gst_element_release_request_pad (data.tee, tee_video_pad);
  gst_element_release_request_pad (data.tee, tee_app_pad);
  gst_object_unref (tee_audio_pad);
  gst_object_unref (tee_video_pad);
  gst_object_unref (tee_app_pad);

  /* Free resources */
  gst_element_set_state (data.pipeline, GST_STATE_NULL);
  gst_object_unref (data.pipeline);
  return 0;
}
</code></pre>
<blockquote>
<p><img src="images/icons/emoticons/information.svg" alt="Information" id="information">
Need help?</p>
<p>If you need help to compile this code, refer to the <strong>Building the tutorials</strong>  section for your platform: <a href="../../installing/on-linux.html#InstallingonLinux-Build">Linux</a>, <a href="../../installing/on-mac-osx.html#InstallingonMacOSX-Build">Mac OS X</a> or <a href="../../installing/on-windows.html#InstallingonWindows-Build">Windows</a>, or use this specific command on Linux:</p>
<p><code>gcc basic-tutorial-8.c -o basic-tutorial-8 `pkg-config --cflags --libs gstreamer-1.0 gst-audio-1.0`</code></p>
<p>If you need help to run this code, refer to the <strong>Running the tutorials</strong> section for your platform: <a href="../../installing/on-linux.html#InstallingonLinux-Run">Linux</a>, <a href="../../installing/on-mac-osx.html#InstallingonMacOSX-Run">Mac OS X</a> or <a href="../../installing/on-windows.html#InstallingonWindows-Run">Windows</a>.</p>
<p>This tutorial plays an audible tone for varying frequency through the audio card and opens a window with a waveform representation of the tone. The waveform should be a sinusoid, but due to the refreshing of the window might not appear so.</p>
<p>Required libraries: <code>gstreamer-1.0</code></p>
</blockquote>
<h2 id="walkthrough">Walkthrough</h2>
<p>The code to create the pipeline (Lines 131 to 205) is an enlarged
version of <a href="multithreading-and-pad-availability.html">Basic tutorial 7: Multithreading and Pad
Availability</a>.
It involves instantiating all the elements, link the elements with
Always Pads, and manually link the Request Pads of the <code>tee</code> element.</p>
<p>Regarding the configuration of the <code>appsrc</code> and <code>appsink</code> elements:</p>
<pre><code class="language-c">/* Configure appsrc */
audio_caps_text = g_strdup_printf (AUDIO_CAPS, SAMPLE_RATE);
audio_caps = gst_caps_from_string (audio_caps_text);
g_object_set (data.app_source, "caps", audio_caps, NULL);
g_signal_connect (data.app_source, "need-data", G_CALLBACK (start_feed), &amp;data);
g_signal_connect (data.app_source, "enough-data", G_CALLBACK (stop_feed), &amp;data);
</code></pre>
<p>The first property that needs to be set on the <code>appsrc</code> is <code>caps</code>. It
specifies the kind of data that the element is going to produce, so
GStreamer can check if linking with downstream elements is possible
(this is, if the downstream elements will understand this kind of data).
This property must be a <code>GstCaps</code> object, which is easily built from a
string with <code>gst_caps_from_string()</code>.</p>
<p>We then connect to the <code>need-data</code> and <code>enough-data</code> signals. These are
fired by <code>appsrc</code> when its internal queue of data is running low or
almost full, respectively. We will use these signals to start and stop
(respectively) our signal generation process.</p>
<pre><code class="language-c">/* Configure appsink */
g_object_set (data.app_sink, "emit-signals", TRUE, "caps", audio_caps, NULL);
g_signal_connect (data.app_sink, "new-sample", G_CALLBACK (new_sample), &amp;data);
gst_caps_unref (audio_caps);
g_free (audio_caps_text);
</code></pre>
<p>Regarding the <code>appsink</code> configuration, we connect to the
<code>new-sample</code> signal, which is emitted every time the sink receives a
buffer. Also, the signal emission needs to be enabled through the
<code>emit-signals</code> property, because, by default, it is disabled.</p>
<p>Starting the pipeline, waiting for messages and final cleanup is done as
usual. Let's review the callbacks we have just
registered:</p>
<pre><code class="language-c">/* This signal callback triggers when appsrc needs data. Here, we add an idle handler
 * to the mainloop to start pushing data into the appsrc */
static void start_feed (GstElement *source, guint size, CustomData *data) {
  if (data-&gt;sourceid == 0) {
    g_print ("Start feeding\n");
    data-&gt;sourceid = g_idle_add ((GSourceFunc) push_data, data);
  }
}
</code></pre>
<p>This function is called when the internal queue of <code>appsrc</code> is about to
starve (run out of data). The only thing we do here is register a GLib
idle function with <code>g_idle_add()</code> that feeds data to <code>appsrc</code> until it
is full again. A GLib idle function is a method that GLib will call from
its main loop whenever it is “idle”, this is, when it has no
higher-priority tasks to perform. It requires a GLib <code>GMainLoop</code> to be
instantiated and running, obviously.</p>
<p>This is only one of the multiple approaches that <code>appsrc</code> allows. In
particular, buffers do not need to be fed into <code>appsrc</code> from the main
thread using GLib, and you do not need to use the <code>need-data</code> and
<code>enough-data</code> signals to synchronize with <code>appsrc</code> (although this is
allegedly the most convenient).</p>
<p>We take note of the sourceid that <code>g_idle_add()</code> returns, so we can
disable it
later.</p>
<pre><code class="language-c">/* This callback triggers when appsrc has enough data and we can stop sending.
 * We remove the idle handler from the mainloop */
static void stop_feed (GstElement *source, CustomData *data) {
  if (data-&gt;sourceid != 0) {
    g_print ("Stop feeding\n");
    g_source_remove (data-&gt;sourceid);
    data-&gt;sourceid = 0;
  }
}
</code></pre>
<p>This function is called when the internal queue of <code>appsrc</code> is full
enough so we stop pushing data. Here we simply remove the idle function
by using <code>g_source_remove()</code> (The idle function is implemented as a
<code>GSource</code>).</p>
<pre><code class="language-c">/* This method is called by the idle GSource in the mainloop, to feed CHUNK_SIZE bytes into appsrc.
 * The ide handler is added to the mainloop when appsrc requests us to start sending data (need-data signal)
 * and is removed when appsrc has enough data (enough-data signal).
 */
static gboolean push_data (CustomData *data) {
  GstBuffer *buffer;
  GstFlowReturn ret;
  int i;
  gint16 *raw;
  gint num_samples = CHUNK_SIZE / 2; /* Because each sample is 16 bits */
  gfloat freq;

  /* Create a new empty buffer */
  buffer = gst_buffer_new_and_alloc (CHUNK_SIZE);

  /* Set its timestamp and duration */
  GST_BUFFER_TIMESTAMP (buffer) = gst_util_uint64_scale (data-&gt;num_samples, GST_SECOND, SAMPLE_RATE);
  GST_BUFFER_DURATION (buffer) = gst_util_uint64_scale (CHUNK_SIZE, GST_SECOND, SAMPLE_RATE);

  /* Generate some psychodelic waveforms */
  raw = (gint16 *)GST_BUFFER_DATA (buffer);
</code></pre>
<p>This is the function that feeds <code>appsrc</code>. It will be called by GLib at
times and rates which are out of our control, but we know that we will
disable it when its job is done (when the queue in <code>appsrc</code> is full).</p>
<p>Its first task is to create a new buffer with a given size (in this
example, it is arbitrarily set to 1024 bytes) with
<code>gst_buffer_new_and_alloc()</code>.</p>
<p>We count the number of samples that we have generated so far with the
<code>CustomData.num_samples</code> variable, so we can time-stamp this buffer
using the <code>GST_BUFFER_TIMESTAMP</code> macro in <code>GstBuffer</code>.</p>
<p>Since we are producing buffers of the same size, their duration is the
same and is set using the <code>GST_BUFFER_DURATION</code> in <code>GstBuffer</code>.</p>
<p><code>gst_util_uint64_scale()</code> is a utility function that scales (multiply
and divide) numbers which can be large, without fear of overflows.</p>
<p>The bytes that for the buffer can be accessed with GST_BUFFER_DATA in
<code>GstBuffer</code> (Be careful not to write past the end of the buffer: you
allocated it, so you know its size).</p>
<p>We will skip over the waveform generation, since it is outside the scope
of this tutorial (it is simply a funny way of generating a pretty
psychedelic wave).</p>
<pre><code class="language-c">/* Push the buffer into the appsrc */
g_signal_emit_by_name (data-&gt;app_source, "push-buffer", buffer, &amp;ret);

/* Free the buffer now that we are done with it */
gst_buffer_unref (buffer);
</code></pre>
<p>Once we have the buffer ready, we pass it to <code>appsrc</code> with the
<code>push-buffer</code> action signal (see information box at the end of <a href="../playback/playbin-usage.html">Playback tutorial 1: Playbin usage</a>), and then
<code>gst_buffer_unref()</code> it since we no longer need it.</p>
<pre><code class="language-c">/* The appsink has received a buffer */
static void new_sample (GstElement *sink, CustomData *data) {
  GstSample *sample;
  /* Retrieve the buffer */
  g_signal_emit_by_name (sink, "pull-sample", &amp;sample);
  if (sample) {
    /* The only thing we do in this example is print a * to indicate a received buffer */
    g_print ("*");
    gst_sample_unref (sample);
  }
}
</code></pre>
<p>Finally, this is the function that gets called when the
<code>appsink</code> receives a buffer. We use the <code>pull-sample</code> action signal to
retrieve the buffer and then just print some indicator on the screen. We
can retrieve the data pointer using the <code>GST_BUFFER_DATA</code> macro and the
data size using the <code>GST_BUFFER_SIZE</code> macro in <code>GstBuffer</code>. Remember
that this buffer does not have to match the buffer that we produced in
the <code>push_data</code> function, any element in the path could have altered the
buffers in any way (Not in this example: there is only a <code>tee</code> in the
path between <code>appsrc</code> and <code>appsink</code>, and it does not change the content
of the buffers).</p>
<p>We then <code>gst_buffer_unref()</code> the buffer, and this tutorial is done.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This tutorial has shown how applications can:</p>
<ul>
<li>Inject data into a pipeline using the <code>appsrc</code>element.</li>
<li>Retrieve data from a pipeline using the <code>appsink</code> element.</li>
<li>Manipulate this data by accessing the <code>GstBuffer</code>.</li>
</ul>
<p>In a playbin-based pipeline, the same goals are achieved in a slightly
different way. <a href="../playback/short-cutting-the-pipeline.html">Playback tutorial 3: Short-cutting the pipeline</a> shows
how to do it.</p>
<p>It has been a pleasure having you here, and see you soon!</p>

    </div>
        




		<div id="subpages"></div>
		</div>
		<div id="search_results">
			<p>The results of the search are</p>
		</div>
	</div>

</div>

<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2">
	<div id="toc-column">
		
					<div class="edit-button">
				

			</div>
				<div id="toc-wrapper">
			<nav id="toc"></nav>
		</div>
	</div>
</div>
	</div>

</main>


<footer class="page-row">
	<div class="container-fluid">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-lg-3 col-xl-2" id="footer-left-column"></div>
		<div class="col-xs-12 col-sm-12 col-md-9 col-lg-7 col-xl-8" id="footer-content-column">
						    

		</div>
		<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2" id="footer-right-column"></div>
	</div>
</div>
</footer>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>