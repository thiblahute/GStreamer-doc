<html lang="en">
<head>

<base href="../..">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>Android tutorial 2: A running pipeline</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/jquery.touchSwipe.min.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>

<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>

<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body class="no-script
" data-spy="scroll" data-target="#toc" data-offset="70">

<script>
$('body').removeClass('no-script');
</script>

<nav class="navbar navbar-fixed-top navbar-default" id="topnav">
	<div class="container-fluid">
		<div class="navbar-right">
			<a id="toc-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<form action="" class="navbar-form pull-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                        </form>
		</div>
		<div class="navbar-header">
			<a id="sidenav-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<a id="home-link" href="index.html" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        API References<span class="caret"></span>
    </a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="libgstreamer-1.0/c/index.html">GStreamer core</a>
			</li>
					<li>
				<a href="libs.html">GStreamer Libraries</a>
			</li>
					<li>
				<a href="plugins_doc.html">GStreamer Plugins</a>
			</li>
		</ul>
</li>

<li>
    <a href="application-development/index.html">Application manual</a>
</li>


<li>
    <a href="tutorials/index.html">Tutorials</a>
</li>

			</ul>
			<div class="hidden-xs hidden-sm navbar-text navbar-center">
							</div>
		</div>
	</div>
</nav>

<main>
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer-1.0" data-hotdoc-ref="tutorials/android/a-running-pipeline.html" class="page_container" id="page-wrapper">
<script src="assets/js/utils.js"></script>

<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
	<script src="assets/js/navigation.js"></script>
	<script src="assets/js/sitemap.js"></script>
</div>

<div id="body">
	<div id="main">
				    <div id="page-description" data-hotdoc-source="a-running-pipeline.md" data-hotdoc-role="main">
        <h1 id="android-tutorial-2-a-running-pipeline">Android tutorial 2: A running pipeline</h1>
<h3 id="goal">Goal</h3>
<p><img src="tutorials/android/images/tutorials/android-a-running-pipeline-screenshot.png" alt="screenshot" id="screenshot"></p>
<p>The tutorials seen in the <a href="tutorials/basic/index.html">Basic</a> and
<a href="tutorials/playback/index.html">Playback</a> sections are intended for Desktop
platforms and, therefore, their main thread is allowed to block (using
<code>gst_bus_pop_filtered()</code>) or relinquish control to a GLib main loop. On
Android this would lead to the application being tagged as
non-responsive and probably closed.</p>
<p>This tutorial shows how to overcome this problem. In particular, we will
learn:</p>
<ul>
<li>How to move the native code to its own thread</li>
<li>How to allow threads created from C code to communicate with Java</li>
<li>How to access Java code from C</li>
<li>How to allocate a <code>CustomData</code> structure from C and have Java host
it</li>
</ul>
<h3 id="introduction">Introduction</h3>
<p>When using a Graphical User Interface (UI), if the application waits for
GStreamer calls to complete the user experience will suffer. The usual
approach, with the <a href="http://www.gtk.org">GTK+ toolkit</a> for example, is to
relinquish control to a GLib <code>GMainLoop</code> and let it control the events
coming from the UI or GStreamer.</p>
<p>This approach can be very cumbersome when GStreamer and the Android UI
communicate through the JNI interface, so we take a cleaner route: We
use a GLib main loop, and move it to its own thread, so it does not
block the application. This simplifies the GStreamer-Android
integration, and we only need to worry about a few inter-process
synchronization bits, which are detailed in this tutorial.</p>
<p>Additionally, this tutorial shows how to obtain, from any thread, the
<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/design.html#wp16696">JNI Environment
pointer</a>
required to make JNI calls. This is necessary, for example, to call Java
code from callbacks in threads spawned deep within GStreamer, which
never received this pointer directly.</p>
<p>Finally, this tutorial explains how to call Java methods from native C
code, which involves locating the desired method’s ID in the class.
These IDs never change, so they are cached as global variables in the C
code and obtained in the static initializer of the class.</p>
<p>The code below builds a pipeline with an <code>audiotestsrc</code> and an
<code>autoaudiosink</code> (it plays an audible tone). Two buttons in the UI allow
setting the pipeline to PLAYING or PAUSED. A TextView in the UI shows
messages sent from the C code (for errors and state changes).</p>
<h3 id="a-pipeline-on-android-java-code">A pipeline on Android [Java code]</h3>
<p><strong>src/org/freedesktop/gstreamer/tutorials/tutorial_2/Tutorial2.java</strong></p>
<pre><code class="language-java">package org.freedesktop.gstreamer.tutorials.tutorial_2;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageButton;
import android.widget.TextView;
import android.widget.Toast;

import org.freedesktop.gstreamer.GStreamer;

public class Tutorial2 extends Activity {
    private native void nativeInit();     // Initialize native code, build pipeline, etc
    private native void nativeFinalize(); // Destroy pipeline and shutdown native code
    private native void nativePlay();     // Set pipeline to PLAYING
    private native void nativePause();    // Set pipeline to PAUSED
    private static native boolean nativeClassInit(); // Initialize native class: cache Method IDs for callbacks
    private long native_custom_data;      // Native code will use this to keep private data

    private boolean is_playing_desired;   // Whether the user asked to go to PLAYING

    // Called when the activity is first created.
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        // Initialize GStreamer and warn if it fails
        try {
            GStreamer.init(this);
        } catch (Exception e) {
            Toast.makeText(this, e.getMessage(), Toast.LENGTH_LONG).show();
            finish();
            return;
        }

        setContentView(R.layout.main);

        ImageButton play = (ImageButton) this.findViewById(R.id.button_play);
        play.setOnClickListener(new OnClickListener() {
            public void onClick(View v) {
                is_playing_desired = true;
                nativePlay();
            }
        });

        ImageButton pause = (ImageButton) this.findViewById(R.id.button_stop);
        pause.setOnClickListener(new OnClickListener() {
            public void onClick(View v) {
                is_playing_desired = false;
                nativePause();
            }
        });

        if (savedInstanceState != null) {
            is_playing_desired = savedInstanceState.getBoolean("playing");
            Log.i ("GStreamer", "Activity created. Saved state is playing:" + is_playing_desired);
        } else {
            is_playing_desired = false;
            Log.i ("GStreamer", "Activity created. There is no saved state, playing: false");
        }

        // Start with disabled buttons, until native code is initialized
        this.findViewById(R.id.button_play).setEnabled(false);
        this.findViewById(R.id.button_stop).setEnabled(false);

        nativeInit();
    }

    protected void onSaveInstanceState (Bundle outState) {
        Log.d ("GStreamer", "Saving state, playing:" + is_playing_desired);
        outState.putBoolean("playing", is_playing_desired);
    }

    protected void onDestroy() {
        nativeFinalize();
        super.onDestroy();
    }

    // Called from native code. This sets the content of the TextView from the UI thread.
    private void setMessage(final String message) {
        final TextView tv = (TextView) this.findViewById(R.id.textview_message);
        runOnUiThread (new Runnable() {
          public void run() {
            tv.setText(message);
          }
        });
    }

    // Called from native code. Native code calls this once it has created its pipeline and
    // the main loop is running, so it is ready to accept commands.
    private void onGStreamerInitialized () {
        Log.i ("GStreamer", "Gst initialized. Restoring state, playing:" + is_playing_desired);
        // Restore previous playing state
        if (is_playing_desired) {
            nativePlay();
        } else {
            nativePause();
        }

        // Re-enable buttons, now that GStreamer is initialized
        final Activity activity = this;
        runOnUiThread(new Runnable() {
            public void run() {
                activity.findViewById(R.id.button_play).setEnabled(true);
                activity.findViewById(R.id.button_stop).setEnabled(true);
            }
        });
    }

    static {
        System.loadLibrary("gstreamer_android");
        System.loadLibrary("tutorial-2");
        nativeClassInit();
    }

}
</code></pre>
<p>As usual, the first bit that gets executed is the static initializer of
the class:</p>
<pre><code class="language-java">static {
    System.loadLibrary("gstreamer_android");
    System.loadLibrary("tutorial-2");
    nativeClassInit();
}
</code></pre>
<p>As explained in the previous tutorial, the two native libraries are
loaded and their <code>JNI_OnLoad()</code> methods are executed. Here, we also call
the native method <code>nativeClassInit()</code>, previously declared with the
<code>native</code> keyword in line 19. We will later see what its purpose is</p>
<p>In the <code>onCreate()</code> method GStreamer is initialized as in the previous
tutorial with <code>GStreamer.init(this)</code>, and then the layout is inflated
and listeners are setup for the two UI buttons:</p>
<pre><code class="language-java">ImageButton play = (ImageButton) this.findViewById(R.id.button_play);
play.setOnClickListener(new OnClickListener() {
    public void onClick(View v) {
        is_playing_desired = true;
        nativePlay();
    }
});
ImageButton pause = (ImageButton) this.findViewById(R.id.button_stop);
pause.setOnClickListener(new OnClickListener() {
    public void onClick(View v) {
        is_playing_desired = false;
        nativePause();
    }
});
</code></pre>
<p>Each button instructs the native code to set the pipeline to the desired
state, and also remembers this state in the
<code>is_playing_desired</code> variable.  This is required so, when the
application is restarted (for example, due to an orientation change), it
can set the pipeline again to the desired state. This approach is easier
and safer than tracking the actual pipeline state, because orientation
changes can happen before the pipeline has moved to the desired state,
for example.</p>
<pre><code class="language-java">if (savedInstanceState != null) {
    is_playing_desired = savedInstanceState.getBoolean("playing");
    Log.i ("GStreamer", "Activity created. Saved state is playing:" + is_playing_desired);
} else {
    is_playing_desired = false;
    Log.i ("GStreamer", "Activity created. There is no saved state, playing: false");
}
</code></pre>
<p>Restore the previous playing state (if any) from <code>savedInstanceState</code>.
We will first build the GStreamer pipeline (below) and only when the
native code reports itself as initialized we will use
<code>is_playing_desired</code>.</p>
<pre><code class="language-java">nativeInit();
</code></pre>
<p>As will be shown in the C code, <code>nativeInit()</code> creates a dedicated
thread, a GStreamer pipeline, a GLib main loop, and, right before
calling <code>g_main_loop_run()</code> and going to sleep, it warns the Java code
that the native code is initialized and ready to accept commands.</p>
<p>This finishes the <code>onCreate()</code> method and the Java initialization. The
UI buttons are disabled, so nothing will happen until native code is
ready and <code>onGStreamerInitialized()</code> is called:</p>
<pre><code class="language-java">private void onGStreamerInitialized () {
    Log.i ("GStreamer", "Gst initialized. Restoring state, playing:" + is_playing_desired);
</code></pre>
<p>This is called by the native code when its main loop is finally running.
We first retrieve the desired playing state from <code>is_playing_desired</code>,
and then set that state:</p>
<pre><code class="language-java">// Restore previous playing state
if (is_playing_desired) {
    nativePlay();
} else {
    nativePause();
}
</code></pre>
<p>Here comes the first caveat, when re-enabling the UI buttons:</p>
<pre><code class="language-java">// Re-enable buttons, now that GStreamer is initialized
final Activity activity = this;
runOnUiThread(new Runnable() {
    public void run() {
        activity.findViewById(R.id.button_play).setEnabled(true);
        activity.findViewById(R.id.button_stop).setEnabled(true);
    }
});
</code></pre>
<p>This method is being called from the thread that the native code created
to run its main loop, and is not allowed to issue UI-altering commands:
Only the UI thread can do that. The solution is easy though: Android
Activities have a handy
<a href="http://developer.android.com/reference/android/app/Activity.html#runOnUiThread(java.lang.Runnable)">runOnUiThread()</a>
method which lets bits of code to be executed from the correct thread. A
<a href="http://developer.android.com/reference/java/lang/Runnable.html">Runnable</a>
instance has to be constructed and any parameter can be passed either by
sub-classing
<a href="http://developer.android.com/reference/java/lang/Runnable.html">Runnable</a>
and adding a dedicated constructor, or by using the <code>final</code> modifier, as
shown in the above snippet.</p>
<p>The same problem exists when the native code wants to output a string in
our TextView using the <code>setMessage()</code> method: it has to be done from the
UI thread. The solution is the same:</p>
<pre><code class="language-java">private void setMessage(final String message) {
    final TextView tv = (TextView) this.findViewById(R.id.textview_message);
    runOnUiThread (new Runnable() {
      public void run() {
      tv.setText(message);
    }
  });
}
</code></pre>
<p>Finally, a few remaining bits:</p>
<pre><code class="language-java">protected void onSaveInstanceState (Bundle outState) {
    Log.d ("GStreamer", "Saving state, playing:" + is_playing_desired);
    outState.putBoolean("playing", is_playing_desired);
}
</code></pre>
<p>This method stores the currently desired playing state when Android is
about to shut us down, so next time it restarts (after an orientation
change, for example), it can restore the same state.</p>
<pre><code class="language-java">protected void onDestroy() {
    nativeFinalize();
    super.onDestroy();
}
</code></pre>
<p>And this is called before Android destroys our application. We call the
<code>nativeFinalize()</code>method to exit the main loop, destroy its thread and
all allocated resources.</p>
<p>This concludes the UI part of the tutorial.</p>
<h3 id="a-pipeline-on-android-c-code">A pipeline on Android [C code]</h3>
<p><strong>jni/tutorial-2.c</strong></p>
<pre><code class="language-c">#include &lt;string.h&gt;
#include &lt;jni.h&gt;
#include &lt;android/log.h&gt;
#include &lt;gst/gst.h&gt;
#include &lt;pthread.h&gt;

GST_DEBUG_CATEGORY_STATIC (debug_category);
#define GST_CAT_DEFAULT debug_category

/*
 * These macros provide a way to store the native pointer to CustomData, which might be 32 or 64 bits, into
 * a jlong, which is always 64 bits, without warnings.
 */
#if GLIB_SIZEOF_VOID_P == 8
## define GET_CUSTOM_DATA(env, thiz, fieldID) (CustomData *)(*env)-&gt;GetLongField (env, thiz, fieldID)
## define SET_CUSTOM_DATA(env, thiz, fieldID, data) (*env)-&gt;SetLongField (env, thiz, fieldID, (jlong)data)
#else
## define GET_CUSTOM_DATA(env, thiz, fieldID) (CustomData *)(jint)(*env)-&gt;GetLongField (env, thiz, fieldID)
## define SET_CUSTOM_DATA(env, thiz, fieldID, data) (*env)-&gt;SetLongField (env, thiz, fieldID, (jlong)(jint)data)
#endif

/* Structure to contain all our information, so we can pass it to callbacks */
typedef struct _CustomData {
  jobject app;           /* Application instance, used to call its methods. A global reference is kept. */
  GstElement *pipeline;  /* The running pipeline */
  GMainContext *context; /* GLib context used to run the main loop */
  GMainLoop *main_loop;  /* GLib main loop */
  gboolean initialized;  /* To avoid informing the UI multiple times about the initialization */
} CustomData;

/* These global variables cache values which are not changing during execution */
static pthread_t gst_app_thread;
static pthread_key_t current_jni_env;
static JavaVM *java_vm;
static jfieldID custom_data_field_id;
static jmethodID set_message_method_id;
static jmethodID on_gstreamer_initialized_method_id;

/*
 * Private methods
 */

/* Register this thread with the VM */
static JNIEnv *attach_current_thread (void) {
  JNIEnv *env;
  JavaVMAttachArgs args;

  GST_DEBUG ("Attaching thread %p", g_thread_self ());
  args.version = JNI_VERSION_1_4;
  args.name = NULL;
  args.group = NULL;

  if ((*java_vm)-&gt;AttachCurrentThread (java_vm, &amp;env, &amp;args) &lt; 0) {
    GST_ERROR ("Failed to attach current thread");
    return NULL;
  }

  return env;
}

/* Unregister this thread from the VM */
static void detach_current_thread (void *env) {
  GST_DEBUG ("Detaching thread %p", g_thread_self ());
  (*java_vm)-&gt;DetachCurrentThread (java_vm);
}

/* Retrieve the JNI environment for this thread */
static JNIEnv *get_jni_env (void) {
  JNIEnv *env;

  if ((env = pthread_getspecific (current_jni_env)) == NULL) {
    env = attach_current_thread ();
    pthread_setspecific (current_jni_env, env);
  }

  return env;
}

/* Change the content of the UI's TextView */
static void set_ui_message (const gchar *message, CustomData *data) {
  JNIEnv *env = get_jni_env ();
  GST_DEBUG ("Setting message to: %s", message);
  jstring jmessage = (*env)-&gt;NewStringUTF(env, message);
  (*env)-&gt;CallVoidMethod (env, data-&gt;app, set_message_method_id, jmessage);
  if ((*env)-&gt;ExceptionCheck (env)) {
    GST_ERROR ("Failed to call Java method");
    (*env)-&gt;ExceptionClear (env);
  }
  (*env)-&gt;DeleteLocalRef (env, jmessage);
}

/* Retrieve errors from the bus and show them on the UI */
static void error_cb (GstBus *bus, GstMessage *msg, CustomData *data) {
  GError *err;
  gchar *debug_info;
  gchar *message_string;

  gst_message_parse_error (msg, &amp;err, &amp;debug_info);
  message_string = g_strdup_printf ("Error received from element %s: %s", GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);
  g_clear_error (&amp;err);
  g_free (debug_info);
  set_ui_message (message_string, data);
  g_free (message_string);
  gst_element_set_state (data-&gt;pipeline, GST_STATE_NULL);
}

/* Notify UI about pipeline state changes */
static void state_changed_cb (GstBus *bus, GstMessage *msg, CustomData *data) {
  GstState old_state, new_state, pending_state;
  gst_message_parse_state_changed (msg, &amp;old_state, &amp;new_state, &amp;pending_state);
  /* Only pay attention to messages coming from the pipeline, not its children */
  if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data-&gt;pipeline)) {
    gchar *message = g_strdup_printf("State changed to %s", gst_element_state_get_name(new_state));
    set_ui_message(message, data);
    g_free (message);
  }
}

/* Check if all conditions are met to report GStreamer as initialized.
 * These conditions will change depending on the application */
static void check_initialization_complete (CustomData *data) {
  JNIEnv *env = get_jni_env ();
  if (!data-&gt;initialized &amp;&amp; data-&gt;main_loop) {
    GST_DEBUG ("Initialization complete, notifying application. main_loop:%p", data-&gt;main_loop);
    (*env)-&gt;CallVoidMethod (env, data-&gt;app, on_gstreamer_initialized_method_id);
    if ((*env)-&gt;ExceptionCheck (env)) {
      GST_ERROR ("Failed to call Java method");
      (*env)-&gt;ExceptionClear (env);
    }
    data-&gt;initialized = TRUE;
  }
}

/* Main method for the native code. This is executed on its own thread. */
static void *app_function (void *userdata) {
  JavaVMAttachArgs args;
  GstBus *bus;
  CustomData *data = (CustomData *)userdata;
  GSource *bus_source;
  GError *error = NULL;

  GST_DEBUG ("Creating pipeline in CustomData at %p", data);

  /* Create our own GLib Main Context and make it the default one */
  data-&gt;context = g_main_context_new ();
  g_main_context_push_thread_default(data-&gt;context);

  /* Build pipeline */
  data-&gt;pipeline = gst_parse_launch("audiotestsrc ! audioconvert ! audioresample ! autoaudiosink", &amp;error);
  if (error) {
    gchar *message = g_strdup_printf("Unable to build pipeline: %s", error-&gt;message);
    g_clear_error (&amp;error);
    set_ui_message(message, data);
    g_free (message);
    return NULL;
  }

  /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */
  bus = gst_element_get_bus (data-&gt;pipeline);
  bus_source = gst_bus_create_watch (bus);
  g_source_set_callback (bus_source, (GSourceFunc) gst_bus_async_signal_func, NULL, NULL);
  g_source_attach (bus_source, data-&gt;context);
  g_source_unref (bus_source);
  g_signal_connect (G_OBJECT (bus), "message::error", (GCallback)error_cb, data);
  g_signal_connect (G_OBJECT (bus), "message::state-changed", (GCallback)state_changed_cb, data);
  gst_object_unref (bus);

  /* Create a GLib Main Loop and set it to run */
  GST_DEBUG ("Entering main loop... (CustomData:%p)", data);
  data-&gt;main_loop = g_main_loop_new (data-&gt;context, FALSE);
  check_initialization_complete (data);
  g_main_loop_run (data-&gt;main_loop);
  GST_DEBUG ("Exited main loop");
  g_main_loop_unref (data-&gt;main_loop);
  data-&gt;main_loop = NULL;

  /* Free resources */
  g_main_context_pop_thread_default(data-&gt;context);
  g_main_context_unref (data-&gt;context);
  gst_element_set_state (data-&gt;pipeline, GST_STATE_NULL);
  gst_object_unref (data-&gt;pipeline);

  return NULL;
}

/*
 * Java Bindings
 */

/* Instruct the native code to create its internal data structure, pipeline and thread */
static void gst_native_init (JNIEnv* env, jobject thiz) {
  CustomData *data = g_new0 (CustomData, 1);
  SET_CUSTOM_DATA (env, thiz, custom_data_field_id, data);
  GST_DEBUG_CATEGORY_INIT (debug_category, "tutorial-2", 0, "Android tutorial 2");
  gst_debug_set_threshold_for_name("tutorial-2", GST_LEVEL_DEBUG);
  GST_DEBUG ("Created CustomData at %p", data);
  data-&gt;app = (*env)-&gt;NewGlobalRef (env, thiz);
  GST_DEBUG ("Created GlobalRef for app object at %p", data-&gt;app);
  pthread_create (&amp;gst_app_thread, NULL, &amp;app_function, data);
}

/* Quit the main loop, remove the native thread and free resources */
static void gst_native_finalize (JNIEnv* env, jobject thiz) {
  CustomData *data = GET_CUSTOM_DATA (env, thiz, custom_data_field_id);
  if (!data) return;
  GST_DEBUG ("Quitting main loop...");
  g_main_loop_quit (data-&gt;main_loop);
  GST_DEBUG ("Waiting for thread to finish...");
  pthread_join (gst_app_thread, NULL);
  GST_DEBUG ("Deleting GlobalRef for app object at %p", data-&gt;app);
  (*env)-&gt;DeleteGlobalRef (env, data-&gt;app);
  GST_DEBUG ("Freeing CustomData at %p", data);
  g_free (data);
  SET_CUSTOM_DATA (env, thiz, custom_data_field_id, NULL);
  GST_DEBUG ("Done finalizing");
}

/* Set pipeline to PLAYING state */
static void gst_native_play (JNIEnv* env, jobject thiz) {
  CustomData *data = GET_CUSTOM_DATA (env, thiz, custom_data_field_id);
  if (!data) return;
  GST_DEBUG ("Setting state to PLAYING");
  gst_element_set_state (data-&gt;pipeline, GST_STATE_PLAYING);
}

/* Set pipeline to PAUSED state */
static void gst_native_pause (JNIEnv* env, jobject thiz) {
  CustomData *data = GET_CUSTOM_DATA (env, thiz, custom_data_field_id);
  if (!data) return;
  GST_DEBUG ("Setting state to PAUSED");
  gst_element_set_state (data-&gt;pipeline, GST_STATE_PAUSED);
}

/* Static class initializer: retrieve method and field IDs */
static jboolean gst_native_class_init (JNIEnv* env, jclass klass) {
  custom_data_field_id = (*env)-&gt;GetFieldID (env, klass, "native_custom_data", "J");
  set_message_method_id = (*env)-&gt;GetMethodID (env, klass, "setMessage", "(Ljava/lang/String;)V");
  on_gstreamer_initialized_method_id = (*env)-&gt;GetMethodID (env, klass, "onGStreamerInitialized", "()V");

  if (!custom_data_field_id || !set_message_method_id || !on_gstreamer_initialized_method_id) {
    /* We emit this message through the Android log instead of the GStreamer log because the later
     * has not been initialized yet.
     */
    __android_log_print (ANDROID_LOG_ERROR, "tutorial-2", "The calling class does not implement all necessary interface methods");
    return JNI_FALSE;
  }
  return JNI_TRUE;
}

/* List of implemented native methods */
static JNINativeMethod native_methods[] = {
  { "nativeInit", "()V", (void *) gst_native_init},
  { "nativeFinalize", "()V", (void *) gst_native_finalize},
  { "nativePlay", "()V", (void *) gst_native_play},
  { "nativePause", "()V", (void *) gst_native_pause},
  { "nativeClassInit", "()Z", (void *) gst_native_class_init}
};

/* Library initializer */
jint JNI_OnLoad(JavaVM *vm, void *reserved) {
  JNIEnv *env = NULL;

  java_vm = vm;

  if ((*vm)-&gt;GetEnv(vm, (void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) {
    __android_log_print (ANDROID_LOG_ERROR, "tutorial-2", "Could not retrieve JNIEnv");
    return 0;
  }
  jclass klass = (*env)-&gt;FindClass (env, "org/freedesktop/gstreamer/tutorials/tutorial_2/Tutorial2");
  (*env)-&gt;RegisterNatives (env, klass, native_methods, G_N_ELEMENTS(native_methods));

  pthread_key_create (&amp;current_jni_env, detach_current_thread);

  return JNI_VERSION_1_4;
}
</code></pre>
<p>Let’s start with the <code>CustomData</code> structure. We have seen it in most of
the basic tutorials, and it is used to hold all our information in one
place, so we can easily pass it around to
callbacks:</p>
<pre><code class="language-c">/* Structure to contain all our information, so we can pass it to callbacks */
typedef struct _CustomData {
  jobject app;           /* Application instance, used to call its methods. A global reference is kept. */
  GstElement *pipeline;  /* The running pipeline */
  GMainContext *context; /* GLib context used to run the main loop */
  GMainLoop *main_loop;  /* GLib main loop */
  gboolean initialized;  /* To avoid informing the UI multiple times about the initialization */
} CustomData;
</code></pre>
<p>We will see the meaning of each member as we go. What is interesting now
is that <code>CustomData</code> belongs to the application, so a pointer is kept in
the Tutorial2 Java class in the <code>private long native_custom_data</code> attribute. Java only holds this pointer for us; it
is completely handled in C code.</p>
<p>From C, this pointer can be set and retrieved with the
<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#wp16613">SetLongField()</a>
and
<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#wp16572">GetLongField()</a>
JNI functions, but two convenience macros have been defined,
<code>SET_CUSTOM_DATA</code> and <code>GET_CUSTOM_DATA</code>. These macros are handy because
the <code>long</code> type used in Java is always 64 bits wide, but the pointer
used in C can be either 32 or 64 bits wide. The macros take care of the
conversion without warnings.</p>
<pre><code class="language-c">/* Library initializer */
jint JNI_OnLoad(JavaVM *vm, void *reserved) {
  JNIEnv *env = NULL;

  java_vm = vm;

  if ((*vm)-&gt;GetEnv(vm, (void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) {
    __android_log_print (ANDROID_LOG_ERROR, "tutorial-2", "Could not retrieve JNIEnv");
    return 0;
  }
  jclass klass = (*env)-&gt;FindClass (env, "org/freedesktop/gstreamer/tutorials/tutorial_2/Tutorial2");
  (*env)-&gt;RegisterNatives (env, klass, native_methods, G_N_ELEMENTS(native_methods));

  pthread_key_create (&amp;current_jni_env, detach_current_thread);

  return JNI_VERSION_1_4;
}
</code></pre>
<p>The <code>JNI_OnLoad</code> function is almost the same as the previous tutorial.
It registers the list of native methods (which is longer in this
tutorial). It also
uses <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_key_create.html">pthread_key_create()</a>
to be able to store per-thread information, which is crucial to properly
manage the JNI Environment, as shown later.</p>
<pre><code class="language-c">/* Static class initializer: retrieve method and field IDs */
static jboolean gst_native_class_init (JNIEnv* env, jclass klass) {
  custom_data_field_id = (*env)-&gt;GetFieldID (env, klass, "native_custom_data", "J");
  set_message_method_id = (*env)-&gt;GetMethodID (env, klass, "setMessage", "(Ljava/lang/String;)V");
  on_gstreamer_initialized_method_id = (*env)-&gt;GetMethodID (env, klass, "onGStreamerInitialized", "()V");

  if (!custom_data_field_id || !set_message_method_id || !on_gstreamer_initialized_method_id) {
    /* We emit this message through the Android log instead of the GStreamer log because the later
     * has not been initialized yet.
     */
    __android_log_print (ANDROID_LOG_ERROR, "tutorial-2", "The calling class does not implement all necessary interface methods");
    return JNI_FALSE;
  }
  return JNI_TRUE;
}
</code></pre>
<p>This method is called from the static initializer of the Java class,
which is passed as a parameter (since this is called from a static
method, it receives a class object instead of an instance object). In
order for C code to be able to call a Java method, it needs to know the
method’s
<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/types.html#wp1064">MethodID</a>.
This ID is obtained from the method’s name and signature and can be
cached. The purpose of the <code>gst_native_class_init()</code> function is to
obtain the IDs of all the methods and fields that the C code will need.
If some ID cannot be retrieved, the calling Java class does not offer
the expected interface and execution should halt (which is not currently
done for simplicity).</p>
<p>Let’s review now the first native method which can be directly called
from Java:</p>
<h4 id="gst_native_init-nativeinit-from-java">
<code>gst_native_init()</code> (<code>nativeInit()</code> from Java)</h4>
<p>This method is called at the end of Java's <code>onCreate()</code>.</p>
<pre><code class="language-c">static void gst_native_init (JNIEnv* env, jobject thiz) {
  CustomData *data = g_new0 (CustomData, 1);
  SET_CUSTOM_DATA (env, thiz, custom_data_field_id, data);
</code></pre>
<p>It first allocates memory for the <code>CustomData</code> structure and passes the
pointer to the Java class with <code>SET_CUSTOM_DATA</code>, so it is remembered.</p>
<pre><code class="language-c">data-&gt;app = (*env)-&gt;NewGlobalRef (env, thiz);
</code></pre>
<p>A pointer to the application class (the <code>Tutorial2</code> class) is also kept
in <code>CustomData</code> (a <a href="http://developer.android.com/guide/practices/jni.html#local_and_global_references">Global
Reference</a>
is used) so its methods can be called later.</p>
<pre><code class="language-c">pthread_create (&amp;gst_app_thread, NULL, &amp;app_function, data);
</code></pre>
<p>Finally, a thread is created and it starts running the
<code>app_function()</code> method.</p>
<h4 id="app_function"><code>app_function()</code></h4>
<pre><code class="language-c">/* Main method for the native code. This is executed on its own thread. */
static void *app_function (void *userdata) {
  JavaVMAttachArgs args;
  GstBus *bus;
  CustomData *data = (CustomData *)userdata;
  GSource *bus_source;
  GError *error = NULL;

  GST_DEBUG ("Creating pipeline in CustomData at %p", data);

  /* Create our own GLib Main Context and make it the default one */
  data-&gt;context = g_main_context_new ();
  g_main_context_push_thread_default(data-&gt;context);
</code></pre>
<p>It first creates a GLib context so all <code>GSource</code> are kept in the same
place. This also helps cleaning after GSources created by other
libraries which might not have been properly disposed of. A new context
is created with <code>g_main_context_new()</code> and then it is made the default
one for the thread with
<code>g_main_context_push_thread_default()</code>.</p>
<pre><code class="language-c">data-&gt;pipeline = gst_parse_launch("audiotestsrc ! audioconvert ! audioresample ! autoaudiosink", &amp;error);
if (error) {
  gchar *message = g_strdup_printf("Unable to build pipeline: %s", error-&gt;message);
  g_clear_error (&amp;error);
  set_ui_message(message, data);
  g_free (message);
  return NULL;
}
</code></pre>
<p>It then creates a pipeline the easy way, with <code>gst-parse-launch()</code>. In
this case, it is simply an <code>audiotestsrc</code> (which produces a continuous
tone) and an <code>autoaudiosink</code>, with accompanying adapter elements.</p>
<pre><code class="language-c">bus = gst_element_get_bus (data-&gt;pipeline);
bus_source = gst_bus_create_watch (bus);
g_source_set_callback (bus_source, (GSourceFunc) gst_bus_async_signal_func, NULL, NULL);
g_source_attach (bus_source, data-&gt;context);
g_source_unref (bus_source);
g_signal_connect (G_OBJECT (bus), "message::error", (GCallback)error_cb, data);
g_signal_connect (G_OBJECT (bus), "message::state-changed", (GCallback)state_changed_cb, data);
gst_object_unref (bus);
</code></pre>
<p>These lines create a bus signal watch and connect to some interesting
signals, just like we have been doing in the basic tutorials. The
creation of the watch is done step by step instead of using
<code>gst_bus_add_signal_watch()</code> to exemplify how to use a custom GLib
context.</p>
<pre><code class="language-c">GST_DEBUG ("Entering main loop... (CustomData:%p)", data);
data-&gt;main_loop = g_main_loop_new (data-&gt;context, FALSE);
check_initialization_complete (data);
g_main_loop_run (data-&gt;main_loop);
GST_DEBUG ("Exited main loop");
g_main_loop_unref (data-&gt;main_loop);
data-&gt;main_loop = NULL;
</code></pre>
<p>Finally, the main loop is created and set to run. When it exits (because
somebody else calls <code>g_main_loop_quit()</code>) the main loop is disposed of.
Before entering the main loop, though,
<code>check_initialization_complete()</code> is called. This method checks if all
conditions are met to consider the native code “ready” to accept
commands. Since having a running main loop is one of the conditions,
<code>check_initialization_complete()</code> is called here. This method is
reviewed below.</p>
<p>Once the main loop has quit, all resources are freed in lines 178 to</p>
<ol start="181">
<li>
</ol>
<h4 id="check_initialization_complete"><code>check_initialization_complete()</code></h4>
<pre><code class="language-c">static void check_initialization_complete (CustomData *data) {
  JNIEnv *env = get_jni_env ();
  if (!data-&gt;initialized &amp;&amp; data-&gt;main_loop) {
    GST_DEBUG ("Initialization complete, notifying application. main_loop:%p", data-&gt;main_loop);
    (*env)-&gt;CallVoidMethod (env, data-&gt;app, on_gstreamer_initialized_method_id);
    if ((*env)-&gt;ExceptionCheck (env)) {
      GST_ERROR ("Failed to call Java method");
      (*env)-&gt;ExceptionClear (env);
    }
    data-&gt;initialized = TRUE;
  }
}
</code></pre>
<p>This method does not do much in this tutorial, but it will also be used
in the next ones, with progressively more complex functionality. Its
purpose is to check if the native code is ready to accept commands, and,
if so, notify the UI code.</p>
<p>In tutorial 2, the only conditions are 1) the code is not already
initialized and 2) the main loop is running. If these two are met, the
Java <code>onGStreamerInitialized()</code> method is called via the
<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#wp4256">CallVoidMethod()</a>
JNI call.</p>
<p>Here comes a tricky bit. JNI calls require a JNI Environment, <strong>which is
different for every thread</strong>. C methods called from Java receive a
<code>JNIEnv</code> pointer as a parameter, but this is not the situation with
<code>check_initialization_complete()</code>. Here, we are in a thread which has
never been called from Java, so we have no <code>JNIEnv</code>. We need to use the
<code>JavaVM</code> pointer (passed to us in the <code>JNI_OnLoad()</code> method, and shared
among all threads) to attach this thread to the Java Virtual Machine and
obtain a <code>JNIEnv</code>. This <code>JNIEnv</code> is stored in the <a href="http://en.wikipedia.org/wiki/Thread-local_storage">Thread-Local
Storage</a> (TLS) using
the pthread key we created in <code>JNI_OnLoad()</code>, so we do not need to
attach the thread anymore.</p>
<p>This behavior is implemented in the <code>get_jni_env()</code> method, used for
example in <code>check_initialization_complete()</code> as we have just seen. Let’s
see how it works, step by step:</p>
<h4 id="get_jni_env"><code>get_jni_env()</code></h4>
<pre><code class="language-c">static JNIEnv *get_jni_env (void) {
  JNIEnv *env;
  if ((env = pthread_getspecific (current_jni_env)) == NULL) {
    env = attach_current_thread ();
    pthread_setspecific (current_jni_env, env);
  }
  return env;
}
</code></pre>
<p>It first retrieves the current <code>JNIEnv</code> from the TLS using
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_getspecific.html">pthread_getspecific()</a>
and the key we obtained from
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_key_create.html">pthread_key_create()</a>.
If it returns NULL, we never attached this thread, so we do now with
<code>attach_current_thread()</code> and then store the new <code>JNIEnv</code> into the TLS
with
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_setspecific.html">pthread_setspecific()</a>.</p>
<h4 id="attach_current_thread"><code>attach_current_thread()</code></h4>
<p>This method is simply a convenience wrapper around
<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/invocation.html#attach_current_thread">AttachCurrentThread()</a>
to deal with its parameters.</p>
<h4 id="detach_current_thread"><code>detach_current_thread()</code></h4>
<p>This method is called by the pthreads library when a TLS key is deleted,
meaning that the thread is about to be destroyed. We simply detach the
thread from the JavaVM with
<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/invocation.html#detach_current_thread">DetachCurrentThread()</a>.</p>
<p>Let's now review the rest of the native methods accessible from Java:</p>
<h4 id="gst_native_finalize-nativefinalize-from-java">
<code>gst_native_finalize()</code> (<code>nativeFinalize()</code> from Java)</h4>
<pre><code class="language-c">static void gst_native_finalize (JNIEnv* env, jobject thiz) {
  CustomData *data = GET_CUSTOM_DATA (env, thiz, custom_data_field_id);
  if (!data) return;
  GST_DEBUG ("Quitting main loop...");
  g_main_loop_quit (data-&gt;main_loop);
  GST_DEBUG ("Waiting for thread to finish...");
  pthread_join (gst_app_thread, NULL);
  GST_DEBUG ("Deleting GlobalRef for app object at %p", data-&gt;app);
  (*env)-&gt;DeleteGlobalRef (env, data-&gt;app);
  GST_DEBUG ("Freeing CustomData at %p", data);
  g_free (data);
  SET_CUSTOM_DATA (env, thiz, custom_data_field_id, NULL);
  GST_DEBUG ("Done finalizing");
}
</code></pre>
<p>This method is called from Java in <code>onDestroy()</code>, when the activity is
about to be destroyed. Here, we:</p>
<ul>
<li>Instruct the GLib main loop to quit with <code>g_main_loop_quit()</code>. This
call returns immediately, and the main loop will terminate at its
earliest convenience.</li>
<li>Wait for the thread to finish with
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_join.html">pthread_join()</a>.
This call blocks until the <code>app_function()</code> method returns, meaning
that the main loop has exited, and the thread has been destroyed.</li>
<li>Dispose of the global reference we kept for the Java application
class (<code>Tutorial2</code>) in <code>CustomData</code>.</li>
<li>Free <code>CustomData</code> and set the Java pointer inside the
<code>Tutorial2</code> class to NULL with
<code>SET_CUSTOM_DATA()</code>.</li>
</ul>
<h4 id="gst_native_play-and-gst_native_pause-nativeplay-and-nativepause-from-java">
<code>gst_native_play</code> and <code>gst_native_pause()</code> (<code>nativePlay</code> and <code>nativePause()</code> from Java)</h4>
<p>These two simple methods retrieve <code>CustomData</code> from the passed-in object
with <code>GET_CUSTOM_DATA()</code> and set the pipeline found inside <code>CustomData</code>
to the desired state, returning immediately.</p>
<p>Finally, let’s see how the GStreamer callbacks are handled:</p>
<h4 id="error_cb-and-state_changed_cb">
<code>error_cb</code> and <code>state_changed_cb</code>
</h4>
<p>This tutorial does not do much in these callbacks. They simply parse the
error or state changed message and display a message in the UI using the
<code>set_ui_message()</code> method:</p>
<h4 id="set_ui_message"><code>set_ui_message()</code></h4>
<pre><code class="language-c">static void set_ui_message (const gchar *message, CustomData *data) {
  JNIEnv *env = get_jni_env ();
  GST_DEBUG ("Setting message to: %s", message);
  jstring jmessage = (*env)-&gt;NewStringUTF(env, message);
  (*env)-&gt;CallVoidMethod (env, data-&gt;app, set_message_method_id, jmessage);
  if ((*env)-&gt;ExceptionCheck (env)) {
    GST_ERROR ("Failed to call Java method");
    (*env)-&gt;ExceptionClear (env);
  }
  (*env)-&gt;DeleteLocalRef (env, jmessage);
}
</code></pre>
<p>This is the other method (besides <code>check_initialization_complete()</code>)
that needs to call a Java function from a thread which never received an
<code>JNIEnv</code> pointer directly. Notice how all the complexities of attaching
the thread to the JavaVM and storing the JNI environment in the TLS are
hidden in the simple call to <code>get_jni_env()</code>.</p>
<p>The desired message (received in
<a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a>, or modified
<a href="http://en.wikipedia.org/wiki/Modified_UTF-8#Modified_UTF-8">UTF8</a>), is
converted to <a href="http://en.wikipedia.org/wiki/UTF-16">UTF16</a> as required by
Java using the
<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#wp17220">NewStringUTF()</a>
JNI call.</p>
<p>The <code>setMessage()</code> Java method is called via the JNI
<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#wp4256">CallVoidMethod()</a>
using the global reference to the class we are keeping in
<code>CustomData</code> (<code>data-&gt;app</code>) and the <code>set_message_method_id</code> we cached in
<code>gst_native_class_init()</code>.</p>
<p>We check for exceptions with the JNI
<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#exception_check">ExceptionCheck()</a>
method and free the UTF16 message with
<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#DeleteLocalRef">DeleteLocalRef()</a>.</p>
<h3 id="a-pipeline-on-android-androidmk">A pipeline on Android [Android.mk]</h3>
<p><strong>jni/Android.mk</strong></p>
<pre><code class="language-ruby">LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := tutorial-2
LOCAL_SRC_FILES := tutorial-2.c
LOCAL_SHARED_LIBRARIES := gstreamer_android
LOCAL_LDLIBS := -llog
include $(BUILD_SHARED_LIBRARY)

ifndef GSTREAMER_ROOT
ifndef GSTREAMER_ROOT_ANDROID
$(error GSTREAMER_ROOT_ANDROID is not defined!)
endif
GSTREAMER_ROOT        := $(GSTREAMER_ROOT_ANDROID)
endif
GSTREAMER_NDK_BUILD_PATH  := $(GSTREAMER_ROOT)/share/gst-android/ndk-build/
include $(GSTREAMER_NDK_BUILD_PATH)/plugins.mk
GSTREAMER_PLUGINS         := $(GSTREAMER_PLUGINS_CORE) $(GSTREAMER_PLUGINS_SYS)
include $(GSTREAMER_NDK_BUILD_PATH)/gstreamer-1.0.mk
</code></pre>
<p>Notice how the required <code>GSTREAMER_PLUGINS</code> are now
<code>$(GSTREAMER_PLUGINS_CORE)</code> (For the test source and converter elements)
and <code>$(GSTREAMER_PLUGINS_SYS)</code> (for the audio sink).</p>
<p>And this is it! This has been a rather long tutorial, but we covered a
lot of territory. Building on top of this one, the following ones are
shorter and focus only on the new topics.</p>
<h3 id="conclusion">Conclusion</h3>
<p>This tutorial has shown:</p>
<ul>
<li>How to manage multiple threads from C code and have them interact
with java.</li>
<li>How to access Java code from any C thread
using <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/invocation.html#attach_current_thread">AttachCurrentThread()</a>.</li>
<li>How to allocate a CustomData structure from C and have Java host it,
so it is available to all threads.</li>
</ul>
<p>Most of the methods introduced in this tutorial, like <code>get_jni_env()</code>,
<code>check_initialization_complete()</code>, <code>app_function()</code> and the API methods
<code>gst_native_init()</code>, <code>gst_native_finalize()</code> and
<code>gst_native_class_init()</code> will continue to be used in the following
tutorials with minimal modifications, so better get used to them!</p>
<p>As usual, it has been a pleasure having you here, and see you soon!</p>

    </div>
        




		
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
	<div id="footer">
		    

	</div>
</div>

<div id="toc-column">
	
		<div class="edit-button">
		

	</div>
		<div id="toc-wrapper">
		<nav id="toc"></nav>
	</div>
</div>
</div>
</main>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>
